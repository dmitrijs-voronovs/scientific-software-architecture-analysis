quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,/////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:214209,cache,cache,214209,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"//////////////////////////////////////////////; 4566/// Return the number of methods of this class; 4567/// Note that in case the list of methods is not yet created, it will be done; 4568/// by GetListOfMethods().; 4569/// This will also load/populate the list of methods, to get 'just' the; 4570/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:173389,load,loaded,173389,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"//////////////////////////////////////////////; 4633/// Return the number of methods of this class; 4634/// Note that in case the list of methods is not yet created, it will be done; 4635/// by GetListOfMethods().; 4636/// This will also load/populate the list of methods, to get 'just' the; 4637/// number of currently loaded methods use:; 4638/// cl->GetListOfMethods(false)->GetSize();; 4639 ; 4640Int_t TClass::GetNmethods(); 4641{; 4642 if (!HasInterpreterInfo()) return 0;; 4643 ; 4644 TList *lm = GetListOfMethods();; 4645 if (lm); 4646 return lm->GetSize();; 4647 else; 4648 return 0;; 4649}; 4650 ; 4651////////////////////////////////////////////////////////////////////////////////; 4652/// returns a pointer to the TVirtualStreamerInfo object for version; 4653/// If the object does not exist, it is created; 4654///; 4655/// Note: There are two special version numbers:; 4656///; 4657/// - 0: Use the class version from the currently loaded class library.; 4658/// - -1: Assume no class library loaded (emulated class).; 4659///; 4660/// Warning: If we create a new streamer info, whether or not the build; 4661/// optimizes is controlled externally to us by a global variable!; 4662/// Don't call us unless you have set that variable properly; 4663/// with TStreamer::Optimize()!; 4664///; 4665 ; 4666TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4667{; 4668 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:176140,load,loaded,176140,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"//////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();; 584 ; 585 delete fReadmask;; 586 delete fWritemask;; 587 delete fReadready;; 588 delete fWriteready;; 589 delete fSignals;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Initialize Unix system interface.; 594 ; 595Bool_t TUnixSystem::Init(); 596{; 597 if (TSystem::Init()); 598 return kTRUE;; 599 ; 600 fReadmask = new TFdSet;; 601 fWritemask = new TFdSet;; 602 fReadready = new TFdSet;; 603 fWriteready = new TFdSet;; 604 fSignals = new TFdSet;; 605 ; 606 //--- install default handlers; 607 UnixSignal(kSigChild, SigHandler);; 608 UnixSignal(kSigBus, SigHandler);; 609 UnixSignal(kSigSegmentationViolation, SigHandler);; 610 UnixSignal(kSigIllegalInstruction, SigHandler);; 611 UnixSignal(kSigAbort, SigHandler);; 612 UnixSignal(kSigSystem, SigHandler);; 613 UnixSignal(kSigAlarm, SigHandler);; 614 UnixSignal(kSigUrgent, SigHandler);; 615 UnixSignal(kSigFloatingException, SigHandler);; 616 UnixSignal(kSigWindowChanged, SigHandler);; 617 UnixSignal(kSigUser2, SigHandler);; 618 ; 619#if defined(R__MACOSX); 620 // trap loading of all dylibs to register dylib name,; 621 // sets also ROOTSYS if built without ROOTPREFIX; 622 _dyld_register_func_for_add_image(DylibAdded);; 623#elif defined(HAVE_DLADDR); 624 SetRootSys();; 625#endif; 626 ; 627 // This is a fallback in case TROOT::GetRootSys() can't determine ROOTSYS; 628 gRootDir = ROOT::FoundationUtils::GetFallbackRootSys().c_str();; 629 ; 630 return kFALSE;; 631}; 632 ; 633//---- Misc --------------------------------------------------------------------; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Set the application name (from command line, argv[0]) and copy it in; 637/// gProgName. Copy the application pathname in gProgPath.; 638/// If name is 0 let the system set the actu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:18226,load,loading,18226,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['loading']
Performance,"/////////////////////////////////////////////; 6520/// Parse the headers relative to the class; 6521/// Returns 1 in case of success, 0 in case of failure; 6522 ; 6523Int_t TCling::AutoParse(const char *cls); 6524{; 6525 if (llvm::StringRef(cls).contains(""(lambda)"")); 6526 return 0;; 6527 ; 6528 if (!fHeaderParsingOnDemand || fIsAutoParsingSuspended) {; 6529 if (fClingCallbacks->IsAutoLoadingEnabled()) {; 6530 return AutoLoad(cls);; 6531 } else {; 6532 return 0;; 6533 }; 6534 }; 6535 ; 6536 R__LOCKGUARD(gInterpreterMutex);; 6537 ; 6538 if (gDebug > 1) {; 6539 Info(""TCling::AutoParse"",; 6540 ""Trying to autoparse for %s"", cls);; 6541 }; 6542 ; 6543 // The catalogue of headers is in the dictionary; 6544 if (fClingCallbacks->IsAutoLoadingEnabled(); 6545 && !gClassTable->GetDictNorm(cls)) {; 6546 // Need RAII against recursive (dictionary payload) parsing (ROOT-8445).; 6547 ROOT::Internal::ParsingStateRAII parsingStateRAII(fInterpreter->getParser(),; 6548 fInterpreter->getSema());; 6549 AutoLoad(cls, true /*knowDictNotLoaded*/);; 6550 }; 6551 ; 6552 // Prevent the recursion when the library dictionary are loaded.; 6553 SuspendAutoLoadingRAII autoLoadOff(this);; 6554 ; 6555 // No recursive header parsing on demand; we require headers to be standalone.; 6556 SuspendAutoParsing autoParseRAII(this);; 6557 ; 6558 Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);; 6559 ; 6560 ProcessClassesToUpdate();; 6561 ; 6562 return nHheadersParsed > 0 ? 1 : 0;; 6563}; 6564 ; 6565// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:254704,load,loaded,254704,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"////////////////////////////////////////////; 1625/// Clean temporary volumes and shapes from garbage collection.; 1626 ; 1627void TGeoManager::CleanGarbage(); 1628{; 1629 if (!fGVolumes && !fGShapes); 1630 return;; 1631 Int_t i, nentries;; 1632 if (fGVolumes) {; 1633 nentries = fGVolumes->GetEntries();; 1634 TGeoVolume *vol = nullptr;; 1635 for (i = 0; i < nentries; i++) {; 1636 vol = (TGeoVolume *)fGVolumes->At(i);; 1637 if (vol); 1638 vol->SetFinder(nullptr);; 1639 }; 1640 fGVolumes->Delete();; 1641 delete fGVolumes;; 1642 fGVolumes = nullptr;; 1643 }; 1644 if (fGShapes) {; 1645 fGShapes->Delete();; 1646 delete fGShapes;; 1647 fGShapes = nullptr;; 1648 }; 1649}; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Change current path to point to the node having this id.; 1653/// Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons); 1654 ; 1655void TGeoManager::CdNode(Int_t nodeid); 1656{; 1657 GetCurrentNavigator()->CdNode(nodeid);; 1658}; 1659 ; 1660////////////////////////////////////////////////////////////////////////////////; 1661/// Get the unique ID of the current node.; 1662 ; 1663Int_t TGeoManager::GetCurrentNodeId() const; 1664{; 1665 return GetCurrentNavigator()->GetCurrentNodeId();; 1666}; 1667 ; 1668////////////////////////////////////////////////////////////////////////////////; 1669/// Make top level node the current node. Updates the cache accordingly.; 1670/// Determine the overlapping state of current node.; 1671 ; 1672void TGeoManager::CdTop(); 1673{; 1674 GetCurrentNavigator()->CdTop();; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Go one level up in geometry. Updates cache accordingly.; 1679/// Determine the overlapping state of current node.; 1680 ; 1681void TGeoManager::CdUp(); 1682{; 1683 GetCurrentNavigator()->CdUp();; 1684}; 1685 ; 1686/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:61000,perform,performance,61000,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['perform'],['performance']
Performance,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:95636,perform,perform,95636,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['perform'],['perform']
Performance,"//////////////////////////////////////; 1108/// Fill Graphics Structure and Paint.; 1109///; 1110/// Loop on all objects (memory or file) and all subdirectories.; 1111 ; 1112void TFile::Draw(Option_t *option); 1113{; 1114 GetList()->R__FOR_EACH(TObject,Draw)(option);; 1115}; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Draw map of objects in this file. The map drawing is handled by TFileDrawMap.; 1119/// Once the map is drawn, turn on the TCanvas option ""View->Event Statusbar"". Then, when; 1120/// moving the mouse in the canvas, the ""Event Status"" panels shows the object corresponding; 1121/// to the mouse position.; 1122///; 1123/// Example:; 1124/// ~~~{.cpp}; 1125/// auto f = new TFile(""myfile.root"");; 1126/// f->DrawMap();; 1127/// ~~~; 1128 ; 1129void TFile::DrawMap(const char *keys, Option_t *option); 1130{; 1131 TPluginHandler *h;; 1132 if ((h = gROOT->GetPluginManager()->FindHandler(""TFileDrawMap""))) {; 1133 if (h->LoadPlugin() == -1); 1134 return;; 1135 h->ExecPlugin(3, this, keys, option);; 1136 }; 1137}; 1138 ; 1139////////////////////////////////////////////////////////////////////////////////; 1140/// Synchronize a file's in-memory and on-disk states.; 1141 ; 1142void TFile::Flush(); 1143{; 1144 if (IsOpen() && fWritable) {; 1145 FlushWriteCache();; 1146 if (SysSync(fD) < 0) {; 1147 // Write the system error only once for this file; 1148 SetBit(kWriteError); SetWritable(kFALSE);; 1149 SysError(""Flush"", ""error flushing file %s"", GetName());; 1150 }; 1151 }; 1152}; 1153 ; 1154////////////////////////////////////////////////////////////////////////////////; 1155/// Flush the write cache if active.; 1156///; 1157/// Return kTRUE in case of error; 1158 ; 1159Bool_t TFile::FlushWriteCache(); 1160{; 1161 if (fCacheWrite && IsOpen() && fWritable); 1162 return fCacheWrite->Flush();; 1163 return kFALSE;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:40677,Load,LoadPlugin,40677,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"//////////////////////////////////////; 288/// Returns element with path, specified as string; 289 ; 290std::shared_ptr<Browsable::RElement> RBrowserData::GetElement(const std::string &str); 291{; 292 auto path = DecomposePath(str, true);; 293 ; 294 return GetSubElement(path);; 295}; 296 ; 297/////////////////////////////////////////////////////////////////////////; 298/// Returns element with path, specified as Browsable::RElementPath_t; 299 ; 300std::shared_ptr<Browsable::RElement> RBrowserData::GetElementFromTop(const Browsable::RElementPath_t &path); 301{; 302 return GetSubElement(path);; 303}; 304 ; 305/////////////////////////////////////////////////////////////////////////; 306/// Returns sub-element starting from top, using cached data; 307 ; 308std::shared_ptr<Browsable::RElement> RBrowserData::GetSubElement(const Browsable::RElementPath_t &path); 309{; 310 if (path.empty()); 311 return fTopElement;; 312 ; 313 // validate cache - removes no longer actual elements; 314 RemoveFromCache(nullptr);; 315 ; 316 // first check direct match in cache; 317 for (auto &entry : fCache); 318 if (entry.first == path); 319 return entry.second;; 320 ; 321 // find best possible entry in cache; 322 int pos = 0;; 323 auto elem = fTopElement;; 324 ; 325 for (auto &entry : fCache) {; 326 if (entry.first.size() >= path.size()); 327 continue;; 328 ; 329 auto comp = Browsable::RElement::ComparePaths(path, entry.first);; 330 ; 331 if ((comp > pos) && (comp == (int) entry.first.size())) {; 332 pos = comp;; 333 elem = entry.second;; 334 }; 335 }; 336 ; 337 while (pos < (int) path.size()) {; 338 std::string subname = path[pos];; 339 int indx = Browsable::RElement::ExtractItemIndex(subname);; 340 ; 341 auto iter = elem->GetChildsIter();; 342 if (!iter); 343 return nullptr;; 344 ; 345 if (!iter->Find(subname, indx)) {; 346 if (indx < 0); 347 return nullptr;; 348 iter = elem->GetChildsIter();; 349 if (!iter || !iter->Find(subname)); 350 return nullptr;; 351 }; 352 ; 353 elem = iter->GetElem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:9982,cache,cache,9982,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,4,['cache'],['cache']
Performance,"//////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 5978 // loaded from a file) is consistent with the definition in the library we just loaded.; 5979 // BuildCheck is not appropriate here since it check a streamerinfo against the; 5980 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 5981 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 5982 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:229293,load,loaded,229293,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['loaded']
Performance,"//////////////////////////////////////; 6023/// Do the initialization that can only be done after the CINT dictionary has; 6024/// been fully populated and can not be delayed efficiently.; 6025 ; 6026void TClass::PostLoadCheck(); 6027{; 6028 // In the case of a Foreign class (loaded class without a Streamer function); 6029 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 6030 // be confused with a previously loaded streamerInfo.; 6031 ; 6032 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 6033 && fStreamerInfo->At(1)*/ && IsForeign() ); 6034 {; 6035 SetClassVersion(-1);; 6036 }; 6037 // Note: We are careful to check the class version first because checking; 6038 // for foreign can trigger an AutoParse.; 6039 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 6040 {; 6041 R__LOCKGUARD(gInterpreterMutex);; 6042 ; 6043 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 6044 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 6045 // loaded from a file) is consistent with the definition in the library we just loaded.; 6046 // BuildCheck is not appropriate here since it check a streamerinfo against the; 6047 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 6048 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 6049 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 6050 {; 6051 Bool_t warn = ! TestBit(kWarned);; 6052 if (warn && info->GetOldVersion()<=2) {; 6053 // Names of STL base classes was modified in vers==3. Allocators removed; 6054 //; 6055 TIter nextBC(GetListOfBases());; 6056 TBaseClass *bc;; 6057 while ((bc=(TBaseClass*)nextBC())); 6058 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 6059 }; 6060 ; 6061 if (warn) {; 6062 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:232044,load,loaded,232044,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['loaded']
Performance,"/////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:67836,load,load,67836,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"/////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:4838,cache,cached,4838,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['cache'],['cached']
Performance,"///////////////////////////////////; 2457/// set default level down to which visualization is performed; 2458 ; 2459void TGeoManager::SetVisLevel(Int_t level); 2460{; 2461 if (level > 0) {; 2462 fVisLevel = level;; 2463 fMaxVisNodes = 0;; 2464 if (fgVerboseLevel > 0); 2465 Info(""SetVisLevel"", ""Automatic visible depth disabled"");; 2466 if (fPainter); 2467 fPainter->CountVisibleNodes();; 2468 } else {; 2469 SetMaxVisNodes();; 2470 }; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Sort overlaps by decreasing overlap distance. Extrusions comes first.; 2475 ; 2476void TGeoManager::SortOverlaps(); 2477{; 2478 fOverlaps->Sort();; 2479}; 2480 ; 2481////////////////////////////////////////////////////////////////////////////////; 2482/// Optimize voxelization type for all volumes. Save best choice in a macro.; 2483 ; 2484void TGeoManager::OptimizeVoxels(const char *filename); 2485{; 2486 if (!fTopNode) {; 2487 Error(""OptimizeVoxels"", ""Geometry must be closed first"");; 2488 return;; 2489 }; 2490 std::ofstream out;; 2491 TString fname = filename;; 2492 if (fname.IsNull()); 2493 fname = ""tgeovox.C"";; 2494 out.open(fname, std::ios::out);; 2495 if (!out.good()) {; 2496 Error(""OptimizeVoxels"", ""cannot open file"");; 2497 return;; 2498 }; 2499 // write header; 2500 TDatime t;; 2501 TString sname(fname);; 2502 sname.ReplaceAll("".C"", """");; 2503 out << sname.Data() << ""()"" << std::endl;; 2504 out << ""{"" << std::endl;; 2505 out << ""//=== Macro generated by ROOT version "" << gROOT->GetVersion() << "" : "" << t.AsString() << std::endl;; 2506 out << ""//=== Voxel optimization for "" << GetTitle() << "" geometry"" << std::endl;; 2507 out << ""//===== <run this macro JUST BEFORE closing the geometry>"" << std::endl;; 2508 out << "" TGeoVolume *vol = 0;"" << std::endl;; 2509 out << "" // parse all voxelized volumes"" << std::endl;; 2510 TGeoVolume *vol = nullptr;; 2511 Bool_t cyltype;; 2512 TIter next(fVolumes);; 2513 while ((vol = (TGeoVolume *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:88722,Optimiz,OptimizeVoxels,88722,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['Optimiz'],['OptimizeVoxels']
Performance,"//////////////////////////////////; 1417/// Get next Unix file system directory entry. Returns 0 if no more entries.; 1418 ; 1419const char *TUnixSystem::GetDirEntry(void *dirp); 1420{; 1421 TSystem *helper = FindHelper(nullptr, dirp);; 1422 if (helper); 1423 return helper->GetDirEntry(dirp);; 1424 ; 1425 if (dirp); 1426 return UnixGetdirentry(dirp);; 1427 ; 1428 return nullptr;; 1429}; 1430 ; 1431////////////////////////////////////////////////////////////////////////////////; 1432/// Change directory. Returns kTRUE in case of success, kFALSE otherwise.; 1433 ; 1434Bool_t TUnixSystem::ChangeDirectory(const char *path); 1435{; 1436 Bool_t ret = (Bool_t) (::chdir(path) == 0);; 1437 if (fWdpath != """"); 1438 fWdpath = """"; // invalidate path cache; 1439 return ret;; 1440}; 1441 ; 1442////////////////////////////////////////////////////////////////////////////////; 1443/// Return working directory.; 1444 ; 1445const char *TUnixSystem::WorkingDirectory(); 1446{; 1447 // don't use cache as user can call chdir() directly somewhere else; 1448 //if (fWdpath != """"); 1449 // return fWdpath.Data();; 1450 ; 1451 R__LOCKGUARD2(gSystemMutex);; 1452 ; 1453 static char cwd[kMAXPATHLEN];; 1454 FillWithCwd(cwd);; 1455 fWdpath = cwd;; 1456 ; 1457 return fWdpath.Data();; 1458}; 1459 ; 1460//////////////////////////////////////////////////////////////////////////////; 1461/// Return working directory.; 1462 ; 1463std::string TUnixSystem::GetWorkingDirectory() const; 1464{; 1465 char cwd[kMAXPATHLEN];; 1466 FillWithCwd(cwd);; 1467 return std::string(cwd);; 1468}; 1469 ; 1470//////////////////////////////////////////////////////////////////////////////; 1471/// Fill buffer with current working directory.; 1472 ; 1473void TUnixSystem::FillWithCwd(char *cwd) const; 1474{; 1475 if (::getcwd(cwd, kMAXPATHLEN) == nullptr) {; 1476 Error(""WorkingDirectory"", ""getcwd() failed"");; 1477 }; 1478}; 1479 ; 1480////////////////////////////////////////////////////////////////////////////////; 1481/// Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:43894,cache,cache,43894,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['cache'],['cache']
Performance,"//////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 2199 delete [] path;; 2200 ; 2201 // TSystem::Load returns 1 when the library was already loaded, return success in this case.; 2202 if (err == 1); 2203 err = 0;; 2204 return err;; 2205 }; 2206 } else {; 2207 // This is the branch where libname didn't exist; 2208 if (check) {; 2209 FileStat_t stat;; 2210 if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&; 2211 !gSystem->AccessPathName(libname, kReadPermission))); 2212 return 0;; 2213 }; 2214 ; 2215 // Take care of user who didn't write the whole name; 2216 if (!lib.BeginsWith(""lib"")) {; 2217 lib = ""lib"" + lib;; 2218 return LoadClass("""", lib.Data(), check);; 2219 }; 2220 }; 2221 ; 2222 // Execution reaches here when library was prefixed with lib, check is false and couldn't find; 2223 // the library name.; 2224 return -1;; 222",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:83669,Load,LoadClass,83669,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,10,"['Load', 'load']","['Load', 'LoadClass', 'load', 'loaded']"
Performance,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:56895,cache,cache,56895,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,7,['cache'],['cache']
Performance,"////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5193,concurren,concurrent,5193,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"///////////////////////////////; 5682/// Determine and set pointer to current TVirtualStreamerInfo; 5683 ; 5684TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5685{; 5686 if(!fCurrentInfo.load()) {; 5687 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5688 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ; 5693////////////////////////////////////////////////////////////////////////////////; 5694/// Set pointer to current TVirtualStreamerInfo; 5695 ; 5696void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5697{; 5698 fCurrentInfo = info;; 5699}; 5700 ; 5701////////////////////////////////////////////////////////////////////////////////; 5702/// Return size of object of this class.; 5703 ; 5704Int_t TClass::Size() const; 5705{; 5706 if (fSizeof!=-1) return fSizeof;; 5707 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5708 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5709 return GetStreamerInfo()->GetSize();; 5710}; 5711 ; 5712////////////////////////////////////////////////////////////////////////////////; 5713/// Load class description from I/O buffer and return class object.; 5714 ; 5715TClass *TClass::Load(TBuffer &b); 5716{; 5717 UInt_t maxsize = 256;; 5718 char *s = new char[maxsize];; 5719 ; 5720 Int_t pos = b.Length();; 5721 ; 5722 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5723 while (strlen(s) == (maxsize - 1)) {; 5724 // The classname is too large, try again with a large buffer.; 5725 b.SetBufferOffset(pos);; 5726 maxsize = 2*maxsize;; 5727 delete [] s;; 5728 s = new char[maxsize];; 5729 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5730 }; 5731 ; 5732 TClass *cl = TClass::GetClass(s, kTRUE);; 5733 if (!cl); 5734 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5735 ; 5736 delete [] s;; 5737 return cl;; 5738}; 5739 ; 5740////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:218884,Load,Load,218884,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"///////////////////////////////; 5749/// Determine and set pointer to current TVirtualStreamerInfo; 5750 ; 5751TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5752{; 5753 if(!fCurrentInfo.load()) {; 5754 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5755 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5756 }; 5757 return fCurrentInfo;; 5758}; 5759 ; 5760////////////////////////////////////////////////////////////////////////////////; 5761/// Set pointer to current TVirtualStreamerInfo; 5762 ; 5763void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5764{; 5765 fCurrentInfo = info;; 5766}; 5767 ; 5768////////////////////////////////////////////////////////////////////////////////; 5769/// Return size of object of this class.; 5770 ; 5771Int_t TClass::Size() const; 5772{; 5773 if (fSizeof!=-1) return fSizeof;; 5774 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5775 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5776 return GetStreamerInfo()->GetSize();; 5777}; 5778 ; 5779////////////////////////////////////////////////////////////////////////////////; 5780/// Load class description from I/O buffer and return class object.; 5781 ; 5782TClass *TClass::Load(TBuffer &b); 5783{; 5784 UInt_t maxsize = 256;; 5785 char *s = new char[maxsize];; 5786 ; 5787 Int_t pos = b.Length();; 5788 ; 5789 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5790 while (strlen(s) == (maxsize - 1)) {; 5791 // The classname is too large, try again with a large buffer.; 5792 b.SetBufferOffset(pos);; 5793 maxsize = 2*maxsize;; 5794 delete [] s;; 5795 s = new char[maxsize];; 5796 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5797 }; 5798 ; 5799 TClass *cl = TClass::GetClass(s, kTRUE);; 5800 if (!cl); 5801 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5802 ; 5803 delete [] s;; 5804 return cl;; 5805}; 5806 ; 5807////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:221635,Load,Load,221635,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"//////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += gInterpreter->GetSharedLibs();; 2149 ; 2150 // Cint currently register all libraries that; 2151 // are loaded and have a dictionary in them, this; 2152 // includes all the libraries that are included; 2153 // in the list of (hard) linked libraries.; 2154 ; 2155 TString slinked;; 2156 const char *linked;; 2157 if ((linked = GetLinkedLibraries())) {; 2158 if (fLinkedLibs != LINKEDLIBS) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:69198,load,loaded,69198,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"/////////////////////////////; 800/// Set zero values for point arrays in the range `[begin, end]`.; 801 ; 802void TGraphMultiErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 803{; 804 if (!from_ctor); 805 TGraph::FillZero(begin, end, from_ctor);; 806 ; 807 Int_t n = (end - begin) * sizeof(Double_t);; 808 memset(fExL + begin, 0, n);; 809 memset(fExH + begin, 0, n);; 810 memset(fEyLSum + begin, 0, n);; 811 memset(fEyHSum + begin, 0, n);; 812 ; 813 for (Int_t j = 0; j < fNYErrors; j++) {; 814 memset(fEyL[j].GetArray() + begin, 0, n);; 815 memset(fEyH[j].GetArray() + begin, 0, n);; 816 }; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Recalculates the summed y error arrays.; 821 ; 822void TGraphMultiErrors::CalcYErrorsSum() const; 823{; 824 if (!fEyLSum); 825 fEyLSum = new Double_t[fNpoints];; 826 if (!fEyHSum); 827 fEyHSum = new Double_t[fNpoints];; 828 ; 829 for (Int_t i = 0; i < fNpoints; i++) {; 830 fEyLSum[i] = GetErrorYlow(i);; 831 fEyHSum[i] = GetErrorYhigh(i);; 832 }; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Protected function to perform the merge operation of a graph with multiple asymmetric errors.; 837 ; 838Bool_t TGraphMultiErrors::DoMerge(const TGraph *tg); 839{; 840 if (tg->GetN() == 0); 841 return kFALSE;; 842 ; 843 if (tg->IsA() == TGraphMultiErrors::Class()) {; 844 auto tgme = (TGraphMultiErrors *)tg;; 845 ; 846 for (Int_t i = 0; i < tgme->GetN(); i++) {; 847 Int_t ipoint = GetN();; 848 Double_t x, y;; 849 tgme->GetPoint(i, x, y);; 850 SetPoint(ipoint, x, y);; 851 SetPointEX(ipoint, tgme->GetErrorXlow(i), tgme->GetErrorXhigh(i));; 852 for (Int_t j = 0; j < tgme->GetNYErrors(); j++); 853 SetPointEY(ipoint, j, tgme->GetErrorYlow(i, j), tgme->GetErrorYhigh(i, j));; 854 }; 855 ; 856 return kTRUE;; 857 } else {; 858 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphMultiErrors - Errors will be ignored"",; 859 tg->Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:28616,perform,perform,28616,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file.C will be compiled; 134/// and dynamically loaded. The corresponding binary file and shared; 135/// library will be deleted at the end of the function.; 136/// If filename is of the form file.C+, the file file.C will be compiled; 137/// and dynamically loaded. At next call, if file.C is older than file.o; 138/// and file.so, the file.C is not compiled, only file.so is loaded.; 139///; 140/// The static function returns a pointer to a TSelector object; 141 ; 142TSelector *TSelector::GetSelector(const char *filename); 143{; 144 // If the filename does not contain ""."" assume class is compil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:5248,load,loaded,5248,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance,"//////////////////////////; 281 /// returns configured window height (0 - default); 282 unsigned GetHeight() const { return fHeight; }; 283 ; 284 /////////////////////////////////////////////////////////////////////////; 285 /// returns configured window X position (-1 - default); 286 int GetX() const { return fX; }; 287 ; 288 /////////////////////////////////////////////////////////////////////////; 289 /// returns configured window Y position (-1 - default); 290 int GetY() const { return fY; }; 291 ; 292 void SetConnLimit(unsigned lmt = 0);; 293 ; 294 unsigned GetConnLimit() const;; 295 ; 296 void SetConnToken(const std::string &token = """");; 297 ; 298 /////////////////////////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:14121,queue,queue,14121,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"//////////////////////////; 284 /// returns configured window height (0 - default); 285 unsigned GetHeight() const { return fHeight; }; 286 ; 287 /////////////////////////////////////////////////////////////////////////; 288 /// returns configured window X position (-1 - default); 289 int GetX() const { return fX; }; 290 ; 291 /////////////////////////////////////////////////////////////////////////; 292 /// returns configured window Y position (-1 - default); 293 int GetY() const { return fY; }; 294 ; 295 void SetConnLimit(unsigned lmt = 0);; 296 ; 297 unsigned GetConnLimit() const;; 298 ; 299 void SetConnToken(const std::string &token = """");; 300 ; 301 /////////////////////////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:14272,queue,queue,14272,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"//////////////////////////; 349/// Book a classifier or regression method.; 350 ; 351TMVA::MethodBase *; 352TMVA::Factory::BookMethod(TMVA::DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption); 353{; 354 if (fModelPersistence); 355 gSystem->MakeDirectory(loader->GetName()); // creating directory for DataLoader output; 356 ; 357 TString datasetname = loader->GetName();; 358 ; 359 if (fAnalysisType == Types::kNoAnalysisType) {; 360 if (loader->GetDataSetInfo().GetNClasses() == 2 && loader->GetDataSetInfo().GetClassInfo(""Signal"") != NULL &&; 361 loader->GetDataSetInfo().GetClassInfo(""Background"") != NULL) {; 362 fAnalysisType = Types::kClassification; // default is classification; 363 } else if (loader->GetDataSetInfo().GetNClasses() >= 2) {; 364 fAnalysisType = Types::kMulticlass; // if two classes, but not named ""Signal"" and ""Background""; 365 } else; 366 Log() << kFATAL << ""No analysis type for "" << loader->GetDataSetInfo().GetNClasses() << "" classes and ""; 367 << loader->GetDataSetInfo().GetNTargets() << "" regression targets."" << Endl;; 368 }; 369 ; 370 // booking via name; the names are translated into enums and the; 371 // corresponding overloaded BookMethod is called; 372 ; 373 if (fMethodsMap.find(datasetname) != fMethodsMap.end()) {; 374 if (GetMethod(datasetname, methodTitle) != 0) {; 375 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 376 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 377 }; 378 }; 379 ; 380 Log() << kHEADER << ""Booking method: "" << gTools().Color(""bold""); 381 << methodTitle; 382 // << gTools().Color(""reset"")<<"" DataSet Name: ""<<gTools().Color(""bold"")<<loader->GetName(); 383 << gTools().Color(""reset"") << Endl << Endl;; 384 ; 385 // interpret option string with respect to a request for boosting (i.e., BostNum > 0); 386 Int_t boostNum = 0;; 387 TMVA::Configurable *conf = new TMVA::Configurable(theOption);; 388 conf->DeclareOptionRef(boostNum =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:14624,load,loader,14624,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16451,cache,cache,16451,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,6,['cache'],['cache']
Performance,"/////////////////////////; 264/// To set the address of the minimization objective function; 265/// called by the native compiler (see function below when called by CINT); 266 ; 267void TVirtualFitter::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 268{; 269 fFCN = fcn;; 270}; 271 ; 272////////////////////////////////////////////////////////////////////////////////; 273/// Initialize the cache array; 274/// npoints is the number of points to be stored (or already stored) in the cache; 275/// psize is the number of elements per point; 276///; 277/// if (npoints*psize > fCacheSize) the existing cache is deleted; 278/// and a new array is created.; 279/// The function returns a pointer to the cache; 280 ; 281Double_t *TVirtualFitter::SetCache(Int_t npoints, Int_t psize); 282{; 283 if (npoints*psize > fCacheSize) {; 284 delete [] fCache;; 285 fCacheSize = npoints*psize;; 286 fCache = new Double_t[fCacheSize];; 287 }; 288 fNpoints = npoints;; 289 fPointSize = psize;; 290 return fCache;; 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// static: Set the maximum number of function calls for the minimization algorithm; 295/// For example for MIGRAD this is the maxcalls value passed as first argument; 296/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 297 ; 298void TVirtualFitter::SetMaxIterations(Int_t niter); 299{; 300 ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(niter);; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// static: Set the Error Definition (default=1); 305/// For Minuit this is the value passed with the ""SET ERR"" command; 306/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html); 307 ; 308void TVirtualFitter::SetErrorDef(Double_t errdef); 309{; 310// fgErrorDef = errdef;; 311 ROOT::Math::MinimizerOptions::SetDefaultErrorDef(errdef);; 312 if (!GetGlobalFitter()) return;; 313 Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:8845,cache,cache,8845,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,1,['cache'],['cache']
Performance,"/////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129895,cache,cached,129895,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"//////////////////////; 276 /// returns configured window width (0 - default); 277 /// actual window width can be different; 278 unsigned GetWidth() const { return fWidth; }; 279 ; 280 /////////////////////////////////////////////////////////////////////////; 281 /// returns configured window height (0 - default); 282 unsigned GetHeight() const { return fHeight; }; 283 ; 284 /////////////////////////////////////////////////////////////////////////; 285 /// returns configured window X position (-1 - default); 286 int GetX() const { return fX; }; 287 ; 288 /////////////////////////////////////////////////////////////////////////; 289 /// returns configured window Y position (-1 - default); 290 int GetY() const { return fY; }; 291 ; 292 void SetConnLimit(unsigned lmt = 0);; 293 ; 294 unsigned GetConnLimit() const;; 295 ; 296 void SetConnToken(const std::string &token = """");; 297 ; 298 /////////////////////////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:13889,queue,queue,13889,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"//////////////////////; 279 /// returns configured window width (0 - default); 280 /// actual window width can be different; 281 unsigned GetWidth() const { return fWidth; }; 282 ; 283 /////////////////////////////////////////////////////////////////////////; 284 /// returns configured window height (0 - default); 285 unsigned GetHeight() const { return fHeight; }; 286 ; 287 /////////////////////////////////////////////////////////////////////////; 288 /// returns configured window X position (-1 - default); 289 int GetX() const { return fX; }; 290 ; 291 /////////////////////////////////////////////////////////////////////////; 292 /// returns configured window Y position (-1 - default); 293 int GetY() const { return fY; }; 294 ; 295 void SetConnLimit(unsigned lmt = 0);; 296 ; 297 unsigned GetConnLimit() const;; 298 ; 299 void SetConnToken(const std::string &token = """");; 300 ; 301 /////////////////////////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:14040,queue,queue,14040,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"//////////////////////; 7004/// Copy the content to a new new file, update this TTree with the new; 7005/// location information and attach this TTree to the new directory.; 7006///; 7007/// options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for; 7008/// details; 7009///; 7010/// If new and old directory are in the same file, the data is untouched,; 7011/// this ""just"" does a call to SetDirectory.; 7012/// Equivalent to an ""in place"" cloning of the TTree.; 7013bool TTree::InPlaceClone(TDirectory *newdirectory, const char *options); 7014{; 7015 if (!newdirectory) {; 7016 LoadBaskets(2*fTotBytes);; 7017 SetDirectory(nullptr);; 7018 return true;; 7019 }; 7020 if (newdirectory->GetFile() == GetCurrentFile()) {; 7021 SetDirectory(newdirectory);; 7022 return true;; 7023 }; 7024 TTreeCloner cloner(this, newdirectory, options);; 7025 if (cloner.IsValid()); 7026 return cloner.Exec();; 7027 else; 7028 return false;; 7029}; 7030 ; 7031////////////////////////////////////////////////////////////////////////////////; 7032/// Function called when loading a new class library.; 7033 ; 7034bool TTree::Notify(); 7035{; 7036 TIter next(GetListOfLeaves());; 7037 TLeaf* leaf = nullptr;; 7038 while ((leaf = (TLeaf*) next())) {; 7039 leaf->Notify();; 7040 leaf->GetBranch()->Notify();; 7041 }; 7042 return true;; 7043}; 7044 ; 7045////////////////////////////////////////////////////////////////////////////////; 7046/// This function may be called after having filled some entries in a Tree.; 7047/// Using the information in the existing branch buffers, it will reassign; 7048/// new branch buffer sizes to optimize time and memory.; 7049///; 7050/// The function computes the best values for branch buffer sizes such that; 7051/// the total buffer sizes is less than maxMemory and nearby entries written; 7052/// at the same time.; 7053/// In case the branch compression factor for the data written so far is less; 7054/// than compMin, the compression is disabled.; 7055///; 705",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:275076,load,loading,275076,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loading']
Performance,"///////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:139198,load,loading,139198,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loading']
Performance,"//////////////////; 110/// Destructor; 111 ; 112TGeoPhysicalNode::~TGeoPhysicalNode(); 113{; 114 if (fMatrices) {; 115 fMatrices->Delete();; 116 delete fMatrices;; 117 }; 118 if (fNodes); 119 delete fNodes;; 120 if (fMatrixOrig); 121 delete fMatrixOrig;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////////; 125/// Align a physical node with a new relative matrix/shape.; 126/// Example: /TOP_1/A_1/B_1/C_1; 127/// node->Align(transl_1, box) will perform:; 128/// - change RELATIVE translation of C_1 node (with respect to its; 129/// container volume B) to transl_1; 130/// - change the shape of the C volume; 131/// *NOTE* The operations will affect ONLY the LAST node in the branch. All; 132/// volumes/nodes in the branch represented by this physical node are; 133/// CLONED so the operation does not affect other possible replicas.; 134 ; 135Bool_t TGeoPhysicalNode::Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check, Double_t ovlp); 136{; 137 if (!newmat && !newshape); 138 return kFALSE;; 139 if (TGeoManager::IsLocked()) {; 140 Error(""Align"", ""Not performed. Geometry in LOCKED mode !"");; 141 return kFALSE;; 142 }; 143 if (newmat == gGeoIdentity) {; 144 Error(""Align"", ""Cannot align using gGeoIdentity. Use some default matrix constructor to represent identities."");; 145 return kFALSE;; 146 }; 147 TGeoNode *node = GetNode();; 148 if (node->IsOffset()) {; 149 Error(""Align"", ""Cannot align division nodes: %s\n"", node->GetName());; 150 return kFALSE;; 151 }; 152 // Refresh the node since other Align calls may have altered the stored nodes; 153 Refresh();; 154 TGeoNode *nnode = nullptr;; 155 TGeoVolume *vm = GetVolume(0);; 156 TGeoVolume *vd = nullptr;; 157 Int_t i;; 158 if (!IsAligned()) {; 159 Int_t *id = new Int_t[fLevel];; 160 for (i = 0; i < fLevel; i++) {; 161 // Store daughter indexes; 162 vd = GetVolume(i);; 163 node = GetNode(i + 1);; 164 id[i] = vd->GetIndex(node);; 165 if (id[i] < 0) {; 166 Error(""Align"", ""%s cannot a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:4879,perform,performed,4879,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['perform'],['performed']
Performance,"//////////////////; 536/// Return absolute index to last object in array. Returns -1 in case; 537/// array is empty.; 538 ; 539Int_t TObjArray::GetAbsLast() const; 540{; 541 // For efficiency we need sometimes to update fLast so we have; 542 // to cast const away. Ugly, but making GetAbsLast() not const breaks; 543 // many other const functions.; 544 ; 545 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 546 ; 547 if (fLast == -2) {; 548 for (Int_t i = fSize-1; i >= 0; i--); 549 if (fCont[i]) {; 550 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 551 ((TObjArray*)this)->fLast = i;; 552 return fLast;; 553 }; 554 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 555 ((TObjArray*)this)->fLast = -1;; 556 }; 557 return fLast;; 558}; 559 ; 560////////////////////////////////////////////////////////////////////////////////; 561/// Return the number of objects in array (i.e. number of non-empty slots).; 562/// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; 563/// it will not be invoked concurrently.; 564 ; 565Int_t TObjArray::GetEntriesUnsafe() const; 566{; 567 if (R__unlikely(fLast == -2)); 568 return GetEntriesFast();; 569 else; 570 return fLast + 1;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return index of last object in array. Returns lowerBound-1 in case; 575/// array is empty.; 576 ; 577Int_t TObjArray::GetLast() const; 578{; 579 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 580 ; 581 return fLowerBound+GetAbsLast();; 582}; 583 ; 584////////////////////////////////////////////////////////////////////////////////; 585/// Return address of pointer obj. If obj is 0 returns address of container.; 586 ; 587TObject **TObjArray::GetObjectRef(const TObject *obj) const; 588{; 589 if (!obj); 590 return fCont;; 591 ; 592 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 593 ; 594 Int_t index = IndexOf(obj);; 595 return &fCont[index];; 596}; 597 ; 598////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObjArray_8cxx_source.html:18495,concurren,concurrently,18495,doc/master/TObjArray_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"/////////////////; 4369/// Create list of pointers to base class(es) for TClass cl.; 4370 ; 4371void TCling::CreateListOfBaseClasses(TClass *cl) const; 4372{; 4373 R__LOCKGUARD(gInterpreterMutex);; 4374 if (cl->fBase) {; 4375 return;; 4376 }; 4377 TClingClassInfo *tci = (TClingClassInfo *)cl->GetClassInfo();; 4378 if (!tci) return;; 4379 TClingBaseClassInfo t(GetInterpreterImpl(), tci);; 4380 TList *listOfBase = new TList;; 4381 while (t.Next()) {; 4382 // if name cannot be obtained no use to put in list; 4383 if (t.IsValid() && t.Name()) {; 4384 TClingBaseClassInfo *a = new TClingBaseClassInfo(t);; 4385 listOfBase->Add(new TBaseClass((BaseClassInfo_t *)a, cl));; 4386 }; 4387 }; 4388 // Now that is complete, publish it.; 4389 cl->fBase = listOfBase;; 4390}; 4391 ; 4392////////////////////////////////////////////////////////////////////////////////; 4393/// Create list of pointers to enums for TClass cl.; 4394 ; 4395void TCling::LoadEnums(TListOfEnums& enumList) const; 4396{; 4397 R__LOCKGUARD(gInterpreterMutex);; 4398 ; 4399 const Decl * D;; 4400 TClass* cl = enumList.GetClass();; 4401 if (cl) {; 4402 D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();; 4403 }; 4404 else {; 4405 D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 4406 }; 4407 // Iterate on the decl of the class and get the enums.; 4408 if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {; 4409 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 4410 // Collect all contexts of the namespace.; 4411 llvm::SmallVector< DeclContext *, 4> allDeclContexts;; 4412 const_cast< clang::DeclContext *>(DC)->collectAllContexts(allDeclContexts);; 4413 for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(), declEnd = allDeclContexts.end();; 4414 declIter != declEnd; ++declIter) {; 4415 // Iterate on all decls for each context.; 4416 for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),; 4417 DE = (*declIter)->d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:170525,Load,LoadEnums,170525,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadEnums']
Performance,"///////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != dynamic_cast<TTreeCacheUnzip*>(pf)))) {; 9310 // done with opt and type are in agreement.; 9311 return;; 9312 }; 9313 delete pf;; 9314 auto cacheSize = GetCacheAutoSize(true);; 9315 if (opt) {; 9316 auto unzip = new TTreeCacheUnzip(this, cacheSize);; 9317 unzip->SetUnzipBufferSize( Long64_t(cacheSize * RelSize) );; 9318 } else {; 9319 pf = new TTreeCache(this, cacheSize);; 9320 }; 9321#else; 9322 (void)opt;; 9323 (void)RelSize;; 9324#endif; 9325}; 9326 ; 9327////////////////////////////////////////////////////////////////////////////////; 9328/// Set perf stats; 9329 ; 9330void TTree::SetPerfStats(TVirtualPerfStats *perf); 9331{; 9332 fPerfStats = perf;; 9333}; 9334 ; 9335////////////////////////////////////////////////////////////////////////////////; 9336/// The current TreeIndex is replaced by the new index.; 9337/// Note that this function does not delete the previous index.; 9338/// This gives the possibility to play with more than one index, e.g.,; 9339/// ~~~ {.cpp}; 9340/// TVirtualIndex* oldIndex = tree.GetTreeIndex();; 9341/// tree.SetTreeIndex(newIndex);; 9342/// tree.Draw();; 9343/// tree.SetTreeIndex(oldIndex);; 9344/// tree.Draw(); etc; 9345/// ~~~; 9346 ; 9347void TTree::SetTreeIndex(TVirtualIndex* index); 9348{; 9349 if (fTreeIndex) {; 9350 fTreeIndex->SetTree(nullptr);; 9351 }; 9352 fTreeIndex = index;; 9353}; 9354 ; 9355////////////////////////////////////////////////////////////////////////////////; 9356/// Set tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:359830,cache,cacheSize,359830,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,4,['cache'],['cacheSize']
Performance,"//////////////; 17// //; 18// TBaseClass //; 19// //; 20// Description of a base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TDictionary.h""; 26#include ""TClassRef.h""; 27 ; 28#include <atomic>; 29 ; 30class TBrowser;; 31class TClass;; 32 ; 33class TBaseClass : public TDictionary {; 34#ifndef __CLING__; 35 using AtomicInt_t = std::atomic<Int_t>;; 36 static_assert(sizeof(std::atomic<Int_t>) == sizeof(Int_t),; 37 ""We requiqre atomic<int> and <int> to have the same size but they are not"");; 38#else; 39 // std::atomic is not yet supported in the I/O, so; 40 // we hide them from Cling; 41 using AtomicInt_t = Int_t;; 42#endif; 43 ; 44private:; 45 TBaseClass(const TBaseClass &) = delete;; 46 TBaseClass&operator=(const TBaseClass &) = delete;; 47 ; 48private:; 49 BaseClassInfo_t *fInfo; //!pointer to CINT base class info; 50 TClassRef fClassPtr; // pointer to the base class TClass; 51 TClass *fClass; //!pointer to parent class; 52 AtomicInt_t fDelta; // BaseClassInfo_t offset (INT_MAX if unset); 53 mutable AtomicInt_t fProperty; // BaseClassInfo_t's properties; 54 Int_t fSTLType; // cache of IsSTLContainer(); 55 ; 56public:; 57 TBaseClass(BaseClassInfo_t *info = nullptr, TClass *cl = nullptr);; 58 virtual ~TBaseClass();; 59 ; 60 void Browse(TBrowser *b) override;; 61 const char *GetTitle() const override;; 62 TClass *GetClassPointer(Bool_t load=kTRUE);; 63 Int_t GetDelta();; 64 Bool_t IsFolder() const override {return kTRUE;}; 65 ROOT::ESTLType IsSTLContainer();; 66 Long_t Property() const override;; 67 void SetClass(TClass* cl) { fClass = cl; }; 68 ; 69 ClassDefOverride(TBaseClass,2) //Description of a base class; 70};; 71 ; 72#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TClassRef.h; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBaseClass_8h_source.html:1916,cache,cache,1916,doc/master/TBaseClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html,2,"['cache', 'load']","['cache', 'load']"
Performance,"/////////////; 2490/// Update canvas pad buffers.; 2491 ; 2492void TCanvas::Update(); 2493{; 2494 fUpdated = kTRUE;; 2495 ; 2496 if (fUpdating) return;; 2497 ; 2498 if (fPixmapID == -1) return;; 2499 ; 2500 static const union CastFromFuncToVoidPtr_t {; 2501 CastFromFuncToVoidPtr_t(): fFuncPtr(ROOT_TCanvas_Update) {}; 2502 void (*fFuncPtr)(void*);; 2503 void* fVoidPtr;; 2504 } castFromFuncToVoidPtr;; 2505 ; 2506 if (gThreadXAR) {; 2507 void *arr[3];; 2508 arr[1] = this;; 2509 arr[2] = castFromFuncToVoidPtr.fVoidPtr;; 2510 if ((*gThreadXAR)(""CUPD"", 3, arr, nullptr)) return;; 2511 }; 2512 ; 2513 if (!fCanvasImp) return;; 2514 ; 2515 if (!gVirtualX->IsCmdThread()) {; 2516 // Why do we have this (which uses the interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:81889,Perform,PerformUpdate,81889,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Perform'],['PerformUpdate']
Performance,"/////////////; 2946 ; 2947template Double_t TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const;; 2948template Long64_t TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const;; 2949template LongDouble_t TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const;; 2950 ; 2951template <typename T>; 2952T TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const; 2953{; 2954 // -- Returns the branch value.; 2955 //; 2956 // If the leaf is an array, j is the index in the array.; 2957 //; 2958 // If leaf is an array inside a TClonesArray, len should be the length; 2959 // of the array.; 2960 //; 2961 // If subarr is true, then len is actually the index within the sub-array.; 2962 //; 2963 ; 2964 ValidateAddress();; 2965 ; 2966 Int_t prID = fID;; 2967 char *object = fObject;; 2968 if (TestBit(kCache)) {; 2969 if (GetInfoImp()->GetElements()->At(fID)->TestBit(TStreamerElement::kRepeat)) {; 2970 prID = fID+1;; 2971 } else if (fOnfileObject) {; 2972 object = fOnfileObject->GetObjectAt(0);; 2973 }; 2974 }; 2975 ; 2976 if (!j && fBranchCount) {; 2977 Long64_t entry = fTree->GetReadEntry();; 2978 // Since reloading the index, will reset the ClonesArray, let's; 2979 // skip the load if we already read this entry.; 2980 if (entry != fBranchCount->GetReadEntry()) {; 2981 fBranchCount->TBranch::GetEntry(entry);; 2982 }; 2983 if (fBranchCount2 && entry != fBranchCount2->GetReadEntry()) {; 2984 fBranchCount2->TBranch::GetEntry(entry);; 2985 }; 2986 }; 2987 ; 2988 if (TestBit(kDecomposedObj)) {; 2989 if (!fAddress) {; 2990 return 0;; 2991 }; 2992 if ((fType == 3) || (fType == 4)) {; 2993 // Top-level branch of a TClonesArray.; 2994 return fNdata;; 2995 } else if ((fType == 31) || (fType == 41)) {; 2996 // sub branch of a TClonesArray; 2997 Int_t atype = fStreamerType;; 2998 if (atype < 20) {; 2999 atype += 20;; 3000 }; 3001 return GetInfoImp()->GetTypedValue<T>(fAddress, atype, j, 1);; 3002 } else if (fType <= 2) {; 3003 // branch in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:105732,load,load,105732,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['load']
Performance,/////////////; 326/// Forward to TROOT::GetClass().; 327 ; 328TClass *TBuffer::GetClass(const std::type_info &typeinfo); 329{; 330 return TClass::GetClass(typeinfo);; 331}; 332 ; 333////////////////////////////////////////////////////////////////////////////////; 334/// Forward to TROOT::GetClass().; 335 ; 336TClass *TBuffer::GetClass(const char *className); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the current Process-ID.; 343 ; 344TProcessID *TBuffer::ReadProcessID(UShort_t pidf); 345{; 346 if (!pidf) return TProcessID::GetPID(); //may happen when cloning an object; 347 return nullptr;; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:11910,cache,cache,11910,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"/////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:143252,load,load,143252,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"/////////////; 3835/// Return list containing the TDataMembers of a class.; 3836 ; 3837TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3838{; 3839 // Fast path, no lock? Classes load at creation time.; 3840 if (IsClassStructOrUnion()) {; 3841 auto data = fData.load();; 3842 if (data && data->IsLoaded()); 3843 return data;; 3844 } else if (!load && fData); 3845 return fData;; 3846 ; 3847 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3848}; 3849 ; 3850////////////////////////////////////////////////////////////////////////////////; 3851/// Return list containing the TDataMembers of using declarations of a class.; 3852 ; 3853TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3854{; 3855 // Fast path, no lock? Classes load at creation time.; 3856 if ((!load || IsClassStructOrUnion()) && fUsingData); 3857 return fUsingData;; 3858 ; 3859 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3860}; 3861 ; 3862////////////////////////////////////////////////////////////////////////////////; 3863/// Return TListOfFunctionTemplates for a class.; 3864 ; 3865TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3866{; 3867 R__LOCKGUARD(gInterpreterMutex);; 3868 ; 3869 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3870 if (load) fFuncTemplate->Load();; 3871 return fFuncTemplate;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Return list containing the TMethods of a class.; 3876/// If load is true, the list is populated with all the defined function; 3877/// and currently instantiated function template.; 3878 ; 3879TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3880{; 3881 R__LOCKGUARD(gInterpreterMutex);; 3882 ; 3883 if (!fMethod.load()) GetMethodList();; 3884 if (load) {; 3885 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:146003,load,load,146003,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:171007,cache,cache,171007,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,8,['cache'],"['cache', 'cachetagfile']"
Performance,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:239057,Load,LoadClass,239057,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,7,"['Load', 'load']","['LoadClass', 'loaded', 'loading']"
Performance,"/////////////; 977/// Generate a collection of graphs, for all methods for a given class. Suitable; 978/// for comparing method performance.; 979///; 980/// Argument iClass specifies the class to generate the ROC curve in a; 981/// multiclass setting. It is ignored for binary classification.; 982///; 983/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 984/// and the others considered background. This is ok in binary classification; 985/// but in in multi class classification, the ROC surface is an N dimensional; 986/// shape, where N is number of classes - 1.; 987 ; 988TMultiGraph *TMVA::Factory::GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type); 989{; 990 return GetROCCurveAsMultiGraph((TString)loader->GetName(), iClass, type);; 991}; 992 ; 993////////////////////////////////////////////////////////////////////////////////; 994/// Generate a collection of graphs, for all methods for a given class. Suitable; 995/// for comparing method performance.; 996///; 997/// Argument iClass specifies the class to generate the ROC curve in a; 998/// multiclass setting. It is ignored for binary classification.; 999///; 1000/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 1001/// and the others considered background. This is ok in binary classification; 1002/// but in in multi class classification, the ROC surface is an N dimensional; 1003/// shape, where N is number of classes - 1.; 1004 ; 1005TMultiGraph *TMVA::Factory::GetROCCurveAsMultiGraph(TString datasetname, UInt_t iClass, Types::ETreeType type); 1006{; 1007 UInt_t line_color = 1;; 1008 ; 1009 TMultiGraph *multigraph = new TMultiGraph();; 1010 ; 1011 MVector *methods = fMethodsMap[datasetname.Data()];; 1012 for (auto *method_raw : *methods) {; 1013 TMVA::MethodBase *method = dynamic_cast<TMVA::MethodBase *>(method_raw);; 1014 if (method == nullptr) {; 1015 continue;; 1016 }; 1017 ; 1018 TString methodName = method->GetMethodName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:40725,perform,performance,40725,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['perform'],['performance']
Performance,"////////////; 1390/// Draw random points in the bounding box of this volume.; 1391 ; 1392void TGeoVolume::RandomPoints(Int_t npoints, Option_t *option); 1393{; 1394 if (gGeoManager != fGeoManager); 1395 gGeoManager = fGeoManager;; 1396 TGeoVolume *old_vol = fGeoManager->GetTopVolume();; 1397 if (old_vol != this); 1398 fGeoManager->SetTopVolume(this);; 1399 else; 1400 old_vol = nullptr;; 1401 fGeoManager->RandomPoints(this, npoints, option);; 1402 if (old_vol); 1403 fGeoManager->SetTopVolume(old_vol);; 1404}; 1405 ; 1406////////////////////////////////////////////////////////////////////////////////; 1407/// Random raytracing method.; 1408 ; 1409void TGeoVolume::RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol,; 1410 Bool_t check_norm); 1411{; 1412 if (gGeoManager != fGeoManager); 1413 gGeoManager = fGeoManager;; 1414 TGeoVolume *old_vol = fGeoManager->GetTopVolume();; 1415 if (old_vol != this); 1416 fGeoManager->SetTopVolume(this);; 1417 else; 1418 old_vol = nullptr;; 1419 fGeoManager->RandomRays(nrays, startx, starty, startz, target_vol, check_norm);; 1420 if (old_vol); 1421 fGeoManager->SetTopVolume(old_vol);; 1422}; 1423 ; 1424////////////////////////////////////////////////////////////////////////////////; 1425/// Draw this volume with current settings and perform raytracing in the pad.; 1426 ; 1427void TGeoVolume::Raytrace(Bool_t flag); 1428{; 1429 TGeoAtt::SetVisRaytrace(kFALSE);; 1430 if (gGeoManager != fGeoManager); 1431 gGeoManager = fGeoManager;; 1432 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1433 Bool_t drawn = (painter->GetDrawnVolume() == this) ? kTRUE : kFALSE;; 1434 if (!drawn) {; 1435 painter->DrawVolume(this, """");; 1436 TGeoAtt::SetVisRaytrace(flag);; 1437 painter->ModifiedPad();; 1438 return;; 1439 }; 1440 TGeoAtt::SetVisRaytrace(flag);; 1441 painter->ModifiedPad();; 1442}; 1443 ; 1444////////////////////////////////////////////////////////////////////////////////; 1445/// Save ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:54931,perform,perform,54931,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['perform'],['perform']
Performance,"///////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void TCanvas::SetGrayscale(Bool_t set /*= kTRUE*/); 2580{; 2581 if (IsGrayscale() == set) return;; 2582 SetBit(kIsGrayscale, set);; 2583 if (IsWeb()) {; 2584 Modified();; 2585 UpdateAsync();; 2586 } else {; 2587 Paint(); // update canvas and all sub-pads, unconditionally!; 2588 }; 2589}; 2590 ; 2591////////////////////////////////////////////////////////////////////////////////; 2592/// Probably, TPadPainter must be placed in a separate ROOT module -; 2593/// ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; 2594/// gpad dir, so, in case of default painter, no *.so should be loaded,; 2595/// no need in plugin managers.; 2596/// May change in future.; 2597 ; 2598void TCanvas::CreatePainter(); 2599{; 2600 //Even for batch mode painter is still required, just to delegate; 2601 //some calls to batch ""virtual X"".; 2602 if (!UseGL() || fBatch) {; 2603 fPainter = nullptr;; 2604 if (fCanvasImp) fPainter = fCanvasImp->CreatePadPainter();; 2605 if (!fPainter) fPainter = new TPadPainter; // Do not need plugin manager for this!; 2606 } else {; 2607 fPainter = TVirtualPadPainter::PadPainter(""gl"");; 2608 if (!fPainter) {; 2609 Error(""CreatePainter"", ""GL Painter creation failed! Will use default!"");; 2610 fPainter = new TPadPainter;; 2611 fUseGL = kFALSE;; 2612 }; 2613 }; 2614}; 2615 ; 2616////////////////////////////////////////////////////////////////////////////////; 2617/// Access and (probably) creation of pad painter.; 2618 ; 2619TVirtualPadPainter *TCanvas::GetCanvasPainter(); 2620{; 2621 if (!fPainter) CreatePainter();; 2622 return fPainter;; 2623}; 2624 ; 2625 ; 2626///////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:84175,load,loaded,84175,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['load'],['loaded']
Performance,"//////////; 1020/// Return true if the content is of type 'pointer to'; 1021 ; 1022Bool_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:33877,load,load,33877,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"//////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:86561,load,loading,86561,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loading']
Performance,"/////////; 1214/// Merge all histograms in the collection in this histogram.; 1215/// This function computes the min/max for the axes,; 1216/// compute a new number of bins, if necessary,; 1217/// add bin contents, errors and statistics.; 1218/// If overflows are present and limits are different the function will fail.; 1219/// The function returns the total number of entries in the result histogram; 1220/// if the merge is successful, -1 otherwise.; 1221///; 1222/// IMPORTANT remark. The 2 axis x and y may have different number; 1223/// of bins and different limits, BUT the largest bin width must be; 1224/// a multiple of the smallest bin width and the upper limit must also; 1225/// be a multiple of the bin width.; 1226 ; 1227Long64_t TProfile2D::Merge(TCollection *li); 1228{; 1229 return TProfileHelper::Merge(this, li);; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Performs the operation: this = this*c1*f1; 1234 ; 1235Bool_t TProfile2D::Multiply(TF1 *, Double_t ); 1236{; 1237 Error(""Multiply"",""Function not implemented for TProfile2D"");; 1238 return kFALSE;; 1239}; 1240 ; 1241////////////////////////////////////////////////////////////////////////////////; 1242/// Multiply this profile2D by h1.; 1243///; 1244/// `this = this*h1`; 1245 ; 1246Bool_t TProfile2D::Multiply(const TH1 *); 1247{; 1248 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1249 return kFALSE;; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Replace contents of this profile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:43213,Perform,Performs,43213,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['Perform'],['Performs']
Performance,"///////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClass(className);; 1920 }; 1921 return cla;; 1922}; 1923 ; 1924////////////////////////////////////////////////////////////////////////////////; 1925/// Return 1 if the name of the given include file corresponds to a class that; 1926/// is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector.; 1927 ; 1928Int_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/); 1929{; 1930 if (fname == nullptr) return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:73370,load,loading,73370,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loading']
Performance,"//////; 1266/// Set the TTree to be reloaded as soon as possible. In particular this; 1267/// is needed when adding a Friend.; 1268///; 1269/// If the tree has clones, copy them into the chain; 1270/// clone list so we can change their branch addresses; 1271/// when necessary.; 1272///; 1273/// This is to support the syntax:; 1274/// ~~~ {.cpp}; 1275/// TTree* clone = chain->GetTree()->CloneTree(0);; 1276/// ~~~; 1277 ; 1278void TChain::InvalidateCurrentTree(); 1279{; 1280 if (fTree && fTree->GetListOfClones()) {; 1281 for (TObjLink* lnk = fTree->GetListOfClones()->FirstLink(); lnk; lnk = lnk->Next()) {; 1282 TTree* clone = (TTree*) lnk->GetObject();; 1283 AddClone(clone);; 1284 }; 1285 }; 1286 fTreeNumber = -1;; 1287 fTree = nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Dummy function.; 1292/// It could be implemented and load all baskets of all trees in the chain.; 1293/// For the time being use TChain::Merge and TTree::LoadBasket; 1294/// on the resulting tree.; 1295 ; 1296Int_t TChain::LoadBaskets(Long64_t /*maxmemory*/); 1297{; 1298 Error(""LoadBaskets"", ""Function not yet implemented for TChain."");; 1299 return 0;; 1300}; 1301 ; 1302////////////////////////////////////////////////////////////////////////////////; 1303/// Find the tree which contains entry, and set it as the current tree.; 1304///; 1305/// Returns the entry number in that tree.; 1306///; 1307/// The input argument entry is the entry serial number in the whole chain.; 1308///; 1309/// In case of error, LoadTree returns a negative number:; 1310/// * -1: The chain is empty.; 1311/// * -2: The requested entry number is less than zero or too large for the chain.; 1312/// * -3: The file corresponding to the entry could not be correctly open; 1313/// * -4: The TChainElement corresponding to the entry is missing or; 1314/// the TTree is missing from the file.; 1315/// * -5: Internal error, please report the circumstance when this hap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:47091,Load,LoadBasket,47091,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadBasket']
Performance,//////; 1652/// Change current path to point to the node having this id.; 1653/// Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons); 1654 ; 1655void TGeoManager::CdNode(Int_t nodeid); 1656{; 1657 GetCurrentNavigator()->CdNode(nodeid);; 1658}; 1659 ; 1660////////////////////////////////////////////////////////////////////////////////; 1661/// Get the unique ID of the current node.; 1662 ; 1663Int_t TGeoManager::GetCurrentNodeId() const; 1664{; 1665 return GetCurrentNavigator()->GetCurrentNodeId();; 1666}; 1667 ; 1668////////////////////////////////////////////////////////////////////////////////; 1669/// Make top level node the current node. Updates the cache accordingly.; 1670/// Determine the overlapping state of current node.; 1671 ; 1672void TGeoManager::CdTop(); 1673{; 1674 GetCurrentNavigator()->CdTop();; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Go one level up in geometry. Updates cache accordingly.; 1679/// Determine the overlapping state of current node.; 1680 ; 1681void TGeoManager::CdUp(); 1682{; 1683 GetCurrentNavigator()->CdUp();; 1684}; 1685 ; 1686////////////////////////////////////////////////////////////////////////////////; 1687/// Make a daughter of current node current. Can be called only with a valid; 1688/// daughter index (no check). Updates cache accordingly.; 1689 ; 1690void TGeoManager::CdDown(Int_t index); 1691{; 1692 GetCurrentNavigator()->CdDown(index);; 1693}; 1694 ; 1695////////////////////////////////////////////////////////////////////////////////; 1696/// Do a cd to the node found next by FindNextBoundary; 1697 ; 1698void TGeoManager::CdNext(); 1699{; 1700 GetCurrentNavigator()->CdNext();; 1701}; 1702 ; 1703////////////////////////////////////////////////////////////////////////////////; 1704/// Browse the tree of nodes starting from fTopNode according to pathname.; 1705/// Changes the path accordingly.; 1706 ; 1707Bool_t TGeoManager::cd(co,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:61856,cache,cache,61856,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['cache'],['cache']
Performance,"/////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:138779,optimiz,optimized,138779,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"///; 1144/// Return a pointer to the list of leaves of the current tree.; 1145///; 1146/// Warning: May set the current tree!; 1147 ; 1148TObjArray* TChain::GetListOfLeaves(); 1149{; 1150 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1151 // Make sure the element list is up to date; 1152 if (!TestBit(kProofUptodate)); 1153 SetProof(true, true);; 1154 return fProofChain->GetListOfLeaves();; 1155 }; 1156 if (fTree) {; 1157 return fTree->GetListOfLeaves();; 1158 }; 1159 LoadTree(0);; 1160 if (fTree) {; 1161 return fTree->GetListOfLeaves();; 1162 }; 1163 return nullptr;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Return maximum of column with name columname.; 1168 ; 1169Double_t TChain::GetMaximum(const char* columname); 1170{; 1171 Double_t theMax = -DBL_MAX;; 1172 for (Int_t file = 0; file < fNtrees; file++) {; 1173 Long64_t first = fTreeOffset[file];; 1174 LoadTree(first);; 1175 Double_t curmax = fTree->GetMaximum(columname);; 1176 if (curmax > theMax) {; 1177 theMax = curmax;; 1178 }; 1179 }; 1180 return theMax;; 1181}; 1182 ; 1183////////////////////////////////////////////////////////////////////////////////; 1184/// Return minimum of column with name columname.; 1185 ; 1186Double_t TChain::GetMinimum(const char* columname); 1187{; 1188 Double_t theMin = DBL_MAX;; 1189 for (Int_t file = 0; file < fNtrees; file++) {; 1190 Long64_t first = fTreeOffset[file];; 1191 LoadTree(first);; 1192 Double_t curmin = fTree->GetMinimum(columname);; 1193 if (curmin < theMin) {; 1194 theMin = curmin;; 1195 }; 1196 }; 1197 return theMin;; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Return the number of branches of the current tree.; 1202///; 1203/// Warning: May set the current tree!; 1204 ; 1205Int_t TChain::GetNbranches(); 1206{; 1207 if (fTree) {; 1208 return fTree->GetNbranches();; 1209 }; 1210 LoadTree(0);; 1211 if (fTree) {; 1212 return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:43296,Load,LoadTree,43296,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"///; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:9725,cache,cached,9725,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,3,['cache'],['cached']
Performance,"//; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4802 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4803 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4804 }; 4805 ; 4806 if (sinfo) {; 4807 sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );; 4808 if (sinfo) {; 4809 sinfo->SetClass(nullptr);; 4810 sinfo->SetName( newname );; 4811 sinfo->BuildCheck();; 4812 sinfo->BuildOld();; 4813 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4814 } else {; 4815 Error(""GetStreamerInfoAbstractEmulated"", ""could no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:182070,load,loaded,182070,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"//; 4831/// If the object does not exist, it is created; 4832///; 4833/// Warning: If we create a new streamer info, whether or not the build; 4834/// optimizes is controlled externally to us by a global variable!; 4835/// Don't call us unless you have set that variable properly; 4836/// with TStreamer::Optimize()!; 4837///; 4838 ; 4839TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4840{; 4841 TVirtualStreamerInfo *sinfo = nullptr;; 4842 ; 4843 TString newname(GetName());; 4844 newname += ""@@emulated"";; 4845 ; 4846 R__LOCKGUARD(gInterpreterMutex);; 4847 ; 4848 TClass *emulated = TClass::GetClass(newname);; 4849 ; 4850 if (emulated); 4851 sinfo = emulated->FindStreamerInfo(checksum);; 4852 ; 4853 if (!sinfo) {; 4854 // The emulated version of the streamerInfo is explicitly requested and has; 4855 // not been built yet.; 4856 ; 4857 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4858 ; 4859 if (!sinfo && (checksum != fCheckSum)) {; 4860 // When the requested version does not exist we return; 4861 // the TVirtualStreamerInfo for the currently loaded class version.; 4862 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4863 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4864 }; 4865 ; 4866 if (!sinfo) {; 4867 // Let's take the first available StreamerInfo as a start; 4868 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4869 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4870 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4871 }; 4872 ; 4873 if (sinfo) {; 4874 sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );; 4875 if (sinfo) {; 4876 sinfo->SetClass(nullptr);; 4877 sinfo->SetName( newname );; 4878 sinfo->BuildCheck();; 4879 sinfo->BuildOld();; 4880 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4881 } else {; 4882 Error(""GetStreamerInfoAbstractEmulated"", ""could no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:184821,load,loaded,184821,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"//; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:338999,cache,cacheSize,338999,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"//; 94///destructor; 95 ; 96TVirtualFFT::~TVirtualFFT(); 97{; 98 if (this==fgFFT); 99 fgFFT = nullptr;; 100}; 101 ; 102////////////////////////////////////////////////////////////////////////////////; 103///Returns a pointer to the FFT of requested size and type.; 104///; 105/// \param[in] ndim number of transform dimensions; 106/// \param[in] n sizes of each dimension (an array at least ndim long); 107/// \param [in] option consists of 3 parts - flag option and an option to create a new TVirtualFFT; 108/// 1. transform type option:; 109/// Available transform types are:; 110/// C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; 111/// see class description for details; 112/// 2. flag option: choosing how much time should be spent in planning the transform:; 113/// Possible options:; 114/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 115/// but probably sub-optimal performance; 116/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 117/// to do the transform; 118/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 119/// to do the transform; 120/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 121/// This option should be chosen depending on how many transforms of the; 122/// same size and type are going to be done.; 123/// Planning is only done once, for the first transform of this size and type.; 124/// 3. option allowing to choose between the global fgFFT and a new TVirtualFFT object; 125/// """" - default, changes and returns the global fgFFT variable; 126/// ""K"" (from ""keep"")- without touching the global fgFFT,; 127/// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; 128///; 129/// Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc.; 130 ; 131TVirtualFFT* TVirtualFFT::FFT(Int_t ndim, Int_t *n, Option_t *option); 132{; 133 ; 134 Int_t inputtype=0, currenttype=0;; 135 TString opt = option;; 136 opt.ToUpper();; 137 //find the tranform flag; 138 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:4817,perform,performance,4817,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['perform'],['performance']
Performance,"//Changes line attributes apart from style.; 606 Double_t a=0;; 607 Double_t b,c,d;; 608 b = TMath::Log(10)*test;; 609 d= 2*TMath::Pi()/(double)test;; 610 for (j=1; j<9; j++) {; 611 a=TMath::Log(j+1)-TMath::Log(j)+a;; 612 c=a/b*6.28+d*(i-1);; 613 gPad->PaintLine(0.,0.,TMath::Cos(c),TMath::Sin(c));; 614 }; 615 TAttLine::SetLineStyle(oldLineStyle);; 616 TAttLine::Modify();; 617 }; 618 }; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Paint radial divisions.; 623/// Check for editable pad or create default.; 624 ; 625void TGraphPolargram::PaintRadialDivisions(Bool_t drawaxis); 626{; 627 if (!gPad) return ;; 628 ; 629 static char chopt[8] = """";; 630 Int_t i,j;; 631 Int_t ndiv = TMath::Abs(fNdivRad);; 632 Int_t ndivMajor = ndiv%100;; 633 Int_t ndivMinor = ndiv/100;; 634 Int_t ndivmajor = 0;; 635 Double_t frwrmin = 0., frwrmax = 0., binWidth = 0;; 636 ; 637 THLimitsFinder::Optimize(fRwrmin,fRwrmax,ndivMajor,frwrmin,; 638 frwrmax, ndivmajor,binWidth,"""");; 639 ; 640 if (!gPad->GetLogx()) {; 641 gPad->RangeAxis(-1,-1,1,1);; 642 gPad->Range(-1.25,-1.25,1.25,1.25);; 643 Double_t umin = fRwrmin;; 644 Double_t umax = fRwrmax;; 645 Double_t rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin);; 646 Double_t rmajmax = (frwrmax-fRwrmin)/(fRwrmax-fRwrmin);; 647 Double_t dist = (rmajmax-rmajmin)/ndivmajor;; 648 Int_t ndivminor = 0;; 649 ; 650 chopt[0] = 0;; 651 strncat(chopt, ""SDH"", 4);; 652 if (fNdivRad < 0) strncat(chopt, ""N"",2);; 653 if(drawaxis){; 654 // Paint axis.; 655 TGaxis axis;; 656 axis.SetLabelSize(GetRadialLabelSize());; 657 axis.SetLabelColor(GetRadialColorLabel());; 658 axis.SetLabelFont(GetRadialLabelFont());; 659 axis.SetLabelOffset(GetRadialOffset());; 660 axis.PaintAxis(0, 0, TMath::Cos(GetAngle()), TMath::Sin(GetAngle()),; 661 umin, umax, ndiv, chopt, 0., kFALSE);; 662 }; 663 ; 664 // Paint Circles.; 665 // First paint main circle.; 666 PaintCircle(0.,0.,1,0.,360,0);; 667 // Optimised case.; 668 if (fNdivRad>0 ) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:21425,Optimiz,Optimize,21425,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,1,['Optimiz'],['Optimize']
Performance,"/3]. RooAbsCachedPdf::RooAbsCachedPdf ; (; const RooAbsCachedPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 57 of file RooAbsCachedPdf.cxx. Member Function Documentation. ◆ actualObservables(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedPdf::actualObservables ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooIntegralMorph, RooCachedPdf, and RooFFTConvPdf. ◆ actualParameters(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedPdf::actualParameters ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooIntegralMorph, RooCachedPdf, and RooFFTConvPdf. ◆ analyticalIntegralWN(). double RooAbsCachedPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 376 of file RooAbsCachedPdf.cxx. ◆ binningName(). virtual const char * RooAbsCachedPdf::binningName ; (; ); const. inlineprotectedvirtual . Definition at line 97 of file RooAbsCachedPdf.h. ◆ cacheNameSuffix(). std::string RooAbsCachedPdf::cacheNameSuffix ; (; const RooArgSet & ; nset); const. protected . Construct string with unique suffix for cache objects based on observable names that define cache configuration. ; Definition at line 241 of file RooAbsCachedPdf.cxx. ◆ Class(). static TClass * RooAbsCachedPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCachedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 137 of file RooAbsCachedPdf.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:78278,cache,cache,78278,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"/; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:38163,Load,LoadTree,38163,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,"['Load', 'load']","['LoadTree', 'load']"
Performance,"/; 1048/// The function returns the total number of bytes read.; 1049/// If the Tree has friend trees, the corresponding entry with; 1050/// the index values (major,minor) is read. Note that the master Tree; 1051/// and its friend may have different entry serial numbers corresponding; 1052/// to (major,minor).; 1053 ; 1054Int_t TChain::GetEntryWithIndex(Int_t major, Int_t minor); 1055{; 1056 Long64_t serial = GetEntryNumberWithIndex(major, minor);; 1057 if (serial < 0) return -1;; 1058 return GetEntry(serial);; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return a pointer to the current file.; 1063/// If no file is connected, the first file is automatically loaded.; 1064 ; 1065TFile* TChain::GetFile() const; 1066{; 1067 if (fFile) {; 1068 return fFile;; 1069 }; 1070 // Force opening the first file in the chain.; 1071 const_cast<TChain*>(this)->LoadTree(0);; 1072 return fFile;; 1073}; 1074 ; 1075////////////////////////////////////////////////////////////////////////////////; 1076/// Return a pointer to the leaf name in the current tree.; 1077 ; 1078TLeaf* TChain::GetLeaf(const char* branchname, const char *leafname); 1079{; 1080 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1081 // Make sure the element list is up to date; 1082 if (!TestBit(kProofUptodate)); 1083 SetProof(true, true);; 1084 return fProofChain->GetLeaf(branchname, leafname);; 1085 }; 1086 if (fTree) {; 1087 return fTree->GetLeaf(branchname, leafname);; 1088 }; 1089 LoadTree(0);; 1090 if (fTree) {; 1091 return fTree->GetLeaf(branchname, leafname);; 1092 }; 1093 return nullptr;; 1094}; 1095 ; 1096////////////////////////////////////////////////////////////////////////////////; 1097/// Return a pointer to the leaf name in the current tree.; 1098 ; 1099TLeaf* TChain::GetLeaf(const char* name); 1100{; 1101 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1102 // Make sure the element list is up to date; 1103 if (!TestBit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:40117,Load,LoadTree,40117,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"/; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:107739,perform,performed,107739,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['perform'],['performed']
Performance,"/< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:3340,Cache,Cache,3340,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.012 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00146 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0456 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.101 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:50200,perform,performance,50200,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performance']
Performance,"/df019_Cache.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df019__Cache_8py.html:989,cache,cached,989,doc/master/df019__Cache_8py.html,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html,1,['cache'],['cached']
Performance,"/fit/fitslicesy.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. fitslicesy.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; This macro shows also how to annotate a picture, change some pad parameters. ; ; #include <TCanvas.h>; #include <TFile.h>; #include <TH2F.h>; #include <TROOT.h>; #include <TStyle.h>; ; void fitslicesy() {; // Change some default parameters in the current style; gStyle->SetLabelSize(0.06,""x"");; gStyle->SetLabelSize(0.06,""y"");; gStyle->SetFrameFillColor(38);; gStyle->SetTitleW(0.6);; gStyle->SetTitleH(0.1);; ; // Connect the input file and get the 2-d histogram in memory; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hsimple.C"");; dir.ReplaceAll(""/./"",""/"");; if (!gInterpreter->IsLoaded(dir.Data())) gInterpreter->LoadMacro(dir.Data());; TFile *hsimpleFile = (TFile*)gROOT->ProcessLineFast(""hsimple(1)"");; if (!hsimpleFile) return;; TH2F *hpxpy = (TH2F*)hsimpleFile->Get(""hpxpy"");; ; // Create a canvas and divide it; TCanvas *c1 = new TCanvas(""c1"",""c1"",700,500);; c1->SetFillColor(42);; c1->Divide(2,1);; TPad *leftPad = (TPad*)c1->cd(1);;; leftPad->Divide(1,2);; ; // Draw 2-d original histogram; leftPad->cd(1);; gPad->SetTopMargin(0.12);; gPad->SetFillColor(33);; hpxpy->Draw();; hpxpy->GetXaxis()->SetLabelSize(0.06);; hpxpy->GetYaxis()->SetLabelSize(0.06);; hpxpy->SetMarkerColor(kYellow);; ; // Fit slices projected along Y fron bins in X [7,32] with more than 20 bins in Y filled; hpxpy->FitSlicesY(nullptr,7,32,20);; ; // Show fitted ""mean"" for each slice; leftPad->cd(2);; gPad->SetFillColor(33);; TH2F *hpxpy_0 = (TH2F*)hsimpleFile->Get(""hpxpy_0"");; hpxpy_0->Draw();; TPad *rightPad = (TPad*)c1->cd(2);; rightPad->Divide(1,2);; rightPad->cd(1);; gPad->SetTopMargin(0.12);; gPad->SetLeftMargin(0.15);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitslicesy_8C.html:1022,Load,LoadMacro,1022,doc/master/fitslicesy_8C.html,https://root.cern,https://root.cern/doc/master/fitslicesy_8C.html,1,['Load'],['LoadMacro']
Performance,"/libstdc++.""); 3497 || strstr(filename, ""/libgcc""); 3498 || strstr(filename, ""/libc.""); 3499 || strstr(filename, ""/libdl.""); 3500 || strstr(filename, ""/libm."")); 3501 return;; 3502#endif; 3503 // Update string of available libraries.; 3504 if (!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3538 if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {; 3539 UpdateListOfLoadedSharedLibraries();; 3540 }; 3541 switch (res) {; 3542 case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;; 3543 case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded: return 1;; 354",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:137047,Load,LoadLibResult,137047,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibResult']
Performance,"/size); 4987 fprintf(stderr, ""."");; 4988 } else; 4989 fprintf(stderr, ""="");; 4990 }; 4991 // Allow to update the GUI while uploading files; 4992 gSystem->ProcessEvents();; 4993 watch.Stop();; 4994 Double_t lCopy_time = watch.RealTime();; 4995 fprintf(stderr, ""| %.02f %% [%.01f MB/s]\r"",; 4996 100.0*(size?(bytesread/((float)size)):1), (lCopy_time>0.)?bytesread/lCopy_time/1048576.:0.);; 4997 watch.Continue();; 4998}; 4999 ; 5000////////////////////////////////////////////////////////////////////////////////; 5001/// Allows to copy this file to the dst URL. Returns kTRUE in case of success,; 5002/// kFALSE otherwise.; 5003 ; 5004Bool_t TFile::Cp(const char *dst, Bool_t progressbar, UInt_t buffersize); 5005{; 5006 Bool_t rmdestiferror = kFALSE;; 5007 TStopwatch watch;; 5008 Bool_t success = kFALSE;; 5009 ; 5010 TUrl dURL(dst, kTRUE);; 5011 ; 5012 TString oopt = ""RECREATE"";; 5013 TString ourl = dURL.GetUrl();; 5014 ; 5015 // Files will be open in RAW mode; 5016 TString raw = ""filetype=raw"";; 5017 ; 5018 // Set optimization options for the destination file; 5019 TString opt = dURL.GetOptions();; 5020 if (opt != """") opt += ""&"";; 5021 opt += raw;; 5022 ; 5023 // AliEn files need to know where the source file is; 5024 if (!strcmp(dURL.GetProtocol(), ""alien"")); 5025 opt += TString::Format(""&source=%s"", GetName());; 5026 ; 5027 dURL.SetOptions(opt);; 5028 ; 5029 char *copybuffer = nullptr;; 5030 ; 5031 TFile *sfile = this;; 5032 TFile *dfile = nullptr;; 5033 ; 5034 // ""RECREATE"" does not work always well with XROOTD; 5035 // namely when some pieces of the path are missing;; 5036 // we force ""NEW"" in such a case; 5037 if (TFile::GetType(ourl, """") == TFile::kNet) {; 5038 if (gSystem->AccessPathName(ourl)) {; 5039 oopt = ""NEW"";; 5040 // Force creation of the missing parts of the path; 5041 opt += ""&mkpath=1"";; 5042 dURL.SetOptions(opt);; 5043 }; 5044 }; 5045 ; 5046 // Open destination file; 5047 if (!(dfile = TFile::Open(dURL.GetUrl(), oopt))) {; 5048 ::Error(""TFile::Cp"", ""cannot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:183296,optimiz,optimization,183296,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"/statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool InitPoisson(double mu, const string& method = ""dstd""). Initialize method for the Poisson distribution; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""). Initialize method for the Binomial distribution; Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool ReInitDiscrDist(unsigned int npar, double* params). Reinitialize UNURAN by changing the distribution parameters but mantaining same distribution and method; It is implemented now only for predefined discrete distributions like the poisson or the binomial. double Sample(). Sample 1D distribution; User is responsible for having previously correctly initialized with TUnuran::Init. bool SampleMulti(double* x). Sample multidimensional distributions; User is responsible for having previously correctly initialized with TUnuran::Init. int SampleDiscr(). Sample discrete distributions; User is responsible for having previously correctly initialized with TUnuran::Init. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. void SetSee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuran.html:6635,perform,perform,6635,root/html528/TUnuran.html,https://root.cern,https://root.cern/root/html528/TUnuran.html,4,['perform'],['perform']
Performance,"/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:10020,Load,LoadPlugin,10020,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_KNN.weights.xml; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); <HEADER> ModulekNN : Optimizing tree for 4 variables with 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Booked classifier ""KNN"" of type: ""KNN""; : Booking ""LD method"" of type ""LD"" from dataset/weights/TMVAClassification_LD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_LD.weights.xml; : Booked classifier ""LD"" of type: ""LD""; : Booking ""Likelihood method"" of type ""Likelihood"" from dataset/weights/TMVAClassification_Likelihood.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Likelihood.weights.xml; : Booked classifier ""Likelihood"" of type: ""Likelihood""; : Booking ""LikelihoodPCA method"" of type ""Likelihood"" from dataset/weights/TMVAClassification_LikelihoodPCA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_LikelihoodPCA.weights.xml; : Booked classifier ""LikelihoodPCA"" of type: ""Likelihood""; : Booking ""MLPBNN method"" of type ""MLP"" from dataset/weights/TMVAClassification_MLPBNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:2189,Optimiz,Optimizing,2189,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['Optimiz'],['Optimizing']
Performance,"/weights/TMVARegression_KNN.weights.xml␛[0m; : Creating kd-tree with 1000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 2 variables with 1000 values; : <Fill> Class 1 has 1000 events; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_LD.weights.xml␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: PDEFoam for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of PDEFoam on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.0705 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: KNN for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of KNN on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.0918 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: LD for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of LD on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.00483 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: DNN_CPU for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of DNN_CPU on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.231 sec ; : Create variable histograms; : C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:127556,perform,performance,127556,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,"0 ""which are not pointers or arrays.\n"";; 291 ROOT::TMetaUtils::Error(""AnnotateFieldDecl"",; 292 msg, varName.c_str(), value.c_str());; 293 continue;; 294 }; 295 ; 296 ; 297 // These lines are here to use the root pcms. Indeed we need to annotate the AST; 298 // before persisting the ProtoClasses in the root pcms.; 299 // BEGIN ROOT PCMS; 300 if (name == propNames::comment) {; 301 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, value, nullptr, 0));; 302 }; 303 // END ROOT PCMS; 304 ; 305 if ((name == propNames::transient && value == ""true"") ||; 306 (name == propNames::persistent && value == ""false"")) { // special case; 307 userDefinedProperty = propNames::comment + propNames::separator + ""!"";; 308 // This next line is here to use the root pcms. Indeed we need to annotate the AST; 309 // before persisting the ProtoClasses in the root pcms.; 310 // BEGIN ROOT PCMS; 311 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, ""!"", nullptr, 0));; 312 // END ROOT PCMS; 313 // The rest of the lines are not changed to leave in place the system which; 314 // works with bulk header parsing on library load.; 315 } else {; 316 userDefinedProperty = name + propNames::separator + value;; 317 }; 318 ROOT::TMetaUtils::Info(nullptr, ""%s %s\n"", varName.c_str(), userDefinedProperty.c_str());; 319 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, userDefinedProperty, nullptr, 0));; 320 }; 321 }; 322 }; 323}; 324 ; 325////////////////////////////////////////////////////////////////////////////////; 326 ; 327void AnnotateDecl(clang::CXXRecordDecl &CXXRD,; 328 const RScanner::DeclsSelRulesMap_t &declSelRulesMap,; 329 cling::Interpreter &interpreter,; 330 bool isGenreflex); 331{; 332 // In order to store the meaningful for the IO comments we have to transform; 333 // the comment into annotation of the given decl.; 334 // This works only with comments in the headers, so no selection rules in an; 335 // xml file.; 336 ; 337 using namespace clang;; 338 SourceLocation commentSLoc;; 339 llvm::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:10549,load,load,10549,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['load'],['load']
Performance,"0 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:83172,cache,cache,83172,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,"0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for accelerated running); # Mode = 2 : Run fit from previously stored workspace including cached; # integrals (fast, run in mode=1 first); ; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; ; # Make/load workspace, here in mode 1; w = getWorkspace(mode); if mode == 1:; # Show workspace that was created; w.Print(); ; # Show plot of cached integral values; hhcache = w.expensiveObjectCache().getObj(1); if hhcache:; ROOT.TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:1502,CACHE,CACHEPARMINT,1502,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,2,"['CACHE', 'cache']","['CACHEPARMINT', 'cache']"
Performance,"0 ; 1731 // Remove from the typedef hashtables.; 1732 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1733 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1734 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1735 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1736 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1737 fgClassTypedefHash->Remove (htmp);; 1738 delete htmp;; 1739 break;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:67800,load,load,67800,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"0 \) ! ; Reimplemented from RooAbsPdf.; Definition at line 182 of file RooGamma.cxx. ◆ getAnalyticalIntegral(). Int_t RooGamma::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 105 of file RooGamma.cxx. ◆ getGenerator(). Int_t RooGamma::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 166 of file RooGamma.cxx. ◆ IsA(). TClass * RooGamma::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 51 of file RooGamma.h. ◆ Streamer(). void RooGamma::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooGamma::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:78386,Load,Load,78386,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['Load'],['Load']
Performance,"0 obj.GetAllocator()->Destructor(obj.GetPtr(), dtorOnly);; 5521 } else {; 5522 Destructor(obj.GetPtr(), dtorOnly);; 5523 }; 5524}; 5525 ; 5526////////////////////////////////////////////////////////////////////////////////; 5527/// Explicitly call operator delete[] for an array.; 5528 ; 5529void TClass::DeleteArray(void *ary, Bool_t dtorOnly); 5530{; 5531 // Do nothing if passed a null pointer.; 5532 if (ary == nullptr) return;; 5533 ; 5534 // Make a copy of the address.; 5535 void* p = ary;; 5536 ; 5537 if (fDeleteArray) {; 5538 if (dtorOnly) {; 5539 Error(""DeleteArray"", ""Destructor only is not supported!"");; 5540 } else {; 5541 // We have the array delete wrapper, use it.; 5542 fDeleteArray(ary);; 5543 }; 5544 } else if (HasInterpreterInfo()) {; 5545 // We have the dictionary but do not have the; 5546 // array delete wrapper, so the dictionary was; 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:212252,load,loaded,212252,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,0 of file TGeoNavigator.h. ◆ fCache. TGeoNodeCache* TGeoNavigator::fCache. private . current geometry ; Definition at line 73 of file TGeoNavigator.h. ◆ fCldir. Double_t TGeoNavigator::fCldir[3]. private . cosine of incident angle on current checked surface ; Definition at line 47 of file TGeoNavigator.h. ◆ fCldirChecked. Double_t TGeoNavigator::fCldirChecked[3]. private . unit vector to current closest shape ; Definition at line 48 of file TGeoNavigator.h. ◆ fCurrentMatrix. TGeoHMatrix* TGeoNavigator::fCurrentMatrix. private . backup state ; Definition at line 81 of file TGeoNavigator.h. ◆ fCurrentNode. TGeoNode* TGeoNavigator::fCurrentNode. private . current volume ; Definition at line 75 of file TGeoNavigator.h. ◆ fCurrentOverlapping. Bool_t TGeoNavigator::fCurrentOverlapping. private . flag set when an overlapping cluster is searched ; Definition at line 62 of file TGeoNavigator.h. ◆ fCurrentVolume. TGeoVolume* TGeoNavigator::fCurrentVolume. private . cache of states ; Definition at line 74 of file TGeoNavigator.h. ◆ fDirection. Double_t TGeoNavigator::fDirection[3]. private . current point ; Definition at line 50 of file TGeoNavigator.h. ◆ fDivMatrix. TGeoHMatrix* TGeoNavigator::fDivMatrix. private . current pointer to cached global matrix ; Definition at line 83 of file TGeoNavigator.h. ◆ fForcedNode. TGeoNode* TGeoNavigator::fForcedNode. private . next node that will be crossed ; Definition at line 79 of file TGeoNavigator.h. ◆ fGeometry. TGeoManager* TGeoNavigator::fGeometry. private . flag that last geometric step was null ; Definition at line 72 of file TGeoNavigator.h. ◆ fGlobalMatrix. TGeoHMatrix* TGeoNavigator::fGlobalMatrix. private . current stored global matrix ; Definition at line 82 of file TGeoNavigator.h. ◆ fgUsePWSafetyCaching. Bool_t TGeoNavigator::fgUsePWSafetyCaching = kFALSE. staticprivate . path to current node ; Definition at line 86 of file TGeoNavigator.h. ◆ fIsEntering. Bool_t TGeoNavigator::fIsEntering. private . flag a safe start for p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:46270,cache,cache,46270,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,"0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134171,cache,cache,134171,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance,"0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:17891,cache,cache,17891,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,6,['cache'],['cache']
Performance,"0 } else {; 2751 _normRangeOverride.Clear() ;; 2752 }; 2753 ; 2754 // the stuff that the clients have cached may depend on the normalization range; 2755 sterilizeClientCaches(*this);; 2756 ; 2757 if (_norm) {; 2758 _normMgr.sterilize() ;; 2759 _norm = nullptr ;; 2760 }; 2761}; 2762 ; 2763 ; 2764////////////////////////////////////////////////////////////////////////////////; 2765/// Hook function intercepting redirectServer calls. Discard current; 2766/// normalization object if any server is redirected; 2767 ; 2768bool RooAbsPdf::redirectServersHook(const RooAbsCollection & newServerList, bool mustReplaceAll,; 2769 bool nameChange, bool isRecursiveStep); 2770{; 2771 // If servers are redirected, the cached normalization integrals and; 2772 // normalization sets are most likely invalid.; 2773 _normMgr.sterilize();; 2774 ; 2775 // Object is own by _normCacheManager that will delete object as soon as cache; 2776 // is sterilized by server redirect; 2777 _norm = nullptr ;; 2778 ; 2779 // Similar to the situation with the normalization integral above: if a; 2780 // server is redirected, the cached normalization set might not point to; 2781 // the right observables anymore. We need to reset it.; 2782 setActiveNormSet(nullptr);; 2783 return RooAbsReal::redirectServersHook(newServerList, mustReplaceAll, nameChange, isRecursiveStep);; 2784}; 2785 ; 2786 ; 2787std::unique_ptr<RooAbsArg>; 2788RooAbsPdf::compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const; 2789{; 2790 if (normSet.empty() || selfNormalized()) {; 2791 return RooAbsReal::compileForNormSet(normSet, ctx);; 2792 }; 2793 std::unique_ptr<RooAbsPdf> pdfClone(static_cast<RooAbsPdf *>(this->Clone()));; 2794 ctx.compileServers(*pdfClone, normSet);; 2795 ; 2796 auto newArg = std::make_unique<RooNormalizedPdf>(*pdfClone, normSet);; 2797 ; 2798 // The direct servers are this pdf and the normalization integral, which; 2799 // don't need to be compiled further.; 2800 for (RooAbsArg *server : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:130993,cache,cache,130993,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"0 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252/////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:159560,cache,caches,159560,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['cache', 'load']","['caches', 'loading']"
Performance,"0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; RooNumIntConfig&binIntegratorConfig(); const RooNumIntConfig&binIntegratorConfig() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:2383,cache,cacheUniqueSuffix,2383,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['cache'],['cacheUniqueSuffix']
Performance,"0) override;  Process a data set (TFileCollection) using the specified selector object The default tree is analyzed (i.e. ;  ; Long64_t Process (TSelector *sel, Long64_t nent, Option_t *o="""") override;  Generic (non-data based) selector processing: the Process() method of the specified selector is called 'n' times. ;  ; Bool_t RegisterDataSet (const char *dsName, TFileCollection *ds, const char *opt="""") override;  Register the 'dataSet' on the cluster under the current user, group and the given 'dataSetName'. ;  ; Int_t Remove (const char *ref, Bool_t all);  Handle remove request. ;  ; Int_t RemoveDataSet (const char *uri, const char *=0) override;  Remove the specified dataset from the PROOF cluster. ;  ; Bool_t RequestStagingDataSet (const char *dataset) override;  Allows users to request staging of a particular dataset. ;  ; Int_t SetDataSetTreeName (const char *dataset, const char *treename) override;  Set/Change the name of the default tree. ;  ; void ShowCache (Bool_t all=kFALSE) override;  List contents of file cache. ;  ; void ShowData () override;  List contents of the data directory in the sandbox. ;  ; void ShowDataSetCache (const char *dataset=0) override;  Display the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ShowDataSets (const char *uri="""", const char *=0) override;  Shows datasets in locations that match the uri By default shows the user's datasets and global ones. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t VerifyDataSet (const char *uri, const char *=0) override;  Verify if all files in the specified dataset are available. ;  ;  Public Member Functions inherited from TProof;  TProof (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0);  Create a PROOF environment. ;  ;  ~TProof () override;  Clean up PR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:4909,cache,cache,4909,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:23030,cache,cache,23030,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:39444,optimiz,optimized,39444,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['optimiz'],['optimized']
Performance,"0*fontnumber + precision; fontnumberOption_t Option_t fontnumberDefinition TGWin32VirtualXProxy.cxx:60; Font numbers must be between 1 and 14.; The precision can be:. precision = 0 fast hardware fonts (steps in the size); precision = 1 scalable and rotatable hardware fonts (see below); precision = 2 scalable and rotatable hardware fonts; precision = 3 scalable and rotatable hardware fonts. Text size is given in pixels. The text font and precision of any class inheriting from TAttText can be changed using the method SetTextFont and retrieved using the method GetTextFont. Font quality and speed; When precision 0 is used, only the original non-scaled X11 system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behaviour depending if the True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotatable fonts. These days TTF fonts are rendered fast enough and can be used in all cases. How to use True Type Fonts; TTF fonts are used by default. They can be deactivated via the following line in the .rootrc file:; Unix.*.Root.UseTTFonts: false. List of the currently supported fonts; Font number TTF Names PostScript/PDF Names; 1 : ""Free Serif Italic"" ""Times-Italic""; 2 : ""Free Serif Bold"" ""Times-Bold""; 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 4 : ""Tex Gyre Regular"" ""Helvetica""; 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 8 : ""Free Mono"" ""Courier""; 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 10 : ""Free Mono Bold"" ""Courier-Bold""; 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 12 : ""Symbol"" ""Symbol""; 13 : ""Free Serif"" ""Times-Roman""; 14 : ""Wingdings"" ""ZapfDingbats""; TTFInterface to the freetype 2 library.Definition TTF.h:53; The PostScript and PDF backends use ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttText.html:8853,scalab,scalable,8853,doc/master/classTAttText.html,https://root.cern,https://root.cern/doc/master/classTAttText.html,1,['scalab'],['scalable']
Performance,"0, 1}, ""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; nslots = df2.GetNSlots();; auto h2 = df2.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; R__ADD_INCLUDE_PATH#define R__ADD_INCLUDE_PATH(PATH)Definition Rtypes.h:497; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; SOFIEHelpers.hxx; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; ; Running using 2 threads; AuthorLorenzo Moneta ; Definition in file TMVA_SOFIE_RDataFrame.C. tutorialstmvaTMVA_SOFIE_RDataFrame.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html:3299,multi-thread,multi-threading,3299,doc/master/TMVA__SOFIE__RDataFrame_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html,1,['multi-thread'],['multi-threading']
Performance,"0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. boolfAdaptiveSamplingcontrols use of adaptive sampling algorithm; RooStats::ConfidenceBelt*fConfBelt; boolfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData*fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; Int_tfNbinsnumber of samples per variable; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdfcommon PDF; RooAbsData*fPointsToTestpoints to perform the construction; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(); default constructor; fWS = new RooWorkspace(""FeldmanCousinsWS"");; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__FeldmanCousins.html:8226,perform,perform,8226,root/html526/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html526/RooStats__FeldmanCousins.html,1,['perform'],['perform']
Performance,"0, Total sum= 3.30469e+06; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_PDEFoam.weights.xml␛[0m; : Read foams from file: ␛[0;36mdatasetreg/weights/TMVARegression_PDEFoam.weights_foams.root␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_KNN.weights.xml␛[0m; : Creating kd-tree with 1000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 2 variables with 1000 values; : <Fill> Class 1 has 1000 events; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_LD.weights.xml␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: PDEFoam for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of PDEFoam on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.0705 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: KNN for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of KNN on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.0918 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: LD for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of LD on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.00483 sec ; : Create variable histograms; : Create regression target histograms; : Create regre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:127172,perform,performance,127172,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,"0, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let json = await toJSON(obj);; writrFileSync(""hpxpy.json"", json);; Such JSON string could be parsed by any other JSROOT-based application.; When WebGL rendering is used (lego plots or TGeo drawing), on the Linux one need to have DISPLAY correctly set to make it working. To run JSROOT on headless machine, one have to use xvfb-run utility, see also here:; [shell] xvfb-run -s ""-ac -screen 0 1280x1024x24"" node geomsvg.js; 1.11.9 Use with OpenUI5; OpenUI5 is a web toolkit for developers to ease and speed up the development of full-blown HTML5 web applications. JSROOT provides loadOpenui5 function to load supported OpenUI5:; <script type=""module"">; import { loadOpenui5 } from 'path_to_jsroot/modules/main.mjs';; let sap = await loadOpenui5();; sap.registerModulePath(""NavExample"", ""./"");; new sap.m.App ({; pages: [; new sap.m.Page({; title: ""Nav Container"",; enableScrolling : true,; content: [ new sap.ui.core.ComponentContainer({ name : ""NavExample"" })]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:33541,load,load,33541,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['load']
Performance,"0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:132335,cache,cache,132335,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"0.""; ); # training2 = ROOT.TString(""LearningRate=1e-3,Momentum=0.9""; # ""ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,""; # ""MaxEpochs=20,WeightDecay=1e-4,Regularization=None,""; # ""Optimizer=SGD,DropConfig=0.0+0.0+0.0+0.""); ; # General Options.; dnnMethodName = ROOT.TString(""DNN_CPU""); ; if useDLGPU:; arch = ""GPU""; dnnMethodName = ""DNN_GPU""; else:; arch = ""CPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=""G"",; WeightInitialization=""XAVIER"",; InputLayout=""1|1|7"",; BatchLayout=""1|128|7"",; Layout=""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"",; TrainingStrategy=training1,; Architecture=arch,; ); ; # Keras DL; if useKeras:; ROOT.Info(""TMVA_Higgs_Classification"", ""Building Deep Learning keras model""); # create Keras model with 4 layers of 64 units and relu activations; import tensorflow; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; from tensorflow.keras.layers import Input, Dense; ; model = Sequential(); model.add(Dense(64, activation=""relu"", input_dim=7)); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_higgs.h5""); model.summary(); ; if not os.path.exists(""model_higgs.h5""):; raise FileNotFoundError(""Error creating Keras model file - skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_Higgs_Classification"", ""Booking Deep Learning keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_higgs.h5"",; FilenameTrainedModel=""trained_model_higgs.h5"",; NumEpochs=20,; BatchSize=100,; ); # GpuOptions=""allow_growth=True"",; # ) # needed for RTX NVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:66611,optimiz,optimizers,66611,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['optimiz'],['optimizers']
Performance,"0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 _normSet = tmp ;; 328 ; 329 return TMath::IsNaN(val) ? 0. : val;; 330 }; 331 ; 332 ; 333 // Process change in last data set used; 334 bool nintChanged(false) ;; 335 if (!isActiveNormSet(nset) || _norm==nullptr) {; 336 nintChanged = syncNormalization(nset) ;; 337 }; 338 ; 339 // Return value of object. Calculated if dirty, otherwise cached value is returned.; 340 if (isValueDirty() || nintChanged || _norm->isValueDirty()) {; 341 ; 342 // Evaluate numerator; 343 const double rawVal = evaluate();; 344 ; 345 // Evaluate denominator; 346 const double normVal = _norm->getVal();; 347 ; 348 _value = normalizeWithNaNPacking(rawVal, normVal);; 349 ; 350 cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:12094,perform,performance,12094,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performance']
Performance,"0., . Double_t ; rmin = 0., . Double_t ; rmax = 9999999, . Option_t * ; option = """" . ). Generate a lego plot fot the top volume, according to option. ; Definition at line 1332 of file TGeoVolume.cxx. ◆ MakeCopyNodes(). void TGeoVolume::MakeCopyNodes ; (; const TGeoVolume * ; other). make a new list of nodes and copy all nodes of other volume inside ; Definition at line 1908 of file TGeoVolume.cxx. ◆ MakeCopyVolume(). TGeoVolume * TGeoVolume::MakeCopyVolume ; (; TGeoShape * ; newshape). virtual . make a copy of this volume build a volume with same name, shape and medium ; Reimplemented in TGeoVolumeMulti.; Definition at line 1928 of file TGeoVolume.cxx. ◆ MakeReflectedVolume(). TGeoVolume * TGeoVolume::MakeReflectedVolume ; (; const char * ; newname = """"); const. Make a copy of this volume which is reflected with respect to XY plane. ; Definition at line 1958 of file TGeoVolume.cxx. ◆ operator=(). TGeoVolume & TGeoVolume::operator= ; (; const TGeoVolume & ; ). privatedelete . ◆ OptimizeVoxels(). Bool_t TGeoVolume::OptimizeVoxels ; (; ). Perform an extensive sampling to find which type of voxelization is most efficient. ; Definition at line 1247 of file TGeoVolume.cxx. ◆ Paint(). void TGeoVolume::Paint ; (; Option_t * ; option = """"). overridevirtual . paint volume ; Reimplemented from TObject.; Definition at line 1267 of file TGeoVolume.cxx. ◆ Print(). void TGeoVolume::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print volume info. ; Reimplemented from TObject.; Definition at line 1257 of file TGeoVolume.cxx. ◆ PrintNodes(). void TGeoVolume::PrintNodes ; (; ); const. print nodes ; Definition at line 1320 of file TGeoVolume.cxx. ◆ PrintVoxels(). void TGeoVolume::PrintVoxels ; (; ); const. Print the voxels for this volume. ; Definition at line 1282 of file TGeoVolume.cxx. ◆ RandomPoints(). void TGeoVolume::RandomPoints ; (; Int_t ; npoints = 1000000, . Option_t * ; option = """" . ). Draw random points in the bounding box of this volume. ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:59880,Optimiz,OptimizeVoxels,59880,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['Optimiz'],['OptimizeVoxels']
Performance,"0.01:GDNSteps=10000:GDErrScale=1.02"" );; ; // For an example of the category classifier usage, see: TMVAClassificationCategory; //; // --------------------------------------------------------------------------------------------------; // Now you can optimize the setting (configuration) of the MVAs using the set of training events; // STILL EXPERIMENTAL and only implemented for BDT's !; //; // factory->OptimizeAllMethods(""SigEffAtBkg0.01"",""Scan"");; // factory->OptimizeAllMethods(""ROCIntegral"",""FitGA"");; //; // --------------------------------------------------------------------------------------------------; ; // Now you can tell the factory to train, test, and evaluate the MVAs; //; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Write();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassification is done!"" << std::endl;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; ; return 0;; }; ; int main( int argc, char** argv ); {; // Select methods (don't look at this code - not of interest); TString methodList;; for (int i=1; i<argc; i++) {; TString regMethod(argv[i]);; if(regMethod==""-b"" || regMethod==""--batch"") continue;; if (!methodList.IsNull()) methodList += TString("","");; methodList += regMethod;; }; return TMVAClassification(methodList);; }; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Double_tdouble Double_tDefinition RtypesCore.h:59; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:103578,Optimiz,OptimizeAllMethods,103578,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,2,"['Optimiz', 'perform']","['OptimizeAllMethods', 'performance']"
Performance,"00 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: Interpreters . Hi ROOT user,; Thanks for your comments - they are excellent!; Your scenario would probably work - but we decided against it, and I believe that we have good reasons for that :-); GCCXML's future is limited; there is a re-write based on GCC's plugin mechanism, but both suffer from the same problems: we cannot influence what the GCC parser does. And reading headers, writing XML, parsing XML, writing (huge files of) C++, compiling, linking, loading - that's really, really inefficient and error prone.; Python is much simpler than C++. But it's still a horrible language in our environment, unless it's used as bash++. Not a single algorithm should be written in Python: it'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:15777,perform,performance,15777,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,2,"['cache', 'perform']","['cache', 'performance']"
Performance,00 events); : Elapsed time for evaluation of 10000 events: 0.00226 sec ; Factory : Test method: CutsD for Classification performance; : ; CutsD : [dataset] : Evaluation of CutsD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : [dataset] : Evaluation of LD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00474 sec ; : Dataset[dataset] : Evaluation of LD on testing sample; Factory : Test method: FDA_GA for Classification performance; : ; FDA_GA : [dataset] : Evaluation of FDA_GA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00327 sec ; Factory : Test method: MLPBNN for Classification performance; : ; MLPBNN : [dataset] : Evaluation of MLPBNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classifica,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:66351,perform,performance,66351,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,00 events); : Elapsed time for evaluation of 10000 events: 0.00327 sec ; Factory : Test method: MLPBNN for Classification performance; : ; MLPBNN : [dataset] : Evaluation of MLPBNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.333 sec ; Factory : Test method: SVM for Classification performance; : ; SVM : [dataset] : Evaluation of SVM on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.287 sec ; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.571 sec ; Factory : Test method: RuleFit for Classification performance; : ; RuleFit : [dataset] : Evaluation of RuleFit on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0137 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: Cuts; : ; <WARNING> : You have asked for histogram MVA_EFF_BvsS which does not seem to exist in *Results* .. better don't use it ; <WARNING> : You have asked for histogram EFF_BVSS_TR which does not seem to exist in *Results* .. better don't use it ; TFHandler_Cuts : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:68033,perform,performance,68033,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"00/// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; 2301/// the system that the total size of the imported baskets does not; 2302/// exceed maxmemory bytes.; 2303///; 2304/// The function returns the number of baskets that have been put in memory.; 2305/// This method may be called to force all baskets of one or more branches; 2306/// in memory when random access to entries in this branch is required.; 2307/// See also TTree::LoadBaskets to load all baskets of all branches in memory.; 2308 ; 2309Int_t TBranch::LoadBaskets(); 2310{; 2311 Int_t nimported = 0;; 2312 Int_t nbaskets = fWriteBasket;; 2313 TFile *file = GetFile(0);; 2314 if (!file) return 0;; 2315 TBasket *basket;; 2316 for (Int_t i=0;i<nbaskets;i++) {; 2317 basket = (TBasket*)fBaskets.UncheckedAt(i);; 2318 if (basket) continue;; 2319 basket = GetFreshBasket(i, nullptr);; 2320 if (fBasketBytes[i] == 0) {; 2321 fBasketBytes[i] = basket->ReadBasketBytes(fBasketSeek[i],file);; 2322 }; 2323 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[i],fBasketBytes[i],file);; 2324 if (badread) {; 2325 Error(""Loadbaskets"",""Error while reading basket buffer %d of branch %s"",i,GetName());; 2326 return -1;; 2327 }; 2328 ++fNBaskets;; 2329 fBaskets.AddAt(basket,i);; 2330 nimported++;; 2331 }; 2332 return nimported;; 2333}; 2334 ; 2335////////////////////////////////////////////////////////////////////////////////; 2336/// Print TBranch parameters; 2337///; 2338/// If options contains ""basketsInfo"" print the entry number, location and size; 2339/// of each baskets.; 2340 ; 2341void TBranch::Print(Option_t *option) const; 2342{; 2343 const int kLINEND = 77;; 2344 Float_t cx = 1;; 2345 ; 2346 TString titleContent(GetTitle());; 2347 if ( titleContent == GetName() ) {; 2348 titleContent.Clear();; 2349 }; 2350 ; 2351 if (fLeaves.GetEntries() == 1) {; 2352 if (titleContent.Length()>=2 && titleContent[titleContent.Length()-2]=='/' && isalpha(titleContent[titleContent.Length()-1])) {; 2353 // The type is already en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:84431,Load,Loadbaskets,84431,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['Load'],['Loadbaskets']
Performance,0000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : [dataset] : Evaluation of LD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00474 sec ; : Dataset[dataset] : Evaluation of LD on testing sample; Factory : Test method: FDA_GA for Classification performance; : ; FDA_GA : [dataset] : Evaluation of FDA_GA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00327 sec ; Factory : Test method: MLPBNN for Classification performance; : ; MLPBNN : [dataset] : Evaluation of MLPBNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -------------------------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:66551,perform,performance,66551,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypedefaultStorageType. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:14086,cache,cached,14086,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,2,['cache'],['cached']
Performance,"00000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is process",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:9796,cache,cache,9796,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  MethodMLP (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption);  standard constructor ;  ;  MethodMLP (DataSetInfo &theData, const TString &theWeightFile);  constructor from a weight file ;  ; virtual ~MethodMLP ();  destructor nothing to be done ;  ; Double_t ComputeEstimator (std::vector< Double_t > &parameters);  this function is called by GeneticANN for GA optimization ;  ; Double_t EstimatorFunction (std::vector< Double_t > &parameters);  interface to the estimate ;  ; Double_t GetMvaValue (Double_t *err=nullptr, Double_t *errUpper=nullptr);  get the mva value generated by the NN ;  ; virtual Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  MLP can handle classification with 2 classes and regression with one regression-target. ;  ; bool HasInverseHessian ();  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train ();  ;  Public Member Functions inherited from TMVA::MethodANNBase;  MethodANNBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &theData, const TString &theOption);  standard constructor Note: Right now it is an option to choose the neuron input function, but only the input function ""sum"" leads to weight convergence – otherwise the weight",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:1879,optimiz,optimization,1879,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['optimiz'],['optimization']
Performance,"004////////////////////////////////////////////////////////////////////////////////; 2005/// Set number of points to be generated on the shape outline when checking for overlaps.; 2006 ; 2007void TGeoPainter::SetNmeshPoints(Int_t npoints); 2008{; 2009 fChecker->SetNmeshPoints(npoints);; 2010}; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Select a node to be checked for overlaps. All overlaps not involving it will; 2014/// be ignored.; 2015 ; 2016void TGeoPainter::SetCheckedNode(TGeoNode *node); 2017{; 2018 fChecker->SetSelectedNode(node);; 2019}; 2020 ; 2021////////////////////////////////////////////////////////////////////////////////; 2022/// Set default level down to which visualization is performed; 2023 ; 2024void TGeoPainter::SetVisLevel(Int_t level); 2025{; 2026 if (level == fVisLevel && fLastVolume == fTopVolume); 2027 return;; 2028 fVisLevel = level;; 2029 if (!fTopVolume); 2030 return;; 2031 if (fVisLock) {; 2032 ClearVisibleVolumes();; 2033 fVisLock = kFALSE;; 2034 }; 2035 if (!fLastVolume) {; 2036 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2037 return;; 2038 }; 2039 if (!gPad); 2040 return;; 2041 if (gPad->GetView()) {; 2042 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2043 ModifiedPad();; 2044 }; 2045}; 2046 ; 2047////////////////////////////////////////////////////////////////////////////////; 2048/// Set top geometry volume as visible.; 2049 ; 2050void TGeoPainter::SetTopVisible(Bool_t vis); 2051{; 2052 if (fTopVisible == vis); 2053 return;; 2054 fTopVisible = vis;; 2055 ModifiedPad();; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Set drawing mode :; 2060/// - option=0 (default) all nodes drawn down to vislevel; 2061/// - option=1 leaves and nodes at vislevel drawn; 2062/// - option=2 path is drawn; 2063 ; 2064void TGeoPainter::SetVisOption(Int_t option); 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:66147,perform,performed,66147,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['perform'],['performed']
Performance,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:25752,cache,cache,25752,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:25420,cache,cache,25420,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['cache'],['cache']
Performance,"00];; 296 Double_t Red[] = {0., 0.0, 1.0, 1.0, 1.0};; 297 Double_t Green[] = {0., 0.0, 0.0, 1.0, 1.0};; 298 Double_t Blue[] = {0., 1.0, 0.0, 0.0, 1.0};; 299 Double_t Length[] = {0., .25, .50, .75, 1.0};; 300 Int_t FI = TColor::CreateGradientColorTable(5, Length, Red, Green, Blue, 100);; 301 for (int i=0;i<100;i++) MyPalette[i] = FI+i;; 302~~~; 303 ; 304Later on to reuse the palette `MyPalette` it will be enough to do; 305 ; 306~~~ {.cpp}; 307 gStyle->SetPalette(100, MyPalette);; 308~~~; 309 ; 310As only one palette is active, one need to use `TExec` to be able to; 311display plots using different palettes on the same pad.; 312The tutorial multipalette.C illustrates this feature.; 313 ; 314Begin_Macro(source); 315../../../tutorials/graphs/multipalette.C; 316End_Macro; 317 ; 318\since **6.26:**; 319The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; 320palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; 321the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; 322between adjacent colors. The palette will contain the exact colors stored in the file, that; 323comprises one line per color in the format ""r g b"" as floats.; 324 ; 325\anchor C06; 326## High quality predefined palettes; 327\since **6.04:**; 32863 high quality palettes are predefined with 255 colors each.; 329 ; 330These palettes can be accessed ""by name"" with `gStyle->SetPalette(num)`.; 331`num` can be taken within the following enum:; 332 ; 333~~~ {.cpp}; 334kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 335kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 336kBird=57, kCubehelix=58, kGreenRedViolet=59,; 337kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 338kAlpine=63, kAquamarine=64, kArmy=65,; 339kAtlantic=66, kAurora=67, kAvocado=68,; 340kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 341kBrownCyan=72, kCMYK=73, kCandy=74,; 342kCherry=75, kCoffee=76, kDark",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:11753,tune,tuned,11753,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['tune'],['tuned']
Performance,"00namespace ROOT { namespace Internal {; 201 ; 202class TCDGIILIBase {; 203public:; 204 // All implemented in TGenericClassInfo.cxx.; 205 static void SetInstance(::ROOT::TGenericClassInfo& R__instance,; 206 NewFunc_t, NewArrFunc_t, DelFunc_t, DelArrFunc_t, DesFunc_t);; 207 static void SetName(const std::string& name, std::string& nameMember);; 208 static void SetfgIsA(atomic_TClass_ptr& isA, TClass*(*dictfun)());; 209};; 210 ; 211template <typename T>; 212class ClassDefGenerateInitInstanceLocalInjector:; 213 public TCDGIILIBase {; 214 static atomic_TClass_ptr fgIsA;; 215 static ::ROOT::TGenericClassInfo *fgGenericInfo;; 216 public:; 217 static void *New(void *p) { return p ? new(p) T : new T; };; 218 static void *NewArray(Long_t nElements, void *p) {; 219 return p ? new(p) T[nElements] : new T[nElements]; }; 220 static void Delete(void *p) { delete ((T*)p); }; 221 static void DeleteArray(void *p) { delete[] ((T*)p); }; 222 static void Destruct(void *p) { ((T*)p)->~T(); }; 223 static ::ROOT::TGenericClassInfo *GenerateInitInstanceLocal() {; 224 static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy<T>(nullptr);; 225 static ::ROOT::TGenericClassInfo; 226 R__instance(T::Class_Name(), T::Class_Version(),; 227 T::DeclFileName(), T::DeclFileLine(),; 228 typeid(T), ::ROOT::Internal::DefineBehavior((T*)nullptr, (T*)nullptr),; 229 &T::Dictionary, isa_proxy, 0, sizeof(T) );; 230 SetInstance(R__instance, &New, &NewArray, &Delete, &DeleteArray, &Destruct);; 231 return &R__instance;; 232 }; 233 // We need a reference to the template instance static member in a concrete function in order; 234 // to force its instantiation (even before the function is actually run); 235 // Since we do have a reference to Dictionary (in T::Dictionary), using fgGenericInfo; 236 // here will insure that it is initialized at process start or library load time.; 237 static TClass *Dictionary() { fgIsA = fgGenericInfo->GetClass(); return fgIsA; }; 238 static TClass *Class() { SetfgIsA(fgIsA,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h_source.html:9602,load,load,9602,doc/v632/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h_source.html,1,['load'],['load']
Performance,"01 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).RegisterContext(this);; 115 if (newCurrent); 116 newCurrent->cd();; 117 else; 118 CdNull();; 119 }; 120 TContext() : fDirectory(TDirectory::CurrentDirectory().load()); 121 {; 122 // Store the current directory so we can restore it; 123 // later and cd to the new directory.; 124 RegisterCurrentDirectory();; 125 }; 126 TContext(TDirectory *newCurrent) : fDirectory(TDirectory::CurrentDirectory().load()); 127 {; 128 // Store the current directory so we can restore it; 129 // later and cd to the new directory.; 130 RegisterCurrentDirectory();; 131 if (newCurrent); 132 newCurrent->cd();; 133 else; 134 CdNull();; 135 }; 136 ~TContext();; 137 };; 138 ; 139protected:; 140 ; 141 TObject *fMother{nullptr}; // pointer to mother of the directory; 142 TList *fList{nullptr}; // List of objects in memory; 143 TUUID fUUID; // Unique identifier; 144 mutable TString fPathBuffer; //! Buffer for GetPath() function; 145 TContext *fContext{nullptr}; //! Pointer to a list of TContext object pointing to this TDirectory; 146 ; 147 using SharedGDirectory_t = std::shared_ptr<std::atomic<TDirectory *>>;; 148 ; 149 static SharedGDirectory_t &GetSharedLocalCurrentDirectory();; 150 ; 151 std::vector<SharedGDirectory_t> fGDirectories; //! thread local gDirectory pointing to this object.; 152 ; 153 std::atomic<size_t> fContextPeg{0}; //! Counter delaying the TDirectory destructor from finishing.; 154 mutable std::atomic_flag fSpinLock; //! MSVC doesn't support = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8h_source.html:3730,load,load,3730,doc/master/TDirectory_8h_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html,1,['load'],['load']
Performance,"01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes.; This routine is deprecated, use TClass::AddClass directly. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. void CloseFiles(); Close any files and sockets that gROOT knows about.; This can be used to insures that the files and sockets are closed before any library is unloaded!. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exists. If name contains at least one ""/"" the function calls FindObjectany; else; This function looks in the following order in the ROOT lists:; - List of files; - List of memory mapped files; - List of functions; - List of geometries; - List of canvases; - List of styles; - List of specials; - List of materials in current geometry; - List of shapes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TROOT.html:20320,load,loaded,20320,root/html532/TROOT.html,https://root.cern,https://root.cern/root/html532/TROOT.html,1,['load'],['loaded']
Performance,"01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes.; This routine is deprecated, use TClass::AddClass directly. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. void CloseFiles(); Close any files and sockets that gROOT knows about.; This can be used to insures that the files and sockets are closed before any library is unloaded!. void EndOfProcessCleanups(bool altInterpreter = kFALSE); Execute the cleanups necessary at the end of the process, in particular; those that must be executed before the library start being unloaded. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exists. If name contains at least one ""/"" the function calls FindObjectany; else; This function looks in the following order in the ROOT lists:; - List ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:20616,load,loaded,20616,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['load'],['loaded']
Performance,"01void RGeomDescription::ResetRndrInfos(); 1202{; 1203 for (auto &s : fShapes); 1204 s.reset();; 1205}; 1206 ; 1207/////////////////////////////////////////////////////////////////////; 1208/// Produce JSON string which can be directly used with `build`; 1209/// function from JSROOT to create three.js model of configured geometry; 1210///; 1211/// Collect all information required to draw geometry on the client; 1212/// This includes list of each visible nodes, meshes and matrixes; 1213/// If @param all_nodes is true, all existing nodes will be provided,; 1214/// which allows to create complete nodes hierarchy on client side; 1215///; 1216/// Example of usage:; 1217///; 1218/// void geom() {; 1219/// auto f = TFile::Open(""file_name.root"");; 1220/// auto vol = f->Get<TGeoVolume>(""object_name"");; 1221/// ROOT::RGeomDescription desc;; 1222/// desc.Build(vol);; 1223/// std::ofstream fout(""geom.json"");; 1224/// fout << desc.ProduceJson();; 1225/// }; 1226///; 1227/// In JSROOT one loads data from JSON file and call `build` function to; 1228/// produce three.js model. Also see example in tutorials/webgui/geom/ folder; 1229 ; 1230std::string RGeomDescription::ProduceJson(bool all_nodes); 1231{; 1232 TLockGuard lock(fMutex);; 1233 ; 1234 std::vector<int> viscnt(fDesc.size(), 0);; 1235 ; 1236 int level = GetVisLevel();; 1237 ; 1238 // first count how many times each individual node appears; 1239 int numnodes = ScanNodes(true, level, [&viscnt](RGeomNode &node, std::vector<int> &, bool, int) {; 1240 viscnt[node.id]++;; 1241 return true;; 1242 });; 1243 ; 1244 if (GetMaxVisNodes() > 0) {; 1245 while ((numnodes > GetMaxVisNodes()) && (level > 1)) {; 1246 level--;; 1247 viscnt.assign(viscnt.size(), 0);; 1248 numnodes = ScanNodes(true, level, [&viscnt](RGeomNode &node, std::vector<int> &, bool, int) {; 1249 viscnt[node.id]++;; 1250 return true;; 1251 });; 1252 }; 1253 }; 1254 ; 1255 fActualLevel = level;; 1256 fDrawIdCut = 0;; 1257 ; 1258 int totalnumfaces = 0, totalnumnodes = 0;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:37143,load,loads,37143,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['load'],['loads']
Performance,"020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:146855,cache,cachefile,146855,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,['cache'],"['cached', 'cachefile', 'cachefilepath']"
Performance,"024748, 3518288, 885122, 18537969,; 2416 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 2417 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 2418 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 2419 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 2420 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; 2421 };; 2422 ; 2423 Double_t lon1 = -130;; 2424 Double_t lon2 = -65;; 2425 Double_t lat1 = 24;; 2426 Double_t lat2 = 50;; 2427 auto p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);; 2428 ; 2429 TFile::SetCacheFileDir(""."");; 2430 auto f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");; 2431 ; 2432 TMultiGraph *mg;; 2433 TKey *key;; 2434 TIter nextkey(gDirectory->GetListOfKeys());; 2435 while ((key = (TKey*)nextkey())) {; 2436 TObject *obj = key->ReadObj();; 2437 if (obj->InheritsFrom(""TMultiGraph"")) {; 2438 mg = (TMultiGraph*)obj;; 2439 bin = p->AddBin(mg);; 2440 }; 2441 }; 2442 ; 2443 for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);; 2444 ; 2445 gStyle->SetOptStat(11);; 2446 p->Draw(""COLZ L"");; 2447}; 2448End_Macro; 2449 ; 2450`TH2Poly` histograms can also be plotted using the GL interface using; 2451the option ""GLLEGO"".; 2452 ; 2453\since **ROOT version 6.09/01**; 2454 ; 2455In some cases it can be useful to not draw the empty bins. the option ""0""; 2456combined with the option ""COL"" et COLZ allows to do that.; 2457 ; 2458Begin_Macro(source); 2459{; 2460 auto chc = new TCanvas(""chc"",""chc"",600,400);; 2461 ; 2462 auto hc = new TH2Poly();; 2463 hc->Honeycomb(0,0,.1,25,25);; 2464 hc->SetName(""hc"");; 2465 hc->SetTitle(""Option COLZ 0"");; 2466 TRandom ran;; 2467 for (int i = 0; i<300; i++) hc->Fill(ran.Gaus(2.,1), ran.Gaus(2.,1));; 2468 hc->Draw(""colz 0"");; 2469}; 2470End_Macro; 2471 ; 2472\anchor HP21; 2473### The SPEC option; 2474 ; 2475 ; 2476This option allows to use the `TSpectrum2Painter` tools. See the full; 2477documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:99249,CACHE,CACHEREAD,99249,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['CACHE'],['CACHEREAD']
Performance,"026 }; 1027 }; 1028 ; 1029 if ((stepCount % minimizer.GetTestInterval()) == 0) {; 1030 ; 1031 // Compute test error.; 1032 Double_t testError = 0.0;; 1033 for (auto batch : testData) {; 1034 auto inputMatrix = batch.GetInput();; 1035 auto outputMatrix = batch.GetOutput();; 1036 testError += testNet.Loss(inputMatrix, outputMatrix);; 1037 }; 1038 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1039 ; 1040 //Log the loss value; 1041 fTrainHistory.AddValue(""testError"",stepCount,testError);; 1042 ; 1043 end = std::chrono::system_clock::now();; 1044 ; 1045 // Compute training error.; 1046 Double_t trainingError = 0.0;; 1047 for (auto batch : trainingData) {; 1048 auto inputMatrix = batch.GetInput();; 1049 auto outputMatrix = batch.GetOutput();; 1050 trainingError += net.Loss(inputMatrix, outputMatrix);; 1051 }; 1052 trainingError /= (Double_t) (nTrainingSamples / settings.batchSize);; 1053 //Log the loss value; 1054 fTrainHistory.AddValue(""trainingError"",stepCount,trainingError);; 1055 ; 1056 // Compute numerical throughput.; 1057 std::chrono::duration<double> elapsed_seconds = end - start;; 1058 double seconds = elapsed_seconds.count();; 1059 double nFlops = (double) (settings.testInterval * batchesInEpoch);; 1060 nFlops *= net.GetNFlops() * 1e-9;; 1061 ; 1062 converged = minimizer.HasConverged(testError);; 1063 start = std::chrono::system_clock::now();; 1064 ; 1065 if (fInteractive) {; 1066 fInteractive->AddPoint(stepCount, trainingError, testError);; 1067 fIPyCurrentIter = 100.0 * minimizer.GetConvergenceCount(); 1068 / minimizer.GetConvergenceSteps ();; 1069 if (fExitFromTraining) break;; 1070 } else {; 1071 Log() << std::setw(10) << stepCount << "" | ""; 1072 << std::setw(12) << trainingError; 1073 << std::setw(12) << testError; 1074 << std::setw(12) << nFlops / seconds; 1075 << std::setw(12) << minimizer.GetConvergenceCount() << Endl;; 1076 if (converged) {; 1077 Log() << Endl;; 1078 }; 1079 }; 1080 }; 1081 }; 1082 for (size_t l = 0; l < net.GetDepth(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:37793,throughput,throughput,37793,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['throughput'],['throughput']
Performance,"02_dataimport.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; ; -----------------------; Reading data from ASCII; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 0.0174204 L(-10 - 10) ""x""; 2) y = 9.46654 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; ; Original data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; ; Read-back data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[x,y] = 64 entries; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf102_dataimport.C. tutorialsro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8C.html:11157,load,loadValues,11157,doc/master/rf102__dataimport_8C.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html,1,['load'],['loadValues']
Performance,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:120169,cache,cache,120169,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,4,"['Cache', 'cache']","['Cache-Control', 'cache', 'cache-control', 'cached']"
Performance,"03}; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Return pointer to object identified by namecycle.; 907/// The returned object may or may not derive from TObject.; 908///; 909/// - namecycle has the format name;cycle; 910/// - name = * is illegal, cycle = * is illegal; 911/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 912///; 913/// VERY IMPORTANT NOTE:; 914///; 915/// The calling application must cast the returned object to; 916/// the final type, e.g.; 917/// ~~~ {.cpp}; 918/// MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");; 919/// ~~~; 920 ; 921void *TDirectory::GetObjectUnchecked(const char *namecycle); 922{; 923 return GetObjectChecked(namecycle,(TClass *)nullptr);; 924}; 925 ; 926////////////////////////////////////////////////////////////////////////////////; 927/// See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl); 928 ; 929void *TDirectory::GetObjectChecked(const char *namecycle, const char* classname); 930{; 931 return GetObjectChecked(namecycle, TClass::GetClass(classname));; 932}; 933 ; 934 ; 935////////////////////////////////////////////////////////////////////////////////; 936/// Return pointer to object identified by namecycle if and only if the actual; 937/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 938/// If expectedClass is null, no check is performed.; 939///; 940/// namecycle has the format `name;cycle`; 941/// - name = * is illegal, cycle = * is illegal; 942/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 943///; 944/// VERY IMPORTANT NOTE:; 945///; 946/// The calling application must cast the returned pointer to; 947/// the type described by the 2 arguments (i.e. cl):; 948/// ~~~ {.cpp}; 949/// MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 950/// ~~~; 951/// Note: We recommend using the method TDirectory::GetObject:; 952",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:32814,perform,performed,32814,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['perform'],['performed']
Performance,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:120201,cache,cache,120201,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,4,"['Cache', 'cache']","['Cache-Control', 'cache', 'cache-control', 'cached']"
Performance,"0406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_right' created with bounds [6,10]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -1134.15, estimated distance to minimum: 3.61209e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 3.2415e-01 +/- 1.09e-01; a1 3.0373e-02 +/- 2.12e-01; nbkg 5.0182e+02 +/- 3.94e+01; nsig 4.1091e+02 +/- 2.63e+02; sig1frac 8.5838e-01 +/- 2.74e-01; ; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html:8909,optimiz,optimization,8909,doc/master/rf204a__extendedLikelihood_8C.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html,4,['optimiz'],['optimization']
Performance,"047}; 2048 ; 2049////////////////////////////////////////////////////////////////////////////////; 2050/// Unload a shared library.; 2051 ; 2052void TSystem::Unload(const char *module); 2053{; 2054 char *path;; 2055 if ((path = DynamicPathName(module))) {; 2056 gInterpreter->UnloadFile(path);; 2057 delete [] path;; 2058 }; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// List symbols in a shared library.; 2063 ; 2064void TSystem::ListSymbols(const char *, const char *); 2065{; 2066 AbstractMethod(""ListSymbols"");; 2067}; 2068 ; 2069////////////////////////////////////////////////////////////////////////////////; 2070/// List the loaded shared libraries.; 2071/// `regexp` is a regular expression allowing to filter the list.; 2072///; 2073/// Examples:; 2074///; 2075/// The following line lists all the libraries currently loaded:; 2076/// ~~~ {.cpp}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:67315,load,loaded,67315,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"048. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. TTree. Do not automatically setup read cache during TTree::Fill(). This fixes [ROOT-8031]. Fast Cloning. Added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078].; The new cache can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces.; The new cache is enabled by default.; To update the size of the cache or disable it:; From TTreeCloner use: TTreeCloner::SetCacheSize; From TTree::CopyEntries add to the option string ""cachesize=SIZE""; From hadd, use the command line option -cachesize SIZE; SIZE should be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Release 6.04/18; Published on 2016-06-22.; Core. Fix the validity of TRef after the first ProcessID is full. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258. Bugs and issues fixed. [ROOT-6923] - Memory leak with circular TTree; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-7867] - memprobe script is broken when using CMake; [ROOT-8066] - problems creating dictionaries in pyROOT; [ROOT-8068] - Fix file flags for bin/setxrd.* bin/thisroot.*; [ROOT-8096] - genreflex crash with gcc6 build; [ROOT-8148] - Memory leak in TStorage::ObjectAlloc; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6. HEAD of the v6-04-00-patches branch; Changes will be part of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:38990,cache,cache,38990,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,3,['cache'],"['cache', 'cachesize']"
Performance,"05 of file MethodBDT.h. ◆ MakeClassInstantiateNode(). void TMVA::MethodBDT::MakeClassInstantiateNode ; (; DecisionTreeNode * ; n, . std::ostream & ; fout, . const TString & ; className . ); const. Recursively descends a tree and writes the node instance to the output stream. ; Definition at line 2990 of file MethodBDT.cxx. ◆ MakeClassSpecific(). void TMVA::MethodBDT::MakeClassSpecific ; (; std::ostream & ; fout, . const TString & ; className . ); const. virtual . Make ROOT-independent C++ class for classifier response (classifier-specific implementation). ; Reimplemented from TMVA::MethodBase.; Definition at line 2756 of file MethodBDT.cxx. ◆ MakeClassSpecificHeader(). void TMVA::MethodBDT::MakeClassSpecificHeader ; (; std::ostream & ; fout, . const TString & ; className . ); const. virtual . Specific class header. ; Reimplemented from TMVA::MethodBase.; Definition at line 2876 of file MethodBDT.cxx. ◆ OptimizeTuningParameters(). std::map< TString, Double_t > TMVA::MethodBDT::OptimizeTuningParameters ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). virtual . Call the Optimizer with the set of parameters and ranges that are meant to be tuned. ; Reimplemented from TMVA::MethodBase.; Definition at line 1068 of file MethodBDT.cxx. ◆ PreProcessNegativeEventWeights(). void TMVA::MethodBDT::PreProcessNegativeEventWeights ; (; ). private . O.k. ; you know there are events with negative event weights. This routine will remove them by pairing them with the closest event(s) of the same event class with positive weights A first attempt is ""brute force"", I dont' try to be clever using search trees etc, just quick and dirty to see if the result is any good ; Definition at line 932 of file MethodBDT.cxx. ◆ PrivateGetMvaValue(). Double_t TMVA::MethodBDT::PrivateGetMvaValue ; (; const TMVA::Event * ; ev, . Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr, . UInt_t ; useNTrees = 0 . ). private . Return the MVA value (range [-1;1]) that classifie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:54499,Optimiz,OptimizeTuningParameters,54499,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"05177 a=-0.002833, ; prevFCN = 1659.94939 a=0.0002833, ; prevFCN = 1659.944972 a=-0.0002833, ; prevFCN = 1659.919376 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001207, ; prevFCN = 1659.902797 a=-0.001266, ; prevFCN = 1659.902798 [#1] INFO:Minimization -- Command timer: Real time 0:00:02, CP time 2.700; [#1] INFO:Minimization -- Session timer: Real time 0:00:02, CP time 2.700; a=-0.001237, ; prevFCN = 1659.902781 a=-0.001207, ; prevFCN = 1659.902797 a=-0.001266, ; prevFCN = 1659.902798 a=-0.001231, ; prevFCN = 1659.902782 a=-0.001243, ; prevFCN = 1659.902782 [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.950; [#1] INFO:Minimization -- Session timer: Real time 0:00:03, CP time 3.650, 2 slices; a=-0.001237, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] WARNING:NumericIntegration -- RooAdaptiveIntegratorND::dtor(model) WARNING: Number of suppressed warningings about integral evaluations where target precision was not reached is 17; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y,z); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y,z]_Norm[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(y,z); [#0] WARNING:NumericIntegration -- RooAdaptiveIntegratorND::dtor(model) WARNING: Number of suppressed warningings about integral evaluations where target precision was not reached is 1; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf903_numintcache.C. tutorialsroofitrf903_numintcache.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8C.html:10648,optimiz,optimization,10648,doc/master/rf903__numintcache_8C.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html,1,['optimiz'],['optimization']
Performance,"05namespace ROOT { namespace Internal {; 206 ; 207class TCDGIILIBase {; 208public:; 209 // All implemented in TGenericClassInfo.cxx.; 210 static void SetInstance(::ROOT::TGenericClassInfo& R__instance,; 211 NewFunc_t, NewArrFunc_t, DelFunc_t, DelArrFunc_t, DesFunc_t);; 212 static void SetName(const std::string& name, std::string& nameMember);; 213 static void SetfgIsA(atomic_TClass_ptr& isA, TClass*(*dictfun)());; 214};; 215 ; 216template <typename T>; 217class ClassDefGenerateInitInstanceLocalInjector:; 218 public TCDGIILIBase {; 219 static atomic_TClass_ptr fgIsA;; 220 static ::ROOT::TGenericClassInfo *fgGenericInfo;; 221 public:; 222 static void *New(void *p) { return p ? new(p) T : new T; };; 223 static void *NewArray(Long_t nElements, void *p) {; 224 return p ? new(p) T[nElements] : new T[nElements]; }; 225 static void Delete(void *p) { delete ((T*)p); }; 226 static void DeleteArray(void *p) { delete[] ((T*)p); }; 227 static void Destruct(void *p) { ((T*)p)->~T(); }; 228 static ::ROOT::TGenericClassInfo *GenerateInitInstanceLocal() {; 229 static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy<T>(nullptr);; 230 static ::ROOT::TGenericClassInfo; 231 R__instance(T::Class_Name(), T::Class_Version(),; 232 T::DeclFileName(), T::DeclFileLine(),; 233 typeid(T), ::ROOT::Internal::DefineBehavior((T*)nullptr, (T*)nullptr),; 234 &T::Dictionary, isa_proxy, 0, sizeof(T) );; 235 SetInstance(R__instance, &New, &NewArray, &Delete, &DeleteArray, &Destruct);; 236 return &R__instance;; 237 }; 238 // We need a reference to the template instance static member in a concrete function in order; 239 // to force its instantiation (even before the function is actually run); 240 // Since we do have a reference to Dictionary (in T::Dictionary), using fgGenericInfo; 241 // here will insure that it is initialized at process start or library load time.; 242 static TClass *Dictionary() { fgIsA = fgGenericInfo->GetClass(); return fgIsA; }; 243 static TClass *Class() { SetfgIsA(fgIsA,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h_source.html:10023,load,load,10023,doc/master/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html,1,['load'],['load']
Performance,"06 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the list of conversion streamerInfos.; 4257 ; 4258void TClass::ls(Option_t *options) const; 4259{; 4260 TNamed::ls(options);; 4261 if (options==nullptr || options[0]==0) return;; 4262 ; 4263 if (strstr(options,""streamerinfo"")!=nullptr) {; 4264 GetStreamerInfos()->ls(options);; 4265 ; 4266 if (fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:160016,load,load,160016,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"07,2001 - e-Print Archive: hep ex/0011057 For multi-dimensional datasets, the kernels are modeled by multidimensional Gaussians. The kernels are constructed such that they reflect the correlation coefficients between the observables in the input dataset. ; Definition at line 44 of file RooNDKeysPdf.h. Classes; struct  BoxInfo;  . Public Types; enum  Mirror { ;   NoMirror; , MirrorLeft; , MirrorRight; , MirrorBoth; , ;   MirrorAsymLeft; , MirrorAsymLeftRight; , MirrorAsymRight; , MirrorLeftAsymRight; , ;   MirrorAsymBoth. };  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:1963,Cache,CacheMode,1963,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,1,['Cache'],['CacheMode']
Performance,"077 ; 1078TLeaf* TChain::GetLeaf(const char* branchname, const char *leafname); 1079{; 1080 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1081 // Make sure the element list is up to date; 1082 if (!TestBit(kProofUptodate)); 1083 SetProof(true, true);; 1084 return fProofChain->GetLeaf(branchname, leafname);; 1085 }; 1086 if (fTree) {; 1087 return fTree->GetLeaf(branchname, leafname);; 1088 }; 1089 LoadTree(0);; 1090 if (fTree) {; 1091 return fTree->GetLeaf(branchname, leafname);; 1092 }; 1093 return nullptr;; 1094}; 1095 ; 1096////////////////////////////////////////////////////////////////////////////////; 1097/// Return a pointer to the leaf name in the current tree.; 1098 ; 1099TLeaf* TChain::GetLeaf(const char* name); 1100{; 1101 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1102 // Make sure the element list is up to date; 1103 if (!TestBit(kProofUptodate)); 1104 SetProof(true, true);; 1105 return fProofChain->GetLeaf(name);; 1106 }; 1107 if (fTree) {; 1108 return fTree->GetLeaf(name);; 1109 }; 1110 LoadTree(0);; 1111 if (fTree) {; 1112 return fTree->GetLeaf(name);; 1113 }; 1114 return nullptr;; 1115}; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Return a pointer to the list of branches of the current tree.; 1119///; 1120/// Warning: If there is no current TTree yet, this routine will open the; 1121/// first in the chain.; 1122///; 1123/// Returns 0 on failure.; 1124 ; 1125TObjArray* TChain::GetListOfBranches(); 1126{; 1127 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1128 // Make sure the element list is up to date; 1129 if (!TestBit(kProofUptodate)); 1130 SetProof(true, true);; 1131 return fProofChain->GetListOfBranches();; 1132 }; 1133 if (fTree) {; 1134 return fTree->GetListOfBranches();; 1135 }; 1136 LoadTree(0);; 1137 if (fTree) {; 1138 return fTree->GetListOfBranches();; 1139 }; 1140 return nullptr;; 1141}; 1142 ; 1143////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:41361,Load,LoadTree,41361,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"07; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont_tstd::multimap< void *, Version_t > RepoCont_tDefinition TClass.h:343; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:60293,load,loading,60293,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['loading']
Performance,"07; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:325654,load,loading,325654,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"07; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6989; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5763; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3489; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7522; TClass::RepoCont_tstd::multimap< void *, Version_t > RepoCont_tDefinition TClass.h:343; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6890; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:60121,load,loading,60121,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['loading']
Performance,"07; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6989; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5763; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3489; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7522; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6890; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7506; TClass::GetClassMethodWithPrototypeTMethod * GetClassMet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:328292,load,loading,328292,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"0977] - Exit code 0 with failing C++ notebook in nbconvert; [ROOT-11006] - [TTreeReader] Crash when reading array branch. Release 6.32.02; Published on June 18, 2024; Items addressed in this release. [#7236] - Memory leak in TFile::WriteObjectAny, depending on data type; [#10075] - Difficult to configure Xrootd to use non-builtin openssl; [#14051] - [web graphics] Web graphics resizes canvas despite canvas size definition in the macro; [#15321] - [MSVC] Root is failed with error G694476FC: static_assert failed “Unexpected size”; [#15405] - [RF] ExternalConstraints documentation incorrect for RooMCStudy; [#15430] - Test failures with Python 3.13; [#15473] - Segmentation fault when building with the mold linker; [#15498] - gPad is not consistent in pyROOT with web canvas; [#15511] - Possible memory corruption in cling; [#15579] - Performance regression (slowdown) in ALICE event generation; [#15686] - JITted code changes the execution order of computation graph nodes; [#15688] - PyROOT TProfile2D::Fill ambiguities preventing use of some signatures in pyROOT; [#15690] - [RF] SegFault in RooBernstein::fillBuffer; [#15694] - [RF] New RooFit EvalBackend returning incorrect result for binned likelihoods; [#15703] - Leaking memory though strings in PyROOT; [#15727] - Windows CMake project cannot find_library() after integrating with ROOT.; [#15751] - [RF] Using a conditional RooProdPdf in a multi-channel fit spawns too many integrals with new CPU evaluation backend; [#15791] - JS ROOT does not draw tprofile2d correctly with “TEXT” draw option; [#15799] - pyunittests-pyroot-pyz-ttree-setbranchaddress segfaults with Python 3.13; [ROOT-7412] - Strange results looking for nested types; [ROOT-8439] - PyROOT does not treat exceptions properly in overloaded methods; [ROOT-9307] - TPad::GetListOfPrimitives() double deletion error in TList::Clear(). Release 6.32.04; Published on August 14, 2024; Items addressed in this release. [#7223] - [RF] RDataFrame to RooDataSet/RooDataHist conve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:43149,Perform,Performance,43149,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['Perform'],['Performance']
Performance,"0; TBuffer::operator=void operator=(const TBuffer &)=delete; TBuffer::SetPidOffsetvirtual void SetPidOffset(UShort_t offset)=0; TBuffer::TBufferTBuffer(const TBuffer &)=delete; TBuffer::InitMapvirtual void InitMap()=0; TBuffer::GetReAllocFuncReAllocCharFun_t GetReAllocFunc() constReturn the reallocation method currently used.Definition TBuffer.cxx:277; TBuffer::fReAllocFuncReAllocCharFun_t fReAllocFuncDefinition TBuffer.h:55; TBuffer::fBufferchar * fBufferDefinition TBuffer.h:51; TBuffer::fParentTObject * fParentDefinition TBuffer.h:54; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Bool_t *b)=0; TBuffer::WriteObjectvirtual void WriteObject(const TObject *obj, Bool_t cacheReuse)=0; TBuffer::WriteFastArrayFloat16virtual void WriteFastArrayFloat16(const Float_t *f, Long64_t n, TStreamerElement *ele=nullptr)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Bool_t *b, Long64_t n)=0; TBuffer::ReadFastArrayWithNbitsvirtual void ReadFastArrayWithNbits(Double_t *ptr, Int_t n, Int_t nbits)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(Long64_t *&l)=0; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Long64_t *l)=0; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const TClass *cl, const TClass *onFileClass=nullptr)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Char_t *c, Long64_t n)=0; TBuffer::GetMapCountvirtual Int_t GetMapCount() const =0; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::GetLastProcessIDvirtual TProcessID * GetLastProcessID(TRefTable *reftable) const =0; TBuffer::ReadFastArrayWithFactorvirtual void ReadFastArrayWithFactor(Float_t *ptr, Int_t n, Double_t factor, Double_t minvalue)=0; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::GetBufferVersionInt_t GetBufferVersion() constDefinition TBuffer.h:85; TBuffer::ReadUCharvirtual void ReadUChar(UChar_t &c)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(ULong64_t *&l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:41004,cache,cacheReuse,41004,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,1,['cache'],['cacheReuse']
Performance,"0; TView::SetOutlineToCubevirtual void SetOutlineToCube()=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::GetTnormvirtual Double_t * GetTnorm()=0; TView::ExecuteRotateViewvirtual void ExecuteRotateView(Int_t event, Int_t px, Int_t py)=0; TView::GetOutlinevirtual TSeqCollection * GetOutline()=0; TView::PadRangevirtual void PadRange(Int_t rback)=0; TView::SetRangevirtual void SetRange(const Double_t *min, const Double_t *max)=0; TView::FindNormalvirtual void FindNormal(Double_t x, Double_t y, Double_t z, Double_t &zn)=0; TView::AxisVertexvirtual void AxisVertex(Double_t ang, Double_t *av, Int_t &ix1, Int_t &ix2, Int_t &iy1, Int_t &iy2, Int_t &iz1, Int_t &iz2)=0; TView::SetViewvirtual void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t &irep)=0; TVirtualPadEditorAbstract base class used by ROOT graphics editor.Definition TVirtualPadEditor.h:27; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadEditor::Showvirtual void Show()Definition TVirtualPadEditor.h:49; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Closevirtual void Close(Option_t *option="""")=0; TVirtualX::kInvert@ kInvertDefinition TVirtualX.h:49; TVirtualX::kFilled@ kFilledDefinition TVirtualX.h:50; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition leg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:493199,load,load,493199,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['load'],['load']
Performance,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:22836,cache,cache,22836,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,6,['cache'],['cache']
Performance,"0{; 1001 fContent.reserve(size);; 1002}; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005 ; 1006inline const char *TCling::TUniqueString::Data(); 1007{; 1008 return fContent.c_str();; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Append string to the storage if not added already.; 1013 ; 1014inline bool TCling::TUniqueString::Append(const std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:36354,Load,LoadModule,36354,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['LoadModule', 'load']"
Performance,"0}; 241 ; 242bool Fitter::SetFCN(MinuitFCN_t fcn, int npar, const double *params, unsigned int dataSize, int fitType); 243{; 244 // set TMinuit style FCN type (global function pointer); 245 // create corresponding objective function from that function; 246 ; 247 if (npar == 0) {; 248 npar = fConfig.ParamsSettings().size();; 249 if (npar == 0) {; 250 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Fit Parameter settings have not been created "");; 251 return false;; 252 }; 253 }; 254 ; 255 ROOT::Fit::FcnAdapter newFcn(fcn, npar);; 256 return DoSetFCN(false,newFcn, params, dataSize, fitType);; 257}; 258 ; 259bool Fitter::FitFCN(MinuitFCN_t fcn, int npar, const double *params, unsigned int dataSize, int fitType); 260{; 261 // fit using Minuit style FCN type (global function pointer); 262 // create corresponding objective function from that function; 263 if (!SetFCN(fcn, npar, params, dataSize, fitType)); 264 return false;; 265 fUseGradient = false;; 266 return FitFCN();; 267}; 268 ; 269bool Fitter::FitFCN(); 270{; 271 // fit using the previously set FCN function; 272 ; 273 ; 274 if (!fExtObjFunction && !fObjFunction) {; 275 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:10118,perform,perform,10118,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['perform'],['perform']
Performance,"0}; 461////////////////////////////////////////////////////////////////////////////////; 462/// Set the name of the file where to redirect `<Scan>` output.; 463 ; 464void TTreeViewer::SetScanFileName(const char *name); 465{; 466 if (fTree) ((TTreePlayer *)fTree->GetPlayer())->SetScanFileName(name);; 467}; 468////////////////////////////////////////////////////////////////////////////////; 469/// Set the state of Scan check button.; 470 ; 471void TTreeViewer::SetScanRedirect(bool mode); 472{; 473 if (mode); 474 fBarScan->SetState(kButtonDown);; 475 else; 476 fBarScan->SetState(kButtonUp);; 477}; 478////////////////////////////////////////////////////////////////////////////////; 479/// Assign the fTree member from existing tree, e.g. when calling; 480/// tree->StartViewer() from the browser, or even from the command line.; 481 ; 482void TTreeViewer::SetTree(TTree *tree); 483{; 484 if (!tree) return;; 485 if (fTree != tree) {; 486 fTree = tree;; 487 // load the tree via the interpreter; 488 // define a global ""tree"" variable for the same tree; 489 TString command = TString::Format(""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 490 ExecuteCommand(command.Data());; 491 }; 492 //--- add the tree to the list if it is not already in; 493 if (fTreeList) fTreeList->Add(fTree);; 494 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 495 //--- map this tree; 496 TGListTreeItem *base = nullptr;; 497 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 498 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 499 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 500 fTreeIndex++;; 501 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 502 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 503 MapTree(fTree, lTreeItem, false);; 504 fLt->OpenItem(parent);; 505 fLt->HighlightItem(lTreeItem);; 506 fClient->NeedRedraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:17866,load,load,17866,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['load'],['load']
Performance,"1 * ; h2, . bool ; useMerge = false . ); const. protected . Definition at line 883 of file TH1.cxx. ◆ Merge() [1/2]. virtual Long64_t TH1::Merge ; (; TCollection * ; list). inlinevirtual . Reimplemented in TH2Poly, TProfile2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 345 of file TH1.h. ◆ Merge() [2/2]. Long64_t TH1::Merge ; (; TCollection * ; li, . Option_t * ; opt . ). Add all histograms in the collection to this histogram. ; This function computes the min/max for the x axis, compute a new number of bins, if necessary, add bin contents, errors and statistics. If all histograms have bin labels, bins with identical labels will be merged, no matter what their order is. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.; Possible option: -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check (enabled by default) slows down the merging; IMPORTANT remark. The axis x may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width. Example:; void atest() {; TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }; ; TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h->Merge(list);; h->Draw();; }; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TObject::Drawvirtual void Draw(Option_t *option="""")Default Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:189543,perform,perform,189543,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['perform'],['perform']
Performance,"1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {}, . const RooCmdArg & ; arg9 = {}, . const RooCmdArg & ; arg10 = {} . ); const. virtual . Plot (project) PDF on specified frame. ; If a PDF is plotted in an empty frame, it will show a unit normalized curve in the frame variable, taken at the present value of other observables defined for this PDF.; Parameters. [in]framepointer to RooPlot ; [in]arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10Ordered arguments. If a PDF is plotted in a frame in which a dataset has already been plotted, it will show a projected curve integrated over all variables that were present in the shown dataset except for the one on the x-axis. The normalization of the curve will also be adjusted to the event count of the plotted dataset. An informational message will be printed for each projection step that is performed.; This function takes the following named arguments . Projection control . Slice(const RooArgSet& set) Override default projection behaviour by omitting observables listed in set from the projection, i.e. by not integrating over these. Slicing is usually only sensible in discrete observables, by e.g. creating a slice of the PDF at the current value of the category observable. Slice(RooCategory& cat, const char* label) Override default projection behaviour by omitting the specified category observable from the projection, i.e., by not integrating over all states of this category. The slice is positioned at the given label value. To pass multiple Slice() commands, please use the Slice(std::map<RooCategory*, std::string> const&) argument explained below. Slice(std::map<RooCategory*, std::string> const&) Omits multiple categories from the projection, as explianed above. Can be used with initializer lists for convenience, e.g. pdf.plotOn(frame, Slic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:130110,perform,performed,130110,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['perform'],['performed']
Performance,"1 auto isHeaderInModule = [&moduleHeaders](const std::string &header) {; 3892 for (const clang::Module::Header &moduleHeader : moduleHeaders); 3893 if (header == moduleHeader.NameAsWritten); 3894 return true;; 3895 return false;; 3896 };; 3897 ; 3898 // Go through the list of headers that are required by the ModuleGenerator; 3899 // and check for each header if it's in one of the modules we loaded.; 3900 // If not, make sure we fail at the end and mark the header as missing.; 3901 for (const std::string &header : modGen.GetHeaders()) {; 3902 if (isHeaderInModule(header)); 3903 continue;; 3904 ; 3905 clang::ModuleMap::KnownHeader SuggestedModule;; 3906 clang::ConstSearchDirIterator *CurDir = nullptr;; 3907 if (auto FE = headerSearch.LookupFile(; 3908 header, clang::SourceLocation(),; 3909 /*isAngled*/ false,; 3910 /*FromDir*/ 0, CurDir,; 3911 clang::ArrayRef<std::pair<clang::OptionalFileEntryRef, clang::DirectoryEntryRef>>(),; 3912 /*SearchPath*/ 0,; 3913 /*RelativePath*/ 0,; 3914 /*RequestingModule*/ 0, &SuggestedModule,; 3915 /*IsMapped*/ 0,; 3916 /*IsFrameworkFound*/ nullptr,; 3917 /*SkipCache*/ false,; 3918 /*BuildSystemModule*/ false,; 3919 /*OpenFile*/ false,; 3920 /*CacheFail*/ false)) {; 3921 if (auto OtherModule = SuggestedModule.getModule()) {; 3922 std::string OtherModuleName;; 3923 auto TLM = OtherModule->getTopLevelModuleName();; 3924 if (!TLM.empty()); 3925 OtherModuleName = TLM.str();; 3926 else; 3927 OtherModuleName = OtherModule->Name;; 3928 ; 3929 // Don't complain about headers that are actually in by-products:; 3930 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), OtherModuleName); 3931 != gOptModuleByproducts.end()); 3932 continue;; 3933 ; 3934 missingHeaders.push_back({header, OtherModuleName});; 3935 }; 3936 } else {; 3937 missingHeaders.push_back({header, {}});; 3938 }; 3939 foundAllHeaders = false;; 3940 }; 3941 return foundAllHeaders;; 3942}; 3943 ; 3944//////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:158513,Cache,CacheFail,158513,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['Cache'],['CacheFail']
Performance,"1 on error . Reimplemented from TTree.; Definition at line 2441 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2640 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """" (default): both the file names of the chain elements and the file names of the TEntryList sublists are expanded to full path name.; ""ne"": the file names are taken as they are and not expanded; ""sync"": the TChain will go through the TEntryList in lockstep with the trees in the chain rather than performing a lookup based on treename and filename. This is mostly useful when the TEntryList has multiple sublists for the same tree and filename. . Exceptions. std::runtime_errorIf option ""sync"" was chosen and either:; elist doesn't have sub entry lists.; the number of sub entry lists in elist is different than the number of trees in the chain.; any of the sub entry lists in elist doesn't correspond to the tree of the chain with the same index (i.e. it doesn't share the same tree name and file name). This function finds correspondence between the sub-lists of the TEntryList and the trees of the TChain. ; Reimplemented from TTree.; Definition at line 2677 of file TChain.cxx. ◆ SetEntryListFile(). void TChain::SetEntryListFile ; (; const char * ; filename = """", . Option_t * ; opt = """" . ). virtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; This function crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:98096,perform,performing,98096,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['perform'],['performing']
Performance,"1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2666 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """" (default): both the file names of the chain elements and the file names of the TEntryList sublists are expanded to full path name.; ""ne"": the file names are taken as they are and not expanded; ""sync"": the TChain will go through the TEntryList in lockstep with the trees in the chain rather than performing a lookup based on treename and filename. This is mostly useful when the TEntryList has multiple sublists for the same tree and filename. . Exceptions. std::runtime_errorIf option ""sync"" was chosen and either:; elist doesn't have sub entry lists.; the number of sub entry lists in elist is different than the number of trees in the chain.; any of the sub entry lists in elist doesn't correspond to the tree of the chain with the same index (i.e. it doesn't share the same tree name and file name). This function finds correspondence between the sub-lists of the TEntryList and the trees of the TChain. ; Reimplemented from TTree.; Definition at line 2703 of file TChain.cxx. ◆ SetEntryListFile(). void TChain::SetEntryListFile ; (; const char * ; filename = """", . Option_t * ; opt = """" . ). virtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; This function crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:98717,perform,performing,98717,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['perform'],['performing']
Performance,"1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:339118,cache,cacheSize,339118,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"1 }; 812 g1->Draw(""ALP"");; 813 if (g2); 814 g2->Draw(""LP"");; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Draw method.; 819 ; 820void TGeoPainter::DrawVolume(TGeoVolume *vol, Option_t *option); 821{; 822 fTopVolume = vol;; 823 fLastVolume = nullptr;; 824 fIsPaintingShape = kFALSE;; 825 // if (fVisOption==kGeoVisOnly ||; 826 // fVisOption==kGeoVisBranch) fGeoManager->SetVisOption(kGeoVisLeaves);; 827 CountVisibleNodes();; 828 TString opt = option;; 829 opt.ToLower();; 830 fPaintingOverlaps = kFALSE;; 831 fOverlap = nullptr;; 832 ; 833 if (fVisLock) {; 834 ClearVisibleVolumes();; 835 fVisLock = kFALSE;; 836 }; 837 Bool_t has_pad = (gPad == nullptr) ? kFALSE : kTRUE;; 838 // Clear pad if option ""same"" not given; 839 if (!gPad) {; 840 gROOT->MakeDefCanvas();; 841 }; 842 if (!opt.Contains(""same"")); 843 gPad->Clear();; 844 // append this volume to pad; 845 fTopVolume->AppendPad(option);; 846 ; 847 // Create a 3-D view; 848 TView *view = gPad->GetView();; 849 if (!view) {; 850 view = TView::CreateView(11, nullptr, nullptr);; 851 // Set the view to perform a first autorange (frame) draw.; 852 // TViewer3DPad will revert view to normal painting after this; 853 view->SetAutoRange(kTRUE);; 854 if (has_pad); 855 gPad->Update();; 856 }; 857 if (!opt.Contains(""same"")); 858 Paint(""range"");; 859 else; 860 Paint(opt);; 861 view->SetAutoRange(kFALSE);; 862 // If we are drawing into the pad, then the view needs to be; 863 // set to perspective; 864 // if (!view->IsPerspective()) view->SetPerspective();; 865 ; 866 fLastVolume = fTopVolume;; 867 ; 868 // Create a 3D viewer to paint us; 869 gPad->GetViewer3D(option);; 870}; 871 ; 872////////////////////////////////////////////////////////////////////////////////; 873/// Draw a shape.; 874 ; 875void TGeoPainter::DrawShape(TGeoShape *shape, Option_t *option); 876{; 877 TString opt = option;; 878 opt.ToLower();; 879 fPaintingOverlaps = kFALSE;; 880 fOverlap = nullptr;; 881 fIsPainti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:27437,perform,perform,27437,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['perform'],['perform']
Performance,"1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function at; the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:41146,Perform,Performs,41146,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['Perform'],['Performs']
Performance,"1); 4252 return nullptr;; 4253 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4254 }; 4255 ; 4256 } else if (type == kWeb) {; 4257 ; 4258 // Web files; 4259 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name))) {; 4260 if (h->LoadPlugin() == -1); 4261 return nullptr;; 4262 f = (TFile*) h->ExecPlugin(2, name.Data(), option);; 4263 }; 4264 ; 4265 } else if (type == kFile) {; 4266 ; 4267 // 'file:' protocol; 4268 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4269 h->LoadPlugin() == 0) {; 4270 name.ReplaceAll(""file:"", """");; 4271 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4272 } else; 4273 f = new TFile(name.Data(), option, ftitle, compress);; 4274 ; 4275 } else {; 4276 ; 4277 // no recognized specification: try the plugin manager; 4278 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name.Data()))) {; 4279 if (h->LoadPlugin() == -1); 4280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::Open( newUrl, option, ftitle, compress );; 4300 else; 4301 f = nullptr;; 4302 }; 4303 }; 4304 ; 4305 if (rediroutput) {; 4306 // Restore output to stdout; 4307 gSystem->RedirectOutput(0, """", &rh);; 43",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:156461,Load,LoadPlugin,156461,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:7673,Load,Load,7673,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['Load'],['Load']
Performance,"1, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1604,Perform,Perform,1604,doc/master/rf606__nllerrorhandling_8py.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html,1,['Perform'],['Perform']
Performance,"1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofSuperMaster.html:21613,cache,cachedir,21613,root/html604/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofSuperMaster.html,1,['cache'],['cachedir']
Performance,"1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofCondor.html:21763,cache,cachedir,21763,root/html604/TProofCondor.html,https://root.cern,https://root.cern/root/html604/TProofCondor.html,1,['cache'],['cachedir']
Performance,"1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot, e.g. a different element of a list. See here for an example usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other. On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage. ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently: ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");; ; // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop; ; // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Performance considerations; To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible. For instance, Filter(""x > 0"") requir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:48478,concurren,concurrently,48478,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrently']
Performance,"1.cxx:1439; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TSpectrumAdvanced Spectra Processing.Definition TSpectrum.h:18; TSpectrum::Backgroundvirtual TH1 * Background(const TH1 *hist, Int_t niter=20, Option_t *option="""")One-dimensional background estimation function.Definition TSpectrum.cxx:145; TSpectrum::Searchvirtual Int_t Search(const TH1 *hist, Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05)One-dimensional peak search function.Definition TSpectrum.cxx:259; TSpectrum::GetPositionXDouble_t * GetPositionX() constDefinition TSpectrum.h:58; TVirtualFitter::Fitterstatic TVirtualFitter * Fitter(TObject *obj, Int_t maxpar=25)Static function returning a pointer to the current fitter.Definition TVirtualFitter.cxx:159; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; c1return c1Definition legend1.C:41; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; AuthorRene Brun ; Definition in file peaks.C. tutorialsspectrumpeaks.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/peaks_8C.html:7751,optimiz,optimizer,7751,doc/master/peaks_8C.html,https://root.cern,https://root.cern/doc/master/peaks_8C.html,1,['optimiz'],['optimizer']
Performance,"1/2]. void TGWin32VirtualXProxy::MoveWindow ; (; Int_t ; wid, . Int_t ; x, . Int_t ; y . ). overridevirtual . Moves the window ""wid"" to the specified x and y coordinates. ; It does not change the window's size, raise the window, or change the mapping state of the window.; Parameters. [in]widwindow identifier ; [in]x,ycoordinates, which define the new position of the window relative to its parent. . Reimplemented from TVirtualX. ◆ MoveWindow() [2/2]. void TGWin32VirtualXProxy::MoveWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y . ). overridevirtual . Moves the specified window to the specified x and y coordinates. ; It does not change the window's size, raise the window, or change the mapping state of the window.; Parameters. [in]idwindow identifier ; [in]x,ycoordinates, which define the new position of the window relative to its parent. . Reimplemented from TVirtualX. ◆ NextEvent(). void TGWin32VirtualXProxy::NextEvent ; (; Event_t & ; event). overridevirtual . Process next event in the queue - if any. ; Reimplemented from TVirtualX.; Definition at line 304 of file TGWin32VirtualXProxy.cxx. ◆ OpenDisplay(). Int_t TGWin32VirtualXProxy::OpenDisplay ; (; const char * ; dpyName = nullptr). overridevirtual . Opens connection to display server (if such a thing exist on the current platform). ; The encoding and interpretation of the display name.; On X11 this method returns on success the X display socket descriptor >0, 0 in case of batch mode, and <0 in case of failure (cannot connect to display dpyName). ; Reimplemented from TVirtualX. ◆ OpenPixmap(). Int_t TGWin32VirtualXProxy::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Creates a pixmap of the width ""w"" and height ""h"" you specified. ; Reimplemented from TVirtualX. ◆ ParseColor(). Bool_t TGWin32VirtualXProxy::ParseColor ; (; Colormap_t ; cmap, . const char * ; cname, . ColorStruct_t & ; color . ). overridevirtual . Looks up the string name of a color ""cname"" with respect to the screen associated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:96699,queue,queue,96699,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['queue'],['queue']
Performance,"10 ; 11#include ""ROOT/InternalTreeUtils.hxx""; 12#include ""ROOT/RDataFrame.hxx""; 13#include ""ROOT/RDataSource.hxx""; 14#include ""ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:1559,multi-thread,multi-threading,1559,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance,"10 = 0); Initialize up to 11 parameters; All arguments except THE FIRST TWO are optional; In case of a function with only one parameter, call this function with p1=0.; Minimum two arguments are required to differentiate this function; from the SetParameters(cont Double_t *params). void SetParName(Int_t ipar, const char* name); Set name of parameter number ipar. void SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10""); Set up to 11 parameter names. void Streamer(TBuffer& ); Stream a class object. void Convert(UInt_t fromVersion); Convert the fOper of a TFormula version fromVersion to the current in memory version. void MakePrimitive(const char* expr, Int_t pos); MakePrimitive; find TFormulaPrimitive replacement for some operands. void Optimize(); MI include. Optimize formula; 1.) Minimize the number of operands; a.) several operanands are glued togther; b.) some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); c.) maximize number of standard calls minimizing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is chosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:27007,Optimiz,Optimize,27007,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,2,['Optimiz'],['Optimize']
Performance,"10 static AFloat * fDeviceReturn; ///< Buffer for kernel return values.; 111 static AFloat * fOnes; ///< Vector used for summations of columns.; 112 static size_t fNOnes; ///< Current length of the one vector.; 113 static curandState_t * fCurandStates;; 114 static size_t fNCurandStates;; 115 ; 116 ; 117 size_t fNRows;; 118 size_t fNCols;; 119 TCudaDeviceBuffer<AFloat> fElementBuffer;; 120 ; 121public:; 122 ; 123 static Bool_t gInitializeCurand;; 124 ; 125 static AFloat * GetOnes() {return fOnes;}; 126 ; 127 TCudaMatrix();; 128 TCudaMatrix(size_t i, size_t j);; 129 TCudaMatrix(const TMatrixT<AFloat> &);; 130 TCudaMatrix(TCudaDeviceBuffer<AFloat> buffer, size_t m, size_t n);; 131 ; 132 TCudaMatrix(const TCudaMatrix &) = default;; 133 TCudaMatrix( TCudaMatrix &&) = default;; 134 TCudaMatrix & operator=(const TCudaMatrix &) = default;; 135 TCudaMatrix & operator=( TCudaMatrix &&) = default;; 136 ~TCudaMatrix() = default;; 137 ; 138 /** Convert cuda matrix to Root TMatrix. Performs synchronous data transfer. */; 139 operator TMatrixT<AFloat>() const;; 140 ; 141 inline cudaStream_t GetComputeStream() const;; 142 inline void SetComputeStream(cudaStream_t stream);; 143 /** Set the return buffer on the device to the specified value. This is; 144 * required for example for reductions in order to initialize the; 145 * accumulator. */; 146 inline static void ResetDeviceReturn(AFloat value = 0.0);; 147 /** Transfer the value in the device return buffer to the host. This; 148 * transfer is synchronous */; 149 inline static AFloat GetDeviceReturn();; 150 /** Return device pointer to the device return buffer */; 151 inline static AFloat * GetDeviceReturnPointer() {return fDeviceReturn;}; 152 inline static curandState_t * GetCurandStatesPointer() {return fCurandStates;}; 153 ; 154 /** Blocking synchronization with the associated compute stream, if it's; 155 * not the default stream. */; 156 inline void Synchronize(const TCudaMatrix &) const;; 157 ; 158 static size_t GetNDim() {retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:5297,Perform,Performs,5297,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['Perform'],['Performs']
Performance,"10):FitMethod=GA:PopSize=300:Cycles=3:Steps=20:Trim=True:SaveBestGen=1"" );; if (Use[""PDEFoam""]) // PDE-Foam approach; factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"", ""!H:!V:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Nmin=100:Kernel=None:Compress=T"" );; ; ; if (Use[""DL_CPU""]) {; TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; nnOptions.Append("":"");; nnOptions.Append(layoutString);; nnOptions.Append("":"");; nnOptions.Append(trainingStrategyString);; factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_CPU"", nnOptions);; }; if (Use[""DL_GPU""]) {; TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; nnOptions.Append("":"");; nnOptions.Append(layoutString);; nnOptions.Append("":"");; nnOptions.Append(trainingStrategyString);; factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; }; ; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAMulticlass is done!"" << std::endl;; ; delete factory;; delete dataloader;; ; // Launch the GUI fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:36526,Optimiz,Optimizer,36526,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['Optimiz'],['Optimizer']
Performance,"1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000011920929 Classical: 1000000000.00000011920929; DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df022_useKahan.C. tutorialsdataframedf022_useKahan.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df022__useKahan_8C.html:3471,multi-thread,multi-threading,3471,doc/master/df022__useKahan_8C.html,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html,2,['multi-thread'],['multi-threading']
Performance,"104 TString /*methodOption*/,; 105 TMVA::Types::EMVA /*theComposite*/,; 106 TString /*compositeOption = """"*/ ) { return nullptr; }; 107 ; 108 // optimize all booked methods (well, if desired by the method); 109 std::map<TString,Double_t> OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 110 void OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 111 void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 112 ; 113 // training for all booked methods; 114 void TrainAllMethods ();; 115 void TrainAllMethodsForClassification( void ) { TrainAllMethods(); }; 116 void TrainAllMethodsForRegression ( void ) { TrainAllMethods(); }; 117 ; 118 // testing; 119 void TestAllMethods();; 120 ; 121 // performance evaluation; 122 void EvaluateAllMethods( void );; 123 void EvaluateAllVariables(DataLoader *loader, TString options = """" );; 124 ; 125 TH1F* EvaluateImportance( DataLoader *loader,VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 126 ; 127 // delete all methods and reset the method vector; 128 void DeleteAllMethods( void );; 129 ; 130 // accessors; 131 IMethod* GetMethod( const TString& datasetname, const TString& title ) const;; 132 Bool_t HasMethod( const TString& datasetname, const TString& title ) const;; 133 ; 134 Bool_t Verbose( void ) const { return fVerbose; }; 135 void SetVerbose( Bool_t v=kTRUE );; 136 ; 137 // make ROOT-independent C++ class for classifier response; 138 // (classifier-specific implementation); 139 // If no classifier name is given, help messages for all booked; 140 // classifiers are printed; 141 virtual void MakeClass(const TString& datasetname , const TString& methodTitle = """" ) const;; 142 ; 143 // prints classifier-specific help messages, dedicated to; 144 // help with the optimisation and configuration options tuning.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:4987,load,loader,4987,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"10{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52875,cache,cache,52875,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; -D_WINDOWS $IncludePath $SourceFile; /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""). void AddIncludePath(const char* includePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:46306,optimiz,optimization,46306,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['optimiz'],['optimization']
Performance,"11 f1->GetName(), f1->GetNdim(), dim);; 112 return -5;; 113 }; 114 ; 115 return 0;; 116 ; 117}; 118 ; 119 ; 120void HFit::GetFunctionRange(const TF1 & f1, ROOT::Fit::DataRange & range) {; 121 // get the range form the function and fill and return the DataRange object; 122 Double_t fxmin, fymin, fzmin, fxmax, fymax, fzmax;; 123 f1.GetRange(fxmin, fymin, fzmin, fxmax, fymax, fzmax);; 124 // support only one range - so add only if was not set before; 125 if (range.Size(0) == 0) range.AddRange(0,fxmin,fxmax);; 126 if (range.Size(1) == 0) range.AddRange(1,fymin,fymax);; 127 if (range.Size(2) == 0) range.AddRange(2,fzmin,fzmax);; 128 return;; 129}; 130 ; 131 ; 132template<class FitObject>; 133TFitResultPtr HFit::Fit(FitObject * h1, TF1 *f1 , Foption_t & fitOption , const ROOT::Math::MinimizerOptions & minOption, const char *goption, ROOT::Fit::DataRange & range); 134{; 135 // perform fit of histograms, or graphs using new fitting classes; 136 // use same routines for fitting both graphs and histograms; 137 ; 138#ifdef DEBUG; 139 printf(""fit function %s\n"",f1->GetName() );; 140#endif; 141 ; 142 // replacement function using new fitter; 143 int hdim = HFit::GetDimension(h1);; 144 int iret = HFit::CheckFitFunction(f1, hdim);; 145 if (iret != 0) return iret;; 146 ; 147 ; 148 ; 149 // integral option is not supported in this case; 150 if (f1->GetNdim() < hdim ) {; 151 if (fitOption.Integral) Info(""Fit"",""Ignore Integral option. Model function dimension is less than the data object dimension"");; 152 if (fitOption.Like) Info(""Fit"",""Ignore Likelihood option. Model function dimension is less than the data object dimension"");; 153 fitOption.Integral = 0;; 154 fitOption.Like = 0;; 155 }; 156 ; 157 Int_t special = f1->GetNumber();; 158 Bool_t linear = f1->IsLinear();; 159 Int_t npar = f1->GetNpar();; 160 if (special==299+npar) linear = kTRUE; // for polynomial functions; 161 // do not use linear fitter in these case; 162 if (fitOption.Bound || fitOption.Like || fitOption.Errors || fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:4435,perform,perform,4435,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['perform'],['perform']
Performance,"110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 315",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:118792,load,loadedcl,118792,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,['load'],['loadedcl']
Performance,"1123/// Returns 0 on failure.; 1124 ; 1125TObjArray* TChain::GetListOfBranches(); 1126{; 1127 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1128 // Make sure the element list is up to date; 1129 if (!TestBit(kProofUptodate)); 1130 SetProof(true, true);; 1131 return fProofChain->GetListOfBranches();; 1132 }; 1133 if (fTree) {; 1134 return fTree->GetListOfBranches();; 1135 }; 1136 LoadTree(0);; 1137 if (fTree) {; 1138 return fTree->GetListOfBranches();; 1139 }; 1140 return nullptr;; 1141}; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Return a pointer to the list of leaves of the current tree.; 1145///; 1146/// Warning: May set the current tree!; 1147 ; 1148TObjArray* TChain::GetListOfLeaves(); 1149{; 1150 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1151 // Make sure the element list is up to date; 1152 if (!TestBit(kProofUptodate)); 1153 SetProof(true, true);; 1154 return fProofChain->GetListOfLeaves();; 1155 }; 1156 if (fTree) {; 1157 return fTree->GetListOfLeaves();; 1158 }; 1159 LoadTree(0);; 1160 if (fTree) {; 1161 return fTree->GetListOfLeaves();; 1162 }; 1163 return nullptr;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Return maximum of column with name columname.; 1168 ; 1169Double_t TChain::GetMaximum(const char* columname); 1170{; 1171 Double_t theMax = -DBL_MAX;; 1172 for (Int_t file = 0; file < fNtrees; file++) {; 1173 Long64_t first = fTreeOffset[file];; 1174 LoadTree(first);; 1175 Double_t curmax = fTree->GetMaximum(columname);; 1176 if (curmax > theMax) {; 1177 theMax = curmax;; 1178 }; 1179 }; 1180 return theMax;; 1181}; 1182 ; 1183////////////////////////////////////////////////////////////////////////////////; 1184/// Return minimum of column with name columname.; 1185 ; 1186Double_t TChain::GetMinimum(const char* columname); 1187{; 1188 Double_t theMin = DBL_MAX;; 1189 for (Int_t file = 0; file < fNtrees;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:42835,Load,LoadTree,42835,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; FACTOR 0 : 15; FACTOR 1 : 12.9972; FACTOR 2 : 0; ; #include <iostream> // Stream declarations; #include <vector>; ; #include ""TMVA/GeneticAlgorithm.h""; #include ""TMVA/GeneticFitter.h""; #include ""TMVA/IFitterTarget.h""; ; using std::vector;; ; using namespace TMVA;; ; class MyFitness : public IFitterTarget {; public:; MyFitness() : IFitterTarget() {; }; ; // the fitness-function goes here; // the factors are optimized such that the return-value of this function is minimized; // take care!! the fitness-function must never fail, .. means: you have to prevent; // the function from reaching undefined values (such as x=0 for 1/x or so); //; // HINT: to use INTEGER variables, it is sufficient to cast the ""factor"" in the fitness-function; // to (int). In this case the variable-range has to be chosen +1 ( to get 0..5, take Interval(0,6) ); // since the introduction of ""Interval"" ranges can be defined with a third parameter; // which gives the number of bins within the interval. With that technique discrete values; // can be achieved easier. The random selection out of this discrete numbers is completely uniform.; //; Double_t EstimatorFunction( std::vector<Double_t> & factors ){; //return (10.- (int)factors.at(0) *factors.at(1) + (int)factors.at(2));; return (10.- factors.at(0) *factors.at(1) + factors.at(2));; ; //return 100.- (10 + factors.at(1)) *factors.at(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAGAexample_8C.html:2767,optimiz,optimized,2767,doc/master/TMVAGAexample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAGAexample_8C.html,1,['optimiz'],['optimized']
Performance,"122; TGraph2D::GetXmaxEvirtual Double_t GetXmaxE() constDefinition TGraph2D.h:141; TGraph2D::Setvirtual void Set(Int_t n)Set number of points in the 2D graph.Definition TGraph2D.cxx:1528; TGraph2D::SetMinimumvoid SetMinimum(Double_t minimum=-1111)Set minimum.Definition TGraph2D.cxx:1630; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph2D.h:130; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::SetHistogramvirtual void SetHistogram(TH2 *h, Option_t *option="""")Sets the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::GetEXlowvirtual Double_t * GetEXlow() constDefinition TGraph2D.h:129; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated.Definition TGraph2D.cxx:642; TGraph2D::GetYmaxDouble_t GetYmax() constReturns the Y maximum.Definition TGraph2D.cxx:1175; TGraph2D::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point px,py to a graph.Definition TGraph2D.cxx:730; TGraph2D::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default when an 2D graph is created, it is added to the list of 2D graph objects in the current di...Definition TGraph2D.cxx:1544; TGraph2D::fDirectoryTDirectory * fDirectory!Pointer to directory holding this 2D graphDefinition TGraph2D.h:60; TGraph2D::Clearvoid Clear(Option_t *option="""") overrideFree all memory allocated by this object.Definition TGraph2D.cxx:681; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::GetEXvirtual Double_t * GetEX() constDefinition TGraph2D.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8h_source.html:17698,Perform,Performs,17698,doc/master/TGraph2D_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html,1,['Perform'],['Performs']
Performance,"13/// serv->CreateEngine(""fastcgi:9000"");; 414///; 415/// One could apply additional parameters, using URL syntax:; 416///; 417/// serv->CreateEngine(""http:8080?thrds=10"");; 418 ; 419Bool_t THttpServer::CreateEngine(const char *engine); 420{; 421 if (!engine); 422 return kFALSE;; 423 ; 424 const char *arg = strchr(engine, ':');; 425 if (!arg); 426 return kFALSE;; 427 ; 428 TString clname, sarg;; 429 if (arg != engine); 430 clname.Append(engine, arg - engine);; 431 arg++; // skip first :; 432 ; 433 THttpEngine *eng = nullptr;; 434 ; 435 if ((clname.Length() == 0) || (clname == ""http"") || (clname == ""civetweb"")) {; 436 eng = new TCivetweb(kFALSE);; 437#ifndef R__WIN32; 438 } else if (clname == ""socket"") {; 439 eng = new TCivetweb(kFALSE);; 440 sarg = ""x""; // civetweb require x before socket name; 441 sarg.Append(arg);; 442 arg = sarg.Data();; 443#endif; 444 } else if (clname == ""https"") {; 445 eng = new TCivetweb(kTRUE);; 446 } else if (clname == ""fastcgi"") {; 447 eng = new TFastCgi();; 448 }; 449 ; 450 if (!eng) {; 451 // ensure that required engine class exists before we try to create it; 452 TClass *engine_class = gROOT->LoadClass(clname.Data());; 453 if (!engine_class); 454 return kFALSE;; 455 ; 456 eng = (THttpEngine *)engine_class->New();; 457 if (!eng); 458 return kFALSE;; 459 }; 460 ; 461 eng->SetServer(this);; 462 ; 463 if (!eng->Create(arg)) {; 464 delete eng;; 465 return kFALSE;; 466 }; 467 ; 468 fEngines.Add(eng);; 469 ; 470 return kTRUE;; 471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Create timer which will invoke ProcessRequests() function periodically; 475///; 476/// Timer is required to perform all actions in main ROOT thread; 477/// Method arguments are the same as for TTimer constructor; 478/// By default, sync timer with 100 ms period is created; 479///; 480/// It is recommended to always use sync timer mode and only change period to; 481/// adjust server reaction time. Use of async timer requ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:14802,Load,LoadClass,14802,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['Load'],['LoadClass']
Performance,"1355 }; 1356 }; 1357 }; 1358 ; 1359 // Calculate the entry number relative to the found tree.; 1360 Long64_t treeReadEntry = entry - fTreeOffset[treenum];; 1361 fReadEntry = entry;; 1362 ; 1363 // If entry belongs to the current tree return entry.; 1364 if (fTree && treenum == fTreeNumber) {; 1365 // First set the entry the tree on its owns friends; 1366 // (the friends of the chain will be updated in the; 1367 // next loop).; 1368 fTree->LoadTree(treeReadEntry);; 1369 ; 1370 if (fFriends) {; 1371 // The current tree has not changed but some of its friends might.; 1372 //; 1373 TIter next(fFriends);; 1374 TFriendLock lock(this, kLoadTree);; 1375 TFriendElement* fe = nullptr;; 1376 while ((fe = (TFriendElement*) next())) {; 1377 TTree* at = fe->GetTree();; 1378 // If the tree is a; 1379 // direct friend of the chain, it should be scanned; 1380 // used the chain entry number and NOT the tree entry; 1381 // number (treeReadEntry) hence we do:; 1382 at->LoadTreeFriend(entry, this);; 1383 }; 1384 bool needUpdate = false;; 1385 if (fTree->GetListOfFriends()) {; 1386 for(auto fetree : ROOT::Detail::TRangeStaticCast<TFriendElement>(*fTree->GetListOfFriends())) {; 1387 if (fetree->IsUpdated()) {; 1388 needUpdate = true;; 1389 fetree->ResetUpdated();; 1390 }; 1391 }; 1392 }; 1393 if (needUpdate) {; 1394 // Update the branch/leaf addresses and; 1395 // the list of leaves in all TTreeFormula of the TTreePlayer (if any).; 1396 ; 1397 // Set the branch statuses for the newly opened file.; 1398 TChainElement *frelement;; 1399 TIter fnext(fStatus);; 1400 while ((frelement = (TChainElement*) fnext())) {; 1401 Int_t status = frelement->GetStatus();; 1402 fTree->SetBranchStatus(frelement->GetName(), status);; 1403 }; 1404 ; 1405 // Set the branch addresses for the newly opened file.; 1406 fnext.Reset();; 1407 while ((frelement = (TChainElement*) fnext())) {; 1408 void* addr = frelement->GetBaddress();; 1409 if (addr) {; 1410 TBranch* br = fTree->GetBranch(frelement->GetName());; 1411 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:50613,Load,LoadTreeFriend,50613,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTreeFriend']
Performance,"136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:6105,load,load,6105,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['load'],['load']
Performance,"137 c.ReplaceAll(""::"", ""@@"");; 7138 // convert ""-"" to "" "", since class names may have; 7139 // blanks and TEnv considers a blank a terminator; 7140 c.ReplaceAll("" "", ""-"");; 7141 // Use TEnv::Lookup here as the rootmap file must start with Library.; 7142 // and do not support using any stars (so we do not need to waste time; 7143 // with the search made by TEnv::GetValue).; 7144 TEnvRec* libs_record = nullptr;; 7145 libs_record = fMapfile->Lookup(c);; 7146 if (libs_record) {; 7147 const char* libs = libs_record->GetValue();; 7148 return (*libs) ? libs : nullptr;; 7149 }; 7150 }; 7151 }; 7152 return nullptr;; 7153}; 7154 ; 7155/// This interface returns a list of dependent libraries in the form:; 7156/// lib libA.so libB.so libC.so. The first library is the library we are; 7157/// searching dependencies for.; 7158/// Note: In order to speed up the search, we display the dependencies of the; 7159/// libraries which are not yet loaded. For instance, if libB.so was already; 7160/// loaded the list would contain: lib libA.so libC.so.; 7161static std::string GetSharedLibImmediateDepsSlow(std::string lib,; 7162 cling::Interpreter *interp,; 7163 bool skipLoadedLibs = true); 7164{; 7165 TString LibFullPath(lib);; 7166 if (!llvm::sys::path::is_absolute(lib)) {; 7167 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 7168 Error(""TCling__GetSharedLibImmediateDepsSlow"", ""Cannot find library '%s'"", lib.c_str());; 7169 return """";; 7170 }; 7171 } else {; 7172 assert(llvm::sys::fs::exists(lib) && ""Must exist!"");; 7173 lib = llvm::sys::path::filename(lib).str();; 7174 }; 7175 ; 7176 auto ObjF = llvm::object::ObjectFile::createObjectFile(LibFullPath.Data());; 7177 if (!ObjF) {; 7178 Warning(""TCling__GetSharedLibImmediateDepsSlow"", ""Failed to read object file %s"", lib.c_str());; 7179 return """";; 7180 }; 7181 ; 7182 llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();; 7183 ; 7184 std::set<string> DedupSet;; 7185 std::string Result = lib + ' ';; 7186 for (const a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:279958,load,loaded,279958,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"14 ""ROOT_Foundation_Stage1_NoRTTI"",; 1215 ""Core"",; 1216 ""Rint"",; 1217 ""RIO""};; 1218 ; 1219 LoadModules(CoreModules, clingInterp);; 1220 ; 1221 // Take this branch only from ROOT because we don't need to preload modules in rootcling; 1222 if (!IsFromRootCling()) {; 1223 std::vector<std::string> CommonModules = {""MathCore""};; 1224 LoadModules(CommonModules, clingInterp);; 1225 ; 1226 // These modules should not be preloaded but they fix issues.; 1227 // FIXME: Hist is not a core module but is very entangled to MathCore and; 1228 // causes issues.; 1229 std::vector<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:44718,Load,LoadModules,44718,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,4,"['Load', 'load']","['LoadModules', 'loadGlobalIndex', 'loadGlobalModuleIndex', 'loads']"
Performance,"14 ; 1715 } else if (extended) {; 1716 ; 1717 // Extended mode, set contents to Poisson(pdf*nEvents); 1718 double w = RooRandom::randomGenerator()->Poisson(hist->weight()*nEvents) ;; 1719 hist->set(w,sqrt(w)) ;; 1720 ; 1721 } else {; 1722 ; 1723 // Regular mode, fill array of weights with Poisson(pdf*nEvents), but to not fill; 1724 // histogram yet.; 1725 if (hist->weight()>histMax) {; 1726 histMax = hist->weight() ;; 1727 }; 1728 histOut[i] = RooRandom::randomGenerator()->Poisson(hist->weight()*nEvents) ;; 1729 histOutSum += histOut[i] ;; 1730 }; 1731 }; 1732 ; 1733 ; 1734 if (!expectedData && !extended) {; 1735 ; 1736 // Second pass for regular mode - Trim/Extend dataset to exact number of entries; 1737 ; 1738 // Calculate difference between what is generated so far and what is requested; 1739 Int_t nEvtExtra = std::abs(Int_t(nEvents)-histOutSum) ;; 1740 Int_t wgt = (histOutSum>nEvents) ? -1 : 1 ;; 1741 ; 1742 // Perform simple binned accept/reject procedure to get to exact event count; 1743 std::size_t counter = 0;; 1744 bool havePrintedInfo = false;; 1745 while(nEvtExtra>0) {; 1746 ; 1747 Int_t ibinRand = RooRandom::randomGenerator()->Integer(hist->numEntries()) ;; 1748 hist->get(ibinRand) ;; 1749 double ranY = RooRandom::randomGenerator()->Uniform(histMax) ;; 1750 ; 1751 if (ranY<hist->weight()) {; 1752 if (wgt==1) {; 1753 histOut[ibinRand]++ ;; 1754 } else {; 1755 // If weight is negative, prior bin content must be at least 1; 1756 if (histOut[ibinRand]>0) {; 1757 histOut[ibinRand]-- ;; 1758 } else {; 1759 continue ;; 1760 }; 1761 }; 1762 nEvtExtra-- ;; 1763 }; 1764 ; 1765 if ((counter++ > 10*nEvents || nEvents > 1.E7) && !havePrintedInfo) {; 1766 havePrintedInfo = true;; 1767 coutP(Generation) << ""RooAbsPdf::generateBinned("" << GetName() << "") Performing costly accept/reject sampling. If this takes too long, use ""; 1768 << ""extended mode to speed up the process."" << std::endl;; 1769 }; 1770 }; 1771 ; 1772 // Transfer working array to histogram; 1773 for (int ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:84326,Perform,Perform,84326,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['Perform'],['Perform']
Performance,"14 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:141488,load,load,141488,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special cases for normalized gaussian or landau distributions; *-* =============================================================; *-* the expression ""gaus"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2); *-* to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; *-* the expression ""gausn"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); *-* WARNING: gaus and gausn are mutually exclusive in the same expression.; -; *-* In the same way the expression ""landau"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kFALSE); *-* to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; *-* the expression ""landaun"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kTRUE); *-* WARNING: landau and landaun are mutually exclusive in the same expression.; -; *-* boolean optimization (kBoolOptmize) :; *-* =====================================; -; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFormula.html:18409,optimiz,optimization,18409,root/html528/TFormula.html,https://root.cern,https://root.cern/root/html528/TFormula.html,3,['optimiz'],['optimization']
Performance,"1456 oldcl->fMethod = nullptr;; 1457 ; 1458 }; 1459 ; 1460 SetBit(kLoading);; 1461 // Advertise ourself as the loading class for this class name; 1462 TClass::AddClass(this);; 1463 ; 1464 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1465 ; 1466 if (!gInterpreter); 1467 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1468 ; 1469 if (givenInfo) {; 1470 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1471 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1472 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1473 ; 1474 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1475 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1476 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1477 MakeZombie();; 1478 fState = kNoInfo;; 1479 TClass::RemoveClass(this);; 1480 return;; 1481 }; 1482 }; 1483 ; 1484 if (!invalid) {; 1485 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1486 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:57188,Load,LoadClassInfo,57188,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClassInfo', 'loaded']"
Performance,"146 of file TGLViewer.h. ◆ fCameraOverlay. TGLCameraOverlay* TGLViewer::fCameraOverlay. protected . reference marker on? ; Definition at line 151 of file TGLViewer.h. ◆ fClipSet. TGLClipSet* TGLViewer::fClipSet. protected . Definition at line 109 of file TGLViewer.h. ◆ fContextMenu. TContextMenu* TGLViewer::fContextMenu. protected . external pad - remove replace with signal ; Definition at line 81 of file TGLViewer.h. ◆ fCurrentCamera. TGLCamera* TGLViewer::fCurrentCamera. protected . Definition at line 96 of file TGLViewer.h. ◆ fCurrentOvlElm. TGLOverlayElement* TGLViewer::fCurrentOvlElm. protected . Definition at line 116 of file TGLViewer.h. ◆ fCurrentSelRec. TGLSelectRecord TGLViewer::fCurrentSelRec. protected . Definition at line 111 of file TGLViewer.h. ◆ fDarkColorSet. TGLColorSet TGLViewer::fDarkColorSet. protected . viewport - drawn area ; Definition at line 140 of file TGLViewer.h. ◆ fDebugMode. Bool_t TGLViewer::fDebugMode. protected . cache logicals during scene rebuilds ; Definition at line 156 of file TGLViewer.h. ◆ fDragAction. EDragAction TGLViewer::fDragAction. protected . Definition at line 132 of file TGLViewer.h. ◆ fDrawCameraCenter. Bool_t TGLViewer::fDrawCameraCenter. protected . reference position ; Definition at line 150 of file TGLViewer.h. ◆ fEventHandler. TGEventHandler* TGLViewer::fEventHandler. protected . select record from last overlay select ; Definition at line 119 of file TGLViewer.h. ◆ fFader. Float_t TGLViewer::fFader. protected . default file-name for SavePicture() ; Definition at line 159 of file TGLViewer.h. ◆ fgAxisLabelScale. Float_t TGLViewer::fgAxisLabelScale = 1. staticprotected . name says it all ; Definition at line 163 of file TGLViewer.h. ◆ fgDefaultColorSet. TGLColorSet TGLViewer::fgDefaultColorSet. staticprotected . fade the view (0 - no fade/default, 1 - full fade/no rendering done) ; Definition at line 161 of file TGLViewer.h. ◆ fGedEditor. TGedEditor* TGLViewer::fGedEditor. protected . event handler ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:73398,cache,cache,73398,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['cache'],['cache']
Performance,"147 of file TEveCaloData.h. ◆ vCellId_t. typedef std::vector<CellId_t> TEveCaloData::vCellId_t. Definition at line 146 of file TEveCaloData.h. ◆ vSliceInfo_i. typedef std::vector<SliceInfo_t>::iterator TEveCaloData::vSliceInfo_i. Definition at line 53 of file TEveCaloData.h. ◆ vSliceInfo_t. typedef std::vector<SliceInfo_t> TEveCaloData::vSliceInfo_t. Definition at line 52 of file TEveCaloData.h. Constructor & Destructor Documentation. ◆ TEveCaloData() [1/2]. TEveCaloData::TEveCaloData ; (; const TEveCaloData & ; ). private . ◆ TEveCaloData() [2/2]. TEveCaloData::TEveCaloData ; (; const char * ; n = ""TEveCalData"", . const char * ; t = """" . ). Definition at line 113 of file TEveCaloData.cxx. ◆ ~TEveCaloData(). TEveCaloData::~TEveCaloData ; (; ). inlineoverride . Definition at line 175 of file TEveCaloData.h. Member Function Documentation. ◆ CellSelectionChanged(). void TEveCaloData::CellSelectionChanged ; (; ). virtual . Tell users (TEveCaloViz instances using this data) that cell selection has changed and they should update selection cache if necessary. ; This is done by calling TEveCaloViz::CellSelectionChanged(). ; Definition at line 398 of file TEveCaloData.cxx. ◆ Class(). static TClass * TEveCaloData::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveCaloData::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveCaloData::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 233 of file TEveCaloData.h. ◆ DataChanged(). void TEveCaloData::DataChanged ; (; ). virtual . Tell users (TEveCaloViz instances using this data) that data has changed and they should update the limits/scales etc. ; This is done by calling TEveCaloViz::DataChanged(). ; Reimplemented in TEveCaloDataVec, and TEveCaloDataHist.; Definition at line 382 of file TEveCaloData.cxx. ◆ DeclFileName(). static const char * TEveCaloData::DeclFileName ; (; ). inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:34941,cache,cache,34941,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,1,['cache'],['cache']
Performance,"149; , kDefinedVariable = 150; , kDefinedString = 151; , kPlusD = 152; , ;   kPlusDD = 153; , kMultD = 154; , kMultDD = 155; , kBoolOptimizeOr = 156; , ;   kBoolOptimizeAnd = 157; , kBoolSet = 158; , kFDM = 159; , kFD0 = 160; , ;   kFD1 = 161; , kFD2 = 162; , kFD3 = 163. };  ; typedef Double_t(TObject::* TFuncG) (const Double_t *, const Double_t *) const;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TTreeFormula (const char *name, const char *formula, TTree *tree, const std::vector< std::string > &aliases);  Constructor used during the expansion of an alias. ;  ; bool BranchHasMethod (TLeaf *leaf, TBranch *branch, const char *method, const char *params, Long64_t readentry) const;  Return the leaf (if any) of the tree with contains an object of a class having a method which has the name provided in the argument. ;  ; void Convert (UInt_t fromVersion) override;  ; Int_t DefineAlternate (const char *expression);  This method check for treat the case where expression contains $Atl and load up both fAliases and fExpr. ;  ; void DefineDimensions (Int_t code, Int_t size, TFormLeafInfoMultiVarDim *info, Int_t &virt_dim);  This method is used internally to decode the dimensions of the variables. ;  ; virtual TClass * EvalClass (Int_t oper) const;  Evaluate the class of the operation oper. ;  ; Int_t FindLeafForExpression (const char *expression, TLeaf *&leaf, TString &leftover, bool &final, UInt_t &paran_level, TObjArray &castqueue, std::vector< std::string > &aliasUsed, bool &useLeafCollectionObject, const char *fullExpression);  Look for the leaf corresponding to the start of expression. ;  ; TLeaf * GetLeafWithDatamember (const char *topchoice, const char *nextchice, Long64_t readentry) const;  Return the leaf (if any) which contains an object containing a data member which has the name provided in the arguments. ;  ; Int_t GetRealInstance (Int_t instance, Int_t codeindex);  Now let calculate what ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:21871,load,load,21871,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['load'],['load']
Performance,"1523 oldcl->fMethod = nullptr;; 1524 ; 1525 }; 1526 ; 1527 SetBit(kLoading);; 1528 // Advertise ourself as the loading class for this class name; 1529 TClass::AddClass(this);; 1530 ; 1531 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1532 ; 1533 if (!gInterpreter); 1534 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1535 ; 1536 if (givenInfo) {; 1537 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1538 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1539 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1540 ; 1541 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1542 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1543 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1544 MakeZombie();; 1545 fState = kNoInfo;; 1546 TClass::RemoveClass(this);; 1547 return;; 1548 }; 1549 }; 1550 ; 1551 if (!invalid) {; 1552 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1553 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1554 if (fState <= kEmulated); 1555 fState = kInterpreted;; 1556 }; 1557 }; 1558 ; 1559 // We need to check if the class it is not fwd declared for the cases where we; 1560 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1561 // fClassInfo will always be nullptr.; 1562 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1563 ; 1564 if (fState == kHasTClassInit) {; 1565 // If the TClass is being generated from a ROOT dictionary,; 1566 // even though we do not seem to have a CINT dictionary for; 1567 // the class, we will will try to load it anyway UNLESS; 1568 // the class is an STL container (or string).; 1569 // This is because we do not expect the CINT dictionary; 1570 // to be present for all STL classes (and we can handle; 1571 // the lack of CINT dictionary in that cases).; 1572 // However, the cling the dictionary no longer carries; 1573 // an instantiation with it, unless we re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:59939,Load,LoadClassInfo,59939,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClassInfo', 'loaded']"
Performance,"1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->GetNumber() == color) return col;; 1547 ; 1548 return nullptr;; 1549}; 1550 ; 1551////////////////////////////////////////////////////////////////////////////////; 1552/// Return a default canvas.; 1553 ; 1554TCanvas *TROOT::MakeDefCanvas() const; 1555{; 1556 return (TCanvas*)gROOT->ProcessLine(""TCanvas::MakeDefCanvas();"");; 1557}; 1558 ; 1559////////////////////////////////////////////////////////////////////////////////; 1560/// Return pointer to type with name.; 1561 ; 1562TDataType *TROOT::GetType(const char *name, Bool_t /* load */) const; 1563{; 1564 return (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 1565}; 1566 ; 1567////////////////////////////////////////////////////////////////////////////////; 1568/// Return pointer to file with name.; 1569 ; 1570TFile *TROOT::GetFile(const char *name) const; 1571{; 1572 R__LOCKGUARD(gROOTMutex);; 1573 return (TFile*)GetListOfFiles()->FindObject(name);; 1574}; 1575 ; 1576////////////////////////////////////////////////////////////////////////////////; 1577/// Return pointer to style with name; 1578 ; 1579TStyle *TROOT::GetStyle(const char *name) const; 1580{; 1581 return (TStyle*)GetListOfStyles()->FindObject(name);; 1582}; 1583 ; 1584////////////////////////////////////////////////////////////////////////////////; 1585/// Return pointer to function with name.; 1586 ; 1587TObject *TROOT::GetFunction(const char *name) const; 1588{; 1589 if (!name || !*name); 1590 return nullptr;; 1591 ; 1592 static std::atomic<bool> isInited = false;; 1593 ; 1594 // Capture the state before calling FindObject as it could change; 1595 // between the end ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:60176,load,load,60176,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"1556736; // months (average # days); 1231 rangeOffset = (Double_t) ((Long_t)(timeoffset)%rangeBase);; 1232 if (range>31536000) {; 1233 tp0 = gmtime(&timetp);; 1234 tp0->tm_mon = 0;; 1235 tp0->tm_mday = 1;; 1236 tp0->tm_hour = 0;; 1237 tp0->tm_min = 0;; 1238 tp0->tm_sec = 0;; 1239 tp0->tm_isdst = 1; // daylight saving time is on.; 1240 rangeBase = (timetp-mktime(tp0)); // years; 1241 rangeOffset = (Double_t) (rangeBase);; 1242 }; 1243 wmax += rangeOffset;; 1244 wmin += rangeOffset;; 1245 }; 1246 ; 1247// Determine number of divisions 1, 2 and 3 and the maximum digits for this axis; 1248 n1a = (ndiv%100);; 1249 n2a = (ndiv%10000 - n1a)/100;; 1250 n3a = (ndiv%1000000 - n2a -n1a)/10000;; 1251 nn3 = TMath::Max(n3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:44941,Optimiz,Optimize,44941,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['Optimiz'],['Optimize']
Performance,"158 ; 159TVirtualFitter *TVirtualFitter::Fitter(TObject *obj, Int_t maxpar); 160{; 161 if (GetGlobalFitter() && maxpar > GetGlobalMaxPar()) {; 162 delete GetGlobalFitter();; 163 GetGlobalFitter() = nullptr;; 164 }; 165 ; 166 if (!GetGlobalFitter()) {; 167 TPluginHandler *h;; 168 if (GetGlobalDefault().Length() == 0) GetGlobalDefault() = gEnv->GetValue(""Root.Fitter"",""Minuit"");; 169 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualFitter"",GetGlobalDefault()))) {; 170 if (h->LoadPlugin() == -1); 171 return nullptr;; 172 GetGlobalFitter() = (TVirtualFitter*) h->ExecPlugin(1, maxpar);; 173 GetGlobalMaxPar() = maxpar;; 174 }; 175 }; 176 ; 177 if (GetGlobalFitter()) GetGlobalFitter()->SetObjectFit(obj);; 178 return GetGlobalFitter();; 179}; 180 ; 181////////////////////////////////////////////////////////////////////////////////; 182///return confidence intervals in array x of dimension ndim; 183///implemented in TFitter and TLinearFitter; 184 ; 185void TVirtualFitter::GetConfidenceIntervals(Int_t /*n*/, Int_t /*ndim*/, const Double_t * /*x*/, Double_t * /*ci*/, Double_t /*cl*/); 186{; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190///return confidence intervals in TObject obj; 191///implemented in TFitter and TLinearFitter; 192 ; 193void TVirtualFitter::GetConfidenceIntervals(TObject * /*obj*/, Double_t /*cl*/); 194{; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// static: return the name of the default fitter; 199 ; 200const char *TVirtualFitter::GetDefaultFitter(); 201{; 202 //return GetGlobalDefault().Data();; 203 return ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str();; 204}; 205 ; 206////////////////////////////////////////////////////////////////////////////////; 207/// static: return the current Fitter; 208 ; 209TVirtualFitter *TVirtualFitter::GetFitter(); 210{; 211 return GetGlobalFitter();; 212}; 213 ; 214////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:4935,Load,LoadPlugin,4935,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"159 of file TTreeCacheUnzip.cxx. ◆ TTreeCacheUnzip() [3/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:27779,cache,cache,27779,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"159 of file TTreeCacheUnzip.cxx. ◆ TTreeCacheUnzip() [3/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 614 of file TTreeCacheUnzip.cxx. ◆ DeclFileName().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:27783,cache,cache,27783,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"1715///; 1716/// typical length of text line:; 1717/// ""|--------------------------------------------------------------|""; 1718 ; 1719void TMVA::MethodCuts::GetHelpMessage() const; 1720{; 1721 TString bold = gConfig().WriteOptionsReference() ? ""<b>"" : """";; 1722 TString resbold = gConfig().WriteOptionsReference() ? ""</b>"" : """";; 1723 TString brk = gConfig().WriteOptionsReference() ? ""<br>"" : """";; 1724 ; 1725 Log() << Endl;; 1726 Log() << gTools().Color(""bold"") << ""--- Short description:"" << gTools().Color(""reset"") << Endl;; 1727 Log() << Endl;; 1728 Log() << ""The optimisation of rectangular cuts performed by TMVA maximises "" << Endl;; 1729 Log() << ""the background rejection at given signal efficiency, and scans "" << Endl;; 1730 Log() << ""over the full range of the latter quantity. Three optimisation"" << Endl;; 1731 Log() << ""methods are optional: Monte Carlo sampling (MC), a Genetics"" << Endl;; 1732 Log() << ""Algorithm (GA), and Simulated Annealing (SA). GA and SA are"" << Endl;; 1733 Log() << ""expected to perform best."" << Endl;; 1734 Log() << Endl;; 1735 Log() << ""The difficulty to find the optimal cuts strongly increases with"" << Endl;; 1736 Log() << ""the dimensionality (number of input variables) of the problem."" << Endl;; 1737 Log() << ""This behavior is due to the non-uniqueness of the solution space.""<< Endl;; 1738 Log() << Endl;; 1739 Log() << gTools().Color(""bold"") << ""--- Performance optimisation:"" << gTools().Color(""reset"") << Endl;; 1740 Log() << Endl;; 1741 Log() << ""If the dimensionality exceeds, say, 4 input variables, it is "" << Endl;; 1742 Log() << ""advisable to scrutinize the separation power of the variables,"" << Endl;; 1743 Log() << ""and to remove the weakest ones. If some among the input variables"" << Endl;; 1744 Log() << ""can be described by a single cut (e.g., because signal tends to be"" << Endl;; 1745 Log() << ""larger than background), this can be indicated to MethodCuts via"" << Endl;; 1746 Log() << ""the \""Fsmart\"" options (see option string). C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:67649,perform,perform,67649,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['perform'],['perform']
Performance,"1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:67644,load,load,67644,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['load']
Performance,"177 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3178 // lead to a different value.; 3179 {; 3180 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3186 if (e); 3187 return nullptr;; 3188 // Maybe this was a typedef: let's try to see if this is the case; 3189 if (!loadedcl && !ispair && !ispairbase) {; 3190 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3191 // We have a typedef: we get the name of the underlying type; 3192 auto underlyingTypeName = theDataType->GetTypeName();; 3193 // We see if we can bootstrap a class with it; 3194 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3195 if (underlyingTypeDict){; 3196 loadedcl = underlyingTypeDict();; 3197 }; 3198 ; 3199 }; 3200 }; 3201 }; 3202 if (loadedcl) return loadedcl;; 3203 ; 3204 // See if the TClassGenerator can produce the TClass we need.; 3205 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3206 if (loadedcl) return loadedcl;; 3207 ; 3208 // We have not been able to find a loaded TClass, return the Emulated; 3209 // TClass if we have one.; 3210 if (cl) return cl;; 3211 ; 3212 if (ispair) {; 3213 if (hint_pair_offset && hint_pair_size) {; 3214 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3215 // Fall-through to allow TClass to be created when known by the interpreter; 3216 // This is used in the case where TStreamerInfo can not handle them.; 3217 if (pairinfo); 3218 return pairinfo->GetClass();; 3219 } else {; 3220 // Check if we have an STL container that might provide it.; 3221 static const size_t slen = strlen(""pair"");; 3222 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 322",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:121543,load,loadedcl,121543,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,['load'],['loadedcl']
Performance,"17; TTree::kPrint@ kPrintDefinition TTree.h:222; TTree::kGetFriend@ kGetFriendDefinition TTree.h:218; TTree::kGetBranch@ kGetBranchDefinition TTree.h:215; TTree::kSetBranchStatus@ kSetBranchStatusDefinition TTree.h:224; TTree::kLoadTree@ kLoadTreeDefinition TTree.h:221; TTree::kGetEntry@ kGetEntryDefinition TTree.h:216; TTree::kGetLeaf@ kGetLeafDefinition TTree.h:220; TTree::kRemoveFriend@ kRemoveFriendDefinition TTree.h:223; TTree::kGetFriendAlias@ kGetFriendAliasDefinition TTree.h:219; TTree::kGetAlias@ kGetAliasDefinition TTree.h:214; TTree::GetV4virtual Double_t * GetV4()Definition TTree.h:582; TTree::BranchTBranch * Branch(const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:395; TTree::GetVar3TTreeFormula * GetVar3()Definition TTree.h:570; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:83146,Optimiz,OptimizeBasketsvirtual,83146,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,2,['Optimiz'],"['OptimizeBaskets', 'OptimizeBasketsvirtual']"
Performance,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:12811,cache,cache,12811,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['cache'],['cache']
Performance,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:5777,queue,queue,5777,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,6,['queue'],['queue']
Performance,"1866 return false;; 1867 ; 1868 dnode.vis = selected ? 99 : 0;; 1869 vol->SetVisibility(selected);; 1870 if (!dnode.chlds.empty()) {; 1871 if (selected); 1872 dnode.vis = 1; // visibility disabled when any child; 1873 vol->SetVisDaughters(selected);; 1874 }; 1875 ; 1876 int id = 0;; 1877 for (auto &desc : fDesc); 1878 if (GetVolume(id++) == vol); 1879 desc.vis = dnode.vis;; 1880 ; 1881 auto stack = MakeStackByIds(giter.CurrentIds());; 1882 ; 1883 // any change in logical node visibility erase individual physical node settings; 1884 for (auto iter = fVisibility.begin(); iter != fVisibility.end(); iter++); 1885 if (compare_stacks(iter->stack, stack) == 0) {; 1886 fVisibility.erase(iter);; 1887 break;; 1888 }; 1889 ; 1890 ClearDrawData(); // after change raw data is no longer valid; 1891 ; 1892 return true;; 1893}; 1894 ; 1895/////////////////////////////////////////////////////////////////////////////////; 1896/// Change visibility for specified element; 1897/// Returns true if changes was performed; 1898 ; 1899std::unique_ptr<RGeomNodeInfo> RGeomDescription::MakeNodeInfo(const std::vector<int> &stack); 1900{; 1901 auto path = MakePathByStack(stack);; 1902 ; 1903 TLockGuard lock(fMutex);; 1904 ; 1905 std::unique_ptr<RGeomNodeInfo> res;; 1906 ; 1907 RGeomBrowserIter iter(*this);; 1908 ; 1909 if (iter.Navigate(path)) {; 1910 ; 1911 auto node = fNodes[iter.GetNodeId()];; 1912 ; 1913 auto &desc = fDesc[iter.GetNodeId()];; 1914 ; 1915 res = std::make_unique<RGeomNodeInfo>();; 1916 ; 1917 res->path = path;; 1918 res->node_name = node ? node->GetName() : ""node_name"";; 1919 res->node_type = node ? node->ClassName() : ""no class"";; 1920 ; 1921 auto vol = GetVolume(iter.GetNodeId());; 1922 ; 1923 TGeoShape *shape = vol ? vol->GetShape() : nullptr;; 1924 ; 1925 if (shape) {; 1926 res->shape_name = shape->GetName();; 1927 res->shape_type = shape->ClassName();; 1928 }; 1929 ; 1930 if (shape && desc.CanDisplay()) {; 1931 ; 1932 auto &shape_descr = MakeShapeDescr(shape);; 1933 ; 1934 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:57621,perform,performed,57621,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['perform'],['performed']
Performance,"1988 // basket, just iterate backwards until the correct basket is reached. This should; 1989 // be fast as long as the number of baskets per cluster is small; 1990 Int_t basketToUnload = fReadBasket;; 1991 while (fBasketEntry[basketToUnload] != entryToUnload) {; 1992 basketToUnload--;; 1993 if (basketToUnload < 0) {; 1994 return CreateOrReuseBasket();; 1995 }; 1996 }; 1997 ; 1998 // Retrieves the basket that is going to be unloaded from memory. If the basket did not; 1999 // exist, create a new one; 2000 basket = (TBasket *)fBaskets.UncheckedAt(basketToUnload);; 2001 if (basket) {; 2002 fBaskets.AddAt(nullptr, basketToUnload);; 2003 --fNBaskets;; 2004 } else {; 2005 basket = CreateOrReuseBasket();; 2006 }; 2007 ++basketToUnload;; 2008 ; 2009 // Clear the rest of the baskets. While it would be ideal to reuse these baskets; 2010 // for other baskets in the new cluster. It would require the function to go; 2011 // beyond its current scope. In the ideal case when each cluster only has 1 basket; 2012 // this will perform well; 2013 iter.Next();; 2014 while (fBasketEntry[basketToUnload] < iter.GetStartEntry()) {; 2015 TBasket *oldbasket = (TBasket *)fBaskets.UncheckedAt(basketToUnload);; 2016 if (oldbasket) {; 2017 oldbasket->DropBuffers();; 2018 delete oldbasket;; 2019 fBaskets.AddAt(nullptr, basketToUnload);; 2020 --fNBaskets;; 2021 }; 2022 ++basketToUnload;; 2023 }; 2024 fBaskets.SetLast(-1);; 2025 return basket;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Return the 'full' name of the branch. In particular prefix the mother's name; 2030/// when it does not end in a trailing dot and thus is not part of the branch name; 2031TString TBranch::GetFullName() const; 2032{; 2033 TBranch* mother = GetMother();; 2034 if (!mother || mother==this) {; 2035 return fName;; 2036 }; 2037 ; 2038 const auto motherName = mother->GetName();; 2039 const auto len = strlen(motherName);; 2040 if (len > 0 && (motherName[len-1] =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:73375,perform,perform,73375,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['perform'],['perform']
Performance,"1; ROOT::Experimental::RNTupleReader::RetrieveFieldIdDescriptorId_t RetrieveFieldId(std::string_view fieldName) constDefinition RNTupleReader.cxx:238; ROOT::Experimental::RNTupleReader::Showvoid Show(NTupleSize_t index, std::ostream &output=std::cout)Shows the values of the i-th entry/row, starting with 0 for the first entry.Definition RNTupleReader.cxx:208; ROOT::Experimental::RNTupleReader::GetDirectAccessViewRNTupleDirectAccessView< T > GetDirectAccessView(DescriptorId_t fieldId)Definition RNTupleReader.hxx:317; ROOT::Experimental::RNTupleReader::Clonestd::unique_ptr< RNTupleReader > Clone()Definition RNTupleReader.hxx:167; ROOT::Experimental::RNTupleReader::fMetricsDetail::RNTupleMetrics fMetricsDefinition RNTupleReader.hxx:90; ROOT::Experimental::RNTupleReader::fDisplayReaderstd::unique_ptr< RNTupleReader > fDisplayReaderWe use a dedicated on-demand reader for Show() and Scan().Definition RNTupleReader.hxx:83; ROOT::Experimental::RNTupleReader::EnableMetricsvoid EnableMetrics()Enable performance measurements (decompression time, bytes read from storage, etc....Definition RNTupleReader.hxx:364; ROOT::Experimental::RNTupleReader::GetMetricsconst Detail::RNTupleMetrics & GetMetrics() constDefinition RNTupleReader.hxx:365; ROOT::Experimental::RNTupleReader::beginRIterator begin()Definition RNTupleReader.hxx:342; ROOT::Experimental::RNTupleReader::~RNTupleReader~RNTupleReader(); ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(DescriptorId_t fieldId, std::shared_ptr< T > objPtr)Definition RNTupleReader.hxx:295; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(std::string_view fieldName)Provides access to an individual field that can contain either a scalar value or a collection,...Definition RNTupleReader.hxx:269; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(std::string_view fieldName, std::shared_ptr< T > objPtr)Definition RNTupleReader.hxx:275; ROOT::Experimental::RNTupleReader::GetDescriptorconst RNTupleDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:21367,perform,performance,21367,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['perform'],['performance']
Performance,"1;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Set socket option.; 2435 ; 2436int TSystem::SetSockOpt(int, int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 othe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:79424,load,load,79424,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['load'],['load']
Performance,"1F( 's1', 'This is the first signal', 100, -4, 4 ); s2 = TH1F( 's2', 'This is the second signal', 100, -4, 4 ); total.Sumw2() # this makes sure that the sum of squares of weights will be stored; ; # Set canvas/frame attributes.; total.SetMarkerStyle( 21 ); total.SetMarkerSize( 0.7 ); main.SetFillColor( 16 ); s1.SetFillColor( 42 ); s2.SetFillColor( 46 ); ; # Initialize random number generator.; gRandom.SetSeed(); gauss, landau = gRandom.Gaus, gRandom.Landau; ; # for speed, bind and cache the Fill member functions; histos = [ 'total', 'main', 's1', 's2' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly; kUPDATE = 500; for i in range( 10000 ):; # Generate random values.; xmain = gauss( -1, 1.5 ); xs1 = gauss( -0.5, 0.5 ); xs2 = landau( 1, 0.15 ); mainFill( xmain ); ; # Fill histograms.; s1Fill( xs1, 0.3 ); s2Fill( xs2, 0.2 ); totalFill( xmain ); totalFill( xs1, 0.3 ); totalFill( xs2, 0.2 ); ; # Update display every kUPDATE events.; if i and (i%kUPDATE) == 0 :; if i == kUPDATE :; total.Draw( 'e1p' ); main.Draw( 'same' ); s1.Draw( 'same' ); s2.Draw( 'same' ); c1.Update(); slider = TSlider( 'slider', 'test', 4.2, 0, 4.6, total.GetMaximum(), 38 ); slider.SetFillColor( 46 ); ; if slider:; slider.SetRange( 0, float(i) / 10000. ); ; c1.Modified(); c1.Update(); ; # Destroy member functions cache.; for name in histos:; exec('del %sFill' % name); del histos; ; # Done, finalized and trigger an update.; slider.SetRange( 0, 1 ); total.Draw( 'sameaxis' ) # to redraw axis hidden by the fill area; c1.Modified(); c1.Update(); ; gBenchmark.Show( 'hsum' ); TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TSliderA specialized TPad including a TSliderBox object.Definition TSlider.h:17; AuthorWim Lavrijsen ; Definition in file hsum.py. tutorialspyroothsum.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsum_8py.html:2021,cache,cache,2021,doc/master/hsum_8py.html,https://root.cern,https://root.cern/doc/master/hsum_8py.html,1,['cache'],['cache']
Performance,"1F* EvaluateImportanceRandom( DataLoader *loader,UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 186 ; 187 TH1F* GetImportance(const int nbits,std::vector<Double_t> importances,std::vector<TString> varNames);; 188 ; 189 // Helpers for public facing ROC methods; 190 ROCCurve *GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass = 0,; 191 Types::ETreeType type = Types::kTesting);; 192 ROCCurve *GetROC(TString datasetname, TString theMethodName, UInt_t iClass = 0,; 193 Types::ETreeType type = Types::kTesting);; 194 ; 195 void WriteDataInformation(DataSetInfo& fDataSetInfo);; 196 ; 197 void SetInputTreesFromEventAssignTrees();; 198 ; 199 MethodBase* BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile);; 200 ; 201 private:; 202 ; 203 // data members; 204 ; 205 TFile* fgTargetFile; ///<! ROOT output file; 206 ; 207 ; 208 std::vector<TMVA::VariableTransformBase*> fDefaultTrfs; ///<! list of transformations on default DataSet; 209 ; 210 // cd to local directory; 211 TString fOptions; ///<! option string given by construction (presently only ""V""); 212 TString fTransformations; ///<! list of transformations to test; 213 Bool_t fVerbose; ///<! verbose mode; 214 TString fVerboseLevel; ///<! verbosity level, controls granularity of logging; 215 Bool_t fCorrelations; ///<! enable to calculate correlations; 216 Bool_t fROC; ///<! enable to calculate ROC values; 217 Bool_t fSilentFile; ///<! used in constructor without file; 218 ; 219 TString fJobName; ///<! jobname, used as extension in weight file names; 220 ; 221 Types::EAnalysisType fAnalysisType; ///<! the training type; 222 Bool_t fModelPersistence;///<! option to save the trained model in xml file or using serialization; 223 ; 224 ; 225 protected:; 226 ; 227 ClassDef(Factory,0); // The factory creates all MVA methods, and performs their training and testing; 228 };; 229 ; 230} // namespace TMVA; 231 ; 232#endif; Configurable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:10172,perform,performs,10172,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['perform'],['performs']
Performance,"1ULL << ( 20 )); };  ; enum  EGeoVisibilityAtt { ;   kVisOverride = (1ULL << ( 0 )); , kVisNone = (1ULL << ( 1 )); , kVisThis = (1ULL << ( 2 )); , kVisDaughters = (1ULL << ( 3 )); , ;   kVisOneLevel = (1ULL << ( 4 )); , kVisStreamed = (1ULL << ( 5 )); , kVisTouched = (1ULL << ( 6 )); , kVisOnScreen = (1ULL << ( 7 )); , ;   kVisContainers = (1ULL << ( 12 )); , kVisOnly = (1ULL << ( 13 )); , kVisBranch = (1ULL << ( 14 )); , kVisRaytrace = (1ULL << ( 15 )). };  . Public Member Functions;  TGeoAtt ();  Default constructor. ;  ;  TGeoAtt (Option_t *vis_opt, Option_t *activity_opt="""", Option_t *optimization_opt="""");  Constructor. ;  ; virtual ~TGeoAtt ();  Destructor. ;  ; virtual TClass * IsA () const;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsVisBranch () const;  ; Bool_t IsVisContainers () const;  ; Bool_t IsVisDaughters () const;  ; Bool_t IsVisible () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; Bool_t IsVisRaytrace () const;  ; Bool_t IsVisStreamed () const;  ; Bool_t IsVisTouched () const;  ; void ResetAttBit (UInt_t f);  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAttBit (UInt_t f);  ; void SetAttBit (UInt_t f, Bool_t set);  ; void SetOptimization (Option_t *option);  Set optimization flags. ;  ; void SetVisBranch ();  Set branch type visibility. ;  ; virtual void SetVisContainers (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; void SetVisDaughters (Bool_t vis=kTRUE);  Set visibility for the daughters. ;  ; virtual void SetVisibility (Bool_t vis=kTRUE);  Set visibility for this object. ;  ; virtual void SetVisLeaves (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; virtual void SetVisOnly (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; void SetVisRaytrace (Bool_t flag=kTRUE);  ; void SetVisStreamed (Bool_t vis=kTRUE);  Mark attributes as ""streamed to file"". ;  ; void SetVisTouched (Bool_t vis=kTRUE);  Mark visualization attribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoAtt.html:2309,optimiz,optimization,2309,doc/master/classTGeoAtt.html,https://root.cern,https://root.cern/doc/master/classTGeoAtt.html,1,['optimiz'],['optimization']
Performance,"1e-4,Momentum=0.3,ConvergenceSteps=50,BatchSize=20,TestRepetitions=7,WeightDecay=0.001,Renormalize=L2,DropFractions=0.0,DropRepetitions=5\"" \n \; 1562 . LearningRate : \n \; 1563 - recommended for classification: 0.1 initially, 1e-4 later \n \; 1564 - recommended for regression: 1e-4 and less \n \; 1565 . Momentum : \n \; 1566 preserve a fraction of the momentum for the next training batch [fraction = 0.0 - 1.0] \n \; 1567 . Repetitions : \n \; 1568 train \""Repetitions\"" repetitions with the same minibatch before switching to the next one \n \; 1569 . ConvergenceSteps : \n \; 1570 Assume that convergence is reached after \""ConvergenceSteps\"" cycles where no improvement \n \; 1571 of the error on the test samples has been found. (Mind that only at each \""TestRepetitions\"" \n \; 1572 cycle the test samples are evaluated and thus the convergence is checked) \n \; 1573 . BatchSize \n \; 1574 Size of the mini-batches. \n \; 1575 . TestRepetitions \n \; 1576 Perform testing the neural net on the test samples each \""TestRepetitions\"" cycle \n \; 1577 . WeightDecay \n \; 1578 If \""Renormalize\"" is set to L1 or L2, \""WeightDecay\"" provides the renormalization factor \n \; 1579 . Renormalize \n \; 1580 NONE, L1 (|w|) or L2 (w^2) \n \; 1581 . DropConfig \n \; 1582 Drop a fraction of arbitrary nodes of each of the layers according to the values given \n \; 1583 in the DropConfig. \n \; 1584 [example: DropConfig=0.0+0.5+0.3 \n \; 1585 meaning: drop no nodes in layer 0 (input layer), half of the nodes in layer 1 and 30% of the nodes \n \; 1586 in layer 2 \n \; 1587 recommended: leave all the nodes turned on for the input layer (layer 0) \n \; 1588 turn off half of the nodes in later layers for the initial training; leave all nodes \n \; 1589 turned on (0.0) in later training stages] \n \; 1590 . DropRepetitions \n \; 1591 Each \""DropRepetitions\"" cycle the configuration of which nodes are dropped is changed \n \; 1592 [recommended : 1] \n \; 1593 . Multithreading \n \; 1594 turn ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:59296,Perform,Perform,59296,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['Perform'],['Perform']
Performance,"1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 14000 events: 0.117 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.02 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.class.C␛[0m; : Higgs_ClassificationOutput.root:/dataset/Method_Likelihood/Likelihood; Fact",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:17377,tune,tune,17377,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['tune'],['tune']
Performance,"1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 14000 events: 0.118 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.0223 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.class.C␛[0m; : Higgs_ClassificationOutput.root:/dataset/Method_Likelihood/Likelihood; Fa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:17312,tune,tune,17312,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['tune'],['tune']
Performance,"1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 2000 events: 0.0149 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0035 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.class.C␛[0m; : TMVAC.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:28721,tune,tune,28721,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['tune'],['tune']
Performance,"1std::unique_ptr< TF1 > fFunction1First function to be convolved.Definition TF1Convolution.h:21; TF1Convolution::fNofPointsInt_t fNofPointsNumber of point for FFT array.Definition TF1Convolution.h:35; TF1Convolution::SetDefaultExtraRangestatic Double_t SetDefaultExtraRange(Double_t percentage)Set the default extra range fraction used when doing a FFT convolution.Definition TF1Convolution.cxx:477; TF1Convolution::GetXminDouble_t GetXmin() constDefinition TF1Convolution.h:69; TF1Convolution::fParams2std::vector< Double_t > fParams2Definition TF1Convolution.h:26; TF1Convolution::fXminDouble_t fXminMinimal bound of the range of the convolution.Definition TF1Convolution.h:30; TF1Convolution::SetExtraRangevoid SetExtraRange(Double_t percentage)Set the fraction of extra range used when doing an FFT convolution.Definition TF1Convolution.cxx:438; TF1Convolution::Copyvoid Copy(TObject &obj) const overrideCopy this to obj.Definition TF1Convolution.cxx:504; TF1Convolution::EvalNumConvDouble_t EvalNumConv(Double_t t)Perform numerical convolution.Definition TF1Convolution.cxx:345; TF1Convolution::Updatevoid Update() overrideUpdate the two component functions of the convolution.Definition TF1Convolution.cxx:496; TF1Convolution::SetRangevoid SetRange(Double_t a, Double_t b) overrideSet the actual range used for the convolution.Definition TF1Convolution.cxx:452; TF1Convolution::fFlagFFTBool_t fFlagFFTChoose FFT or numerical convolution.Definition TF1Convolution.h:36; TF1Convolution::GetXmaxDouble_t GetXmax() constDefinition TF1Convolution.h:70; TF1Convolution::operator=TF1Convolution & operator=(const TF1Convolution &rhs)Operator =.Definition TF1Convolution.cxx:249; TF1Convolution::MakeFFTConvvoid MakeFFTConv()Perform the FFT of the two functions.Definition TF1Convolution.cxx:259; TF1Convolution::fgExtraRangeFractionstatic Double_t fgExtraRangeFraction! Additional default fraction of the range used for FFT convolutionDefinition TF1Convolution.h:38; TF1Convolution::fNofParams1Int_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:25287,Perform,Perform,25287,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['Perform'],['Perform']
Performance,"2 *f2, Option_t *option, Option_t *); 843{; 844 // internal graph2D fitting methods; 845 Foption_t fitOption;; 846 Option_t *goption = """";; 847 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 848 ; 849 // create range and minimizer options with default values; 850 ROOT::Fit::DataRange range(2);; 851 ROOT::Math::MinimizerOptions minOption;; 852 return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; 853}; 854 ; 855 ; 856////////////////////////////////////////////////////////////////////////////////; 857/// Display a GUI panel with all graph fit options.; 858///; 859/// See class TFitEditor for example; 860 ; 861void TGraph2D::FitPanel(); 862{; 863 if (!gPad); 864 gROOT->MakeDefCanvas();; 865 ; 866 if (!gPad) {; 867 Error(""FitPanel"", ""Unable to create a default canvas"");; 868 return;; 869 }; 870 ; 871 // use plugin manager to create instance of TFitEditor; 872 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 873 if (handler && handler->LoadPlugin() != -1) {; 874 if (handler->ExecPlugin(2, gPad, this) == 0); 875 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 876 } else; 877 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 878 ; 879}; 880 ; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Get x axis of the graph.; 884 ; 885TAxis *TGraph2D::GetXaxis() const; 886{; 887 TH1 *h = ((TGraph2D*)this)->GetHistogram(""empty"");; 888 if (!h) return nullptr;; 889 return h->GetXaxis();; 890}; 891 ; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Get y axis of the graph.; 895 ; 896TAxis *TGraph2D::GetYaxis() const; 897{; 898 TH1 *h = ((TGraph2D*)this)->GetHistogram(""empty"");; 899 if (!h) return nullptr;; 900 return h->GetYaxis();; 901}; 902 ; 903 ; 904////////////////////////////////////////////////////////////////////////////////; 905/// Get z axis of the graph.; 906 ; 907TAxis *TGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:28488,Load,LoadPlugin,28488,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"2 ; 123 //mark this class as being used in the current file; 124 b.TagStreamerInfo(this);; 125 ; 126 //============; 127 ; 128 //loop on all active members; 129// Int_t last;; 130// if (first < 0) {first = 0; last = ninfo;}; 131// else last = first+1;; 132 ; 133 // In order to speed up the case where the object being written is; 134 // not in a collection (i.e. arrayMode is false), we actually; 135 // duplicate the elementary types using this typeOffset.; 136 static const int kHaveLoop = 1024;; 137 const Int_t typeOffset = arrayMode ? kHaveLoop : 0;; 138 ; 139 for (Int_t i=first;i<last;i++) {; 140 ; 141 TStreamerElement *aElement = (TStreamerElement*)compinfo[i]->fElem;; 142 ; 143 if (needIncrement) b.SetStreamerElementNumber(aElement,compinfo[i]->fType);; 144 ; 145 Int_t ioffset = eoffset+compinfo[i]->fOffset;; 146 ; 147 if (R__TestUseCache<T>(aElement)) {; 148 if (aElement->TestBit(TStreamerElement::kWrite)) {; 149 if (((TBufferFile&)b).PeekDataCache()==0) {; 150 Warning(""WriteBuffer"",""Skipping %s::%s because the cache is missing."",GetName(),aElement->GetName());; 151 } else {; 152 if (gDebug > 1) {; 153 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d,""; 154 "" %s, bufpos=%d, arr=%p, eoffset=%d, Redirect=%p\n"",; 155 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 156 aElement->ClassName(),b.Length(),arr[0], eoffset,((TBufferFile&)b).PeekDataCache()->GetObjectAt(0));; 157 }; 158 WriteBufferAux(b,*((TBufferFile&)b).PeekDataCache(),compinfo,i,i+1,narr,eoffset, arrayMode);; 159 }; 160 continue;; 161 } else {; 162 if (gDebug > 1) {; 163 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d,""; 164 "" %s, bufpos=%d, arr=%p, eoffset=%d, not a write rule, skipping.\n"",; 165 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 166 aElement->ClassName(),b.Length(),arr[0], eoffset);; 167 }; 168 // The rule was a cached element for a read, rule, the real offset is in the; 169 // next element (the one for the rule itself).; 170 if (aElement->TestBit(TStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:4778,cache,cache,4778,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"2 ; 4203////////////////////////////////////////////////////////////////////////////////; 4204/// Return the StreamerElement of ""datamember"" inside our; 4205/// class or any of its base classes.; 4206///; 4207/// The offset information; 4208/// contained in the StreamerElement is related to its immediately; 4209/// containing class, so we return in 'offset' the offset inside; 4210/// our class.; 4211 ; 4212TStreamerElement* TStreamerInfo::GetStreamerElement(const char* datamember, Int_t& offset) const; 4213{; 4214 if (!fElements) {; 4215 return 0;; 4216 }; 4217 ; 4218 // Look first at the data members and base classes; 4219 // of our class.; 4220 TStreamerElement* element = (TStreamerElement*) fElements->FindObject(datamember);; 4221 if (element) {; 4222 offset = element->GetOffset();; 4223 return element;; 4224 }; 4225 ; 4226 // Not found, so now try the data members and base classes; 4227 // of the base classes of our class.; 4228 if (fClass->HasDataMemberInfo()) {; 4229 // Our class has a dictionary loaded, use it to search the base classes.; 4230 TStreamerElement* base_element = 0;; 4231 TBaseClass* base = 0;; 4232 TClass* base_cl = 0;; 4233 Int_t base_offset = 0;; 4234 Int_t local_offset = 0;; 4235 TIter nextb(fClass->GetListOfBases());; 4236 // Iterate on list of base classes.; 4237 while ((base = (TBaseClass*) nextb())) {; 4238 base_cl = TClass::GetClass(base->GetName());; 4239 base_element = (TStreamerElement*) fElements->FindObject(base->GetName());; 4240 if (!base_cl || !base_element) {; 4241 continue;; 4242 }; 4243 base_offset = base_element->GetOffset();; 4244 element = ((TStreamerInfo*)base_cl->GetStreamerInfo())->GetStreamerElement(datamember, local_offset);; 4245 if (element) {; 4246 offset = base_offset + local_offset;; 4247 return element;; 4248 }; 4249 }; 4250 } else {; 4251 // Our class's dictionary is not loaded. Search through the base class streamer elements.; 4252 TIter next(fElements);; 4253 TStreamerElement* curelem = 0;; 4254 while ((curele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:169367,load,loaded,169367,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidexpand(). Data Members; protected:. RooSetPair*_asArr! do not persist; RooHashTable*_htable! do not persist; RooNameSet_name1!; RooNameSet_name2!; Int_t_nreg; Int_t_regSize; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(Int_t regSize = 10); Construct normalization set manager with given initial size. RooNormSetCache(const RooNormSetCache& other); Copy constructor. ~RooNormSetCache(); Destructor. void clear(); Clear contents. void initialize(const RooNormSetCache& other); Initialize cache from contents of given other cache. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. void expand(); Expand registry size by doubling capacity. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _nreg>0?_asArr[_nreg-1]._set1:0 ; }. const RooArgSet* lastSet2() const; { return _nreg>0?_asArr[_nreg-1]._set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNormSetCache.html:2643,cache,cache,2643,root/html528/RooNormSetCache.html,https://root.cern,https://root.cern/root/html528/RooNormSetCache.html,2,['cache'],['cache']
Performance,"2 Log() << kERROR << Form(""No metohds have class %i defined."", iClass) << Endl;; 1043 return nullptr;; 1044 }; 1045 ; 1046 return multigraph;; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Draws ROC curves for all methods booked with the factory for a given class; 1051/// onto a canvas.; 1052///; 1053/// Argument iClass specifies the class to generate the ROC curve in a; 1054/// multiclass setting. It is ignored for binary classification.; 1055///; 1056/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 1057/// and the others considered background. This is ok in binary classification; 1058/// but in in multi class classification, the ROC surface is an N dimensional; 1059/// shape, where N is number of classes - 1.; 1060 ; 1061TCanvas *TMVA::Factory::GetROCCurve(TMVA::DataLoader *loader, UInt_t iClass, Types::ETreeType type); 1062{; 1063 return GetROCCurve((TString)loader->GetName(), iClass, type);; 1064}; 1065 ; 1066////////////////////////////////////////////////////////////////////////////////; 1067/// Draws ROC curves for all methods booked with the factory for a given class.; 1068///; 1069/// Argument iClass specifies the class to generate the ROC curve in a; 1070/// multiclass setting. It is ignored for binary classification.; 1071///; 1072/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 1073/// and the others considered background. This is ok in binary classification; 1074/// but in in multi class classification, the ROC surface is an N dimensional; 1075/// shape, where N is number of classes - 1.; 1076 ; 1077TCanvas *TMVA::Factory::GetROCCurve(TString datasetname, UInt_t iClass, Types::ETreeType type); 1078{; 1079 if (fMethodsMap.find(datasetname) == fMethodsMap.end()) {; 1080 Log() << kERROR << Form(""DataSet = %s not found in methods map."", datasetname.Data()) << Endl;; 1081 return 0;; 1082 }; 1083 ; 1084 TString name = TString::Format(""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:43356,load,loader,43356,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance,"2 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i < nel; ++i) {; 1039 e1 = (TStreamerElement*) fElements->UncheckedAt(i);; 1040 e2 = (TStreamerElement*) elems->At(i);; 1041 if (!e1 || !e2) {; 1042 continue;; 1043 }; 1044 if (strlen(e1->GetTitle()) != strlen(e2->GetTitle())) {; 1045 e2->SetTitle(e1->GetTitle());; 1046 }; 1047 }; 1048 ; 1049 done = kTRUE;; 1050 } else {; 1051 fClass->RemoveStreamerInfo(fClassVersion);; 1052 info = 0;; 1053 }; 1054 TString origin;; 1055 if (!match && !fClass->TestBit(TClass::kWarned)) {; 1056 if (oldIsNonVersioned) {; 1057 if (file) {; 1058 Warning(""BuildCheck"", ""\n\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:39543,load,loaded,39543,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"2 bcount->ResetBit(kDoNotProcess);; 8643 }; 8644 } else {; 8645 //Int_t nbranches = branch->GetListOfBranches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:337829,cache,cachesize,337829,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],"['cache', 'cachesize']"
Performance,"2 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:68454,cache,cache,68454,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,"2 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt o) const; 1884{; 1885 // Sanity checks; 1886 if (plotSanityChecks(frame)) return frame ;; 1887 ; 1888 // ProjDataVars is either all projData observables, or the user indicated subset of it; 1889 RooArgSet projDataVars ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82163,perform,performed,82163,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"2 namespace Math {; 53 ; 54 template <class T, unsigned int D>; 55 class SVector;; 56 ; 57#ifdef XXX; 58//==============================================================================; 59// SMatrix * SVector; 60//==============================================================================; 61template <class T, unsigned int D1, unsigned int D2, class R>; 62SVector<T,D1> operator*(const SMatrix<T,D1,D2,R>& rhs, const SVector<T,D2>& lhs); 63{; 64 SVector<T,D1> tmp;; 65 for(unsigned int i=0; i<D1; ++i) {; 66 const unsigned int rpos = i*D2;; 67 for(unsigned int j=0; j<D2; ++j) {; 68 tmp[i] += rhs.apply(rpos+j) * lhs.apply(j);; 69 }; 70 }; 71 return tmp;; 72}; 73#endif; 74 ; 75 ; 76// matrix-vector product:; 77// use apply(i) function for matrices. Tested (11/05/06) with using (i,j) but; 78// performances are slightly worse (not clear why); 79 ; 80//==============================================================================; 81// meta_row_dot; 82//==============================================================================; 83template <unsigned int I>; 84struct meta_row_dot {; 85 template <class A, class B>; 86 static inline typename A::value_type f(const A& lhs, const B& rhs,; 87 const unsigned int offset) {; 88 return lhs.apply(offset+I) * rhs.apply(I) + meta_row_dot<I-1>::f(lhs,rhs,offset);; 89 }; 90};; 91 ; 92 ; 93//==============================================================================; 94// meta_row_dot<0>; 95//==============================================================================; 96template <>; 97struct meta_row_dot<0> {; 98 template <class A, class B>; 99 static inline typename A::value_type f(const A& lhs, const B& rhs,; 100 const unsigned int offset) {; 101 return lhs.apply(offset) * rhs.apply(0);; 102 }; 103};; 104 ; 105//==============================================================================; 106// VectorMatrixRowOp; 107//==============================================================================; 108template <class Matrix, cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MatrixFunctions_8h_source.html:2499,perform,performances,2499,doc/master/MatrixFunctions_8h_source.html,https://root.cern,https://root.cern/doc/master/MatrixFunctions_8h_source.html,1,['perform'],['performances']
Performance,"2 of file RooDecay.h. ◆ coefficient(). double RooDecay::coefficient ; (; Int_t ; basisIndex); const. overridevirtual . Implements RooAbsAnaConvPdf.; Definition at line 84 of file RooDecay.cxx. ◆ DeclFileName(). static const char * RooDecay::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 46 of file RooDecay.h. ◆ generateEvent(). void RooDecay::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 99 of file RooDecay.cxx. ◆ getGenerator(). Int_t RooDecay::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 91 of file RooDecay.cxx. ◆ IsA(). TClass * RooDecay::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 46 of file RooDecay.h. ◆ Streamer(). void RooDecay::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsAnaConvPdf. ◆ StreamerNVirtual(). void RooDecay::StreamerNVirtual ; (; TBuffer & ; ClassDef_Str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:80355,Load,Load,80355,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['Load'],['Load']
Performance,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:170879,load,loading,170879,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['load'],['loading']
Performance,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173067,load,loading,173067,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['load'],['loading']
Performance,"2 of file TUnfoldSys.cxx. ◆ Class(). static TClass * TUnfoldSys::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TUnfoldSys::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TUnfoldSys::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TUnfoldSys.h. ◆ ClearResults(). void TUnfoldSys::ClearResults ; (; void ; ). overrideprotectedvirtual . Clear all data members which depend on the unfolding results. ; Reimplemented from TUnfold.; Definition at line 650 of file TUnfoldSys.cxx. ◆ DeclFileName(). static const char * TUnfoldSys::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TUnfoldSys.h. ◆ DoBackgroundSubtraction(). void TUnfoldSys::DoBackgroundSubtraction ; (; void ; ). protected . perform background subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all sources of background ; [in]binMap(default=nullptr) remap histogram bins ; [in]includeError(default=3) include uncorrelated(1), correlated (2) or both (3) sources of uncertainty in the histogram errors ; [in]clearHist(default=true) reset histogram before adding up the specified background sources. the array binMap is explained with the method GetOutput(). The flag clearHist may be used to add background from several sources in successive calls to GetBackground(). ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:33478,perform,perform,33478,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['perform'],['perform']
Performance,"2 public:; 163 TDeclNameRegistry(Int_t verbLevel=0);; 164 void AddQualifiedName(const char *name);; 165 Bool_t HasDeclName(const char *name) const;; 166 ~TDeclNameRegistry();; 167 private:; 168 Int_t fVerbLevel=0;; 169 std::unordered_set<std::string> fClassNamesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry);; 180 ~InsertTClassInRegistryRAII();; 181 };; 182 ; 183 // TClass objects can be created as a result of opening a TFile (in which; 184 // they are in emulated mode) or as a result of loading the dictionary for; 185 // the corresponding class. When a dictionary is loaded any pre-existing; 186 // emulated TClass is replaced by the one created/coming from the dictionary.; 187 // To have a reference that always point to the 'current' TClass object for; 188 // a given class, one should use a TClassRef.; 189 // TClassRef works by holding on to the fPersistentRef which is updated; 190 // atomically whenever a TClass is replaced. During the replacement the; 191 // value of fPersistentRef is set to zero, leading the TClassRef to call; 192 // TClass::GetClass which is also locked by the replacement. At the end; 193 // of the replacement, fPersistentRef points to the new TClass object.; 194 std::atomic<TClass**> fPersistentRef;//!Persistent address of pointer to this TClass object and its successors.; 195 ; 196 typedef std::atomic<std::map<std::string, TObjArray*>*> ConvSIMap_t;; 197 ; 198 mutable TObjArray *fStreamerInfo; //Array of TVirtualStreamerInfo; 199 mutable ConvSIMap_t fConversionStreamerInfo; //Array of the streamer infos derived from another class.; 200 TList *fRealData; //linked list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:6607,load,loaded,6607,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['loaded']
Performance,2*_callHist! Histogram recording number of calls per convolution integral calculation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvolution.html:37831,cache,cache,37831,root/html602/RooNumConvolution.html,https://root.cern,https://root.cern/root/html602/RooNumConvolution.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"2, . Int_t ; bin3, . Int_t ; inBin, . Bool_t ; useWeights . ); const. protected . internal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile2D ; Definition at line 2550 of file TH3.cxx. ◆ DoProject1D() [1/3]. TH1D * TH3::DoProject1D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projAxis, . const TAxis * ; axis1, . const TAxis * ; axis2, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal methdod performing the projection to 1D histogram called from other TH3::DoProject1D ; Definition at line 1889 of file TH3.cxx. ◆ DoProject1D() [2/3]. TH1D * TH3::DoProject1D ; (; const char * ; name, . const char * ; title, . int ; imin1, . int ; imax1, . int ; imin2, . int ; imax2, . const TAxis * ; projAxis, . const TAxis * ; axis1, . const TAxis * ; axis2, . Option_t * ; option . ); const. protectedvirtual . internal method performing the projection to 1D histogram called from TH3::Project3D ; Definition at line 1829 of file TH3.cxx. ◆ DoProject1D() [3/3]. TH1D * TH3::DoProject1D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 1D histogram ; Definition at line 3504 of file TH3.cxx. ◆ DoProject2D() [1/2]. TH2D * TH3::DoProject2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method performing the projection to a 2D histogram called from TH3::Project3D ; Definition at line 2103 of file TH3.cxx. ◆ DoProject2D() [2/2]. TH2D * TH3::DoProject2D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; orig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:67050,perform,performing,67050,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['perform'],['performing']
Performance,"2.259, p0=6.404e-10, ; prevFCN = 26.37493074 p0=6.286e-10, ; prevFCN = 26.37493074 p0=1.367e-14, s=0.2103, ; prevFCN = 26.3749307 s=0.2103, ; prevFCN = 26.37493077 f=0.2654, m=2.259, s=0.2103, ; prevFCN = 26.37493101 m=2.259, p0=1.589e-08, ; prevFCN = 26.37493123 p0=1.367e-14, s=0.2104, ; prevFCN = 26.37493103 f=0.2652, m=2.259, p0=1.589e-08, s=0.2103, ; prevFCN = 26.37493099 p0=1.367e-14, s=0.2104, ; prevFCN = 26.37493085 m=2.259, p0=1.589e-08, ; prevFCN = 26.37493105 p0=1.367e-14, s=0.2103, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; All Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [3] MinLevel = DEBUG Topic = LinkStateMgmt ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server x(0x7fff8734d4f0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server m(0x7fff8734b8d8) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server s(0x7fff8734bcc0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server x(0x7fff8734d4f0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server m(0x7fff8734b8d8) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server s(0x7fff8734bcc0) for value ; RooGaussian::g[ x=x mean=m sigma=s ] = 8.804e-26; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf506_msgservice.C. tutorialsroofitrf506_msgservice.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:28688,optimiz,optimization,28688,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"21 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:61821,Load,LoadLibraryMap,61821,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"21#include ""TF1.h""; 22#include ""TStyle.h""; 23#include ""TMath.h""; 24#include ""TVectorD.h""; 25#include ""Foption.h""; 26#include ""TRandom.h""; 27#include ""TSpline.h""; 28#include ""TVirtualFitter.h""; 29#include ""TVirtualPad.h""; 30#include ""TVirtualGraphPainter.h""; 31#include ""TBrowser.h""; 32#include ""TSystem.h""; 33#include ""TPluginManager.h""; 34#include ""strtok.h""; 35 ; 36#include <cstdlib>; 37#include <string>; 38#include <cassert>; 39#include <iostream>; 40#include <fstream>; 41#include <cstring>; 42#include <numeric>; 43 ; 44#include ""HFitInterface.h""; 45#include ""Fit/DataRange.h""; 46#include ""Math/MinimizerOptions.h""; 47 ; 48extern void H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b);; 49 ; 50ClassImp(TGraph);; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53 ; 54/** \class TGraph; 55 \ingroup Graphs; 56A TGraph is an object made of two arrays X and Y with npoints each.; 57The TGraph painting is performed thanks to the TGraphPainter; 58class. All details about the various painting options are given in this class.; 59 ; 60#### Notes; 61 ; 62 - Unlike histogram or tree (or even TGraph2D), TGraph objects; 63 are not automatically attached to the current TFile, in order to keep the; 64 management and size of the TGraph as small as possible.; 65 - The TGraph constructors do not have the TGraph title and name as parameters.; 66 A TGraph has the default title and name ""Graph"". To change the default title; 67 and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; 68 TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; 69 That’s why it did not have any title and name parameters in the constructors.; 70 ; 71#### Example; 72 ; 73The picture below gives an example:; 74 ; 75Begin_Macro(source); 76{; 77 double x[100], y[100];; 78 int n = 20;; 79 for (int i=0;i<n;i++) {; 80 x[i] = i*0.1;; 81 y[i] = 10*sin(x[i]+0.2);; 82 }; 83 auto g = new TGrap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:1830,perform,performed,1830,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['perform'],['performed']
Performance,"21, 0.80, ""#sqrt{{s}} = 13 TeV, {:.2f} fb^{{-1}}"".format(lumi * args.lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df105_WBosonAnalysis.png""); print(""Saved figure to df105_WBosonAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.01 fb^-1 ...; Saved figure to df105_WBosonAnalysis.png; DateMarch 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df105_WBosonAnalysis.py. tutorialsdataframedf105_WBosonAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:9529,concurren,concurrently,9529,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,2,"['concurren', 'multi-thread']","['concurrently', 'multi-threading']"
Performance,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:9932,Load,Load,9932,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,3,['Load'],"['Load', 'LoadLibraryMap', 'LoadMacro']"
Performance,"227////////////////////////////////////////////////////////////////////////////////; 2228/// Return true if the file is local and is (likely) to be a ROOT file; 2229 ; 2230Bool_t TROOT::IsRootFile(const char *filename) const; 2231{; 2232 Bool_t result = kFALSE;; 2233 FILE *mayberootfile = fopen(filename,""rb"");; 2234 if (mayberootfile) {; 2235 char header[5];; 2236 if (fgets(header,5,mayberootfile)) {; 2237 result = strncmp(header,""root"",4)==0;; 2238 }; 2239 fclose(mayberootfile);; 2240 }; 2241 return result;; 2242}; 2243 ; 2244////////////////////////////////////////////////////////////////////////////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->Split",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:86100,Load,Load,86100,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Load'],['Load']
Performance,"2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physical context:; 2314 * This holds threads, ports, timeouts, ...; 2315 * set for the entire server, independent from the; 2316 * addressed hostname.; 2317 */; 2318 ; 2319 /* Connection related */; 2320 int context_type; /* See CONTEXT_* above */; 2321 ; 2322 struct socket *listening_sockets;; 2323 struct mg_pollfd *listening_socket_fds;; 2324 unsigned int num_listening_sockets;; 2325 ; 2326 struct mg_connection *worker_connections; /* The connection struct, pre-; 2327 * allocated for each worker */; 2328 ; 2329#if defined(USE_SERVER_STATS); 2330 volatile ptrdiff_t active_connections;; 2331 volatile ptrdiff_t max_active_connections;; 2332 volatile ptrdiff_t total_connections;; 2333 volatile ptrdiff_t total_requests;; 2334 volatile int64_t total_data_read;; 2335 volatile int64_t total_data_written;; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:72340,queue,queue,72340,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdiff_t active_connections;; 2332 volatile ptrdiff_t max_active_connections;; 2333 volatile ptrdiff_t total_connections;; 2334 volatile ptrdiff_t total_requests;; 2335 volatile int64_t total_data_read;; 2336 volatile int64_t total_data_written;; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:72372,queue,queue,72372,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"2344 }; 2345 }; 2346 subbranch->fOnfileObject = fOnfileObject;; 2347 lastbranch = subbranch;; 2348 }; 2349 }; 2350 if (toplevel) {; 2351 SetBit(kOwnOnfileObj);; 2352 if (lastbranch != this); 2353 lastbranch->ResetBit(kOwnOnfileObj);; 2354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:85146,cache,cache,85146,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['cache'],['cache']
Performance,"237 of file TROOT.h. ◆ GetListOfFunctionOverloads(). TCollection * TROOT::GetListOfFunctionOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:57022,load,load,57022,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['load'],['load']
Performance,"24 of file TFoam.h. ◆ fNBin. Int_t TFoam::fNBin. protected . No. of bins in the edge histogram for cell MC exploration. ; Definition at line 35 of file TFoam.h. ◆ fNCalls. Long_t TFoam::fNCalls. protected . Total number of the function calls. ; Definition at line 64 of file TFoam.h. ◆ fNCells. Int_t TFoam::fNCells. protected . Maximum number of cells. ; Definition at line 28 of file TFoam.h. ◆ fNEffev. Long_t TFoam::fNEffev. protected . Total number of effective events (wt=1) in the foam buildup. ; Definition at line 65 of file TFoam.h. ◆ fNevGen. Double_t TFoam::fNevGen. protected . Total number of the generated MC events. ; Definition at line 68 of file TFoam.h. ◆ fNoAct. Int_t TFoam::fNoAct. protected . Number of active cells. ; Definition at line 44 of file TFoam.h. ◆ fNSampl. Int_t TFoam::fNSampl. protected . No. of MC events, when dividing (exploring) cell. ; Definition at line 36 of file TFoam.h. ◆ fOptDrive. Int_t TFoam::fOptDrive. protected . Optimization switch =1,2 for variance or maximum weight optimization. ; Definition at line 31 of file TFoam.h. ◆ fOptPRD. Int_t TFoam::fOptPRD. protected . Option switch for predefined division, for quick check. ; Definition at line 41 of file TFoam.h. ◆ fOptRej. Int_t TFoam::fOptRej. protected . Switch =0 for weighted events; =1 for unweighted events in MC. ; Definition at line 33 of file TFoam.h. ◆ fPrimAcu. Double_t* TFoam::fPrimAcu. protected . [fNoAct] Array of cumulative probability of all active cells ; Definition at line 51 of file TFoam.h. ◆ fPrime. Double_t TFoam::fPrime. protected . Primary integral R' (R=R'<wt>) ; Definition at line 70 of file TFoam.h. ◆ fPseRan. TRandom* TFoam::fPseRan. protected . Pointer to user-defined generator of pseudorandom numbers. ; Definition at line 62 of file TFoam.h. ◆ fRho. TFoamIntegrand* TFoam::fRho. protected . ! Pointer to the user-defined integrand function/distribution ; Definition at line 60 of file TFoam.h. ◆ fRNmax. Int_t TFoam::fRNmax. protected . Maximum No. of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:44001,Optimiz,Optimization,44001,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"249 void GetCorrelationMatrix(Matrix & mat) const {; 250 unsigned int npar = fErrors.size();; 251 if (fCovMatrix.size() != npar*(npar+1)/2) return; // do nothing; 252 for (unsigned int i = 0; i< npar; ++i) {; 253 for (unsigned int j = 0; j<=i; ++j) {; 254 double tmp = fCovMatrix[i * (i +3)/2 ] * fCovMatrix[ j * (j+3)/2 ];; 255 mat(i,j) = (tmp > 0) ? fCovMatrix[j + i*(i+1)/2 ] / std::sqrt(tmp) : 0;; 256 if (i != j) mat(j,i) = mat(i,j);; 257 }; 258 }; 259 }; 260 ; 261 /**; 262 get confidence intervals for an array of n points x.; 263 stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; 264 For 1-dim points : stride1=1, stride2=1; 265 for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; 266 for multi-dim points arranged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1; 267 ; 268 the confidence interval are returned in the array ci; 269 cl is the desired confidence interval value; 270 norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; 271 The intervals can be corrected optionally using the chi2/ndf value of the fit if a chi2 fit is performed.; 272 This has changed since ROOT 6.14, before the interval were corrected by default.; 273 */; 274 void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double * x, double * ci, double cl=0.95, bool norm = false ) const;; 275 ; 276 /**; 277 evaluate confidence interval for the point specified in the passed data sets; 278 the confidence interval are returned in the array ci; 279 cl is the desired confidence interval value.; 280 This method is maintained for backward compatibility and will be deprecated; 281 */; 282 void GetConfidenceIntervals(const BinData & data, double * ci, double cl=0.95, bool norm = false ) const;; 283 ; 284 /**; 285 evaluate confidence interval for the data set used in the last fit; 286 the confidence interval are returned as a vector of data points; 287 */",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8h_source.html:10694,perform,performed,10694,doc/master/FitResult_8h_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html,1,['perform'],['performed']
Performance,"256; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree bkg_tree; : Using variable vars[0] from array expression vars of size 256; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 800; : Signal -- testing events : 200; : Signal -- training and testing events: 1000; : Background -- training events : 800; : Background -- testing events : 200; : Background -- training and testing events: 1000; : ; Factory : Booking method: ␛[1mTMVA_DNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussian",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:1967,Optimiz,Optimizer,1967,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,"258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent to the command line; 2309/// command "".x filename"". If the filename has ""+"" or ""++"" appended; 2310/// the macro will be compiled by ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error cod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:87081,Load,LoadMacro,87081,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Load'],['LoadMacro']
Performance,"2590/// The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; 2591/// not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; 2592///; 2593/// Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; 2594/// is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; 2595/// from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; 2596/// for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; 2597/// that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); 2598/// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); 2599/// longer to calculate.; 2600 ; 2601RooPlot* RooAbsReal::plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z,const RooArgSet* params, const RooLinkedList& argList, bool linMethod) const; 2602{; 2603 RooLinkedList plotArgListTmp(argList) ;; 2604 RooCmdConfig::stripCmdList(plotArgListTmp,""VisualizeError,MoveToBack"") ;; 2605 ; 2606 // Strip any 'internal normalization' arguments from list; 2607 RooLinkedList plotArgList ;; 2608 for (auto * cmd : static_range_cast<RooCmdArg*>(plotArgListTmp)) {; 2609 if (std::string(""Normalization"")==cmd->GetName()) {; 2610 if (((RooCmdArg*)cmd)->getInt(1)!=0) {; 2611 } else {; 2612 plotArgList.Add(cmd) ;; 2613 }; 2614 } else {; 2615 plotArgList.Add(cmd) ;; 2616 }; 2617 }; 2618 ; 2619 // Function to plot a single curve, creating a copy of the plotArgList to; 2620 // pass as plot command arguments. The ""FillColor"" command is removed because; 2621 // it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:114652,perform,perform,114652,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['perform']
Performance,"263}; 1264 ; 1265////////////////////////////////////////////////////////////////////////////////; 1266/// Set the TTree to be reloaded as soon as possible. In particular this; 1267/// is needed when adding a Friend.; 1268///; 1269/// If the tree has clones, copy them into the chain; 1270/// clone list so we can change their branch addresses; 1271/// when necessary.; 1272///; 1273/// This is to support the syntax:; 1274/// ~~~ {.cpp}; 1275/// TTree* clone = chain->GetTree()->CloneTree(0);; 1276/// ~~~; 1277 ; 1278void TChain::InvalidateCurrentTree(); 1279{; 1280 if (fTree && fTree->GetListOfClones()) {; 1281 for (TObjLink* lnk = fTree->GetListOfClones()->FirstLink(); lnk; lnk = lnk->Next()) {; 1282 TTree* clone = (TTree*) lnk->GetObject();; 1283 AddClone(clone);; 1284 }; 1285 }; 1286 fTreeNumber = -1;; 1287 fTree = nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Dummy function.; 1292/// It could be implemented and load all baskets of all trees in the chain.; 1293/// For the time being use TChain::Merge and TTree::LoadBasket; 1294/// on the resulting tree.; 1295 ; 1296Int_t TChain::LoadBaskets(Long64_t /*maxmemory*/); 1297{; 1298 Error(""LoadBaskets"", ""Function not yet implemented for TChain."");; 1299 return 0;; 1300}; 1301 ; 1302////////////////////////////////////////////////////////////////////////////////; 1303/// Find the tree which contains entry, and set it as the current tree.; 1304///; 1305/// Returns the entry number in that tree.; 1306///; 1307/// The input argument entry is the entry serial number in the whole chain.; 1308///; 1309/// In case of error, LoadTree returns a negative number:; 1310/// * -1: The chain is empty.; 1311/// * -2: The requested entry number is less than zero or too large for the chain.; 1312/// * -3: The file corresponding to the entry could not be correctly open; 1313/// * -4: The TChainElement corresponding to the entry is missing or; 1314/// the TTree is missing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:46990,load,load,46990,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['load']
Performance,"269 of file RNTupleReader.hxx. ◆ GetView() [5/6]. template<typename T > . RNTupleView< T > ROOT::Experimental::RNTupleReader::GetView ; (; std::string_view ; fieldName, . std::shared_ptr< T > ; objPtr . ). inline . Definition at line 275 of file RNTupleReader.hxx. ◆ GetView() [6/6]. template<typename T > . RNTupleView< T > ROOT::Experimental::RNTupleReader::GetView ; (; std::string_view ; fieldName, . T * ; rawPtr . ). inline . Definition at line 281 of file RNTupleReader.hxx. ◆ InitPageSource(). void ROOT::Experimental::RNTupleReader::InitPageSource ; (; bool ; enableMetrics). private . Definition at line 46 of file RNTupleReader.cxx. ◆ LoadEntry() [1/2]. void ROOT::Experimental::RNTupleReader::LoadEntry ; (; NTupleSize_t ; index). inline . Analogous to Fill(), fills the default entry of the model. ; Returns false at the end of the ntuple. On I/O errors, raises an exception. ; Definition at line 219 of file RNTupleReader.hxx. ◆ LoadEntry() [2/2]. void ROOT::Experimental::RNTupleReader::LoadEntry ; (; NTupleSize_t ; index, . REntry & ; entry . ). inline . Fills a user provided entry after checking that the entry has been instantiated from the ntuple model. ; Definition at line 229 of file RNTupleReader.hxx. ◆ Open() [1/4]. std::unique_ptr< ROOT::Experimental::RNTupleReader > ROOT::Experimental::RNTupleReader::Open ; (; const RNTuple & ; ntuple, . const RNTupleReadOptions & ; options = RNTupleReadOptions() . ). static . Definition at line 102 of file RNTupleReader.cxx. ◆ Open() [2/4]. std::unique_ptr< ROOT::Experimental::RNTupleReader > ROOT::Experimental::RNTupleReader::Open ; (; std::string_view ; ntupleName, . std::string_view ; storage, . const RNTupleReadOptions & ; options = RNTupleReadOptions() . ). static . Open an RNTuple for reading. ; Throws an RException if there is no RNTuple with the given name.; Example: open an RNTuple and print the number of entries #include <ROOT/RNTupleReader.hxx>; using ROOT::Experimental::RNTupleReader;; ; #include <iostream>; ; a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:13486,Load,LoadEntry,13486,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['Load'],['LoadEntry']
Performance,"27#include <unordered_map>; 28 ; 29class TBrowser;; 30class TFile;; 31class TTree;; 32class TStopwatch;; 33class TPaveText;; 34class TGraphErrors;; 35class TGaxis;; 36class TText;; 37 ; 38class TTreePerfStats : public TVirtualPerfStats {; 39 ; 40public:; 41 struct BasketInfo {; 42 UInt_t fUsed = {0}; ///< Number of times the basket was requested from the disk.; 43 UInt_t fLoaded = {0}; ///< Number of times the basket was put in the primary TTreeCache; 44 UInt_t fLoadedMiss = {0}; ///< Number of times the basket was put in the secondary cache; 45 UInt_t fMissed = {0}; ///< Number of times the basket was read directly from the file.; 46 };; 47 ; 48 using BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t>>>;; 49 ; 50protected:; 51 Int_t fTreeCacheSize; ///< TTreeCache buffer size; 52 Int_t fNleaves; ///< Number of leaves in the tree; 53 Int_t fReadCalls; ///< Number of read calls; 54 Int_t fReadaheadSize; ///< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:1992,cache,cache,1992,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,2,['cache'],['cache']
Performance,"27/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char *library_specified,; 2838 const char *build_dir,; 2839 UInt_t dirmode); 2840{; 2841 static const char *version_var_prefix = ""__ROOTBUILDVERSION="";; 2842 ; 2843 // ======= Analyze the options; 2844 Bool_t keep = kFALSE;; 2845 Bool_t recompile = kFALSE;; 2846 int mode = fAclicMode;; 2847 Bool_t loadLib = kTRUE;; 2848 Bool_t withInfo = kTRUE;; 2849 Bool_t verbose = kFALSE;; 2850 Bool_t internalDebug = kFALSE;; 2851 if (opt) {; 2852 keep = (strchr(opt,'k')!=nullptr);; 2853 recompile = (strchr(opt,'f')!=nullptr);; 2854 if (strchr(opt,'O')!=nullptr) {; 2855 mode |= kOpt;; 2856 }; 2857 if (strchr(opt,'g')!=nullptr) {; 2858 mode |= kDebug;; 2859 }; 2860 if (strchr(opt,'c')!=nullptr) {; 2861 loadLib = kFALSE;; 2862 }; 2863 withInfo = strchr(opt, 's') == nullptr;; 2864 verbose = strchr(opt, 'v') != nullptr;; 2865 internalDebug = strchr(opt, 'd') != nullptr;; 2866 }; 2867 if (mode==kDefault) {; 2868 TString rootbuild = ROOTBUILD;; 2869 if (rootbuild.Index(""debug"",0,TString::kIgnoreCase)==kNPOS) {; 2870 mode = kOpt;; 2871 } else {; 2872 mode = kDebug;; 2873 }; 2874 }; 2875 UInt_t verboseLevel = verbose ? 7 : gDebug;; 2876 Bool_t flatBuildDir = (fAclicProperties & kFlatBuildDir) || (opt && strchr(opt,'-')!=nullptr);; 2877 ; 2878 // if non-zero, build_loc indicates where to build the shared library.; 2879 TString build_loc = ExpandFileName(GetBuildDir());; 2880 if (build_dir && strlen(build_dir)) build_loc = build_dir;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:94378,load,loadLib,94378,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['load'],['loadLib']
Performance,"28 OpenGitHubIssue(strippedCommand);; 1229}; 1230 ; 1231////////////////////////////////////////////////////////////////////////////////; 1232/// The function lists useful commands ("".help"") or opens the online reference; 1233/// guide, generated with Doxygen ("".help scope"" or "".help scope::member"").; 1234/// \note You can use "".?"" as the short version of "".help""; 1235/// \param[in] line command from the command line; 1236 ; 1237void TApplication::Help(const char *line); 1238{; 1239 // We first check if the user wants to print the help on the interpreter.; 1240 TString strippedCommand = TString(line).Strip(TString::kBoth);; 1241 // If the user chooses "".help"" or "".?"".; 1242 if ((strippedCommand == "".help"") || (strippedCommand == "".?"")) {; 1243 gInterpreter->ProcessLine(line);; 1244 Printf(""\n ROOT special commands."");; 1245 Printf("" =============================================================================="");; 1246 Printf("" .L <filename>[flags]: load the given file with optional flags like\n""; 1247 "" + to compile or ++ to force recompile.\n""; 1248 "" Type .? TSystem::CompileMacro for a list of all flags.\n""; 1249 "" <filename> can also be a shared library; skip flags."");; 1250 Printf("" .(x|X) <filename>[flags](args) :\n""; 1251 "" same as .L <filename>[flags] and runs then a function\n""; 1252 "" with signature: ret_type filename(args)."");; 1253 Printf("" .credits : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:49225,load,load,49225,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['load'],['load']
Performance,"28,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|128,TANH|128,TANH|128,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:7334,perform,perform,7334,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['perform']
Performance,"286 if (opt.Contains(""M"")) flag = ""M"";; 287 if (opt.Contains(""P"")) flag = ""P"";; 288 if (opt.Contains(""EX"")) flag = ""EX"";; 289 ; 290 if (!opt.Contains(""K"")) {; 291 if (fgFFT){; 292 Int_t ndiff = 0;; 293 if (fgFFT->GetNdim()!=ndim || strcmp(fgFFT->GetType(),""R2R"")!=0); 294 ndiff++;; 295 else {; 296 Int_t *ncurrent = fgFFT->GetN();; 297 for (Int_t i=0; i<ndim; i++) {; 298 if (n[i] != ncurrent[i]); 299 ndiff++;; 300 }; 301 ; 302 }; 303 if (ndiff>0) {; 304 delete fgFFT;; 305 fgFFT = nullptr;; 306 }; 307 }; 308 }; 309 TVirtualFFT *fft = nullptr;; 310 ; 311 R__LOCKGUARD(gROOTMutex);; 312 ; 313 if (!fgFFT || opt.Contains(""K"")) {; 314 TPluginHandler *h;; 315 TString pluginname;; 316 if (fgDefault.Length()==0) fgDefault=""fftw"";; 317 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 318 pluginname = ""fftwr2r"";; 319 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 320 if (h->LoadPlugin()==-1){; 321 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 322 return nullptr;; 323 }; 324 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 325 if (!fft) {; 326 ::Error(""TVirtualFFT::SineCosine"", ""plugin failed to create TVirtualFFT object"");; 327 return nullptr;; 328 }; 329 fft->Init(flag, 0, r2rkind);; 330 if (!opt.Contains(""K"")); 331 fgFFT = fft;; 332 return fft;; 333 } else {; 334 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 335 return nullptr;; 336 }; 337 }; 338 }; 339 ; 340 //if (fgFFT->GetTransformFlag()!=flag); 341 fgFFT->Init(flag,0, r2rkind);; 342 return fgFFT;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// static: return current fgFFT; 347 ; 348TVirtualFFT* TVirtualFFT::GetCurrentTransform(); 349{; 350 if (fgFFT); 351 return fgFFT;; 352 else{; 353 ::Warning(""TVirtualFFT::GetCurrentTransform"", ""fgFFT is not defined yet"");; 354 return nullptr;; 355 }; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// static: set the current t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:11931,Load,LoadPlugin,11931,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"2904; TGaxis::SetExponentOffsetstatic void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""xy"")Static method to set X and Y offset of the axis 10^n notation.Definition TGaxis.cxx:3035; TGaxis::LabelsLimitsvoid LabelsLimits(const char *label, Int_t &first, Int_t &last)Internal method to find first and last character of a label.Definition TGaxis.cxx:2533; TGaxis::IsOwnedModLabsBool_t IsOwnedModLabs() constReturns kTRUE when fModLabs owned by TGaxis and should be cleaned up.Definition TGaxis.cxx:869; TGaxis::ResetLabelAttributesvoid ResetLabelAttributes(TLatex *t)Helper method used by TGaxis::ChangeLabel.Definition TGaxis.cxx:2880; TGaxis::GetLabelSizeFloat_t GetLabelSize() constDefinition TGaxis.h:81; TGaxis::SetOptionvoid SetOption(Option_t *option="""")To set axis options.Definition TGaxis.cxx:2934; TGaxis::IsATClass * IsA() const overrideDefinition TGaxis.h:136; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::GetXsizeDouble_t GetXsize()Return size of the formula along X in pad coordinates when the text precision is smaller than 3.Definition TLatex.cxx:2569; TLatex::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideReturn text size in pixels.Definition TLatex.cxx:2600; TLatex::PaintLatexvirtual void PaintLatex(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Main drawing function.Definition TLatex.cxx:2114; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::operator=TLine & opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:124841,Optimiz,Optimizestatic,124841,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,2,['Optimiz'],"['Optimize', 'Optimizestatic']"
Performance,"29; TMVA::MethodDL::GetRegressionValuesvirtual const std::vector< Float_t > & GetRegressionValues(); TMVA::MethodDL::fTrainingStrategyStringTString fTrainingStrategyStringThe string defining the training strategy.Definition MethodDL.h:196; TMVA::MethodDL::CreateRankingconst Ranking * CreateRanking()Definition MethodDL.cxx:2335; TMVA::MethodDL::HostBufferImpl_ttypename ArchitectureImpl_t::HostBuffer_t HostBufferImpl_tDefinition MethodDL.h:110; TMVA::MethodDL::SetBatchDepthvoid SetBatchDepth(size_t batchDepth)Definition MethodDL.h:292; TMVA::MethodDL::ParseKeyValueStringKeyValueVector_t ParseKeyValueString(TString parseString, TString blockDelim, TString tokenDelim)Function for parsing the training settings, provided as a string in a key-value form.Definition MethodDL.cxx:1052; TMVA::MethodDL::SetBatchWidthvoid SetBatchWidth(size_t batchWidth)Definition MethodDL.h:294; TMVA::MethodDL::PredictDeepNetstd::vector< Double_t > PredictDeepNet(Long64_t firstEvt, Long64_t lastEvt, size_t batchSize, Bool_t logProgress)perform prediction of the deep neural network using batches (called by GetMvaValues)Definition MethodDL.cxx:1828; TMVA::MethodDL::GetWeightInitializationDNN::EInitialization GetWeightInitialization() constDefinition MethodDL.h:268; TMVA::MethodDL::SetBatchSizevoid SetBatchSize(size_t batchSize)Definition MethodDL.h:291; TMVA::MethodDL::GetLayoutStringTString GetLayoutString() constDefinition MethodDL.h:274; TMVA::MethodDL::fBatchDepthsize_t fBatchDepthThe depth of the batch used to train the deep net.Definition MethodDL.h:182; TMVA::MethodDL::DeepNetImpl_tTMVA::DNN::TDeepNet< ArchitectureImpl_t > DeepNetImpl_tDefinition MethodDL.h:106; TMVA::MethodDL::GetBatchWidthsize_t GetBatchWidth() constDefinition MethodDL.h:264; TMVA::MethodDL::AddWeightsXMLTovoid AddWeightsXMLTo(void *parent) constDefinition MethodDL.cxx:2051; TMVA::MethodDL::MatrixImpl_ttypename ArchitectureImpl_t::Matrix_t MatrixImpl_tDefinition MethodDL.h:107; TMVA::MethodDL::~MethodDLvirtual ~MethodDL(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:111207,perform,perform,111207,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['perform'],['perform']
Performance,"2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: PDEFoam; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: DL_CPU; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_DL_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.077270 0.29534 [ -1.1155 1.0914 ]; : var2: 0.068045 0.27981 [ -1.0016 1.0000 ]; : var3: 0.027548 0.24565 [ -0.80459 0.85902 ]; : var4: -0.034157 0.25816 [ -1.0000 0.83435 ]; : -----------------------------------------------------------; TFHandler_DL_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.077270 0.29534 [ -1.1155 1.0914 ]; : var2: 0.068045 0.27981 [ -1.0016 1.0000 ]; : var3: 0.027548 0.24565 [ -0.80459 0.85902 ]; : var4: -0.034157 0.25816 [ -1.0000 0.83435 ]; : -----------------------------------------------------------; : ; : 1-vs-rest performance metrics per class; : -------------------------------------------------------------------------------------------------------; : ; : Considers the listed class as signal and the other classes; : as background, reporting the re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:22842,perform,performance,22842,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"2; }) // will act on ""b1"" and ""b2""; .Histo1D(); // will act on ""b1""; ; // just one default column this time; RDataFrame d2(""myTree"", ""file.root"", {""b1""});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2471. Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called rdfentry_ and rdfslot_. The rdfentry_ column is of type ULong64_t and it holds the current entry number while rdfslot_ is an unsigned int holding the index of the current data processing slot. For backwards compatibility reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:62614,Cache,Cache,62614,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['Cache'],['Cache']
Performance,"2; }) // will act on ""b1"" and ""b2""; .Histo1D(); // will act on ""b1""; ; // just one default column this time; RDataFrame d2(""myTree"", ""file.root"", {""b1""});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2640. Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called rdfentry_ and rdfslot_. The rdfentry_ column is of type ULong64_t and it holds the current entry number while rdfslot_ is an unsigned int holding the index of the current data processing slot. For backwards compatibility reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:64036,Cache,Cache,64036,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['Cache'],['Cache']
Performance,"2D, and TProfile3D.; Definition at line 6111 of file TH1.cxx. ◆ Multiply() [2/3]. Bool_t TH1::Multiply ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1, . Option_t * ; option = """" . ). virtual . Replace contents of this histogram by multiplication of h1 by h2. ; this = (c1*h1)*(c2*h2); If errors of this are available (TH1::Sumw2), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply; The function return kFALSE if the Multiply operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 6160 of file TH1.cxx. ◆ Multiply() [3/3]. Bool_t TH1::Multiply ; (; TF1 * ; f1, . Double_t ; c1 = 1 . ). virtual . Performs the operation: ; this = this*c1*f1; If errors are defined (see TH1::Sumw2), errors are also recalculated.; Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply; The function return kFALSE if the Multiply operation failed ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 6049 of file TH1.cxx. ◆ operator=(). TH1 & TH1::operator= ; (; const TH1 & ; ). privatedelete . ◆ Paint(). void TH1::Paint ; (; Option_t * ; option = """"). overridevirtual . Control routine to paint any kind of histograms. ; This function is automatically called by TCanvas::Update. (see TH1::Draw for the list of options) ; Reimplemented from TObject.; Definition at line 6206 of file TH1.cxx. ◆ Print(). void TH1::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print some global quantities for this histogram. ; Parameters. [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:192208,Perform,Performs,192208,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['Perform'],['Performs']
Performance,"2VirtualXProxy.cxx:106; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276; RooAbsReal::Relative@ RelativeDefinition RooAbsReal.h:276; RooAbsReal::Raw@ RawDefinition RooAbsReal.h:276. Reimplemented from RooAbsPdf.; Definition at line 305 of file RooAbsPdf.cxx. ◆ plotOn() [4/5]. RooPlot * RooAbsPdf::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. overridevirtual . Plot (project) PDF on specified frame. . If a PDF is plotted in an empty frame, it will show a unit-normalized curve in the frame variable. When projecting a multi- dimensional PDF onto the frame axis, hidden parameters are taken are taken at their current value.; If a PDF is plotted in a frame in which a dataset has already been plotted, it will show a projection integrated over all variables that were present in the shown dataset (except for the one on the x-axis). The normalization of the curve will be adjusted to the event count of the plotted dataset. An informational message will be printed for each projection step that is performed.; If a PDF is plotted in a frame showing a dataset after a fit, the above happens, but the PDF will be drawn and normalised only in the fit range. If this is not desired, plotting and normalisation range can be overridden using Range() and NormRange() as documented in the table below. This function takes the following named arguments (for more arguments, see also RooAbsReal::plotOn(RooPlot*,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&) const ). Type of argument Controlling normalisation . NormRange(const char* name) Calculate curve normalization w.r.t. specified range[s]. See the tutorial rf212_plottingInRanges_blinding.C NoteSetting a Range() by default also sets a NormRange() on the same range, meaning that the PDF is plotted and normalised in the same range. Overriding this can be useful if the PDF was fit in limit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:91204,perform,performed,91204,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['perform'],['performed']
Performance,"2VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTargetvoid AddTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:20724,cache,cacheDir,20724,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"2];; 126 buf[6] = sw[1];; 127 buf[7] = sw[0];; 128 }; 129#else; 130 if (sizeof(ULong_t) == 8) {; 131 memcpy(buf, &x, 8);; 132 } else {; 133 buf[0] = 0;; 134 buf[1] = 0;; 135 buf[2] = 0;; 136 buf[3] = 0;; 137 memcpy(buf+4, &x, 4);; 138 }; 139#endif; 140 buf += 8;; 141}; 142 ; 143inline void tobuf(char *&buf, Long_t x); 144{; 145#ifdef R__BYTESWAP; 146 // To work around a stupid optimization bug in MSVC++ 6.0; 147 const Long_t *intermediary = &x;; 148 const char *sw = (const char *)intermediary;; 149 if (sizeof(Long_t) == 8) {; 150 buf[0] = sw[7];; 151 buf[1] = sw[6];; 152 buf[2] = sw[5];; 153 buf[3] = sw[4];; 154 buf[4] = sw[3];; 155 buf[5] = sw[2];; 156 buf[6] = sw[1];; 157 buf[7] = sw[0];; 158 } else {; 159 if (x < 0) {; 160 buf[0] = (char) -1;; 161 buf[1] = (char) -1;; 162 buf[2] = (char) -1;; 163 buf[3] = (char) -1;; 164 } else {; 165 buf[0] = 0;; 166 buf[1] = 0;; 167 buf[2] = 0;; 168 buf[3] = 0;; 169 }; 170 buf[4] = sw[3];; 171 buf[5] = sw[2];; 172 buf[6] = sw[1];; 173 buf[7] = sw[0];; 174 }; 175#else; 176 if (sizeof(Long_t) == 8) {; 177 memcpy(buf, &x, 8);; 178 } else {; 179 if (x < 0) {; 180 buf[0] = (char) -1;; 181 buf[1] = (char) -1;; 182 buf[2] = (char) -1;; 183 buf[3] = (char) -1;; 184 } else {; 185 buf[0] = 0;; 186 buf[1] = 0;; 187 buf[2] = 0;; 188 buf[3] = 0;; 189 }; 190 memcpy(buf+4, &x, 4);; 191 }; 192#endif; 193 buf += 8;; 194}; 195 ; 196inline void tobuf(char *&buf, ULong64_t x); 197{; 198#ifdef R__BYTESWAP; 199# if defined(R__USEASMSWAP); 200 *((ULong64_t *)buf) = Rbswap_64(x);; 201# else; 202 // To work around a stupid optimization bug in MSVC++ 6.0; 203 const ULong64_t *intermediary = &x;; 204 const char *sw = (const char *)intermediary;; 205 buf[0] = sw[7];; 206 buf[1] = sw[6];; 207 buf[2] = sw[5];; 208 buf[3] = sw[4];; 209 buf[4] = sw[3];; 210 buf[5] = sw[2];; 211 buf[6] = sw[1];; 212 buf[7] = sw[0];; 213# endif; 214#else; 215 memcpy(buf, &x, sizeof(ULong64_t));; 216#endif; 217 buf += sizeof(ULong64_t);; 218}; 219 ; 220inline void tobuf(char *&bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Bytes_8h_source.html:5241,optimiz,optimization,5241,doc/master/Bytes_8h_source.html,https://root.cern,https://root.cern/doc/master/Bytes_8h_source.html,1,['optimiz'],['optimization']
Performance,"2_pythonizationDecorator.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -nodraw; 4## This tutorial shows how to use the `@pythonization` decorator to add extra; 5## behaviour to C++ user classes that are used from Python via PyROOT.; 6##; 7## \macro_code; 8## \macro_output; 9##; 10## \date November 2021; 11## \author Enric Tejedor; 12 ; 13import ROOT; 14from ROOT import pythonization; 15 ; 16# Let's first define a new C++ class. In this tutorial, we will see how we can; 17# ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; 18# make it more pythonic or easier to use from Python.; 19#; 20# Note: In this example, the class is defined dynamically for demonstration; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what wou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:1138,load,loading-user-libraries-and-just-in-time-compilation-jitting,1138,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['load'],['loading-user-libraries-and-just-in-time-compilation-jitting']
Performance,"3 ; 1534 switch (ctyp) {; 1535 ; 1536 case 1 :; 1537 break;; 1538 ; 1539 case 2 :; 1540 XDrawLine((Display*)fDisplay, gCws->fWindow, gGCecho,; 1541 xloc, 0, xloc, gCws->fHeight);; 1542 XDrawLine((Display*)fDisplay, gCws->fWindow, gGCecho,; 1543 0, yloc, gCws->fWidth, yloc);; 1544 break;; 1545 ; 1546 case 3 :; 1547 radius = (int) TMath::Sqrt((double)((xloc-xlocp)*(xloc-xlocp) +; 1548 (yloc-ylocp)*(yloc-ylocp)));; 1549 XDrawArc((Display*)fDisplay, gCws->fWindow, gGCecho,; 1550 xlocp-radius, ylocp-radius,; 1551 2*radius, 2*radius, 0, 23040);; 1552 break;; 1553 ; 1554 case 4 :; 1555 XDrawLine((Display*)fDisplay, gCws->fWindow, gGCecho,; 1556 xlocp, ylocp, xloc, yloc);; 1557 break;; 1558 ; 1559 case 5 :; 1560 XDrawRectangle((Display*)fDisplay, gCws->fWindow, gGCecho,; 1561 TMath::Min(xlocp,xloc), TMath::Min(ylocp,yloc),; 1562 TMath::Abs(xloc-xlocp), TMath::Abs(yloc-ylocp));; 1563 break;; 1564 ; 1565 default:; 1566 break;; 1567 }; 1568 ; 1569 while (XEventsQueued( (Display*)fDisplay, QueuedAlready) > 1) {; 1570 XNextEvent((Display*)fDisplay, &event);; 1571 }; 1572 XWindowEvent((Display*)fDisplay, gCws->fWindow, gMouseMask, &event);; 1573 ; 1574 switch (ctyp) {; 1575 ; 1576 case 1 :; 1577 break;; 1578 ; 1579 case 2 :; 1580 XDrawLine((Display*)fDisplay, gCws->fWindow, gGCecho,; 1581 xloc, 0, xloc, gCws->fHeight);; 1582 XDrawLine((Display*)fDisplay, gCws->fWindow, gGCecho,; 1583 0, yloc, gCws->fWidth, yloc);; 1584 break;; 1585 ; 1586 case 3 :; 1587 radius = (int) TMath::Sqrt((double)((xloc-xlocp)*(xloc-xlocp) +; 1588 (yloc-ylocp)*(yloc-ylocp)));; 1589 XDrawArc((Display*)fDisplay, gCws->fWindow, gGCecho,; 1590 xlocp-radius, ylocp-radius,; 1591 2*radius, 2*radius, 0, 23040);; 1592 break;; 1593 ; 1594 case 4 :; 1595 XDrawLine((Display*)fDisplay, gCws->fWindow, gGCecho,; 1596 xlocp, ylocp, xloc, yloc);; 1597 break;; 1598 ; 1599 case 5 :; 1600 XDrawRectangle((Display*)fDisplay, gCws->fWindow, gGCecho,; 1601 TMath::Min(xlocp,xloc), TMath::Min(ylocp,yloc),; 1602 TMath::Abs(xloc-xlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:51501,Queue,QueuedAlready,51501,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['Queue'],['QueuedAlready']
Performance,"3 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:65049,load,load,65049,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"3 = ROOT.RooDataSet(""ds3"", ""ds3"", {i, x}, Import=tree); ds3.Print(); ; # Define category i; icat = ROOT.RooCategory(""i"", ""i"", {""State0"": 0, ""State1"": 1}); ; # Import integer tree branch as ROOT.RooCategory (only events with i==0 and i==1; # will be imported as those are the only defined states); ds4 = ROOT.RooDataSet(""ds4"", ""ds4"", {icat, x}, Import=tree); ds4.Print(); ; # Import multiple RooDataSets into a RooDataSet; # ----------------------------------------------------------------------------------------; ; # Create three ROOT.RooDataSets in (y,z); dsA = ds2.reduce({x, y}, ""z<-5""); dsB = ds2.reduce({x, y}, ""abs(z)<5""); dsC = ds2.reduce({x, y}, ""z>5""); ; # Create a dataset that imports contents of all the above datasets mapped; # by index category c; dsABC = ROOT.RooDataSet(""dsABC"", ""dsABC"", {x, y}, Index=c, Import={""SampleA"": dsA, ""SampleB"": dsB, ""SampleC"": dsC}); ; dsABC.Print(); RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:3924,load,loadValues,3924,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,1,['load'],['loadValues']
Performance,"3 fDirectory = file;; 1864 return file;; 1865 }; 1866 }; 1867 ; 1868 if (fFileName.Length() == 0) return nullptr;; 1869 ; 1870 TString bFileName( GetRealFileName() );; 1871 ; 1872 // Open file (new file if mode = 1); 1873 {; 1874 TDirectory::TContext ctxt;; 1875 if (mode) file = TFile::Open(bFileName, ""recreate"");; 1876 else file = TFile::Open(bFileName);; 1877 }; 1878 if (!file) return nullptr;; 1879 if (file->IsZombie()) {delete file; return nullptr;}; 1880 fDirectory = (TDirectory*)file;; 1881 return file;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Return a fresh basket by either reusing an existing basket that needs; 1886/// to be drop (according to TTree::MemoryFull) or create a new one.; 1887///; 1888/// If the user_buffer argument is non-null, then the memory in the; 1889/// user-provided buffer will be utilized by the underlying basket.; 1890///; 1891/// The basket number is used to estimate the required buffer size; 1892/// and try to optimize memory usage and number of memory allocation.; 1893 ; 1894TBasket* TBranch::GetFreshBasket(Int_t basketnumber, TBuffer* user_buffer); 1895{; 1896 TBasket *basket = nullptr;; 1897 if (user_buffer && fExtraBasket) {; 1898 basket = fExtraBasket;; 1899 fExtraBasket = nullptr;; 1900 basket->AdoptBuffer(user_buffer);; 1901 } else {; 1902 if (GetTree()->MemoryFull(0)) {; 1903 if (fNBaskets==1) {; 1904 // Steal the existing basket; 1905 Int_t oldindex = fBaskets.GetLast();; 1906 basket = (TBasket*)fBaskets.UncheckedAt(oldindex);; 1907 if (!basket) {; 1908 fBaskets.SetLast(-2); // For recalculation of Last.; 1909 oldindex = fBaskets.GetLast();; 1910 if (oldindex != fBaskets.LowerBound()-1) {; 1911 basket = (TBasket*)fBaskets.UncheckedAt(oldindex);; 1912 }; 1913 }; 1914 if (basket && fBasketBytes[oldindex]!=0) {; 1915 if (basket == fCurrentBasket) {; 1916 fCurrentBasket = nullptr;; 1917 fFirstBasketEntry = -1;; 1918 fNextBasketEntry = -1;; 1919 }; 1920 fBaskets.A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:68944,optimiz,optimize,68944,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"3 frombuf(buffer, &nbytes);; 1224 if (nbytes < 0) {; 1225 idcur -= nbytes;; 1226 Seek(idcur);; 1227 continue;; 1228 }; 1229 if (nbytes == 0) break; //this may happen when the file is corrupted; 1230 Version_t versionkey;; 1231 frombuf(buffer, &versionkey);; 1232 frombuf(buffer, &objlen);; 1233 frombuf(buffer, &datime);; 1234 frombuf(buffer, &keylen);; 1235 if (!objlen) objlen = nbytes-keylen;; 1236 comp += nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:44722,cache,cache,44722,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"3 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Mark the queue as advanced */; 12595 conn->data_len -= (int)len;; 12596 }; 12597 ; 12598 /* Apply mask if necessary */; 12599 if (mask_len > 0) {; 12600 for (i = 0; i < (size_t)data_len; i++) {; 12601 data[i] ^= mask[i & 3];; 12602 }; 12603 }; 12604 ; 12605 exit_by_callback = 0;; 12606 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12607 /* filter PONG messages */; 12608 DEBUG_TRACE(""PONG from %s:%u"",; 12609 conn->request_info.remote_addr,; 12610 conn->request_info.remote_port);; 12611 /* No unanwered PINGs left */; 12612 ping_count = 0;; 12613 } else if (enable_ping_pong; 12614 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12615 /* reply PING messages */; 12616 DEBUG_TRACE(""Reply PING from %s:%u"",; 12617 conn->request_info.remote_addr,; 12618 conn->request_info.remote_port);; 12619 ret = mg_websocket_write(conn,; 12620 MG_WEBSOCKET_OPCODE_PONG,; 12621 (char *)data,; 12622 (size_t)data_len);; 12623 if (ret <= 0) {; 12624 /* Error: send failed */; 12625 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12626 break;; 12627 }; 12628 ; 12629 ; 12630 } else {; 12631 /* Exit t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:365655,queue,queue,365655,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['queue'],['queue']
Performance,"3 return kFALSE;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Evaluate a python expression (e.g. ""ROOT.TBrowser()"").; 458///; 459/// Caution: do not hold on to the return value: either store it in a builtin; 460/// type (implicit casting will work), or in a pointer to a ROOT object (explicit; 461/// casting to a void* is required).; 462///; 463/// \deprecated Use TPython::Exec() with an std::any output parameter instead.; 464 ; 465const TPyReturn TPython::Eval(const char *expr); 466{; 467 // setup; 468 if (!Initialize()); 469 return TPyReturn();; 470 ; 471 PyGILRAII gilRaii;; 472 ; 473 // evaluate the expression; 474 PyObject *result = PyRun_String(const_cast<char *>(expr), Py_eval_input, gMainDict, gMainDict);; 475 ; 476 // report errors as appropriate; return void; 477 if (!result) {; 478 PyErr_Print();; 479 return TPyReturn();; 480 }; 481 ; 482 // results that require no conversion; 483 if (result == Py_None || CPyCppyy::Instance_Check(result) || PyBytes_Check(result) || PyFloat_Check(result) ||; 484 PyLong_Check(result)); 485 return TPyReturn(result);; 486 ; 487 // explicit conversion for python type required; 488 PyObject *pyclass = PyObject_GetAttrString(result, const_cast<char *>(""__class__""));; 489 if (pyclass != 0) {; 490 CachedPyString moduleStr{""__module__""};; 491 CachedPyString nameStr{""__name__""};; 492 ; 493 // retrieve class name and the module in which it resides; 494 PyObject *name = PyObject_GetAttr(pyclass, nameStr.obj());; 495 PyObject *module = PyObject_GetAttr(pyclass, moduleStr.obj());; 496 ; 497 // concat name; 498 std::string qname = std::string(PyUnicode_AsUTF8(module)) + '.' + PyUnicode_AsUTF8(name);; 499 Py_DECREF(module);; 500 Py_DECREF(name);; 501 Py_DECREF(pyclass);; 502 ; 503 // locate ROOT style class with this name; 504 TClass *klass = TClass::GetClass(qname.c_str());; 505 ; 506 // construct general ROOT python object that pretends to be of class 'klass'; 507 if (klass != 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:16506,Cache,CachedPyString,16506,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,2,['Cache'],['CachedPyString']
Performance,"3 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16751,load,load,16751,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['load'],['load']
Performance,"3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNtuple.html:10859,Load,LoadTreeFriend,10859,root/html528/TNtuple.html,https://root.cern,https://root.cern/root/html528/TNtuple.html,2,['Load'],['LoadTreeFriend']
Performance,"3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNtuple.html:10981,Load,LoadTreeFriend,10981,root/html530/TNtuple.html,https://root.cern,https://root.cern/root/html530/TNtuple.html,6,['Load'],['LoadTreeFriend']
Performance,"3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:11346,Load,LoadTreeFriend,11346,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,4,['Load'],['LoadTreeFriend']
Performance,"30 of file TROOT.cxx. ◆ IsWebDisplay(). Bool_t TROOT::IsWebDisplay ; (; ); const. inline . Definition at line 287 of file TROOT.h. ◆ IsWebDisplayBatch(). Bool_t TROOT::IsWebDisplayBatch ; (; ); const. inline . Definition at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filena",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:66766,Load,LoadClass,66766,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['Load'],['LoadClass']
Performance,"306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:126886,load,load,126886,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"310/// PrintErrors - Print each error through RooMsgService() as it occurs; 4311/// CollectErrors - Accumulate errors, but do not print them. A subsequent call; 4312/// to printEvalErrors() will print a summary; 4313/// CountErrors - Accumulate error count, but do not print them.; 4314///; 4315 ; 4316void RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); 4317{; 4318 evalErrorData().mode = m;; 4319}; 4320 ; 4321 ; 4322////////////////////////////////////////////////////////////////////////////////; 4323 ; 4324void RooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); 4325{; 4326 std::string plist ;; 4327 for (auto const* arg : paramVars) {; 4328 if (!dependsOnValue(*arg)) {; 4329 coutW(InputArguments) << ""RooAbsReal::setParameterizeIntegral("" << GetName(); 4330 << "") function does not depend on listed parameter "" << arg->GetName() << "", ignoring"" << std::endl ;; 4331 continue ;; 4332 }; 4333 if (!plist.empty()) plist += "":"" ;; 4334 plist += arg->GetName() ;; 4335 }; 4336 setStringAttribute(""CACHEPARAMINT"",plist.c_str()) ;; 4337}; 4338 ; 4339 ; 4340/** Base function for computing multiple values of a RooAbsReal.; 4341\param ctx An evaluation context object; 4342**/; 4343void RooAbsReal::doEval(RooFit::EvalContext & ctx) const; 4344{; 4345 std::span<double> output = ctx.output();; 4346 ; 4347 // Find all servers that are serving real numbers to us, retrieve their batch data,; 4348 // and switch them into ""always clean"" operating mode, so they return always the last-set value.; 4349 struct ServerData {; 4350 RooAbsArg* server;; 4351 std::span<const double> batch;; 4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMode;; 4354 bool oldValueDirty;; 4355 bool oldShapeDirty;; 4356 };; 4357 std::vector<ServerData> ourServers;; 4358 ourServers.reserve(servers().size());; 4359 ; 4360 for (auto server : servers()) {; 4361 auto serverValues = ctx.at(server);; 4362 if(serverValues.empty()) continue;; 4363 ; 4364 // maybe we are still missing inhib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:191439,CACHE,CACHEPARAMINT,191439,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['CACHE'],['CACHEPARAMINT']
Performance,"3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:118377,load,loadedcl,118377,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loadedcl']
Performance,"312 // Don't redo the work.; 6313 return;; 6314 }; 6315 SetBit(kUnloading);; 6316 ; 6317 //R__ASSERT(fState == kLoaded);; 6318 if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetName(),(int)fState);; 6321 }; 6322 ; 6323 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6324 ; 6325 // Make sure SetClassInfo, re-calculated the state.; 6326 fState = kForwardDeclared;; 6327 ; 6328 delete fIsA; fIsA = nullptr;; 6329 // Disable the autoloader while calling SetClassInfo, to prevent; 6330 // the library from being reloaded!; 6331 {; 6332 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6333 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 6334 gInterpreter->SetClassInfo(this,kTRUE);; 6335 }; 6336 fDeclFileName = nullptr;; 6337 fDeclFileLine = 0;; 6338 fImplFileName = nullptr;; 6339 fImplFileLine = 0;; 6340 fTypeInfo = nullptr;; 6341 ; 6342 if (fMethod.load()) {; 6343 (*fMethod).Unload();; 6344 }; 6345 if (fData.load()) {; 6346 (*fData).Unload();; 6347 }; 6348 if (fUsingData.load()) {; 6349 (*fUsingData).Unload();; 6350 }; 6351 if (fEnums.load()) {; 6352 (*fEnums).Unload();; 6353 }; 6354 ; 6355 if (fState <= kForwardDeclared && !fStreamerInfo->IsEmpty()) {; 6356 fState = kEmulated;; 6357 }; 6358 ; 6359 ResetBit(kUnloading);; 6360 SetBit(kUnloaded);; 6361}; 6362 ; 6363////////////////////////////////////////////////////////////////////////////////; 6364/// Info is a string describing the names and types of attributes; 6365/// written by the class Streamer function.; 6366/// If info is an empty string (when called by TObject::StreamerInfo); 6367/// the default Streamer info string is build. This corresponds to; 6368/// the case of an automatically generated Streamer.; 6369/// In case of user defined Streamer function, it is the user responsibility; 6370/// to implement a StreamerInfo function (override TObject::StreamerInfo).; 6371/// The user must ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:244031,load,load,244031,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be pertinent to the normalization of the name.; 3174 // For example it might contain or be a typedef for which we don't; 3175 // have a forward declaration (eg. typedef to instance of class; 3176 // template with default parameters). So let's redo the normalization; 3177 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3178 // lead to a different value.; 3179 {; 3180 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3186 if (e); 3187 return nullptr;; 3188 // Maybe this was a typedef: let's try to see if this is the case; 3189 if (!loadedcl && !ispair && !ispairbase) {; 3190 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3191 // We have a typedef: we get the name of the underlying type; 3192 auto underlyingTypeName = theDataType->GetTypeName();; 3193 // We see if we can bootstrap a class with it; 3194 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3195 if (underlyingTypeDict){; 3196 loadedcl = underlyingTypeDict();; 3197 }; 3198 ; 3199 }; 3200 }; 3201 }; 3202 if (loadedcl) return loadedcl;; 3203 ; 3204 // See if the TClassGenerator can produce the TClass we need.; 3205 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3206 if (loadedcl) return loadedcl;; 3207 ; 3208 // We have not been able to find a loaded TClass, return the Emulated; 3209 // TClass if we have one.; 3210 if (cl) return cl;; 3211 ; 3212 if (ispair) {; 3213 if (hint_pair_offset && hint_pair_size) {; 3214 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:121128,load,loadedcl,121128,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loadedcl']
Performance,"3169 of file rootcling_impl.cxx. ◆ IsGoodLibraryName(). bool IsGoodLibraryName ; (; const std::string & ; name). Definition at line 5563 of file rootcling_impl.cxx. ◆ IsImplementationName(). bool IsImplementationName ; (; const std::string & ; filename). Definition at line 3410 of file rootcling_impl.cxx. ◆ IsLinkdefFile(). bool IsLinkdefFile ; (; const clang::PresumedLoc & ; PLoc). Definition at line 467 of file rootcling_impl.cxx. ◆ isPointerToPointer(). bool isPointerToPointer ; (; const clang::FieldDecl & ; m). Definition at line 1152 of file rootcling_impl.cxx. ◆ IsSelectionFile(). bool IsSelectionFile ; (; const char * ; filename). Definition at line 474 of file rootcling_impl.cxx. ◆ IsSelectionXml(). bool IsSelectionXml ; (; const char * ; filename). Definition at line 454 of file rootcling_impl.cxx. ◆ IsSupportedClassName(). bool IsSupportedClassName ; (; const char * ; name). Definition at line 3439 of file rootcling_impl.cxx. ◆ LoadLibraryMap(). void LoadLibraryMap ; (; const std::string & ; fileListName, . map< string, string > & ; autoloads . ). Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ; Definition at line 692 of file rootcling_impl.cxx. ◆ MaybeSuppressWin32CrashDialogs(). static void MaybeSuppressWin32CrashDialogs ; (; ). static . Definition at line 3675 of file rootcling_impl.cxx. ◆ ModuleContainsHeaders(). static bool ModuleContainsHeaders ; (; TModuleGenerator & ; modGen, . clang::HeaderSearch & ; headerSearch, . clang::Module * ; module, . std::vector< std::array< std::string, 2 > > & ; missingHeaders . ). static . Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ; The names of all header files that are needed by the ModuleGenerator but are not in the given module will be inserted into the MissingHeader variable. Returns true iff the PCH was successfully generated. ; Definition at line 3881 of file rootcling_im",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:56082,Load,LoadLibraryMap,56082,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['Load'],['LoadLibraryMap']
Performance,"32 b.WriteClassBuffer(pThis, object);; 6933 }; 6934}; 6935 ; 6936////////////////////////////////////////////////////////////////////////////////; 6937/// Default streaming in cases where either we have no way to know what to do; 6938/// or if Property() has not yet been called.; 6939 ; 6940void TClass::StreamerDefault(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class); 6941{; 6942 if (pThis->fProperty==(-1)) {; 6943 pThis->Property();; 6944 }; 6945 ; 6946 // We could get here because after this thread started StreamerDefault; 6947 // *and* before check fProperty, another thread might have call Property; 6948 // and this fProperty when we read it, is not -1 and fStreamerImpl is; 6949 // supposed to be set properly (no longer pointing to the default).; 6950 if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {; 6951 pThis->Fatal(""StreamerDefault"", ""fStreamerImpl not properly initialized (%d)"", pThis->fStreamerType);; 6952 } else {; 6953 (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);; 6954 }; 6955}; 6956 ; 6957////////////////////////////////////////////////////////////////////////////////; 6958/// Adopt a TClassStreamer object. Ownership is transfered to this TClass; 6959/// object.; 6960 ; 6961void TClass::AdoptStreamer(TClassStreamer *str); 6962{; 6963// // This code can be used to quickly test the STL Emulation layer; 6964// Int_t k = TClassEdit::IsSTLCont(GetName());; 6965// if (k==1||k==-1) { delete str; return; }; 6966 ; 6967 R__LOCKGUARD(gInterpreterMutex);; 6968 ; 6969 if (fStreamer) delete fStreamer;; 6970 if (str) {; 6971 fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );; 6972 fStreamer = str;; 6973 fStreamerImpl = &TClass::StreamerExternal;; 6974 } else if (fStreamer) {; 6975 // Case where there was a custom streamer and it is hereby removed,; 6976 // we need to reset fStreamerType; 6977 fStreamer = str;; 6978 fStreamerType = TClass::kDefault;; 6979 if (fProperty != -1) {; 6980 fProperty = -1;; 6981 Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:267025,load,load,267025,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"32 if (cname.IsNull()) {; 1833 invalid = kTRUE;; 1834 cname = ""c1"";; 1835 }; 1836 ; 1837 // if filename is given, open this file, otherwise create a file; 1838 // with a name equal to the canvasname.C; 1839 TString fname;; 1840 if (filename && *filename) {; 1841 fname = filename;; 1842 } else {; 1843 fname = cname + "".C"";; 1844 }; 1845 ; 1846 std::ofstream out;; 1847 out.open(fname.Data(), std::ios::out);; 1848 if (!out.good()) {; 1849 Error(""SaveSource"", ""Cannot open file: %s"", fname.Data());; 1850 return;; 1851 }; 1852 ; 1853 //set precision; 1854 Int_t precision = gEnv->GetValue(""Canvas.SavePrecision"",7);; 1855 out.precision(precision);; 1856 ; 1857 // Write macro header and date/time stamp; 1858 TDatime t;; 1859 Float_t cx = gStyle->GetScreenFactor();; 1860 Int_t topx,topy;; 1861 UInt_t w, h;; 1862 if (!fCanvasImp) {; 1863 Error(""SaveSource"", ""Cannot open TCanvas"");; 1864 return;; 1865 }; 1866 UInt_t editorWidth = fCanvasImp->GetWindowGeometry(topx,topy,w,h);; 1867 w = UInt_t((fWindowWidth - editorWidth)/cx);; 1868 h = UInt_t((fWindowHeight)/cx);; 1869 topx = GetWindowTopX();; 1870 topy = GetWindowTopY();; 1871 ; 1872 if (w == 0) {; 1873 w = GetWw()+4; h = GetWh()+4;; 1874 topx = 1; topy = 1;; 1875 }; 1876 ; 1877 TString mname = fname;; 1878 out << R""CODE(#ifdef __CLING__; 1879#pragma cling optimize(0); 1880#endif; 1881)CODE"";; 1882 Int_t p = mname.Last('.');; 1883 Int_t s = mname.Last('/')+1;; 1884 ; 1885 // A named macro is generated only if the function name is valid. If not, the; 1886 // macro is unnamed.; 1887 TString first(mname(s,s+1));; 1888 if (!first.IsDigit()) out <<""void "" << mname(s,p-s) << ""()"" << std::endl;; 1889 ; 1890 out <<""{""<<std::endl;; 1891 out <<""//=========Macro generated from canvas: ""<<GetName()<<""/""<<GetTitle()<<std::endl;; 1892 out <<""//========= (""<<t.AsString()<<"") by ROOT version ""<<gROOT->GetVersion()<<std::endl;; 1893 ; 1894 if (gStyle->GetCanvasPreferGL()); 1895 out <<std::endl<<"" gStyle->SetCanvasPreferGL(kTRUE);""<<std::endl<<st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:58837,optimiz,optimize,58837,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"325#else; 3326 Warning(""MakeProject"", ""on Windows systems the PAR file cannot be generated out of the package directory!"");; 3327#endif; 3328 }; 3329 ; 3330 ; 3331 if (!makepar && !opt.Contains(""nocompilation"")) {; 3332 // now execute the generated script compiling and generating the shared lib; 3333 path = gSystem->WorkingDirectory();; 3334 gSystem->ChangeDirectory(clean_dirname.Data());; 3335#ifndef WIN32; 3336 gSystem->Exec(""chmod +x MAKEP"");; 3337 int res = !gSystem->Exec(""./MAKEP"");; 3338#else; 3339 // not really needed for Windows but it would work both both Unix and NT; 3340 chmod(""makep.cmd"",00700);; 3341 int res = !gSystem->Exec(""MAKEP"");; 3342#endif; 3343 gSystem->ChangeDirectory(path);; 3344 path.Form(""%s/%s.%s"",clean_dirname.Data(),subdirname.Data(),gSystem->GetSoExt());; 3345 if (res) printf(""Shared lib %s has been generated\n"",path.Data());; 3346 ; 3347 //dynamically link the generated shared lib; 3348 if (opt.Contains(""++"")) {; 3349 res = !gSystem->Load(path);; 3350 if (res) printf(""Shared lib %s has been dynamically linked\n"",path.Data());; 3351 }; 3352 }; 3353 ; 3354 delete list;; 3355 filelist->Delete();; 3356 delete filelist;; 3357}; 3358 ; 3359////////////////////////////////////////////////////////////////////////////////; 3360/// Create makefile at 'filemake' for PAR package 'pack'.; 3361///; 3362/// Called by MakeProject when option 'par' is given.; 3363/// Return 0 on success, -1 on error.; 3364 ; 3365Int_t TFile::MakeProjectParMake(const char *pack, const char *filemake); 3366{; 3367 // Output file path must be defined; 3368 if (!filemake || (filemake && strlen(filemake) <= 0)) {; 3369 Error(""MakeProjectParMake"", ""path for output file undefined!"");; 3370 return -1;; 3371 }; 3372 ; 3373 // Package name must be defined; 3374 if (!pack || (pack && strlen(pack) <= 0)) {; 3375 Error(""MakeProjectParMake"", ""package name undefined!"");; 3376 return -1;; 3377 }; 3378 ; 3379#ifdef R__WINGCC; 3380 FILE *fmk = fopen(filemake, ""wb"");; 3381#else; 3382 FILE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:120831,Load,Load,120831,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Load'],['Load']
Performance,"332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 345 For the options same consideration as in the previous method; 346 */; 347 bool SetFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:14560,Perform,Perform,14560,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['Perform'],['Perform']
Performance,"3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3538 if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {; 3539 UpdateListOfLoadedSharedLibraries();; 3540 }; 3541 switch (res) {; 3542 case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;; 3543 case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded: return 1;; 3544 default: break;; 3545 };; 3546 return -1;; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Load a macro file in cling's memory.; 3551 ; 3552void TCling::LoadMacro(const char* filename, EErrorCode* error); 3553{; 3554 ProcessLine(Form("".L %s"", filename), error);; 3555}; 3556 ; 3557////////////////////////////////////////////////////////////////////////////////; 3558/// Let cling process a command line asynch.; 3559 ; 3560Longptr_t TCling::ProcessLineAsynch(const char* line, EErrorCode* error); 3561{; 3562 return ProcessLine(line, error);; 3563}; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Let cling process a command line synchronously, i.e we are waiting; 3567/// it will be finished.; 3568 ; 3569Longptr_t TCling::ProcessLineSynch(const char* line, EErrorCode* error); 3570{; 3571 R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : nullptr);; 3572 if (gApplication) {; 3573 if (gApplication->IsCmdThread()) {; 3574 return ProcessLine(line, error);; 3575 }; 3576 return 0;; 3577 }; 3578 return ProcessLine(line, error);; 3579}; 3580 ; 3581////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:138197,Load,LoadMacro,138197,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadMacro']
Performance,"354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel = fInfo->GetElement(i);; 2407 ; 2408 std::string ename = nextel->GetName();; 2409 if (ename[0] == '*'); 2410 ename = ename.substr(1);; 2411 ; 2412 while ((pos = ename.rfind('[')) != std::string::npos) {; 2413 ename = ename.substr(0, pos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:85244,cache,cache,85244,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['cache'],['cache']
Performance,"361; ROOT::Math::Minimizer::fValidErrorbool fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit)Definition Minimizer.h:369; ROOT::Math::Minimizer::MinosStatusvirtual int MinosStatus() conststatus code of Minos (to be re-implemented by the minimizers supporting Minos)Definition Minimizer.h:313; ROOT::Math::Minimizer::SetVariableLimitsvirtual bool SetVariableLimits(unsigned int ivar, double lower, double upper)set the limits of an already existing variableDefinition Minimizer.h:199; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::MinimizerMinimizer(Minimizer const &)=delete; ROOT::Math::Minimizer::CovMatrixStatusvirtual int CovMatrixStatus() constreturn status of covariance matrix using Minuit convention {0 not calculated 1 approximated 2 made po...Definition Minimizer.h:256; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::Statusint Status() conststatus code of minimizerDefinition Minimizer.h:310; ROOT::Math::Minimizer::SetVariableUpperLimitvirtual bool SetVariableUpperLimit(unsigned int ivar, double upper)set the upper-limit of an already existing variableDefinition Minimizer.cxx:78; ROOT::Math::Minimizer::SetCovariancevirtual bool SetCovariance(std::span< const double > cov, unsigned int nrow)set initial covariance matrixDefinition Minimizer.cxx:25; ROOT::Math::Minimizer::MinimizerMinimizer()Default constructor.Definition Minimizer.h:124; ROOT::Math::Minimizer::VariableNamevirtual std::string VariableName(unsigned int ivar) constget name of variables (override if minimizer support storing of variable names) return an empty strin...Definition Minimizer.cxx:224; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::CovMatrixvirtual double CovMatrix(unsigned int ivar, unsigned int jvar) constreturn covar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:25825,perform,perform,25825,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"3627 if (fSharedLibs.IsNull()); 3628 fSharedLibs = gInterpreter->GetClassSharedLibs(fName);; 3629 ; 3630 return !fSharedLibs.IsNull() ? fSharedLibs.Data() : nullptr;; 3631}; 3632 ; 3633////////////////////////////////////////////////////////////////////////////////; 3634/// Return list containing the TBaseClass(es) of a class.; 3635 ; 3636TList *TClass::GetListOfBases(); 3637{; 3638 if (!fBase.load()) {; 3639 if (fCanLoadClassInfo) {; 3640 if (fState == kHasTClassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:138350,Load,LoadClassInfo,138350,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['LoadClassInfo']
Performance,"3694 if (fSharedLibs.IsNull()); 3695 fSharedLibs = gInterpreter->GetClassSharedLibs(fName);; 3696 ; 3697 return !fSharedLibs.IsNull() ? fSharedLibs.Data() : nullptr;; 3698}; 3699 ; 3700////////////////////////////////////////////////////////////////////////////////; 3701/// Return list containing the TBaseClass(es) of a class.; 3702 ; 3703TList *TClass::GetListOfBases(); 3704{; 3705 if (!fBase.load()) {; 3706 if (fCanLoadClassInfo) {; 3707 if (fState == kHasTClassInit) {; 3708 ; 3709 R__LOCKGUARD(gInterpreterMutex);; 3710 if (!fHasRootPcmInfo) {; 3711 // The bases are in our ProtoClass; we don't need the class info.; 3712 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3713 if (proto && proto->FillTClass(this)); 3714 return fBase;; 3715 }; 3716 }; 3717 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3718 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3719 LoadClassInfo();; 3720 }; 3721 }; 3722 if (!fClassInfo); 3723 return nullptr;; 3724 ; 3725 if (!gInterpreter); 3726 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3727 ; 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 if (!fBase.load()) {; 3730 gInterpreter->CreateListOfBaseClasses(this);; 3731 }; 3732 }; 3733 return fBase;; 3734}; 3735 ; 3736////////////////////////////////////////////////////////////////////////////////; 3737/// Return a list containing the TEnums of a class.; 3738///; 3739/// The list returned is safe to use from multiple thread without explicitly; 3740/// taking the ROOT global lock.; 3741///; 3742/// In the case the TClass represents a namespace, the returned list will; 3743/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3744///; 3745/// In the case the TClass represents a class or struct and requestListLoading; 3746/// is true, the list is immutable (and thus safe to access from multiple thread; 3747/// without taking the global lock at all).; 3748///; 3749/// In the case the TClass represents a class or stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:141101,Load,LoadClassInfo,141101,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['LoadClassInfo']
Performance,"37 while (true) {; 738 std::shared_ptr<THttpCallArg> arg;; 739 ; 740 lk.lock();; 741 if (!fArgs.empty()) {; 742 arg = fArgs.front();; 743 fArgs.pop();; 744 }; 745 lk.unlock();; 746 ; 747 if (!arg); 748 break;; 749 ; 750 if (arg->fFileName == ""root_batch_holder.js"") {; 751 ProcessBatchHolder(arg);; 752 continue;; 753 }; 754 ; 755 auto prev = fSniffer->SetCurrentCallArg(arg.get());; 756 ; 757 try {; 758 cnt++;; 759 ProcessRequest(arg);; 760 fSniffer->SetCurrentCallArg(prev);; 761 } catch (...) {; 762 fSniffer->SetCurrentCallArg(prev);; 763 }; 764 ; 765 arg->NotifyCondition();; 766 }; 767 ; 768 // regularly call Process() method of engine to let perform actions in ROOT context; 769 TIter iter(&fEngines);; 770 while (auto engine = static_cast<THttpEngine *>(iter())) {; 771 if (fTerminated); 772 engine->Terminate();; 773 engine->Process();; 774 }; 775 ; 776 if (!recursion); 777 fProcessingThrdId = 0;; 778 ; 779 return cnt;; 780}; 781 ; 782////////////////////////////////////////////////////////////////////////////////; 783/// Method called when THttpServer cannot process request; 784///; 785/// By default such requests replied with 404 code; 786/// One could overwrite with method in derived class to process all kinds of such non-standard requests; 787 ; 788void THttpServer::MissedRequest(THttpCallArg *arg); 789{; 790 arg->Set404();; 791}; 792 ; 793////////////////////////////////////////////////////////////////////////////////; 794/// Process special http request for root_batch_holder.js script; 795///; 796/// This kind of requests used to hold web browser running in headless mode; 797/// Intentionally requests does not replied immediately; 798 ; 799void THttpServer::ProcessBatchHolder(std::shared_ptr<THttpCallArg> &arg); 800{; 801 auto wsptr = FindWS(arg->GetPathName());; 802 ; 803 if (!wsptr || !wsptr->ProcessBatchHolder(arg)) {; 804 arg->Set404();; 805 arg->NotifyCondition();; 806 }; 807}; 808 ; 809//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:24089,perform,perform,24089,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['perform'],['perform']
Performance,"373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3404 // classes; 3405 cl = gInterpreter->GetClass(typeinfo, load);; 3406 ; 3407 return cl; // Can be zero.; 3408}; 3409 ; 3410////////////////////////////////////////////////////////////////////////////////; 3411/// Static method returning pointer to TClass of the specified ClassInfo.; 3412/// If load is true an attempt is made to obtain the class by loading; 3413/// the appropriate shared library (directed by the rootmap file).; 3414/// If silent is 'true', do not warn about missing dictionary for the class.; 3415/// (typically used for class that are used only for transient members); 3416/// Returns 0 in case class is not found.; 3417 ; 3418TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3419{; 3420 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3421 if (!gROOT->GetListOfClasses()) return nullptr;; 3422 ; 3423 // Technically we need the write lock only for the call to ClassInfo_FullName; 3424 // and GenerateTClass but FindObject will take the read lock (and LoadCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:129637,load,load,129637,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:91272,load,load,91272,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"376 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 377 }; 378 }; 379 ; 380 Log() << kHEADER << ""Booking method: "" << gTools().Color(""bold""); 381 << methodTitle; 382 // << gTools().Color(""reset"")<<"" DataSet Name: ""<<gTools().Color(""bold"")<<loader->GetName(); 383 << gTools().Color(""reset"") << Endl << Endl;; 384 ; 385 // interpret option string with respect to a request for boosting (i.e., BostNum > 0); 386 Int_t boostNum = 0;; 387 TMVA::Configurable *conf = new TMVA::Configurable(theOption);; 388 conf->DeclareOptionRef(boostNum = 0, ""Boost_num"", ""Number of times the classifier will be boosted"");; 389 conf->ParseOptions();; 390 delete conf;; 391 // this is name of weight file directory; 392 TString fileDir;; 393 if (fModelPersistence) {; 394 // find prefix in fWeightFileDir;; 395 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 396 fileDir = prefix;; 397 if (!prefix.IsNull()); 398 if (fileDir[fileDir.Length() - 1] != '/'); 399 fileDir += ""/"";; 400 fileDir += loader->GetName();; 401 fileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 402 }; 403 // initialize methods; 404 IMethod *im;; 405 if (!boostNum) {; 406 im = ClassifierFactory::Instance().Create(theMethodName.Data(), fJobName, methodTitle, loader->GetDataSetInfo(),; 407 theOption);; 408 } else {; 409 // boosted classifier, requires a specific definition, making it transparent for the user; 410 Log() << kDEBUG << ""Boost Number is "" << boostNum << "" > 0: train boosted classifier"" << Endl;; 411 im = ClassifierFactory::Instance().Create(""Boost"", fJobName, methodTitle, loader->GetDataSetInfo(), theOption);; 412 MethodBoost *methBoost = dynamic_cast<MethodBoost *>(im); // DSMTEST divided into two lines; 413 if (!methBoost) { // DSMTEST; 414 Log() << kFATAL << ""Method with type kBoost cannot be casted to MethodCategory. /Factory"" << Endl; // DSMTEST; 415 return nullptr;; 416 }; 417 if (fModelPersistence); 418 methBoost->SetWeightFileDir(fileDir);; 419 methBoost->SetModelPersistence(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:16067,load,loader,16067,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"378 of file RooAddModel.cxx. ◆ evaluate(). double RooAddModel::evaluate ; (; ); const. overridevirtual . Calculate the current value. ; Implements RooAbsReal.; Definition at line 347 of file RooAddModel.cxx. ◆ expectedEvents(). double RooAddModel::expectedEvents ; (; const RooArgSet * ; nset); const. overridevirtual . Return expected number of events for extended likelihood calculation, which is the sum of all coefficients. ; Return the number of expected events, which is either the sum of all coefficients or the sum of the components extended terms. ; Reimplemented from RooAbsPdf.; Definition at line 569 of file RooAddModel.cxx. ◆ extendMode(). ExtendMode RooAddModel::extendMode ; (; ); const. inlineoverridevirtual . Return extended mode capabilities. ; Reimplemented from RooAbsPdf.; Definition at line 57 of file RooAddModel.h. ◆ fixCoefNormalization(). void RooAddModel::fixCoefNormalization ; (; const RooArgSet & ; refCoefNorm). By default the interpretation of the fraction coefficients is performed in the contextual choice of observables. ; This makes the shape of the p.d.f explicitly dependent on the choice of observables. This method instructs RooAddModel to freeze the interpretation of the coefficients to be done in the given set of observables. If frozen, fractions are automatically transformed from the reference normalization set to the contextual normalization set by ratios of integrals ; Definition at line 185 of file RooAddModel.cxx. ◆ fixCoefRange(). void RooAddModel::fixCoefRange ; (; const char * ; rangeName). By default the interpretation of the fraction coefficients is performed in the default range. ; This make the shape of a RooAddModel explicitly dependent on the range of the observables. To allow a range independent definition of the fraction this function instructs RooAddModel to freeze its interpretation in the given named range. If the current normalization range is different from the reference range, the appropriate fraction coefficients are a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:83954,perform,performed,83954,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['perform'],['performed']
Performance,"379 // Don't redo the work.; 6380 return;; 6381 }; 6382 SetBit(kUnloading);; 6383 ; 6384 //R__ASSERT(fState == kLoaded);; 6385 if (fState != kLoaded) {; 6386 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6387 GetName(),(int)fState);; 6388 }; 6389 ; 6390 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6391 ; 6392 // Make sure SetClassInfo, re-calculated the state.; 6393 fState = kForwardDeclared;; 6394 ; 6395 delete fIsA; fIsA = nullptr;; 6396 // Disable the autoloader while calling SetClassInfo, to prevent; 6397 // the library from being reloaded!; 6398 {; 6399 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6400 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 6401 gInterpreter->SetClassInfo(this,kTRUE);; 6402 }; 6403 fDeclFileName = nullptr;; 6404 fDeclFileLine = 0;; 6405 fImplFileName = nullptr;; 6406 fImplFileLine = 0;; 6407 fTypeInfo = nullptr;; 6408 ; 6409 if (fMethod.load()) {; 6410 (*fMethod).Unload();; 6411 }; 6412 if (fData.load()) {; 6413 (*fData).Unload();; 6414 }; 6415 if (fUsingData.load()) {; 6416 (*fUsingData).Unload();; 6417 }; 6418 if (fEnums.load()) {; 6419 (*fEnums).Unload();; 6420 }; 6421 ; 6422 if (fState <= kForwardDeclared && !fStreamerInfo->IsEmpty()) {; 6423 fState = kEmulated;; 6424 }; 6425 ; 6426 ResetBit(kUnloading);; 6427 SetBit(kUnloaded);; 6428}; 6429 ; 6430////////////////////////////////////////////////////////////////////////////////; 6431/// Info is a string describing the names and types of attributes; 6432/// written by the class Streamer function.; 6433/// If info is an empty string (when called by TObject::StreamerInfo); 6434/// the default Streamer info string is build. This corresponds to; 6435/// the case of an automatically generated Streamer.; 6436/// In case of user defined Streamer function, it is the user responsibility; 6437/// to implement a StreamerInfo function (override TObject::StreamerInfo).; 6438/// The user must ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:246782,load,load,246782,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"37; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleOffsetvoid SetTitleOffset(Float_t titleoffset=1)Definition TGaxis.h:128; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetTitleColorvoid SetTitleColor(Int_t titlecolor)Definition TGaxis.h:131; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGaxis::SetNamevirtual void SetName(const char *name)Change the name of the axis.Definition TGaxis.cxx:2904; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:32910,cache,cache,32910,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cache']
Performance,"381template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj); 382{; 383 // Read TObject derived classes from a TBuffer. Need to provide; 384 // custom version for non-TObject derived classes.; 385 ; 386 // This operator has to be a templated and/or automatically; 387 // generated if we want to be able to check the type of the; 388 // incoming object. I.e. a operator>>(TBuffer &buf, TObject *&); 389 // would not be sufficient to pass the information 'which class do we want'; 390 // since the pointer could be zero (so typeid(*obj) is not usable).; 391 ; 392 auto cl = TClass::GetClass<Tmpl>();; 393 obj = (Tmpl *) ( (void*) buf.ReadObjectAny(cl) );; 394 return buf;; 395}; 396 ; 397template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj); 398{; 399 auto cl = (obj) ? TClass::GetClass<Tmpl>() : nullptr;; 400 buf.WriteObjectAny(obj, cl);; 401 return buf;; 402}; 403 ; 404template <class T>; 405inline Int_t TBuffer::WriteObject(const T *objptr, Bool_t cacheReuse); 406{; 407 auto cl = (objptr) ? TClass::GetClass<T>() : nullptr;; 408 return WriteObjectAny(objptr, cl, cacheReuse);; 409}; 410 ; 411#endif // ROOT_TBuffer; Bytes.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Char_tchar Char_tDefinition RtypesCore.h:37; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition Rtypes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:21917,cache,cacheReuse,21917,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,2,['cache'],['cacheReuse']
Performance,"39 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 2340 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 2341 TIter next(sinfo->GetElements());; 2342 TStreamerElement *element;; 2343 while ((element = (TStreamerElement*)next())) {; 2344 if (element->IsA() == TStreamerBase::Class()) {; 2345 TClass *clbase = element->GetClassPointer();; 2346 if (!clbase) {; 2347 // If there is a missing base class, we can't split the immediate; 2348 // derived class.; 2349 fCanSplit = 0;; 2350 return kFALSE;; 2351 } else if (!clbase->CanSplitBaseAllow()) {; 2352 fCanSplit = 2;; 2353 return kFALSE;; 2354 }; 2355 }; 2356 }; 2357 }; 2358 ; 2359 // If we don't have data member info there is no more information; 2360 // we can find out.; 2361 if (!HasDataMemberInfo()) return kTRUE;; 2362 ; 2363 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2364 ; 2365 // Look at inheritance tree; 2366 while (lnk) {; 2367 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2368 TClass *c = base->GetClassPointer();; 2369 if(!c) {; 2370 // If there is a missing base class, we can't split the immediate; 2371 // derived class.; 2372 fCanSplit = 0;; 2373 return kFALSE;; 2374 } else if (!c->CanSplitBaseAllow()) {; 2375 fCanSplit = 2;; 2376 return kFALSE;; 2377 }; 2378 lnk = lnk->Next();; 2379 }; 2380 return kTRUE;; 2381}; 2382 ; 2383////////////////////////////////////////////////////////////////////////////////; 2384/// Return true if the data member of this TClass can be saved separately.; 2385 ; 2386Bool_t TClass::CanSplit() const; 2387{; 2388 // Note: add the possibility to set it for the class and the derived class.; 2389 // save the info in TVirtualStreamerInfo; 2390 // deal with the info in MakeProject; 2391 if (fCanSplit >= 0) {; 2392 // The user explicitly set the value; 2393 return (fCanSplit & 0x1) == 1;; 2394 }; 2395 ; 2396 R__LOCKGUARD(gInterpreterMutex);; 2397 TClass *This = const_cast<TClass*>(this);; 2398 ; 2399 if (this == TObject::Class()) { T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:89513,load,load,89513,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"39 if (!sinfo->IsCompiled()) {; 4740 // Streamer info has not been compiled, but exists.; 4741 // Therefore it was read in from a file and we have to do schema evolution?; 4742 // Or it didn't have a dictionary before, but does now?; 4743 sinfo->BuildOld();; 4744 }; 4745 }; 4746 ; 4747 // Cache the current info if we now have it.; 4748 if (version == fClassVersion); 4749 fCurrentInfo = sinfo;; 4750 ; 4751 // If the compilation succeeded, remember this StreamerInfo.; 4752 if (sinfo->IsCompiled()); 4753 fLastReadInfo = sinfo;; 4754 ; 4755 return sinfo;; 4756}; 4757 ; 4758////////////////////////////////////////////////////////////////////////////////; 4759/// For the case where the requestor class is emulated and this class is abstract,; 4760/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4761/// representation whether or not the class is loaded.; 4762///; 4763/// If the object does not exist, it is created; 4764///; 4765/// Note: There are two special version numbers:; 4766///; 4767/// - 0: Use the class version from the currently loaded class library.; 4768/// - -1: Assume no class library loaded (emulated class).; 4769///; 4770/// Warning: If we create a new streamer info, whether or not the build; 4771/// optimizes is controlled externally to us by a global variable!; 4772/// Don't call us unless you have set that variable properly; 4773/// with TStreamer::Optimize()!; 4774///; 4775 ; 4776TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4777{; 4778 TVirtualStreamerInfo *sinfo = nullptr;; 4779 ; 4780 TString newname(GetName());; 4781 newname += ""@@emulated"";; 4782 ; 4783 R__LOCKGUARD(gInterpreterMutex);; 4784 ; 4785 TClass *emulated = TClass::GetClass(newname);; 4786 ; 4787 if (emulated); 4788 sinfo = emulated->GetStreamerInfo(version);; 4789 ; 4790 if (!sinfo) {; 4791 // The emulated version of the streamerInfo is explicitly requested and has; 4792 // not been built yet.; 4793 ; 479",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:181254,load,loaded,181254,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"3977; TTreeFormula::SetQuickLoadvoid SetQuickLoad(bool quick)Definition TTreeFormula.h:210; TTreeFormula::GetNdatavirtual Int_t GetNdata()Return number of available instances in the formula.Definition TTreeFormula.cxx:4485; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TVectorT< Double_t >; bool; double; int; unsigned int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::LargestCommonDividerInt_t LargestCommonDivider(Int_t a, Int_t b)Definition DataSetFactory.cxx:80; TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; whatstatic c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:95719,Load,LoadTreevirtual,95719,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['Load'],"['LoadTree', 'LoadTreevirtual']"
Performance,"398 ; 2399 out << "" TChain *"" << chName.Data() << "" = new TChain(\"""" << GetName() << ""\"");"" << std::endl;; 2400 ; 2401 if (opt.Contains(""friend"")) {; 2402 opt.ReplaceAll(""friend"", """");; 2403 for (TObject *frel : *fFriends) {; 2404 TTree *frtree = ((TFriendElement *)frel)->GetTree();; 2405 if (dynamic_cast<TChain *>(frtree)) {; 2406 if (strcmp(frtree->GetName(), GetName()) != 0); 2407 --chCounter; // make friends get the same chain counter; 2408 frtree->SavePrimitive(out, opt.Data());; 2409 out << "" "" << chName.Data() << ""->AddFriend(\"""" << frtree->GetName() << ""\"");"" << std::endl;; 2410 } else { // ordinary friend TTree; 2411 TDirectory *file = frtree->GetDirectory();; 2412 if (file && dynamic_cast<TFile *>(file)); 2413 out << "" "" << chName.Data() << ""->AddFriend(\"""" << frtree->GetName() << ""\"", \"""" << file->GetName(); 2414 << ""\"");"" << std::endl;; 2415 }; 2416 }; 2417 }; 2418 out << std::endl;; 2419 ; 2420 for (TObject *el : *fFiles) {; 2421 TChainElement *chel = (TChainElement *)el;; 2422 // Save tree file if it is really loaded to the chain; 2423 if (chel->GetLoadResult() == 0 && chel->GetEntries() != 0) {; 2424 if (chel->GetEntries() == TTree::kMaxEntries) // tree number of entries is not yet known; 2425 out << "" "" << chName.Data() << ""->AddFile(\"""" << chel->GetTitle() << ""\"");"" << std::endl;; 2426 else; 2427 out << "" "" << chName.Data() << ""->AddFile(\"""" << chel->GetTitle() << ""\"","" << chel->GetEntries() << "");""; 2428 << std::endl;; 2429 }; 2430 }; 2431 out << std::endl;; 2432 ; 2433 SaveMarkerAttributes(out, chName.Data(), 1, 1, 1);; 2434}; 2435 ; 2436////////////////////////////////////////////////////////////////////////////////; 2437/// Loop on tree and print entries passing selection.; 2438/// - If varexp is 0 (or """") then print only first 8 columns.; 2439/// - If varexp = ""*"" print all columns.; 2440/// - Otherwise a columns selection can be made using ""var1:var2:var3"".; 2441/// See TTreePlayer::Scan for more information.; 2442 ; 2443Long64_t TChain::Scan(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:87216,load,loaded,87216,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loaded']
Performance,"3988 Info(""Export"", ""Exporting %s %s as gdml code"", GetName(), GetTitle());; 3989 // C++ version; 3990 TString cmd;; 3991 cmd = TString::Format(""TGDMLWrite::StartGDMLWriting(gGeoManager,\""%s\"",\""%s\"")"", filename, option);; 3992 gROOT->ProcessLineFast(cmd);; 3993 return 1;; 3994 }; 3995 if (sfile.Contains("".root"") || sfile.Contains("".xml"")) {; 3996 // Save geometry as a root file; 3997 TFile *f = TFile::Open(filename, ""recreate"");; 3998 if (!f || f->IsZombie()) {; 3999 Error(""Export"", ""Cannot open file"");; 4000 return 0;; 4001 }; 4002 TString keyname = name;; 4003 if (keyname.IsNull()); 4004 keyname = GetName();; 4005 TString opt = option;; 4006 opt.ToLower();; 4007 if (opt.Contains(""v"")) {; 4008 fStreamVoxels = kTRUE;; 4009 if (fgVerboseLevel > 0); 4010 Info(""Export"", ""Exporting %s %s as root file. Optimizations streamed."", GetName(), GetTitle());; 4011 } else {; 4012 fStreamVoxels = kFALSE;; 4013 if (fgVerboseLevel > 0); 4014 Info(""Export"", ""Exporting %s %s as root file. Optimizations not streamed."", GetName(), GetTitle());; 4015 }; 4016 ; 4017 const char *precision_dbl = TBufferText::GetDoubleFormat();; 4018 const char *precision_flt = TBufferText::GetFloatFormat();; 4019 TString new_format_dbl = TString::Format(""%%.%dg"", TGeoManager::GetExportPrecision());; 4020 if (sfile.Contains("".xml"")) {; 4021 TBufferText::SetDoubleFormat(new_format_dbl.Data());; 4022 TBufferText::SetFloatFormat(new_format_dbl.Data());; 4023 }; 4024 Int_t nbytes = Write(keyname);; 4025 if (sfile.Contains("".xml"")) {; 4026 TBufferText::SetFloatFormat(precision_dbl);; 4027 TBufferText::SetDoubleFormat(precision_flt);; 4028 }; 4029 ; 4030 fStreamVoxels = kFALSE;; 4031 delete f;; 4032 return nbytes;; 4033 }; 4034 return 0;; 4035}; 4036 ; 4037////////////////////////////////////////////////////////////////////////////////; 4038/// Lock current geometry so that no other geometry can be imported.; 4039 ; 4040void TGeoManager::LockGeometry(); 4041{; 4042 fgLock = kTRUE;; 4043}; 4044 ; 4045////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:146942,Optimiz,Optimizations,146942,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Optimiz'],['Optimizations']
Performance,"3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:27835,perform,perform,27835,root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,4,['perform'],['perform']
Performance,"3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLow += binWidth; nbins--; }; 1287 if ((binHigh-wmax) > epsilon) { binHigh -= binWidth; nbins--; }; 1288 if (xmax == xmin) {; 1289 rtyw = (ymax-ymin)/(wmax-wmin);; 1290 xxmin = xmin;; 1291 xxmax = xmax;; 1292 yymin = rtyw*(binLow-wmin) + ymin;; 1293 yymax = rtyw*(binHigh-wmin) + ymin;; 1294 }; 1295 else {; 1296 rtxw = (xmax-xmin)/(wmax-wmin);; 1297 xxmin = rtxw*(binLow-wmin) + xmin;; 1298 xxmax = rtxw*(binHigh-wmin) + xmin;; 1299 if (ymax == ymin) {; 1300 yymin = ymin;; 1301 yymax = ymax;; 1302 }; 1303 else {; 1304 alfa = (ymax-ymin)/(xmax-xmin);; 1305 beta = (ymin*xmax-ymax*xmin)/(xmax-xmin);; 1306 yymin = alfa*xxmin + beta;; 1307 yymax = alfa*xxmax + beta;; 1308 }; 1309 }; 1310 if (fFunction) {; 1311 yymin ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:45082,Optimiz,Optimize,45082,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['Optimiz'],['Optimize']
Performance,"3b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class StringCollection_t > ; std::string Join (const std::string &sep, StringCollection_t &&strings);  Concatenate a list of strings with a separator. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. ;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. ;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. ;  ; enum R__DEPRECATED (6, 34, ""Use RCompressionSetting::EAlgorithm instead"") ECompressionAlgorithm;  ; template<typename T , typename Range_t > ; RRangeCast< T, true, Range_t > RangeDynCast (Range_t &&coll);  Takes any collection t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:15204,multi-thread,multi-threading,15204,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"3b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class StringCollection_t > ; std::string Join (const std::string &sep, StringCollection_t &&strings);  Concatenate a list of strings with a separator. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. ;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. ;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. ;  ; template<typename T , typename Range_t > ; RRangeCast< T, true, Range_t > RangeDynCast (Range_t &&coll);  Takes any collection that can be used in range-based loops and applies dynamic_cast<T> to each element. ;  ; template<type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT.html:15300,multi-thread,multi-threading,15300,doc/v632/namespaceROOT.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"3b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. ;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. ;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. ;  ; template<typename T , typename Range_t > ; RRangeCast< T, true, Range_t > RangeDynCast (Range_t &&coll);  Takes any collection that can be used in range-based loops and applies dynamic_cast<T> to each element. ;  ; template<typename T , typename U , std::size_t N> ; RRangeCast< T, true, std::span< U > > RangeDynCast (U(&arr)[N]);  ; template<typename T , typename Range_t > ; RRangeCast< T, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:10763,multi-thread,multi-threading,10763,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"4 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:37463,Load,LoadModules,37463,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['Load'],"['LoadModule', 'LoadModules']"
Performance,"4 ; 355 The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; 356volume is in fact a virtual container that does not represent a physical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; 385#include ""TBrowser.h""; 386#include ""TStyle.h""; 387#include ""TH2F.h""; 388#include ""TROOT.h""; 389#include ""TEnv.h""; 390#include ""TMap.h""; 391#include ""TFile.h""; 392#include ""TKey.h""; 393 ; 394#include ""TGeoManager.h""; 395#include ""TGeoNode.h""; 396#include ""TGeoMatrix.h""; 397#include ""TVirtualGeoPainter.h""; 398#include ""TGeoVolume.h""; 399#include ""TGeoShapeAssembly.h""; 400#include ""TGeoScaledShape.h""; 401#include ""TGeoCompositeShape.h""; 402#include ""TGeoVoxelFinder.h""; 403#include ""TGeoExtension.h""; 404 ; 405Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:19258,optimiz,optimized,19258,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"4 TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);; 4155 }; 4156}; 4157 ; 4158////////////////////////////////////////////////////////////////////////////////; 4159/// Checks if an entity with the specified name is defined in Cling.; 4160/// Returns kUnknown if the entity is not defined.; 4161/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; 4162/// Returns kKnown if the entity is defined.; 4163///; 4164/// By default, structs, namespaces, classes, enums and unions are looked for.; 4165/// If the flag isClassOrNamespaceOnly is true, classes, structs and; 4166/// namespaces only are considered. I.e. if the name is an enum or a union,; 4167/// the returned value is false.; 4168///; 4169/// In the case where the class is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:161643,load,loaded,161643,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,4 TIOFeatures fIOFeatures{0}; ///< IO features to define for newly-written baskets and branches.; 115 Int_t fMakeClass; ///<! not zero when processing code generated by MakeClass; 116 Int_t fFileNumber; ///<! current file number (if file extensions); 117 /// Object to be notified when loading a Tree.; 118 /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; 119 /// Usually points to a TNotifyLink if this is a TChain.; 120 TObject *fNotify; //!; 121 TDirectory *fDirectory; ///<! Pointer to directory holding this tree; 122 TObjArray fBranches; ///< List of Branches; 123 TObjArray fLeaves; ///< Direct pointers to individual branch leaves; 124 TList *fAliases; ///< List of aliases for expressions based on the tree branches.; 125 TEventList *fEventList; ///<! Pointer to event selection list (if one); 126 TEntryList *fEntryList; ///<! Pointer to event selection list (if one); 127 TArrayD fIndexValues; ///< Sorted index values; 128 TArrayI fIndex; ///< Index of sorted values; 129 TVirtualIndex *fTreeIndex; ///< Pointer to the tree Index (if any); 130 TList *fFriends; ///< pointer to list of friend elements; 131 TList *fExternalFriends; ///<! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.; 132 TVirtualPerfStats *fPerfStats; ///<! pointer to the current perf stats object; 133 TList *fUserInfo; ///< pointer to a list of user objects associated to this Tree; 134 TVirtualTreePlayer *fPlayer; ///<! Pointer to current Tree player; 135 TList *fClones; ///<! List of cloned trees which share our addresses; 136 TBranchRef *fBranchRef; ///< Branch supporting the TRefTable (if any); 137 UInt_t fFriendLockStatus; ///<! Record which method is locking the friend recursion; 138 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 139 bool fCacheDoAutoInit; ///<! true if cache auto creation or resize check is needed; 140 bool fCacheDoClusterPrefetch;///<! true if cache is prefetching whole clusters; 1,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:5894,Load,LoadTree,5894,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['Load'],['LoadTree']
Performance,"4 TransactionDeclSet.insert(*DI);; 6795 ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);; 6796 }; 6797 }; 6798 }; 6799 ; 6800 // The above might trigger more decls to be deserialized.; 6801 // Thus the iteration over the deserialized decls must be last.; 6802 for (cling::Transaction::const_iterator I = T.deserialized_decls_begin(),; 6803 E = T.deserialized_decls_end(); I != E; ++I) {; 6804 for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),; 6805 DE = I->m_DGR.end(); DI != DE; ++DI); 6806 if (TransactionDeclSet.find(*DI) == TransactionDeclSet.end()) {; 6807 //FIXME: HandleNewDecl should take DeclGroupRef; 6808 ((TCling*)gCling)->HandleNewDecl(*DI, /*isDeserialized*/true,; 6809 modifiedTClasses);; 6810 }; 6811 }; 6812 ; 6813 ; 6814 // When fully building the reflection info in TClass, a deserialization; 6815 // could be triggered, which may result in request for building the; 6816 // reflection info for the same TClass. This in turn will clear the caches; 6817 // for the TClass in-flight and cause null ptr derefs.; 6818 // FIXME: This is a quick fix, solving most of the issues. The actual; 6819 // question is: Shouldn't TClass provide a lock mechanism on update or lock; 6820 // itself until the update is done.; 6821 //; 6822 std::vector<TClass*> modifiedTClassesDiff(modifiedTClasses.size());; 6823 std::vector<TClass*>::iterator it;; 6824 it = set_difference(modifiedTClasses.begin(), modifiedTClasses.end(),; 6825 ((TCling*)gCling)->GetModTClasses().begin(),; 6826 ((TCling*)gCling)->GetModTClasses().end(),; 6827 modifiedTClassesDiff.begin());; 6828 modifiedTClassesDiff.resize(it - modifiedTClassesDiff.begin());; 6829 ; 6830 // Lock the TClass for updates; 6831 ((TCling*)gCling)->GetModTClasses().insert(modifiedTClassesDiff.begin(),; 6832 modifiedTClassesDiff.end());; 6833 for (std::vector<TClass*>::const_iterator I = modifiedTClassesDiff.begin(),; 6834 E = modifiedTClassesDiff.end(); I != E; ++I) {; 6835 // Make sure the TClass has not been deleted.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:266103,cache,caches,266103,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['cache'],['caches']
Performance,"4 fCanvasImp = factory->CreateCanvasImp(this, name, Int_t(cx*wtopx), Int_t(cx*wtopy), UInt_t(cx*ww), UInt_t(cx*wh));; 515 if (!fCanvasImp) return;; 516 ; 517 if (!gROOT->IsBatch() && fCanvasID == -1); 518 fCanvasID = fCanvasImp->InitWindow();; 519 ; 520 fCanvasImp->ShowMenuBar(TestBit(kMenuBar));; 521 fBatch = kFALSE;; 522 }; 523 ; 524 CreatePainter();; 525 ; 526 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 527 SetTitle(title); // requires fCanvasImp set; 528 Build();; 529 ; 530 // Popup canvas; 531 fCanvasImp->Show();; 532}; 533 ; 534////////////////////////////////////////////////////////////////////////////////; 535/// Initialize the TCanvas members. Called by all constructors.; 536 ; 537void TCanvas::Init(); 538{; 539 // Make sure the application environment exists. It is need for graphics; 540 // (colors are initialized in the TApplication ctor).; 541 if (!gApplication); 542 TApplication::CreateApplication();; 543 ; 544 // Load and initialize graphics libraries if; 545 // TApplication::NeedGraphicsLibs() has been called by a; 546 // library static initializer.; 547 if (gApplication); 548 gApplication->InitializeGraphics(gROOT->IsWebDisplay());; 549 ; 550 // Get some default from .rootrc. Used in fCanvasImp->InitWindow().; 551 fHighLightColor = gEnv->GetValue(""Canvas.HighLightColor"", kRed);; 552 SetBit(kMoveOpaque, gEnv->GetValue(""Canvas.MoveOpaque"", 0));; 553 SetBit(kResizeOpaque, gEnv->GetValue(""Canvas.ResizeOpaque"", 0));; 554 if (gEnv->GetValue(""Canvas.ShowEventStatus"", kFALSE)) SetBit(kShowEventStatus);; 555 if (gEnv->GetValue(""Canvas.ShowToolTips"", kFALSE)) SetBit(kShowToolTips);; 556 if (gEnv->GetValue(""Canvas.ShowToolBar"", kFALSE)) SetBit(kShowToolBar);; 557 if (gEnv->GetValue(""Canvas.ShowEditor"", kFALSE)) SetBit(kShowEditor);; 558 if (gEnv->GetValue(""Canvas.AutoExec"", kTRUE)) SetBit(kAutoExec);; 559 ; 560 // Fill canvas ROOT data structure; 561 fXsizeUser = 0;; 562 fYsizeUser = 0;; 563 fXsizeReal = kDefaultCanvasSize;; 564 fYs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:17321,Load,Load,17321,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Load'],['Load']
Performance,"4 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:365688,queue,queue,365688,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['queue'],['queue']
Performance,"4 of file RooFFTConvPdf.h. ◆ clone(). TObject * RooFFTConvPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 34 of file RooFFTConvPdf.h. ◆ createCache(). RooFFTConvPdf::PdfCacheElem * RooFFTConvPdf::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Return specialized cache subclass for FFT calculations. ; Reimplemented from RooAbsCachedPdf.; Definition at line 342 of file RooFFTConvPdf.cxx. ◆ DeclFileName(). static const char * RooFFTConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 124 of file RooFFTConvPdf.h. ◆ evaluate(). double RooFFTConvPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 96 of file RooFFTConvPdf.h. ◆ fillCacheObject(). void RooFFTConvPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the contents of the cache the FFT convolution output. ; Implements RooAbsCachedPdf.; Definition at line 479 of file RooFFTConvPdf.cxx. ◆ fillCacheSlice(). void RooFFTConvPdf::fillCacheSlice ; (; FFTCacheElem & ; cache, . const RooArgSet & ; slicePosition . ); const. protected . Fill a slice of cachePdf with the output of the FFT convolution calculation. ; Definition at line 559 of file RooFFTConvPdf.cxx. ◆ genContext(). RooAbsGenContext * RooFFTConvPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Create appropriate generator context for this convolution. ; If both input p.d.f.s support internal generation, if it is safe to use them and if no observables other than the convolution observable are requested for generation, use the specialized convolution generator co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:90436,cache,cache,90436,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"4 of file THtml.h. ◆ GetXwho(). const TString & THtml::GetXwho ; (; ); const. inline . Definition at line 301 of file THtml.h. ◆ HaveDot(). Bool_t THtml::HaveDot ; (; ). Check whether dot is available in $PATH or in the directory set by SetDotPath() ; Definition at line 1411 of file THtml.cxx. ◆ HelperDeleted(). void THtml::HelperDeleted ; (; THtml::THelperBase * ; who). Inform the THtml object that one of its helper objects was deleted. ; Called by THtml::HelperBase::~HelperBase(). ; Definition at line 1438 of file THtml.cxx. ◆ IsA(). TClass * THtml::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 426 of file THtml.h. ◆ IsBatch(). Bool_t THtml::IsBatch ; (; ); const. inline . Definition at line 353 of file THtml.h. ◆ IsNamespace(). Bool_t THtml::IsNamespace ; (; const TClass * ; cl). static . Check whether cl is a namespace. ; Definition at line 2202 of file THtml.cxx. ◆ LoadAllLibs(). void THtml::LoadAllLibs ; (; ). static . Load all libraries known to ROOT via the rootmap system. ; Definition at line 2210 of file THtml.cxx. ◆ MakeAll(). void THtml::MakeAll ; (; Bool_t ; force = kFALSE, . const char * ; filter = ""*"", . int ; numthreads = 1 . ). Produce documentation for all the classes specified in the filter (by default ""*"") To process all classes having a name starting with XX, do: html.MakeAll(kFALSE,""XX*""); If force=kFALSE (default), only the classes that have been modified since the previous call to this function will be generated. ; If force=kTRUE, all classes passing the filter will be processed. If numthreads is != -1, use numthreads threads, else decide automatically based on the number of CPUs. ; Definition at line 2226 of file THtml.cxx. ◆ MakeClass() [1/2]. void THtml::MakeClass ; (; const char * ; className, . Bool_t ; force = kFALSE . ). Make HTML files for a single class. ; Input: className - name of the class to process ; Definition at line 2292 of file THtml.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml.html:48640,Load,LoadAllLibs,48640,doc/master/classTHtml.html,https://root.cern,https://root.cern/doc/master/classTHtml.html,2,['Load'],['LoadAllLibs']
Performance,"4 of file TProof.h. ◆ IsSync(). Bool_t TProof::IsSync ; (; ); const. inlineprivate . Definition at line 669 of file TProof.h. ◆ IsTty(). Bool_t TProof::IsTty ; (; ); const. inline . Definition at line 938 of file TProof.h. ◆ IsValid(). Bool_t TProof::IsValid ; (; ); const. inline . Definition at line 937 of file TProof.h. ◆ IsWaiting(). Bool_t TProof::IsWaiting ; (; ); const. inline . Definition at line 941 of file TProof.h. ◆ Load(). Int_t TProof::Load ; (; const char * ; macro, . Bool_t ; notOnClient = kFALSE, . Bool_t ; uniqueWorkers = kTRUE, . TList * ; wrks = 0 . ). virtual . Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ; The macro file is uploaded if new or updated. Additional files to be uploaded (or updated, if needed) can be specified after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"". If existing in the same directory, a header basename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. ◆ LoadPackage(). Int_t TProof::LoadPackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; loadopts = 0, . TList * ; workers = 0 . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:114333,load,load,114333,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['load'],"['load', 'loading']"
Performance,"4 of file TVirtualStreamerInfo.h. ◆ IsRecovered(). Int_t TVirtualStreamerInfo::IsRecovered ; (; ); const. inline . Definition at line 175 of file TVirtualStreamerInfo.h. ◆ ls(). virtual void TVirtualStreamerInfo::ls ; (; Option_t * ; option = """"); const. overridepure virtual . List TNamed name and title. ; Reimplemented from TNamed.; Implemented in TStreamerInfo. ◆ New(). virtual void * TVirtualStreamerInfo::New ; (; void * ; obj = nullptr). pure virtual . Implemented in TStreamerInfo. ◆ NewArray(). virtual void * TVirtualStreamerInfo::NewArray ; (; Long_t ; nElements, . void * ; ary = nullptr . ). pure virtual . Implemented in TStreamerInfo. ◆ NewInfo(). virtual TVirtualStreamerInfo * TVirtualStreamerInfo::NewInfo ; (; TClass * ; cl). pure virtual . Implemented in TStreamerInfo. ◆ operator=(). TVirtualStreamerInfo & TVirtualStreamerInfo::operator= ; (; const TVirtualStreamerInfo & ; info). protected . assignment operator ; Definition at line 60 of file TVirtualStreamerInfo.cxx. ◆ Optimize(). void TVirtualStreamerInfo::Optimize ; (; Bool_t ; opt = kTRUE). static . This is a static function. ; Set optimization option. When this option is activated (default), consecutive data members of the same type are merged into an array (faster). Optimization must be off in TTree split mode. ; Definition at line 167 of file TVirtualStreamerInfo.cxx. ◆ ResetIsCompiled(). void TVirtualStreamerInfo::ResetIsCompiled ; (; ). inlineprotected . Definition at line 60 of file TVirtualStreamerInfo.h. ◆ SetCanDelete(). void TVirtualStreamerInfo::SetCanDelete ; (; Bool_t ; opt = kTRUE). static . This is a static function. ; Set object delete option. When this option is activated (default), ReadBuffer automatically delete objects when a data member is a pointer to an object. If your constructor is not presetting pointers to 0, you must call this static function TStreamerInfo::SetCanDelete(kFALSE); ; Definition at line 220 of file TVirtualStreamerInfo.cxx. ◆ SetCheckSum(). virtual void TVirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:31378,Optimiz,Optimize,31378,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['Optimiz'],['Optimize']
Performance,"4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function. Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.; For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. The viewer indicates this through the interface method PreferLocalFrame(); TVirtualViewer3D::PreferLocalFramevirtual Bool_t PreferLocalFrame() const =0; If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. Scene Rebuilds; It sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:7858,perform,perform,7858,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,2,['perform'],"['perform', 'performance']"
Performance,"4#endif; 19095 ; 19096 worker_thread_run((struct mg_connection *)thread_func_param);; 19097 return NULL;; 19098}; 19099#endif /* _WIN32 */; 19100 ; 19101 ; 19102/* This is an internal function, thus all arguments are expected to be; 19103 * valid - a NULL check is not required. */; 19104static void; 19105accept_new_connection(const struct socket *listener, struct mg_context *ctx); 19106{; 19107 struct socket so;; 19108 char src_addr[IP_ADDR_STR_LEN];; 19109 socklen_t len = sizeof(so.rsa);; 19110#if !defined(__ZEPHYR__); 19111 int on = 1;; 19112#endif; 19113 memset(&so, 0, sizeof(so));; 19114 ; 19115 if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)); 19116 == INVALID_SOCKET) {; 19117 } else if (check_acl(ctx, &so.rsa) != 1) {; 19118 sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);; 19119 mg_cry_ctx_internal(ctx,; 19120 ""%s: %s is not allowed to connect"",; 19121 __func__,; 19122 src_addr);; 19123 closesocket(so.sock);; 19124 } else {; 19125 /* Put so socket structure into the queue */; 19126 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19127 set_close_on_exec(so.sock, NULL, ctx);; 19128 so.is_ssl = listener->is_ssl;; 19129 so.ssl_redir = listener->ssl_redir;; 19130 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19131 mg_cry_ctx_internal(ctx,; 19132 ""%s: getsockname() failed: %s"",; 19133 __func__,; 19134 strerror(ERRNO));; 19135 }; 19136 ; 19137#if !defined(__ZEPHYR__); 19138 if ((so.lsa.sa.sa_family == AF_INET); 19139 || (so.lsa.sa.sa_family == AF_INET6)) {; 19140 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19141 * This is needed because if HTTP-level keep-alive; 19142 * is enabled, and client resets the connection, server won't get; 19143 * TCP FIN or RST and will keep the connection open forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:569733,queue,queue,569733,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7f45240 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x84ccbe0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[mean]_Norm[mean,x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[mean]_Norm[mean,x]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.2; sigma=0.5, [#0] WARNING:Eval -- The FFT convolution '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:5513,cache,cache,5513,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,1,['cache'],['cache']
Performance,"4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TROOT.h""; 14#include ""TBuffer.h""; 15#include ""TGraphErrors.h""; 16#include ""TStyle.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21#include ""TVectorD.h""; 22#include ""TSystem.h""; 23#include ""strtok.h""; 24 ; 25#include <iostream>; 26#include <fstream>; 27#include <cstring>; 28#include <string>; 29 ; 30ClassImp(TGraphErrors);; 31 ; 32 ; 33////////////////////////////////////////////////////////////////////////////////; 34 ; 35/** \class TGraphErrors; 36 \ingroup Graphs; 37A TGraphErrors is a TGraph with error bars.; 38 ; 39The TGraphErrors painting is performed thanks to the TGraphPainter; 40class. All details about the various painting options are given in this class.; 41 ; 42The picture below gives an example:; 43 ; 44Begin_Macro(source); 45{; 46 auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; 47 c1->SetFillColor(42);; 48 c1->SetGrid();; 49 c1->GetFrame()->SetFillColor(21);; 50 c1->GetFrame()->SetBorderSize(12);; 51 const Int_t n = 10;; 52 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 53 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 54 Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 55 Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 56 auto gr = new TGraphErrors(n,x,y,ex,ey);; 57 gr->SetTitle(""TGraphErrors Example"");; 58 gr->SetMarkerColor(4);; 59 gr->SetMarkerStyle(21);; 60 gr->Draw(""ALP"");; 61}; 62End_Macro; 63*/; 64 ; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// TGraphErrors default constructor.; 68 ; 69",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:1245,perform,performed,1245,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['perform'],['performed']
Performance,"4/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456///////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:214880,cache,cacheSize,214880,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],"['cacheFactor', 'cacheSize']"
Performance,"4000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  ~TBufferIO () override;  destructor ;  ; Bool_t CheckObject (const TObject *obj) override;  Check if the specified object is already in the buffer. ;  ; Bool_t CheckObject (const void *obj, const TClass *ptrClass) override;  Check if the specified object of the specified class is already in the buffer. ;  ; void ForceWriteInfo (TVirtualStreamerInfo *info, Bool_t force) override;  force writing the TStreamerInfo to the file ;  ; void ForceWriteInfoClones (TClonesArray *a) override;  Make sure TStreamerInfo is not optimized, otherwise it will not be possible to support schema evolution in read mode. ;  ; Int_t GetBufferDisplacement () const override;  ; TProcessID * GetLastProcessID (TRefTable *reftable) const override;  Return the last TProcessID in the file. ;  ; Int_t GetMapCount () const override;  ; void GetMappedObject (UInt_t tag, void *&ptr, TClass *&ClassPtr) const override;  Retrieve the object stored in the buffer's object map at 'tag' Set ptr and ClassPtr respectively to the address of the object and a pointer to its TClass. ;  ; UShort_t GetPidOffset () const override;  ; UInt_t GetTRefExecId () override;  Return the exec id stored in the current TStreamerInfo element. ;  ; Int_t GetVersionOwner () const override;  Return the version number of the owner file. ;  ; void InitMap () override;  Create the fMap container and initialize them with the null object. ;  ; TClass * IsA () const override;  ; void MapObject (const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:2252,optimiz,optimized,2252,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['optimiz'],['optimized']
Performance,"41 (0.758); : dataset FDA_GA : 0.118 (0.127) 0.428 (0.468) 0.721 (0.745); : dataset Likelihood : 0.082 (0.096) 0.388 (0.415) 0.690 (0.695); : -------------------------------------------------------------------------------------------------------------------; : ; Dataset:dataset : Created tree 'TestTree' with 10000 events; : ; Dataset:dataset : Created tree 'TrainTree' with 2000 events; : ; Factory : ␛[1mThank you for using TMVA!␛[0m; : ␛[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.html␛[0m; ==> Wrote root file: TMVAC.root; ==> TMVAClassification is done!; (int) 0; ; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; ; int TMVAClassification( TString myMethodList = """" ); {; // The explicit loading of the shared libTMVA is done in TMVAlogon.C, defined in .rootrc; // if you use your private .rootrc, or run from a different directory, please copy the; // corresponding lines from .rootrc; ; // Methods to be processed can be given as an argument; use format:; //; // mylinux~> root -l TMVAClassification.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:81012,load,loading,81012,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['load'],['loading']
Performance,"41 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAnd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:79595,load,load,79595,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['load']
Performance,"41 meminfo->fMemBuffer = (s.Atoi() / 1024);; 5242 }; 5243 if (s.BeginsWith(""Shmem"")) {; 5244 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5245 meminfo->fMemShared = (s.Atoi() / 1024);; 5246 }; 5247 if (s.BeginsWith(""SwapTotal"")) {; 5248 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5249 meminfo->fSwapTotal = (s.Atoi() / 1024);; 5250 }; 5251 if (s.BeginsWith(""SwapFree"")) {; 5252 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5253 meminfo->fSwapFree = (s.Atoi() / 1024);; 5254 }; 5255 if (s.BeginsWith(""SwapCached"")) {; 5256 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5257 meminfo->fSwapCached = (s.Atoi() / 1024);; 5258 }; 5259 if (s.BeginsWith(""SReclaimable"")) {; 5260 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5261 meminfo->fSReclaimable = (s.Atoi() / 1024);; 5262 }; 5263 ; 5264 }; 5265 fclose(f);; 5266 ; 5267 /*; 5268 * Compute memory partition like procps(free), see https://gitlab.com/procps-ng/procps/-/blob/master/proc/sysinfo.c; 5269 * ; 5270 * fMemShared is a part of Cached (see https://lore.kernel.org/patchwork/patch/648763/), does not subtract twice from used; 5271 */; 5272 ; 5273 meminfo->fMemCached = meminfo->fMemCached + meminfo->fSReclaimable - meminfo->fMemShared;; 5274 const Int_t usedDiff = meminfo->fMemFree + meminfo->fMemCached + meminfo->fSReclaimable + meminfo->fMemBuffer;; 5275 ; 5276 meminfo->fMemUsed = (meminfo->fMemTotal >= usedDiff) ? meminfo->fMemTotal - usedDiff : meminfo->fMemTotal - meminfo->fMemFree;; 5277 meminfo->fMemAvailable = meminfo->fMemAvailable != 0 ? std::min(meminfo->fMemAvailable, meminfo->fMemTotal) : meminfo->fMemFree;; 5278 ; 5279 meminfo->fSwapUsed = meminfo->fSwapTotal - meminfo->fSwapFree - meminfo->fSwapCached;; 5280 ; 5281}; 5282 ; 5283////////////////////////////////////////////////////////////////////////////////; 5284/// Get process info for this process on Linux.; 5285 ; 5286static void GetLinuxProcInfo(ProcInfo_t *procinfo); 5287{; 5288 struct rusage ru;; 5289 if (getrusage(RUSAGE_SELF, &ru) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:170650,Cache,Cached,170650,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['Cache'],['Cached']
Performance,"42 ; 43 // Create a new RNTupleImporter object.; 44 auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; 45 ; 46 // Begin importing.; 47 importer->Import();; 48 ; 49 // Inspect the schema of the written RNTuple.; 50 auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; 51 if (!file || file->IsZombie()) {; 52 std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; 53 return;; 54 }; 55 auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; 56 auto reader = RNTupleReader::Open(*ntpl);; 57 reader->PrintInfo();; 58 ; 59 ROOT::RDataFrame df(""Events"", kNTupleFileName);; 60 df.Histo1D({""Jet_pt"", ""Jet_pt"", 100, 0, 0}, ""Jet_pt"")->DrawCopy();; 61}; RNTupleDS.hxx; RNTupleImporter.hxx; RNTupleReader.hxx; RPageStorageFile.hxx; TFile.h; TROOT.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::Experimental::RNTupleImporterConverts a TTree into an RNTuple.Definition RNTupleImporter.hxx:103; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539. tutorialsv7ntuplentpl008_import.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl008__import_8C_source.html:3406,multi-thread,multi-threading,3406,doc/master/ntpl008__import_8C_source.html,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C_source.html,1,['multi-thread'],['multi-threading']
Performance,"42 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:141136,cache,cacheSizeStr,141136,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cacheSizeStr']
Performance,"435 {; 436#ifdef R__USE_IMT; 437 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableParBranchProcessing"");; 438 if (sym); 439 sym();; 440#else; 441 ::Warning(""DisableParBranchProcessing"", ""Cannot disable parallel branch processing, please build ROOT with -Dimt=ON"");; 442#endif; 443 }; 444 ; 445 //////////////////////////////////////////////////////////////////////////////; 446 /// Returns true if parallel branch processing is enabled.; 447 Bool_t IsParBranchProcessingEnabled(); 448 {; 449#ifdef R__USE_IMT; 450 static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:16272,load,load,16272,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMode;; 4354 bool oldValueDirty;; 4355 bool oldShapeDirty;; 4356 };; 4357 std::vector<ServerData> ourServers;; 4358 ourServers.reserve(servers().size());; 4359 ; 4360 for (auto server : servers()) {; 4361 auto serverValues = ctx.at(server);; 4362 if(serverValues.empty()) continue;; 4363 ; 4364 // maybe we are still missing inhibit dirty here; 4365 auto oldOperMode = server->operMode();; 4366 // See note at the bottom of this function to learn why we can only set; 4367 // the operation mode to ""always clean"" if there are no other value; 4368 // clients.; 4369 server->setOperMode(RooAbsArg::AClean);; 4370 ourServers.push_back({server,; 4371 serverValues,; 4372 server->isCategory() ? static_cast<RooAbsCategory const*>(server)->getCurrentIndex() : static_cast<RooAbsReal const*>(server)->_value,; 4373 oldOperMode,; 4374 server->_valueDirty,; 4375 server->_shapeDirty});; 4376 // Prevent the server from evaluating; just return cached result, which we will side load:; 4377 }; 4378 ; 4379 ; 4380 // Make sure that we restore all state when we finish:; 4381 struct RestoreStateRAII {; 4382 RestoreStateRAII(std::vector<ServerData>& servers) :; 4383 _servers{servers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:193009,cache,cached,193009,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['cache', 'load']","['cached', 'load']"
Performance,"4395 of file TCling.cxx. ◆ LoadFile(). int TCling::LoadFile ; (; const char * ; path); const. finalvirtual . Load a source file or library called path into the interpreter. ; Reimplemented from TInterpreter.; Definition at line 7500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to load a PCM from TFile; returns true on success. ; Definition at line 1696 of file TCling.cxx. ◆ LoadText(). Bool_t TCling::LoadText ; (; const char * ; text); const. finalvirtual . Load the declarations from text into the interpreter. ; Note that this cannot be (top level) statements; text must contain top level declarations. Returns true on success, false on failure. ; Reimplemented from TInterpreter.; Definition at line 7515 of file TCling.cxx. ◆ MakeInterpreterValue(). std::unique_ptr< TInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:114084,Load,LoadMacro,114084,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadMacro']
Performance,"43void TMVA::Factory::SetVerbose(Bool_t v); 344{; 345 fVerbose = v;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Book a classifier or regression method.; 350 ; 351TMVA::MethodBase *; 352TMVA::Factory::BookMethod(TMVA::DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption); 353{; 354 if (fModelPersistence); 355 gSystem->MakeDirectory(loader->GetName()); // creating directory for DataLoader output; 356 ; 357 TString datasetname = loader->GetName();; 358 ; 359 if (fAnalysisType == Types::kNoAnalysisType) {; 360 if (loader->GetDataSetInfo().GetNClasses() == 2 && loader->GetDataSetInfo().GetClassInfo(""Signal"") != NULL &&; 361 loader->GetDataSetInfo().GetClassInfo(""Background"") != NULL) {; 362 fAnalysisType = Types::kClassification; // default is classification; 363 } else if (loader->GetDataSetInfo().GetNClasses() >= 2) {; 364 fAnalysisType = Types::kMulticlass; // if two classes, but not named ""Signal"" and ""Background""; 365 } else; 366 Log() << kFATAL << ""No analysis type for "" << loader->GetDataSetInfo().GetNClasses() << "" classes and ""; 367 << loader->GetDataSetInfo().GetNTargets() << "" regression targets."" << Endl;; 368 }; 369 ; 370 // booking via name; the names are translated into enums and the; 371 // corresponding overloaded BookMethod is called; 372 ; 373 if (fMethodsMap.find(datasetname) != fMethodsMap.end()) {; 374 if (GetMethod(datasetname, methodTitle) != 0) {; 375 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 376 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 377 }; 378 }; 379 ; 380 Log() << kHEADER << ""Booking method: "" << gTools().Color(""bold""); 381 << methodTitle; 382 // << gTools().Color(""reset"")<<"" DataSet Name: ""<<gTools().Color(""bold"")<<loader->GetName(); 383 << gTools().Color(""reset"") << Endl << Endl;; 384 ; 385 // interpret option string with respect to a request for boosting (i.e., BostN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:14558,load,loader,14558,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"4459 }; 4460 if (!comma) break;; 4461 cuts = comma+1;; 4462 }; 4463 for (i=0;i<=nch;i++) left[i] = ' ';; 4464 return fNcuts;; 4465}; 4466 ; 4467////////////////////////////////////////////////////////////////////////////////; 4468/// [Control routine to paint any kind of histograms](\ref HP00); 4469 ; 4470void THistPainter::Paint(Option_t *option); 4471{; 4472 ; 4473 if (fH->GetBuffer()) fH->BufferEmpty(-1);; 4474 ; 4475 //For iOS: put the histogram on the top of stack of pickable objects.; 4476 const TPickerStackGuard topPush(fH);; 4477 ; 4478 gPad->SetVertical(kTRUE);; 4479 ; 4480 TH1 *oldhist = gCurrentHist;; 4481 gCurrentHist = fH;; 4482 TH1 *hsave = fH;; 4483 Double_t minsav = fH->GetMinimumStored();; 4484 ; 4485 if (!MakeChopt(option)) return; //check options and fill Hoption structure; 4486 ; 4487 // Paint using TSpectrum2Painter; 4488 if (Hoption.Spec) {; 4489 if (!TableInit()) return;; 4490 if (!TClass::GetClass(""TSpectrum2Painter"")) gSystem->Load(""libSpectrumPainter"");; 4491 gROOT->ProcessLineFast(TString::Format(""TSpectrum2Painter::PaintSpectrum((TH2F*)0x%zx,\""%s\"",%d)"",; 4492 (size_t)fH, option, Hoption.Spec).Data());; 4493 return;; 4494 }; 4495 ; 4496 // Deflate the labels in case of alphanumeric labels; 4497 if (fXaxis->CanExtend() && fXaxis->IsAlphanumeric()) fH->LabelsDeflate(""X"");; 4498 if (fYaxis->CanExtend() && fYaxis->IsAlphanumeric()) fH->LabelsDeflate(""Y"");; 4499 if (fZaxis->CanExtend() && fZaxis->IsAlphanumeric()) fH->LabelsDeflate(""Z"");; 4500 ; 4501 if (Hoption.Pie) {; 4502 if (fH->GetDimension() == 1) {; 4503 if (!fPie); 4504 fPie = std::make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:171030,Load,Load,171030,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['Load'],['Load']
Performance,"45 li->fPayloadCode,; 2146 li->fFwdDeclCode,; 2147 li->fTriggerFunc,; 2148 li->fFwdNargsToKeepColl,; 2149 li->fClassesHeaders,; 2150 kTRUE /*lateRegistration*/,; 2151 li->fHasCxxModule);; 2152 }; 2153 GetModuleHeaderInfoBuffer().clear();; 2154 ; 2155 fInterpreter->Initialize();; 2156}; 2157 ; 2158////////////////////////////////////////////////////////////////////////////////; 2159/// Helper function used by TClass::GetClass().; 2160/// This function attempts to load the dictionary for 'classname'; 2161/// either from the TClassTable or from the list of generator.; 2162/// If silent is 'true', do not warn about missing dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:82781,Load,LoadClass,82781,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['Load'],['LoadClass']
Performance,"45 of file TH1Merger.cxx. ◆ MergeBin() [1/4]. void TH1Merger::MergeBin ; (; const TH1 * ; hist, . Int_t ; inbin, . Int_t ; outbin . ). private . Definition at line 1132 of file TH1Merger.cxx. ◆ MergeBin() [2/4]. void TH1Merger::MergeBin ; (; const TProfile * ; hist, . Int_t ; inbin, . Int_t ; outbin . ). inlineprivate . Definition at line 129 of file TH1Merger.h. ◆ MergeBin() [3/4]. void TH1Merger::MergeBin ; (; const TProfile2D * ; hist, . Int_t ; inbin, . Int_t ; outbin . ). inlineprivate . Definition at line 130 of file TH1Merger.h. ◆ MergeBin() [4/4]. void TH1Merger::MergeBin ; (; const TProfile3D * ; hist, . Int_t ; inbin, . Int_t ; outbin . ). inlineprivate . Definition at line 131 of file TH1Merger.h. ◆ MergeProfileBin(). template<class TProfileType > . void TH1Merger::MergeProfileBin ; (; const TProfileType * ; p, . Int_t ; ibin, . Int_t ; outbin . ). private . Definition at line 1154 of file TH1Merger.cxx. ◆ operator()(). Bool_t TH1Merger::operator() ; (; ). Function performing the actual merge. ; Definition at line 27 of file TH1Merger.cxx. ◆ SameAxesMerge(). Bool_t TH1Merger::SameAxesMerge ; (; ). private . Definition at line 755 of file TH1Merger.cxx. Member Data Documentation. ◆ fH0. TH1* TH1Merger::fH0. private . Definition at line 139 of file TH1Merger.h. ◆ fHClone. TH1* TH1Merger::fHClone. private . histogram on which the list is merged ; Definition at line 140 of file TH1Merger.h. ◆ fInputList. TList TH1Merger::fInputList. private . copy of fH0 - managed by this class ; Definition at line 141 of file TH1Merger.h. ◆ fIsProfile1D. Bool_t TH1Merger::fIsProfile1D = kFALSE. private . Definition at line 136 of file TH1Merger.h. ◆ fIsProfile2D. Bool_t TH1Merger::fIsProfile2D = kFALSE. private . Definition at line 137 of file TH1Merger.h. ◆ fIsProfile3D. Bool_t TH1Merger::fIsProfile3D = kFALSE. private . Definition at line 138 of file TH1Merger.h. ◆ fIsProfileMerge. Bool_t TH1Merger::fIsProfileMerge = kFALSE. private . Definition at line 135 of file TH1Merg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Merger.html:8752,perform,performing,8752,doc/master/classTH1Merger.html,https://root.cern,https://root.cern/doc/master/classTH1Merger.html,1,['perform'],['performing']
Performance,"453 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 443 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 424 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooAbsTestStatistic, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, and RooProjectedPdf.; Definition at line 4550 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 384 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:144911,cache,caches,144911,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['caches']
Performance,"455 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 445 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 426 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsTestStatistic, and RooProjectedPdf.; Definition at line 4474 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 377 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:143074,cache,caches,143074,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['caches']
Performance,"46 fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));; 5847 fMapfile->IgnoreDuplicates(ignore);; 5848 }; 5849 }; 5850 TEnvRec* rec;; 5851 TIter next(fMapfile->GetTable());; 5852 while ((rec = (TEnvRec*) next())) {; 5853 TString cls = rec->GetName();; 5854 if (!strncmp(cls.Data(), ""Library."", 8) && cls.Length() > 8) {; 5855 // get the first lib from the list of lib and dependent libs; 5856 TString libs = rec->GetValue();; 5857 if (libs == """") {; 5858 continue;; 5859 }; 5860 TString delim("" "");; 5861 TObjArray* tokens = libs.Tokenize(delim);; 5862 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 5863 // convert ""@@"" to ""::"", we used ""@@"" because TEnv; 5864 // considers ""::"" a terminator; 5865 cls.Remove(0, 8);; 5866 cls.ReplaceAll(""@@"", ""::"");; 5867 // convert ""-"" to "" "", since class names may have; 5868 // blanks and TEnv considers a blank a terminator; 5869 cls.ReplaceAll(""-"", "" "");; 5870 if (gDebug > 6) {; 5871 const char* wlib = gSystem->DynamicPathName(lib, kTRUE);; 5872 if (wlib) {; 5873 Info(""LoadLibraryMap"", ""class %s in %s"", cls.Data(), wlib);; 5874 }; 5875 else {; 5876 Info(""LoadLibraryMap"", ""class %s in %s (library does not exist)"", cls.Data(), lib);; 5877 }; 5878 delete[] wlib;; 5879 }; 5880 delete tokens;; 5881 }; 5882 else if (!strncmp(cls.Data(), ""Declare."", 8) && cls.Length() > 8) {; 5883 cls.Remove(0, 8);; 5884 // convert ""-"" to "" "", since class names may have; 5885 // blanks and TEnv considers a blank a terminator; 5886 cls.ReplaceAll(""-"", "" "");; 5887 fInterpreter->declare(cls.Data());; 5888 }; 5889 }; 5890 ; 5891 // Process the forward declarations collected; 5892 cling::Transaction* T = nullptr;; 5893 auto compRes= fInterpreter->declare(uniqueString.Data(), &T);; 5894 assert(cling::Interpreter::kSuccess == compRes && ""A declaration in a rootmap could not be compiled"");; 5895 ; 5896 if (compRes!=cling::Interpreter::kSuccess){; 5897 Warning(""LoadLibraryMap"",; 5898 ""Problems in %s declaring '%s' were encountered."",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:228332,Load,LoadLibraryMap,228332,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"460 // This will be set at the lastest during TROOT construction, so before; 461 // any threading could happen.; 462 if (!gClassTable); 463 new TClassTable;; 464 ; 465 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 466 ; 467 // By definition the name in the TProtoClass is (must be) the normalized; 468 // name, so there is no need to tweak it.; 469 const char *cname = proto->GetName();; 470 ; 471 // check if already in table, if so return; 472 TClassRec *r = FindElement(cname, kTRUE);; 473 if (r->fName) {; 474 if (r->fProto) delete r->fProto;; 475 r->fProto = proto;; 476 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 477 ; 478 lock.unlock(); // FillTClass might recursively call TClassTable during gROOT init; 479 if (oldcl && oldcl->GetState() == TClass::kHasTClassInit); 480 proto->FillTClass(oldcl);; 481 return;; 482 } else if (ROOT::Internal::gROOTLocal && gCling) {; 483 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 484 if (oldcl) { // && oldcl->GetClassInfo()) {; 485 // As a work-around to ROOT-6012, we need to register the class even if; 486 // it is not a template instance, because a forward declaration in the header; 487 // files loaded by the current dictionary wil also de-activate the update; 488 // class info mechanism!; 489 ; 490 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 491 ::Warning(""TClassTable::Add(TProtoClass*)"",""Called for existing class without a prior call add the dictionary function."");; 492 }; 493 }; 494 ; 495 r->fName = StrDup(cname);; 496 r->fId = 0;; 497 r->fBits = 0;; 498 r->fDict = nullptr;; 499 r->fInfo = nullptr;; 500 r->fProto= proto;; 501 ; 502 fgSorted = kFALSE;; 503}; 504 ; 505////////////////////////////////////////////////////////////////////////////////; 506 ; 507ROOT::TClassAlt* TClassTable::AddAlternate(const char *normName, const char *alternate); 508{; 509 // This will be set at the lastest during TROOT construction, so before; 510 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:16276,load,loaded,16276,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['load'],['loaded']
Performance,"46; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1283; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:139; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:38510,perform,performed,38510,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['perform'],['performed']
Performance,"471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Create timer which will invoke ProcessRequests() function periodically; 475///; 476/// Timer is required to perform all actions in main ROOT thread; 477/// Method arguments are the same as for TTimer constructor; 478/// By default, sync timer with 100 ms period is created; 479///; 480/// It is recommended to always use sync timer mode and only change period to; 481/// adjust server reaction time. Use of async timer requires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any glo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:16185,multi-thread,multi-threaded,16185,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['multi-thread'],['multi-threaded']
Performance,"480 static const int bufsize = 260;; 3481 char posixwindir[bufsize];; 3482 char *windir = getenv(""WINDIR"");; 3483 if (windir); 3484 cygwin_conv_path(CCP_WIN_A_TO_POSIX, windir, posixwindir, bufsize);; 3485 else; 3486 snprintf(posixwindir, sizeof(posixwindir), ""/Windows/"");; 3487 if (strstr(filename, posixwindir) ||; 3488 strstr(filename, ""/usr/bin/cyg"")); 3489 return;; 3490#elif defined(R__WIN32); 3491 if (strstr(filename, ""/Windows/"")); 3492 return;; 3493#elif defined (R__LINUX); 3494 if (strstr(filename, ""/ld-linux""); 3495 || strstr(filename, ""linux-gnu/""); 3496 || strstr(filename, ""/libstdc++.""); 3497 || strstr(filename, ""/libgcc""); 3498 || strstr(filename, ""/libc.""); 3499 || strstr(filename, ""/libdl.""); 3500 || strstr(filename, ""/libm."")); 3501 return;; 3502#endif; 3503 // Update string of available libraries.; 3504 if (!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 35",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:136434,Load,Load,136434,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['Load']
Performance,"4850 ; 4851static void GetDarwinSysInfo(SysInfo_t *sysinfo); 4852{; 4853 FILE *p = gSystem->OpenPipe(""sysctl -n kern.ostype hw.model hw.ncpu hw.cpufrequency ""; 4854 ""hw.busfrequency hw.l2cachesize hw.memsize"", ""r"");; 4855 TString s;; 4856 s.Gets(p);; 4857 sysinfo->fOS = s;; 4858 s.Gets(p);; 4859 sysinfo->fModel = s;; 4860 s.Gets(p);; 4861 sysinfo->fCpus = s.Atoi();; 4862 s.Gets(p);; 4863 Long64_t t = s.Atoll();; 4864 sysinfo->fCpuSpeed = Int_t(t / 1000000);; 4865 s.Gets(p);; 4866 t = s.Atoll();; 4867 sysinfo->fBusSpeed = Int_t(t / 1000000);; 4868 s.Gets(p);; 4869 sysinfo->fL2Cache = s.Atoi() / 1024;; 4870 s.Gets(p);; 4871 t = s.Atoll();; 4872 sysinfo->fPhysRam = Int_t(t / 1024 / 1024);; 4873 gSystem->ClosePipe(p);; 4874 p = gSystem->OpenPipe(""hostinfo"", ""r"");; 4875 while (s.Gets(p)) {; 4876 if (s.BeginsWith(""Processor type: "")) {; 4877 TPRegexp(""Processor type: ([^ ]+).*"").Substitute(s, ""$1"");; 4878 sysinfo->fCpuType = s;; 4879 }; 4880 }; 4881 gSystem->ClosePipe(p);; 4882}; 4883 ; 4884////////////////////////////////////////////////////////////////////////////////; 4885/// Get CPU load on Mac OS X.; 4886 ; 4887static void ReadDarwinCpu(long *ticks); 4888{; 4889 mach_msg_type_number_t count;; 4890 kern_return_t kr;; 4891 host_cpu_load_info_data_t cpu;; 4892 ; 4893 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 4894 ; 4895 count = HOST_CPU_LOAD_INFO_COUNT;; 4896 kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&cpu, &count);; 4897 if (kr != KERN_SUCCESS) {; 4898 ::Error(""TUnixSystem::ReadDarwinCpu"", ""host_statistics: %s"", mach_error_string(kr));; 4899 } else {; 4900 ticks[0] = cpu.cpu_ticks[CPU_STATE_USER];; 4901 ticks[1] = cpu.cpu_ticks[CPU_STATE_SYSTEM];; 4902 ticks[2] = cpu.cpu_ticks[CPU_STATE_IDLE];; 4903 ticks[3] = cpu.cpu_ticks[CPU_STATE_NICE];; 4904 }; 4905}; 4906 ; 4907////////////////////////////////////////////////////////////////////////////////; 4908/// Get CPU stat for Mac OS X. Use sampleTime to set the interval over which; 4909///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:157023,load,load,157023,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['load']
Performance,"493 ; 1494 if (debugFirstEpoch); 1495 std::cout << ""- doing backward \n"";; 1496 ; 1497#ifdef DEBUG; 1498 size_t nlayers = deepNet.GetLayers().size();; 1499 for (size_t l = 0; l < nlayers; ++l) {; 1500 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0); 1501 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),; 1502 TString::Format(""initial weights layer %d"", l).Data());; 1503 ; 1504 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetOutput(),; 1505 TString::Format(""output tensor layer %d"", l).Data());; 1506 }; 1507#endif; 1508 ; 1509 //Architecture_t::PrintTensor(deepNet.GetLayerAt(nlayers-1)->GetOutput(),""output tensor last layer"" );; 1510 ; 1511 deepNet.Backward(my_batch.GetInput(), my_batch.GetOutput(), my_batch.GetWeights());; 1512 ; 1513 if (debugFirstEpoch); 1514 std::cout << ""- doing optimizer update \n"";; 1515 ; 1516 // increment optimizer step that is used in some algorithms (e.g. ADAM); 1517 optimizer->IncrementGlobalStep();; 1518 optimizer->Step();; 1519 ; 1520#ifdef DEBUG; 1521 std::cout << ""minmimizer step - momentum "" << settings.momentum << "" learning rate "" << optimizer->GetLearningRate() << std::endl;; 1522 for (size_t l = 0; l < nlayers; ++l) {; 1523 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0) {; 1524 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),TString::Format(""weights after step layer %d"",l).Data());; 1525 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightGradientsAt(0),""weight gradients"");; 1526 }; 1527 }; 1528#endif; 1529 ; 1530 }; 1531 ; 1532 if (debugFirstEpoch) std::cout << ""\n End batch loop - compute validation loss \n"";; 1533 //}; 1534 debugFirstEpoch = false;; 1535 if ((nTrainEpochs % settings.testInterval) == 0) {; 1536 ; 1537 std::chrono::time_point<std::chrono::system_clock> t1,t2;; 1538 ; 1539 t1 = std::chrono::system_clock::now();; 1540 ; 1541 // Compute validation error.; 1542 ; 1543 ; 1544 Double_t valError = 0.0;; 1545 bool inTraining = false;; 1546 for (auto batch : vali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:60232,optimiz,optimizer,60232,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],['optimizer']
Performance,4931.9 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 18947.1 will supersede previous event count of 11104.6 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 30765.5 will supersede previous event count of 18947.1 for normalization of PDF projections; [#0] PROGRESS:Caching -- creating cache from getCache function for 0xa7ee9d0; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_SM_NPsq0_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_cHq3_NPsq1_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_cHq3_NPsq2_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); [#0] PROGRESS:Caching -- creating cache from getCache function for 0xa8c24c0; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_SM_NPsq0_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_cHq3_NPsq1_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_cHq3_NPsq2_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); DateJanuary 2022 ; AuthorRahul Balasubramanian ; Definition in file rf711_lagrangianmorph.py. tutorialsroofitrf711_lagrangianmorph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html:7757,cache,cache,7757,doc/master/rf711__lagrangianmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html,2,['cache'],['cache']
Performance,"4PdfBinding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4Ref<double,double,double,double,bool> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,double> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,int> Persistable reference to C function pointer; RooCacheManager<RooAbsCacheElement> Cache Manager class generic objects; RooCacheManager<vector<double,allocator<double> > > Cache Manager class generic objects; RooCachedPdf P.d.f class that wraps another p.d.f and caches its output ; RooCachedReal P.d.f class that wraps another p.d.f and caches its output ; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit ; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:30984,cache,caches,30984,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['cache'],['caches']
Performance,"4PdfBinding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4Ref<double,double,double,double,bool> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,double> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,int> Persistable reference to C function pointer; RooCacheManager<RooAbsCacheElement> Cache Manager class generic objects; RooCacheManager<vector<double,allocator<double> > > Cache Manager class generic objects; RooCachedPdf P.d.f class that wraps another p.d.f and caches its output ; RooCachedReal P.d.f class that wraps another p.d.f and caches its output ; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit ; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for use in RooPlots; RooCustomizer Editing tool for R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:30873,cache,caches,30873,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['cache'],['caches']
Performance,4_t* TTreeCloner::fBasketEntry. private . [fMaxBaskets] list of basket start entries. ; Definition at line 50 of file TTreeCloner.h. ◆ fBasketIndex. UInt_t* TTreeCloner::fBasketIndex. private . [fMaxBaskets] ordered list of basket indices to be written. ; Definition at line 51 of file TTreeCloner.h. ◆ fBasketNum. UInt_t* TTreeCloner::fBasketNum. private . [fMaxBaskets] index of the basket within the branch. ; Definition at line 47 of file TTreeCloner.h. ◆ fBasketSeek. Long64_t* TTreeCloner::fBasketSeek. private . [fMaxBaskets] list of basket position to be read. ; Definition at line 49 of file TTreeCloner.h. ◆ fCacheSize. Long64_t TTreeCloner::fCacheSize. private . Requested size of the file cache. ; Definition at line 58 of file TTreeCloner.h. ◆ fCloneMethod. UInt_t TTreeCloner::fCloneMethod. private . Indicates which cloning method was selected. ; Definition at line 55 of file TTreeCloner.h. ◆ fFileCache. TFileCacheRead* TTreeCloner::fFileCache. private . File Cache used to reduce the number of individual reads. ; Definition at line 59 of file TTreeCloner.h. ◆ fFromBranches. TObjArray TTreeCloner::fFromBranches. private . Definition at line 42 of file TTreeCloner.h. ◆ fFromTree. TTree* TTreeCloner::fFromTree. private . Definition at line 37 of file TTreeCloner.h. ◆ fIsValid. bool TTreeCloner::fIsValid. private . Definition at line 34 of file TTreeCloner.h. ◆ fMaxBaskets. UInt_t TTreeCloner::fMaxBaskets. private . Definition at line 45 of file TTreeCloner.h. ◆ fMethod. Option_t* TTreeCloner::fMethod. private . Definition at line 41 of file TTreeCloner.h. ◆ fNeedConversion. bool TTreeCloner::fNeedConversion. private . True if the fast merge is not possible but a slow merge might possible. ; Definition at line 35 of file TTreeCloner.h. ◆ fOptions. UInt_t TTreeCloner::fOptions. private . Definition at line 36 of file TTreeCloner.h. ◆ fPidOffset. UShort_t TTreeCloner::fPidOffset. private . Offset to be added to the copied key/basket. ; Definition at line 53 of file TTr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:13598,Cache,Cache,13598,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['Cache'],['Cache']
Performance,4_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:11783,cache,cached,11783,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,1,['cache'],['cached']
Performance,"4_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 623 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char * ; name). overridevirtual . Change the name of this tree. ; Reimplemented from TNamed.; Definition at line 9195 of file TTree.cxx. ◆ SetNotify(). void TTree::SetNotify ; (; TObject * ; obj). virtual . Sets the address of the object to be notified when the tree is loaded. ; The method TObject::Notify is called for the given object when the tree is loaded. Specifically this occurs in the TTree::LoadTree method. To remove the notification call this method with nullptr: tree->SetNotify(nullptr); ; If this is a TChain, obj is most often going to be a TNotifyLink.; Parameters. [in]objPointer to a TObject to be notified. . Definition at line 9221 of file TTree.cxx. ◆ SetObject(). void TTree::SetObject ; (; const char * ; name, . const char * ; title . ). virtual . Change the name and title of this tree. ; Definition at line 9250 of file TTree.cxx. ◆ SetParallelUnzip(). void TTree::SetParallelUnzip ; (; bool ; opt = true, . Float_t ; RelSize = -1 . ). virtual . Enable or disable parallel unzipping of Tree buffers. ; Definition at line 9281 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9319 of file TTree.cxx. ◆ SetScanField(). vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:215340,load,loaded,215340,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['load'],['loaded']
Performance,"4_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 663 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9197 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 665 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char * ; name). overridevirtual . Change the name of this tree. ; Reimplemented from TNamed.; Definition at line 9205 of file TTree.cxx. ◆ SetNotify(). void TTree::SetNotify ; (; TObject * ; obj). virtual . Sets the address of the object to be notified when the tree is loaded. ; The method TObject::Notify is called for the given object when the tree is loaded. Specifically this occurs in the TTree::LoadTree method. To remove the notification call this method with nullptr: tree->SetNotify(nullptr); ; If this is a TChain, obj is most often going to be a TNotifyLink.; Parameters. [in]objPointer to a TObject to be notified. . Definition at line 9231 of file TTree.cxx. ◆ SetObject(). void TTree::SetObject ; (; const char * ; name, . const char * ; title . ). virtual . Change the name and title of this tree. ; Definition at line 9260 of file TTree.cxx. ◆ SetParallelUnzip(). void TTree::SetParallelUnzip ; (; bool ; opt = true, . Float_t ; RelSize = -1 . ). virtual . Enable or disable parallel unzipping of Tree buffers. ; Definition at line 9291 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9329 of file TTree.cxx. ◆ SetScanField(). vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:217965,load,loaded,217965,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['load'],['loaded']
Performance,"4_t fOnDiskHeaderSize = 0;  Set by the descriptor builder when deserialized. ;  ; std::uint64_t fOnDiskHeaderXxHash3 = 0;  Set by the descriptor builder when deserialized. ;  . Friends; class Internal::RNTupleDescriptorBuilder;  . #include <ROOT/RNTupleDescriptor.hxx>; Constructor & Destructor Documentation. ◆ RNTupleDescriptor() [1/3]. ROOT::Experimental::RNTupleDescriptor::RNTupleDescriptor ; (; ). default . ◆ RNTupleDescriptor() [2/3]. ROOT::Experimental::RNTupleDescriptor::RNTupleDescriptor ; (; const RNTupleDescriptor & ; other). delete . ◆ RNTupleDescriptor() [3/3]. ROOT::Experimental::RNTupleDescriptor::RNTupleDescriptor ; (; RNTupleDescriptor && ; other). default . Member Function Documentation. ◆ AddClusterGroupDetails(). ROOT::Experimental::RResult< void > ROOT::Experimental::RNTupleDescriptor::AddClusterGroupDetails ; (; DescriptorId_t ; clusterGroupId, . std::vector< RClusterDescriptor > & ; clusterDescs . ). Methods to load and drop cluster group details (cluster IDs and page locations) ; Definition at line 473 of file RNTupleDescriptor.cxx. ◆ Clone(). std::unique_ptr< ROOT::Experimental::RNTupleDescriptor > ROOT::Experimental::RNTupleDescriptor::Clone ; (; ); const. Definition at line 538 of file RNTupleDescriptor.cxx. ◆ CreateModel(). std::unique_ptr< ROOT::Experimental::RNTupleModel > ROOT::Experimental::RNTupleDescriptor::CreateModel ; (; const RCreateModelOptions & ; options = RCreateModelOptions()); const. Re-create the C++ model from the stored meta-data. ; Definition at line 514 of file RNTupleDescriptor.cxx. ◆ DropClusterGroupDetails(). ROOT::Experimental::RResult< void > ROOT::Experimental::RNTupleDescriptor::DropClusterGroupDetails ; (; DescriptorId_t ; clusterGroupId). Definition at line 499 of file RNTupleDescriptor.cxx. ◆ FindClusterId(). ROOT::Experimental::DescriptorId_t ROOT::Experimental::RNTupleDescriptor::FindClusterId ; (; DescriptorId_t ; physicalColumnId, . NTupleSize_t ; index . ); const. Definition at line 373 of file RNTupleDes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html:9208,load,load,9208,doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,1,['load'],['load']
Performance,"5 // this id is now also in the holder variable; 116 if (holder == local) {; 117 // The holder was actually this thread, no problem there, we; 118 // allow re-entrancy.; 119 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" re-entered "" << fWriteCurrentRecurse << "" "" << collection; 120 // << "" lock:"" << this << std::endl;; 121 } else {; 122 ConflictReport(holder, ""WriteLock"", collection, function);; 123 }; 124 ++fWriteCurrentRecurse;; 125 }; 126}; 127 ; 128void TCollection::TErrorLock::Unlock(); 129{; 130 auto local = std::this_thread::get_id();; 131 auto none = std::thread::id();; 132 ; 133 --fWriteCurrentRecurse;; 134 if (fWriteCurrentRecurse == 0) {; 135 if (fWriteCurrent.compare_exchange_strong(local, none)) {; 136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:5464,load,load,5464,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['load'],['load']
Performance,"5 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6106 ; 6107 fCollectionProxy->Reset();; 6108 TIter nextClass(gROOT->GetListOfClasses());; 6109 while (auto acl = (TClass*)nextClass()) {; 6110 if (acl == this) continue;; 6111 if (acl->fCollectionProxy && acl->fCollectionProxy->GetValueClass() == pcl) {; 6112 acl->fCollectionProxy->Reset();; 6113 }; 6114 }; 6115 ; 6116 TIter next(pcl->GetStreamerInfos());; 6117 while (auto info = (TVirtualStreamerInfo*)next()) {; 6118 if (info->IsBuilt()) {; 6119 info->Clear(""build"");; 6120 info->BuildOld();; 6121 }; 6122 }; 6123 fCollectionProxy->GetValueClass();; 6124 }; 6125 }; 6126 }; 6127}; 6128 ; 6129////////////////////////////////////////////////////////////////////////////////; 6130/// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; 6131///; 6132/// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); 6133///; 6134/// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; 6135/// class. The bits stored in `TObject::fBits` are; 6136/// ~~~ {.cpp}; 6137/// kIsTObject : the class inherits from TObject; 6138/// kStartWithTObject: TObject is the left-most class in the inheritance tree; 6139/// kIsForeign : the class doe not have a Streamer method; 6140/// ~~~; 6141/// The value of `fStreamerType` are; 6142/// ~~~ {.cpp}; 6143/// kTObject : the class inherits from TObject; 6144/// kForeign : the class does not have a Streamer method; 6145/// kInstrumented: the class does have a Streamer method; 6146/// kExternal: the class has a free standing way of streaming itself; 6147/// kEmulatedStreamer: the class is missing its shared library.; 6148/// ~~~; 6149///; 6150/// Implementation note: the data member fProperty has the value -1; 6151/// until it is initialized.; 6152 ; 6153Long_t TClass::Property() const; 6154{; 6155 // Check if we can return without taking the lock,; 6156 // this is valid since fProperty is atomic an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:236010,cache,cache,236010,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['cache'],['cache']
Performance,"5 TSeqCollection *GetListOfBrowsers() const { return fBrowsers; }; 246 TSeqCollection *GetListOfSpecials() const { return fSpecials; }; 247 TSeqCollection *GetListOfTasks() const { return fTasks; }; 248 TSeqCollection *GetListOfCleanups() const { return fCleanups; }; 249 TSeqCollection *GetListOfStreamerInfo() const { return fStreamerInfo; }; 250 TSeqCollection *GetListOfMessageHandlers() const { return fMessageHandlers; }; 251 TCollection *GetListOfClassGenerators() const { return fClassGenerators; }; 252 TSeqCollection *GetListOfSecContexts() const { return fSecContexts; }; 253 TSeqCollection *GetListOfProofs() const { return fProofs; }; 254 TSeqCollection *GetClipboard() const { return fClipboard; }; 255 TSeqCollection *GetListOfDataSets() const { return fDataSets; }; 256 TCollection *GetListOfEnums(Bool_t load = kFALSE);; 257 TCollection *GetListOfFunctionTemplates();; 258 TList *GetListOfBrowsables() const { return fBrowsables; }; 259 TDataType *GetType(const char *name, Bool_t load = kFALSE) const;; 260 TFile *GetFile() const override { if (gDirectory && gDirectory != this) return gDirectory->GetFile(); else return nullptr;}; 261 TFile *GetFile(const char *name) const;; 262 TFunctionTemplate*GetFunctionTemplate(const char *name);; 263 TStyle *GetStyle(const char *name) const;; 264 TObject *GetFunction(const char *name) const;; 265 TGlobal *GetGlobal(const char *name, Bool_t load = kFALSE) const;; 266 TGlobal *GetGlobal(const TObject *obj, Bool_t load = kFALSE) const;; 267 TFunction *GetGlobalFunction(const char *name, const char *params = nullptr, Bool_t load = kFALSE);; 268 TFunction *GetGlobalFunctionWithPrototype(const char *name, const char *proto = nullptr, Bool_t load = kFALSE);; 269 TObject *GetGeometry(const char *name) const;; 270 const TObject *GetSelectedPrimitive() const { return fPrimitive; }; 271 TVirtualPad *GetSelectedPad() const { return fSelectPad; }; 272 Int_t GetNclasses() const;; 273 Int_t GetNtypes() const;; 274 TFolder *GetRootFolder() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:12633,load,load,12633,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['load'],['load']
Performance,"5 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpreter::EErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401///////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:90386,load,load,90386,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:214499,cache,cacheFactor,214499,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,6,['cache'],"['cacheFactor', 'cacheSize']"
Performance,"5 }; 946 if (strcmp(inner,newname) == 0) {; 947 return true;; 948 }; 949 if (offset) result = ""const "";; 950 result += newname;; 951 if ( end != tname.length() ) {; 952 result += tname.substr(end,tname.length()-end);; 953 }; 954 if (result == tname) result.clear();; 955 return true;; 956 }; 957 ; 958 // Check if the name is an enumerator; 959 const auto lastPos = TClassEdit::GetUnqualifiedName(inner);; 960 if (lastPos != inner) // Main switch: case 1 - scoped enum, case 2 global enum; 961 {; 962 // We have a scope; 963 const auto enName = lastPos;; 964 const auto scopeNameSize = (lastPos - inner) / sizeof(decltype(*lastPos)) - 2;; 965 std::string scopeName{inner, scopeNameSize};; 966 // Check if the scope is in the list of classes; 967 if (auto scope = static_cast<TClass *>(gROOT->GetListOfClasses()->FindObject(scopeName.c_str()))) {; 968 auto enumTable = dynamic_cast<const THashList *>(scope->GetListOfEnums(false));; 969 if (enumTable && enumTable->THashList::FindObject(enName)); 970 return true;; 971 }; 972 // It may still be in one of the loaded protoclasses; 973 else if (auto scope = static_cast<TProtoClass *>(gClassTable->GetProtoNorm(scopeName.c_str()))) {; 974 auto listOfEnums = scope->GetListOfEnums();; 975 if (listOfEnums) { // it could be null: no enumerators in the protoclass; 976 auto enumTable = dynamic_cast<const THashList *>(listOfEnums);; 977 if (enumTable && enumTable->THashList::FindObject(enName)); 978 return true;; 979 }; 980 }; 981 } else; 982 {; 983 // We don't have any scope: this could only be a global enum; 984 auto enumTable = dynamic_cast<const THashList *>(gROOT->GetListOfEnums());; 985 if (enumTable && enumTable->THashList::FindObject(inner)) return true;; 986 }; 987 ; 988 if (gCling->GetClassSharedLibs(inner)); 989 {; 990 // This is a class name.; 991 return true;; 992 }; 993 ; 994 return false;; 995}; 996 ; 997////////////////////////////////////////////////////////////////////////////////; 998 ; 999TCling::TUniqueString::TUniqueString(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:34471,load,loaded,34471,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"5#endif; 19096 ; 19097 worker_thread_run((struct mg_connection *)thread_func_param);; 19098 return NULL;; 19099}; 19100#endif /* _WIN32 */; 19101 ; 19102 ; 19103/* This is an internal function, thus all arguments are expected to be; 19104 * valid - a NULL check is not required. */; 19105static void; 19106accept_new_connection(const struct socket *listener, struct mg_context *ctx); 19107{; 19108 struct socket so;; 19109 char src_addr[IP_ADDR_STR_LEN];; 19110 socklen_t len = sizeof(so.rsa);; 19111#if !defined(__ZEPHYR__); 19112 int on = 1;; 19113#endif; 19114 memset(&so, 0, sizeof(so));; 19115 ; 19116 if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)); 19117 == INVALID_SOCKET) {; 19118 } else if (check_acl(ctx, &so.rsa) != 1) {; 19119 sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);; 19120 mg_cry_ctx_internal(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:569766,queue,queue,569766,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"5) 0.947 (0.933) 0.981 (0.980); : -------------------------------------------------------------------------------------------------------------------; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.html; <HEADER> Factory : Booking method: BDTG_fold2; : ; <HEADER> BDTG_fold2 : #events: (reweighted) sig: 499 bkg: 499; : #events: (unweighted) sig: 499 bkg: 499; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 998 events: 0.0434 sec ; <HEADER> BDTG_fold2 : [datasetcv] : Evaluation of BDTG_fold2 on training sample (998 events); : Elapsed time for evaluation of 998 events: 0.00338 sec ; : Creating xml weight file: datasetcv/weights/TMVACrossValidation_BDTG_fold2.weights.xml; : Creating standalone class: datasetcv/weights/TMVACrossValidation_BDTG_fold2.class.C; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG_fold2 for Classification performance; : ; <HEADER> BDTG_fold2 : [datasetcv] : Evaluation of BDTG_fold2 on testing sample (1000 events); : Elapsed time for evaluation of 1000 events: 0.00341 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: BDTG_fold2; : ; <HEADER> BDTG_fold2 : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : datasetcv BDTG_fold2 : 0.961; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from traini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:6558,perform,performance,6558,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['perform'],['performance']
Performance,"5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:3503,perform,perform,3503,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['perform']
Performance,"5/// effectively optimized away from the computation graph.; 116///; 117/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 118// clang-format on; 119template <typename NodeType>; 120std::string SaveGraph(NodeType node); 121{; 122 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 123 return helper.RepresentGraph(node);; 124}; 125 ; 126// clang-format off; 127/// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; 128/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 129/// \param[in] outputFile file where to save the representation.; 130///; 131/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 132///; 133/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 134/// effectively optimized away from the computation graph.; 135///; 136/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 137// clang-format on; 138template <typename NodeType>; 139void SaveGraph(NodeType node, const std::string &outputFile); 140{; 141 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 142 std::string dotGraph = helper.RepresentGraph(node);; 143 ; 144 std::ofstream out(outputFile);; 145 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of mul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:6157,optimiz,optimized,6157,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['optimiz'],['optimized']
Performance,"50 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is automatic; 182/// ROOT::RDF::RunGraphs({r1, r2});; 183/// ~~~; 184// clang-format on; 185unsigned int RunGraphs(std::vector<RResultHandle> handles);; 186 ; 187namespace Experimental {; 188 ; 189/// \brief Produce all required systematic variations for the given result.; 190/// \param[in] resPtr The result for which variations should be produced.; 191/// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; 192/// (e.g. ""pt:down"") and the corresponding varied results as values.; 193///; 194/// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; 195/// key that will return a value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:7805,concurren,concurrently,7805,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to load a PCM from TFile; returns true on success. ; Definition at line 1696 of file TCling.cxx. ◆ LoadText(). Bool_t TCling::LoadText ; (; const char * ; text); const. finalvirtual . Load the declarations from text into the interpreter. ; Note that this cannot be (top level) statements; text must contain top level declarations. Returns true on success, false on failure. ; Reimplemented from TInterpreter.; Definition at line 7515 of file TCling.cxx. ◆ MakeInterpreterValue(). std::unique_ptr< TInterpreterValue > TCling::MakeInterpreterValue ; (; ); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7663 of file TCling.cxx. ◆ MapCppName(). const char * TCling::MapCppName ; (; const char * ; name); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:114314,Load,LoadPCM,114314,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadPCM']
Performance,"51 assert(fXInput.GetShape().size() >= 4);; 1752 size_t nc = fXInput.GetCSize();; 1753 size_t nh = fXInput.GetHSize();; 1754 size_t nw = fXInput.GetWSize();; 1755 size_t n = nc * nh * nw;; 1756 if (nVariables != n) {; 1757 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1758 << "" n-event variables "" << nVariables << "" expected input tensor "" << nc << "" x "" << nh << "" x "" << nw; 1759 << Endl;; 1760 }; 1761 for (size_t j = 0; j < n; j++) {; 1762 // in this case TMVA event has same order as input tensor; 1763 fXInputBuffer[j] = inputValues[j]; // for column layout !!!; 1764 }; 1765 }; 1766 // copy buffer in input; 1767 fXInput.GetDeviceBuffer().CopyFrom(fXInputBuffer);; 1768 return;; 1769}; 1770 ; 1771////////////////////////////////////////////////////////////////////////////////; 1772Double_t MethodDL::GetMvaValue(Double_t * /*errLower*/, Double_t * /*errUpper*/); 1773{; 1774 ; 1775 FillInputTensor();; 1776 ; 1777 // perform the prediction; 1778 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 1779 ; 1780 // return value; 1781 double mvaValue = (*fYHat)(0, 0);; 1782 ; 1783 // for debugging; 1784#ifdef DEBUG_MVAVALUE; 1785 using Tensor_t = std::vector<MatrixImpl_t>;; 1786 TMatrixF xInput(n1,n2, inputValues.data() );; 1787 std::cout << ""Input data - class "" << GetEvent()->GetClass() << std::endl;; 1788 xInput.Print();; 1789 std::cout << ""Output of DeepNet "" << mvaValue << std::endl;; 1790 auto & deepnet = *fNet;; 1791 std::cout << ""Loop on layers "" << std::endl;; 1792 for (int l = 0; l < deepnet.GetDepth(); ++l) {; 1793 std::cout << ""Layer "" << l;; 1794 const auto * layer = deepnet.GetLayerAt(l);; 1795 const Tensor_t & layer_output = layer->GetOutput();; 1796 layer->Print();; 1797 std::cout << ""DNN output "" << layer_output.size() << std::endl;; 1798 for (size_t i = 0; i < layer_output.size(); ++i) {; 1799#ifdef R__HAS_TMVAGPU; 1800 //TMatrixD m(layer_output[i].GetNrows(), layer_output[i].GetNcols() , laye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:70511,perform,perform,70511,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['perform'],['perform']
Performance,"511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 6520 needUpdate = true;; 6521 fe->ResetUpdated();; 6522 }; 6523 } // for each friend; 6524 }; 6525 if (needUpdate) {; 6526 //update list of leaves in all TTreeFormula of the TTreePlayer (if any); 6527 if (fPlayer) {; 6528 fPlayer->UpdateFormulaLeaves();; 6529 }; 6530 //Notify user if requested; 6531 if (fNotify) {; 6532 if(!fNotify->Notify()) return -6;; 6533 }; 6534 }; 6535 }; 6536 ; 6537 if ((fReadEntry >= fEntries) && !friendHasEntry) {; 6538 fReadEntry = -1;; 6539 return -2;; 6540 }; 6541 return fReadEntry;; 6542}; 6543 ; 6544////////////////////////////////////////////////////////////////////////////////; 6545/// Load entry on behalf of our master tree, we may use an index.; 6546///; 6547/// Called by LoadTree() when the masterTree looks for the entry; 6548/// number in a friend tree (us) corresponding to the passed entry; 6549/// number in the masterTree.; 6550///; 6551/// If we have no index, our entry number and the masterTree entry; 6552/// number are the same.; 6553///; 6554/// If we *do* have an index, we must find the (major, minor) value pair; 6555/// in masterTree to locate our corresponding entry.; 6556///; 6557 ; 6558Long64_t TTree::LoadTreeFriend(Long64_t entry, TTree* masterTree); 6559{; 6560 if (!fTreeIndex) {; 6561 return LoadTree(entry);; 6562 }; 6563 return LoadTree(fTreeIndex->GetEntryNumberFriend(masterTree));; 6564}; 6565 ; 6566////////////////////////////////////////////////////////////////////////////////; 6567/// Generate a skeleton analysis class for this tree.; 6568///; 6569/// The following files are produced: classname.h and classname.C.; 6570/// If classname is 0, classname will be called ""nameoftree"".; 6571///; 6572/// The generated code in classname.h includes the following:; 6573///; 6574/// - Identification of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:255362,Load,LoadTree,255362,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"524 if (TROOT::Initialized() && ROOT::Internal::gROOTLocal) {; 2525 gROOT->CloseFiles();; 2526 }; 2527}; 2528 ; 2529////////////////////////////////////////////////////////////////////////////////; 2530/// Called by static dictionary initialization to register clang modules; 2531/// for headers. Calls TCling::RegisterModule() unless gCling; 2532/// is NULL, i.e. during startup, where the information is buffered in; 2533/// the static GetModuleHeaderInfoBuffer().; 2534 ; 2535void TROOT::RegisterModule(const char* modulename,; 2536 const char** headers,; 2537 const char** includePaths,; 2538 const char* payloadCode,; 2539 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:96443,load,loaded,96443,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loaded']
Performance,5362 subname += l;; 5363 if (*subname != '.') {; 5364 continue;; 5365 }; 5366 subname++;; 5367 TBranch* branch = t->GetBranch(subname);; 5368 if (branch) {; 5369 return branch;; 5370 }; 5371 }; 5372 return nullptr;; 5373}; 5374 ; 5375////////////////////////////////////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAuto,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:214108,cache,cache,214108,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:215588,cache,cacheSize,215588,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,6,['cache'],"['cacheFactor', 'cacheSize']"
Performance,"55 auto temp = fEnums.load();; 3756 if (temp) {; 3757 if (requestListLoading) {; 3758 if (fProperty == -1) Property();; 3759 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3760 R__LOCKGUARD(gROOTMutex);; 3761 temp->Load();; 3762 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3763 // We have a class for which the list was not loaded fully at; 3764 // first use.; 3765 R__LOCKGUARD(gROOTMutex);; 3766 temp->Load();; 3767 }; 3768 }; 3769 return temp;; 3770 }; 3771 ; 3772 if (!requestListLoading) {; 3773 if (fProperty == -1) Property();; 3774 R__LOCKGUARD(gInterpreterMutex);; 3775 if (fEnums.load()) {; 3776 return fEnums.load();; 3777 }; 3778 ; 3779 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3780 fEnums = new TListOfEnums(this);; 3781 else; 3782 fEnums = new TListOfEnumsWithLock(this);; 3783 return fEnums;; 3784 }; 3785 ; 3786 R__LOCKGUARD(gInterpreterMutex);; 3787 if (fEnums.load()) {; 3788 (*fEnums).Load();; 3789 return fEnums.load();; 3790 }; 3791 if (fProperty == -1) Property();; 3792 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3793 // For this case, the list will be immutable; 3794 temp = new TListOfEnums(this);; 3795 } else {; 3796 //namespaces can have enums added to them; 3797 temp = new TListOfEnumsWithLock(this);; 3798 }; 3799 temp->Load();; 3800 fEnums = temp;; 3801 return temp;; 3802}; 3803 ; 3804////////////////////////////////////////////////////////////////////////////////; 3805/// Create the list containing the TDataMembers (of actual data members or members; 3806/// pulled in through using declarations) of a class.; 3807 ; 3808TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3809{; 3810 R__LOCKGUARD(gInterpreterMutex);; 3811 ; 3812 if (!data) {; 3813 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3814 // The members are in our ProtoClass; we don't need the class info.; 3815 TProto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:143448,Load,Load,143448,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"552 ; 1553 if (fgVerboseLevel > 0); 1554 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1555 GetTitle());; 1556 if (fgVerboseLevel > 0); 1557 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1558 return;; 1559 }; 1560 ; 1561 // Create a geometry navigator if not present; 1562 if (!GetCurrentNavigator()); 1563 fCurrentNavigator = AddNavigator();; 1564 nnavigators = GetListOfNavigators()->GetEntriesFast();; 1565 SelectTrackingMedia();; 1566 CheckGeometry();; 1567 if (fgVerboseLevel > 0); 1568 Info(""CloseGeometry"", ""Counting nodes..."");; 1569 fNNodes = CountNodes();; 1570 fNLevel = fMasterVolume->CountNodes(1, 3) + 1;; 1571 if (fNLevel < 30); 1572 fNLevel = 100;; 1573 ; 1574 // BuildIdArray();; 1575 // avoid voxelization if requested to speed up geometry startup; 1576 if (!opt.Contains(""nv"")) {; 1577 Voxelize(""ALL"");; 1578 } else {; 1579 TGeoVolume *vol;; 1580 TIter next(fVolumes);; 1581 while ((vol = (TGeoVolume *)next())) {; 1582 vol->SortNodes();; 1583 }; 1584 }; 1585 if (fgVerboseLevel > 0); 1586 Info(""CloseGeometry"", ""Building cache..."");; 1587 CountLevels();; 1588 for (Int_t i = 0; i < nnavigators; i++) {; 1589 nav = (TGeoNavigator *)GetListOfNavigators()->At(i);; 1590 nav->GetCache()->BuildInfoBranch();; 1591 if (nodeid); 1592 nav->GetCache()->BuildIdArray();; 1593 }; 1594 fClosed = kTRUE;; 1595 if (fgVerboseLevel > 0) {; 1596 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1597 GetTitle());; 1598 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1599 }; 1600}; 1601 ; 1602////////////////////////////////////////////////////////////////////////////////; 1603/// Clear the list of overlaps.; 1604 ; 1605void TGeoManager::ClearOverlaps(); 1606{; 1607 if (fOverlaps) {; 1608 fOverlaps->Delete();; 1609 delete fOverlaps;; 1610 }; 1611 fOverlaps = new TObjArray();; 1612}; 1613 ; 1614//////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:58900,cache,cache,58900,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['cache'],['cache']
Performance,"5610 static TClassRef stringClass(""string"");; 5611 if (ladd && aElement->GetClass() == stringClass) {; 5612 std::string *st = (std::string*)(ladd);; 5613 printf(""%s"",st->c_str());; 5614 } else {; 5615 printf(""(%s*)0x%zx"",aElement->GetClass()->GetName(),(size_t)(ladd));; 5616 }; 5617 } else {; 5618 printf(""(unknown_type*)0x%zx"",(size_t)(ladd));; 5619 }; 5620 break;; 5621 }; 5622 }; 5623}; 5624 ; 5625////////////////////////////////////////////////////////////////////////////////; 5626///function called by the TClass constructor when replacing an emulated class; 5627///by the real class; 5628 ; 5629void TStreamerInfo::Update(const TClass *oldcl, TClass *newcl); 5630{; 5631 TStreamerElement *element;; 5632 TIter nextElement(GetElements());; 5633 while ((element = (TStreamerElement*)nextElement())) {; 5634 element->Update(oldcl,newcl);; 5635 }; 5636 for (Int_t i=0;i < fNslots;i++) {; 5637 fComp[i].Update(oldcl,newcl);; 5638 }; 5639}; 5640 ; 5641////////////////////////////////////////////////////////////////////////////////; 5642/// Update the TClass pointer cached in this object.; 5643 ; 5644void TStreamerInfo::TCompInfo::Update(const TClass *oldcl, TClass *newcl); 5645{; 5646 if (fType != -1) {; 5647 if (fClass == oldcl || strcmp(fClassName, newcl->GetName()) == 0); 5648 fClass = newcl;; 5649 else if (fClass == 0 && TClassTable::GetDict(fClassName)); 5650 fClass = TClass::GetClass(fClassName);; 5651 }; 5652}; 5653 ; 5654////////////////////////////////////////////////////////////////////////////////; 5655/// Generate emulated collection proxy for a given class.; 5656 ; 5657TVirtualCollectionProxy*; 5658TStreamerInfo::GenEmulatedProxy(const char* class_name, Bool_t silent); 5659{; 5660 return TCollectionProxyFactory::GenEmulatedProxy(class_name, silent);; 5661}; 5662 ; 5663////////////////////////////////////////////////////////////////////////////////; 5664/// Generate emulated class streamer for a given collection class.; 5665 ; 5666TClassStreamer*; 5667TStreamerInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:226152,cache,cached,226152,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['cache'],['cached']
Performance,"563 of file rootcling_impl.cxx. ◆ IsImplementationName(). bool IsImplementationName ; (; const std::string & ; filename). Definition at line 3410 of file rootcling_impl.cxx. ◆ IsLinkdefFile(). bool IsLinkdefFile ; (; const clang::PresumedLoc & ; PLoc). Definition at line 467 of file rootcling_impl.cxx. ◆ isPointerToPointer(). bool isPointerToPointer ; (; const clang::FieldDecl & ; m). Definition at line 1152 of file rootcling_impl.cxx. ◆ IsSelectionFile(). bool IsSelectionFile ; (; const char * ; filename). Definition at line 474 of file rootcling_impl.cxx. ◆ IsSelectionXml(). bool IsSelectionXml ; (; const char * ; filename). Definition at line 454 of file rootcling_impl.cxx. ◆ IsSupportedClassName(). bool IsSupportedClassName ; (; const char * ; name). Definition at line 3439 of file rootcling_impl.cxx. ◆ LoadLibraryMap(). void LoadLibraryMap ; (; const std::string & ; fileListName, . map< string, string > & ; autoloads . ). Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ; Definition at line 692 of file rootcling_impl.cxx. ◆ MaybeSuppressWin32CrashDialogs(). static void MaybeSuppressWin32CrashDialogs ; (; ). static . Definition at line 3675 of file rootcling_impl.cxx. ◆ ModuleContainsHeaders(). static bool ModuleContainsHeaders ; (; TModuleGenerator & ; modGen, . clang::HeaderSearch & ; headerSearch, . clang::Module * ; module, . std::vector< std::array< std::string, 2 > > & ; missingHeaders . ). static . Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ; The names of all header files that are needed by the ModuleGenerator but are not in the given module will be inserted into the MissingHeader variable. Returns true iff the PCH was successfully generated. ; Definition at line 3881 of file rootcling_impl.cxx. ◆ Namespace__HasMethod(). bool Namespace__HasMethod ; (; const clang::NamespaceDecl * ; cl, . const char * ; name, . const cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:56213,load,loaded,56213,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['load'],['loaded']
Performance,"5901 if (T) {; 5902 ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);; 5903 for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {; 5904 if (declIt->m_DGR.isSingleDecl()) {; 5905 if (Decl* D = declIt->m_DGR.getSingleDecl()) {; 5906 if (clang::isa<TagDecl>(D) || clang::isa<NamespaceDecl>(D)) {; 5907 evsAdder.TraverseDecl(D);; 5908 }; 5909 }; 5910 }; 5911 }; 5912 }; 5913 ; 5914 // clear duplicates; 5915 ; 5916 return 0;; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Scan again along the dynamic path for library maps. Entries for the loaded; 5921/// shared libraries are unloaded first. This can be useful after reseting; 5922/// the dynamic path through TSystem::SetDynamicPath(); 5923/// In case of error -1 is returned, 0 otherwise.; 5924 ; 5925Int_t TCling::RescanLibraryMap(); 5926{; 5927 UnloadAllSharedLibraryMaps();; 5928 LoadLibraryMap();; 5929 return 0;; 5930}; 5931 ; 5932////////////////////////////////////////////////////////////////////////////////; 5933/// Reload the library map entries coming from all the loaded shared libraries,; 5934/// after first unloading the current ones.; 5935/// In case of error -1 is returned, 0 otherwise.; 5936 ; 5937Int_t TCling::ReloadAllSharedLibraryMaps(); 5938{; 5939 const TString sharedLibLStr = GetSharedLibs();; 5940 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 5941 const Int_t nrSharedLibs = sharedLibL->GetEntriesFast();; 5942 for (Int_t ilib = 0; ilib < nrSharedLibs; ilib++) {; 5943 const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();; 5944 const TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);; 5945 const Int_t ret = UnloadLibraryMap(sharedLibBaseStr);; 5946 if (ret < 0) {; 5947 continue;; 5948 }; 5949 TString rootMapBaseStr = sharedLibBaseStr;; 5950 if (sharedLibBaseStr.EndsWith("".dll"")) {; 5951 rootMapBaseStr.ReplaceAll("".dll"", """");; 5952 }; 5953 else if (sharedLibBaseStr.EndsWith("".DLL"")) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:230249,Load,LoadLibraryMap,230249,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['LoadLibraryMap', 'loaded']"
Performance,"59; TGraph::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::GetEYlowdvirtual Double_t * GetEYlowd() constDefinition TGraph.h:149; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::SaveAsvoid SaveAs(const char *filename=""graph"", Option_t *option="""") const overrideSave the graph as .csv, .tsv or .txt.Definition TGraph.cxx:2093; TGraph::Evalvirtual Double_t Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constInterpolate points in this graph at x using a TSpline.Definition TGraph.cxx:953; TGraph::GetMaxSizeInt_t GetMaxSize() constDefinition TGraph.h:131; TGraph::InitExpovirtual void In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8h_source.html:22682,perform,perform,22682,doc/master/TGraph_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html,1,['perform'],['perform']
Performance,"5; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 11.0066; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; nthreads = 4; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0529 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0218 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.249 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00679 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:52949,perform,performance,52949,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['performance']
Performance,"5{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offset;; 927 }; 928 ; 929 //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,""DEBUG: checking on %s vs %s %lu %lu\n"",tname.c_str(),inner,offset,end);; 930 if (gROOT->GetListOfClasses()->FindObject(inner); 931 || TClassTable::Check(inner,result) ) {; 932 // This is a known class.; 933 return true;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject( inner );; 938 if (type) {; 939 // This is a raw type and an already loaded typedef.; 940 const char *newname = type->GetFullTypeName();; 941 if (type->GetType() == kLong64_t) {; 942 newname = ""Long64_t"";; 943 } else if (type->GetType() == kULong64_t) {; 944 newname = ""ULong64_t"";; 945 }; 946 if (strcmp(inner,newname) == 0) {; 947 return true;; 948 }; 949 if (offset) result = ""const "";; 950 result += newname;; 951 if ( end != tname.length() ) {; 952 result += tname.substr(end,tname.length()-end);; 953 }; 954 if (result == tname) result.clear();; 955 return true;; 956 }; 957 ; 958 // Check if the name is an enumerator; 959 const auto lastPos = TClassEdit::GetUnqualifiedName(inner);; 960 if (lastPos != inner) // Main switch: case 1 - scoped enum, case 2 global enum; 961 {; 962 // We have a scope; 963 const auto enName = lastPos;; 964 const auto scopeNameSize = (lastPos - inner) / sizeof(decltype(*lastPos)) - 2;; 965 std::string scopeName{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:33197,load,loaded,33197,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"6 ; 1727 if (fCw < fCh) {; 1728 fYsizeReal = kDefaultCanvasSize;; 1729 fXsizeReal = fYsizeReal*Double_t(fCw)/Double_t(fCh);; 1730 }; 1731 else {; 1732 fXsizeReal = kDefaultCanvasSize;; 1733 fYsizeReal = fXsizeReal*Double_t(fCh)/Double_t(fCw);; 1734 }; 1735 ; 1736//*-*- Loop on all pads to recompute conversion coefficients; 1737 TPad::ResizePad();; 1738}; 1739 ; 1740 ; 1741////////////////////////////////////////////////////////////////////////////////; 1742/// Raise canvas window; 1743 ; 1744void TCanvas::RaiseWindow(); 1745{; 1746 if (fCanvasImp); 1747 fCanvasImp->RaiseWindow();; 1748}; 1749 ; 1750////////////////////////////////////////////////////////////////////////////////; 1751/// Set option to resize objects/pads in a canvas.; 1752///; 1753/// - set = 1 (default) graphics objects are resized in opaque mode; 1754/// - set = 0 only the outline of objects is drawn when resizing them; 1755///; 1756/// The option opaque produces the best effect. It requires however a; 1757/// a reasonably fast workstation or response time.; 1758 ; 1759void TCanvas::ResizeOpaque(Int_t set); 1760{; 1761 SetBit(kResizeOpaque,set);; 1762}; 1763 ; 1764////////////////////////////////////////////////////////////////////////////////; 1765/// Execute the list of TExecs in the current pad.; 1766 ; 1767void TCanvas::RunAutoExec(); 1768{; 1769 if (!TestBit(kAutoExec)); 1770 return;; 1771 if (gPad); 1772 ((TPad*)gPad)->AutoExec();; 1773}; 1774 ; 1775////////////////////////////////////////////////////////////////////////////////; 1776/// Save primitives in this canvas in C++ macro file with GUI.; 1777 ; 1778void TCanvas::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1779{; 1780 // Write canvas options (in $TROOT or $TStyle); 1781 if (gStyle->GetOptFit()) {; 1782 out<<"" gStyle->SetOptFit(1);""<<std::endl;; 1783 }; 1784 if (!gStyle->GetOptStat()) {; 1785 out<<"" gStyle->SetOptStat(0);""<<std::endl;; 1786 }; 1787 if (!gStyle->GetOptTitle()) {; 1788 out<<"" gStyle->SetOptTitle(0);""<<std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:54896,response time,response time,54896,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['response time'],['response time']
Performance,"6 ResetBit(kMustCleanup);; 9627 b.CheckByteCount(R__s, R__c, TTree::IsA());; 9628 //====end of old versions; 9629 } else {; 9630 if (fBranchRef) {; 9631 fBranchRef->Clear();; 9632 }; 9633 TRefTable *table = TRefTable::GetRefTable();; 9634 if (table) TRefTable::SetRefTable(nullptr);; 9635 ; 9636 b.WriteClassBuffer(TTree::Class(), this);; 9637 ; 9638 if (table) TRefTable::SetRefTable(table);; 9639 }; 9640}; 9641 ; 9642////////////////////////////////////////////////////////////////////////////////; 9643/// Unbinned fit of one or more variable(s) from a tree.; 9644///; 9645/// funcname is a TF1 function.; 9646///; 9647/// \see TTree::Draw for explanations of the other parameters.; 9648///; 9649/// Fit the variable varexp using the function funcname using the; 9650/// selection cuts given by selection.; 9651///; 9652/// The list of fit options is given in parameter option.; 9653///; 9654/// - option = ""Q"" Quiet mode (minimum printing); 9655/// - option = ""V"" Verbose mode (default is between Q and V); 9656/// - option = ""E"" Perform better Errors estimation using Minos technique; 9657/// - option = ""M"" More. Improve fit results; 9658///; 9659/// You can specify boundary limits for some or all parameters via; 9660/// ~~~ {.cpp}; 9661/// func->SetParLimits(p_number, parmin, parmax);; 9662/// ~~~; 9663/// if parmin>=parmax, the parameter is fixed; 9664///; 9665/// Note that you are not forced to fix the limits for all parameters.; 9666/// For example, if you fit a function with 6 parameters, you can do:; 9667/// ~~~ {.cpp}; 9668/// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; 9669/// func->SetParLimits(4,-10,-4);; 9670/// func->SetParLimits(5, 1,1);; 9671/// ~~~; 9672/// With this setup:; 9673///; 9674/// - Parameters 0->3 can vary freely; 9675/// - Parameter 4 has boundaries [-10,-4] with initial value -8; 9676/// - Parameter 5 is fixed to 100.; 9677///; 9678/// For the fit to be meaningful, the function must be self-normalized.; 9679///; 9680/// i.e. It must have the same",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:370518,Perform,Perform,370518,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Perform'],['Perform']
Performance,"6 return false; // not yet implemented; 137 }; 138 ; 139 /// precision value used for calculating the derivative step-size; 140 /// h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly; 141 static void SetDerivPrecision(double eps);; 142 ; 143 /// get precision value used for calculating the derivative step-size; 144 static double GetDerivPrecision();; 145 ; 146 /// method to retrieve the internal function pointer; 147 const TF1 *GetFunction() const; 148 {; 149 return fFunc;; 150 }; 151 ; 152 /// method to set a new function pointer and copy it inside.; 153 /// By calling this method the class manages now the passed TF1 pointer; 154 void SetAndCopyFunction(const TF1 *f = nullptr);; 155 ; 156 private:; 157 /// evaluate function passing coordinates x and vector of parameters; 158 T DoEvalPar(const T *x, const double *p) const override; 159 {; 160 return fFunc->EvalPar(x, p);; 161 }; 162 ; 163 /// evaluate function using the cached parameter values (of TF1); 164 /// re-implement for better efficiency; 165 T DoEvalVec(const T *x) const; 166 {; 167 return fFunc->EvalPar(x, 0);; 168 }; 169 ; 170 /// evaluate function using the cached parameter values (of TF1); 171 /// re-implement for better efficiency; 172 T DoEval(const T *x) const override; 173 {; 174 // no need to call InitArg for interpreted functions (done in ctor); 175 ; 176 //const double * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:5385,cache,cached,5385,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,2,['cache'],['cached']
Performance,"6#include <vector>; 17#include <iostream>; 18#include <map>; 19#include <string>; 20 ; 21#include ""TFile.h""; 22#include ""TTree.h""; 23#include ""TString.h""; 24#include ""TSystem.h""; 25#include ""TROOT.h""; 26#include ""TStopwatch.h""; 27 ; 28#include ""TMVA/Tools.h""; 29#include ""TMVA/Reader.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVARegressionApplication( TString myMethodList = """" ); 34{; 35 //---------------------------------------------------------------; 36 // This loads the library; 37 TMVA::Tools::Instance();; 38 ; 39 // Default MVA methods to be trained + tested; 40 std::map<std::string,int> Use;; 41 ; 42 // --- Mutidimensional likelihood and Nearest-Neighbour methods; 43 Use[""PDERS""] = 0;; 44 Use[""PDEFoam""] = 1;; 45 Use[""KNN""] = 1;; 46 //; 47 // --- Linear Discriminant Analysis; 48 Use[""LD""] = 1;; 49 //; 50 // --- Function Discriminant analysis; 51 Use[""FDA_GA""] = 0;; 52 Use[""FDA_MC""] = 0;; 53 Use[""FDA_MT""] = 0;; 54 Use[""FDA_GAMT""] = 0;; 55 //; 56 // --- Neural Network; 57 Use[""MLP""] = 0;; 58 // Deep neural network; 59#ifdef R__HAS_TMVAGPU; 60 Use[""DNN_GPU""] = 1;; 61 Use[""DNN_CPU""] = 0;; 62#else; 63 Use[""DNN_GPU""] = 0;; 64#ifdef R__HAS_TMVACPU; 65 Use[""DNN_CPU""] = 1;; 66#else; 67 Use[""DNN_CPU""] = 0;; 68#endif; 69#endif; 70 //; 71 // --- Support Vector Machine; 72 Use[""SVM""] = 0;; 73 //; 74 // --- Boosted Decision Trees; 75 Use[""BDT""] = 0;; 76 Use[""BDTG""] = 1;; 77 // ---------------------------------------------------------------; 78 ; 79 std::cout << std::endl;; 80 std::cout << ""==> Start TMVARegressionApplication"" << std::endl;; 81 ; 82 // Select methods (don't look at this code - not of interest); 83 if (myMethodList != """") {; 84 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 85 ; 86 std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; 87 for (UInt_t i=0; i<mlist.size(); i++) {; 88 std::string regMethod(mlist[i]);; 89 ; 90 if (Use.find(regMethod) == Use.end()) {; 91 std::cout << ""Method ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C_source.html:1129,load,loads,1129,doc/master/TMVARegressionApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C_source.html,1,['load'],['loads']
Performance,"6/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRootmapLoadPath) {; 5766 fRootmapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; 5773 for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {; 5774 d = ((TObjString *)paths->At(i))->GetString();; 5775 // check if directory already scanned; 5776 Int_t skip = 0;; 5777 for (Int_t j = 0; j < i; j++) {; 5778 TString pd = ((TObjString *)paths->At(j))->GetString();; 5779 if (pd == d) {; 5780 skip++;; 5781 break;; 5782 }; 5783 }; 5784 if (!skip) {; 5785 void* dirp = gSystem->OpenDirectory(d);; 5786 if (dirp) {; 5787 if (gDebug > 3) {; 5788 Info(""LoadLibraryMap"", ""%s"", d.Data());; 5789 }; 5790 const char* f1;; 5791 while ((f1 = gSystem->GetDirEntry(dirp))) {; 5792 TString f = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:224512,Load,Load,224512,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['Load', 'load']"
Performance,"6/// to a new file. If the TRef or referenced objects of the file being closed; 947/// will not be referenced again, it is possible to minimize the size; 948/// of the TProcessID data structures in memory by forcing a delete of; 949/// the unused TProcessID.; 950 ; 951void TFile::Close(Option_t *option); 952{; 953 TString opt = option;; 954 ; 955 opt.ToLower();; 956 ; 957 if (!IsOpen()) return;; 958 ; 959 if (fIsArchive || !fIsRootFile) {; 960 FlushWriteCache();; 961 SysClose(fD);; 962 fD = -1;; 963 ; 964 if (gMonitoringWriter); 965 gMonitoringWriter->SendFileCloseEvent(this);; 966 ; 967 return;; 968 }; 969 ; 970 if (IsWritable()) {; 971 WriteStreamerInfo();; 972 }; 973 ; 974 // Finish any concurrent I/O operations before we close the file handles.; 975 if (fCacheRead) fCacheRead->Close();; 976 {; 977 TIter iter(fCacheReadMap);; 978 TObject *key = nullptr;; 979 while ((key = iter()) != nullptr) {; 980 TFileCacheRead *cache = dynamic_cast<TFileCacheRead *>(fCacheReadMap->GetValue(key));; 981 cache->Close();; 982 }; 983 }; 984 ; 985 // Delete all supported directories structures from memory; 986 // If gDirectory points to this object or any of the nested; 987 // TDirectoryFile, TDirectoryFile::Close will induce the proper cd.; 988 fMustFlush = kFALSE; // Make sure there is only one Flush.; 989 TDirectoryFile::Close(option);; 990 ; 991 if (IsWritable()) {; 992 TFree *f1 = (TFree*)fFree->First();; 993 if (f1) {; 994 WriteFree(); //*-*- Write free segments linked list; 995 WriteHeader(); //*-*- Now write file header ; this forces a Flush/fsync; 996 } else {; 997 Flush();; 998 }; 999 }; 1000 fMustFlush = kTRUE;; 1001 ; 1002 FlushWriteCache();; 1003 ; 1004 if (gMonitoringWriter); 1005 gMonitoringWriter->SendFileCloseEvent(this);; 1006 ; 1007 delete fClassIndex;; 1008 fClassIndex = nullptr;; 1009 ; 1010 // Delete free segments from free list (but don't delete list header); 1011 if (fFree) {; 1012 fFree->Delete();; 1013 }; 1014 ; 1015 if (IsOpen()) {; 1016 SysClose(fD);; 1017",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:35291,cache,cache,35291,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,"602 /// Users are responsible for the thread-safety of this callable when executing; 1603 /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; 1604 ///; 1605 /// ### Example usage:; 1606 /// ~~~{.cpp}; 1607 /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; 1608 /// ~~~; 1609 // clang-format on; 1610 template <typename F>; 1611 void Foreach(F f, const ColumnNames_t &columns = {}); 1612 {; 1613 using arg_types = typename TTraits::CallableTraits<decltype(f)>::arg_types_nodecay;; 1614 using ret_type = typename TTraits::CallableTraits<decltype(f)>::ret_type;; 1615 ForeachSlot(RDFInternal::AddSlotParameter<ret_type>(f, arg_types()), columns);; 1616 }; 1617 ; 1618 // clang-format off; 1619 ////////////////////////////////////////////////////////////////////////////; 1620 /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; 1621 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; 1622 /// \param[in] columns Names of the columns/branches in input to the user function.; 1623 ///; 1624 /// Same as `Foreach`, but the user-defined function takes an extra; 1625 /// `unsigned int` as its first parameter, the *processing slot index*.; 1626 /// This *slot index* will be assigned a different value, `0` to `poolSize - 1`,; 1627 /// for each thread of execution.; 1628 /// This is meant as a helper in writing thread-safe `Foreach`; 1629 /// actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`.; 1630 /// The user-defined processing callable is able to follow different; 1631 /// *streams of processing* indexed by the first parameter.; 1632 /// `ForeachSlot` works just as well with single-thread execution: in that; 1633 /// case `slot` will always be `0`.; 1634 ///; 1635 /// ### Example usage:; 1636 /// ~~~{.cpp}; 1637 /// myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:90841,perform,performing,90841,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['perform'],['performing']
Performance,"611 }; 1612}; 1613 ; 1614 ; 1615////////////////////////////////////////////////////////////////////////////////; 1616/// Destroy the interpreter interface.; 1617 ; 1618TCling::~TCling(); 1619{; 1620 // ROOT's atexit functions require the interepreter to be available.; 1621 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:61542,load,loading,61542,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],"['load', 'loading']"
Performance,"6128 int err = 0;; 6129 char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6130 if (err) {; 6131 return 0;; 6132 }; 6133 ; 6134 std::string demangled_name(demangled_name_c);; 6135 free(demangled_name_c);; 6136 ; 6137 // AutoLoad expects (because TClass::GetClass already prepares it that way) a; 6138 // shortened name.; 6139 TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );; 6140 splitname.ShortType(demangled_name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd);; 6141 ; 6142 // No need to worry about typedef, they aren't any ... but there are; 6143 // inlined namespaces ...; 6144 ; 6145 Int_t result = AutoLoad(demangled_name.c_str());; 6146 if (result == 0) {; 6147 demangled_name = TClassEdit::GetLong64_Name(demangled_name);; 6148 result = AutoLoad(demangled_name.c_str(), knowDictNotLoaded);; 6149 }; 6150 ; 6151 return result;; 6152}; 6153 ; 6154////////////////////////////////////////////////////////////////////////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:238577,load,load,238577,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"617 if (!narr) {; 618 narr = 1;; 619 }; 620 element->SetSize(dsize*narr);; 621 element->SetStreamer(streamer);; 622 if (!streamer) {; 623 Int_t k = element->GetType();; 624 if (k == kStreamer) {; 625 // if ((k == kSTL) || (k == kSTL + kOffsetL) || (k == kStreamer) || (k == kStreamLoop)); 626 // This is odd. Either we need to update the doc for TVirtualStreamerInfo::kNoType; 627 // or change this value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23154,cache,cached,23154,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['cache'],['cached']
Performance,"618///; 5619/// ## OPTION 3; 5620///; 5621/// ~~~ {.cpp}; 5622/// Same as option 1, but you delete yourself the event.; 5623///; 5624/// for (Long64_t i=0;i<nentries;i++) {; 5625/// delete event;; 5626/// event = 0; // EXTREMELY IMPORTANT; 5627/// T.GetEntry(i);; 5628/// // the object event has been filled at this point; 5629/// }; 5630/// ~~~; 5631/// It is strongly recommended to use the default option 1. It has the; 5632/// additional advantage that functions like TTree::Draw (internally calling; 5633/// TTree::GetEntry) will be functional even when the classes in the file are; 5634/// not available.; 5635///; 5636/// Note: See the comments in TBranchElement::SetAddress() for the; 5637/// object ownership policy of the underlying (user) data.; 5638 ; 5639Int_t TTree::GetEntry(Long64_t entry, Int_t getall); 5640{; 5641 // We already have been visited while recursively looking; 5642 // through the friends tree, let return; 5643 if (kGetEntry & fFriendLockStatus) return 0;; 5644 ; 5645 if (entry < 0 || entry >= fEntries) return 0;; 5646 Int_t i;; 5647 Int_t nbytes = 0;; 5648 fReadEntry = entry;; 5649 ; 5650 // create cache if wanted; 5651 if (fCacheDoAutoInit); 5652 SetCacheSizeAux();; 5653 ; 5654 Int_t nbranches = fBranches.GetEntriesUnsafe();; 5655 Int_t nb=0;; 5656 ; 5657 auto seqprocessing = [&]() {; 5658 TBranch *branch;; 5659 for (i=0;i<nbranches;i++) {; 5660 branch = (TBranch*)fBranches.UncheckedAt(i);; 5661 nb = branch->GetEntry(entry, getall);; 5662 if (nb < 0) break;; 5663 nbytes += nb;; 5664 }; 5665 };; 5666 ; 5667#ifdef R__USE_IMT; 5668 if (nbranches > 1 && ROOT::IsImplicitMTEnabled() && fIMTEnabled && !TTreeCacheUnzip::IsParallelUnzip()) {; 5669 if (fSortedBranches.empty()); 5670 InitializeBranchLists(true);; 5671 ; 5672 // Count branches are processed first and sequentially; 5673 for (auto branch : fSeqBranches) {; 5674 nb = branch->GetEntry(entry, getall);; 5675 if (nb < 0) break;; 5676 nbytes += nb;; 5677 }; 5678 if (nb < 0) return nb;; 5679 ; 5680 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:223666,cache,cache,223666,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"62 void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);; 563 void SetNew(ROOT::NewFunc_t newFunc);; 564 void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);; 565 TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="""");; 566 void SetUnloaded();; 567 Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""");; 568 ; 569 void AdoptReferenceProxy(TVirtualRefProxy* proxy);; 570 void AdoptStreamer(TClassStreamer *strm);; 571 void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);; 572 void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);; 573 void SetStreamerFunc(ClassStreamerFunc_t strm);; 574 void SetConvStreamerFunc(ClassConvStreamerFunc_t strm);; 575 ; 576 // Function to retrieve the TClass object and dictionary function; 577 static void AddClass(TClass *cl);; 578 static void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl);; 579 static void RemoveClass(TClass *cl);; 580 static void RemoveClassDeclId(TDictionary::DeclId_t id);; 581 static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 582 static TClass *GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);; 583 static TClass *GetClass(const std::type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE, size_t hint_pair_offset = 0, size_t hint_pair_size = 0);; 584 static TClass *GetClass(ClassInfo_t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:30125,load,load,30125,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,12,"['Load', 'load']","['Load', 'load']"
Performance,"621 //--- colours; 622 ULong_t color;; 623 gClient->GetColorByName(""blue"",color);; 624 //--- pictures for X, Y and Z expression items; 625 fPicX = gClient->GetPicture(""x_pic.xpm"");; 626 fPicY = gClient->GetPicture(""y_pic.xpm"");; 627 fPicZ = gClient->GetPicture(""z_pic.xpm"");; 628 ; 629 //--- general context menu; 630 fContextMenu = new TContextMenu(""TreeViewer context menu"","""");; 631 fMappedTree = nullptr;; 632 fMappedBranch = nullptr;; 633 fDialogBox = nullptr;; 634 fDimension = 0;; 635 fVarDraw = false;; 636 fStopMapping = false;; 637// fFilename = """";; 638 fSourceFile = ""treeviewer.C"";; 639 //--- lists : trees and widgets to be removed; 640// fTreeList = 0;; 641 fTreeIndex = 0;; 642 fWidgets = new TList();; 643 //--- create menus --------------------------------------------------------; 644 //--- File menu; 645 fFileMenu = new TGPopupMenu(fClient->GetRoot());; 646 fFileMenu->AddEntry(""&New canvas"", kFileCanvas);; 647 fFileMenu->AddEntry(""Open &tree file..."", kFileBrowse);; 648 fFileMenu->AddEntry(""&Load Library..."", kFileLoadLibrary);; 649 fFileMenu->AddEntry(""&Open session"", kFileOpenSession);; 650 fFileMenu->AddEntry(""&Save source..."", kFileSaveMacro);; 651 fFileMenu->AddSeparator();; 652 fFileMenu->AddEntry(""&Print"", kFilePrint);; 653 fFileMenu->AddEntry(""&Close"", kFileClose);; 654 fFileMenu->AddSeparator();; 655 fFileMenu->AddEntry(""&Quit ROOT"", kFileQuit);; 656 ; 657 fFileMenu->DisableEntry(kFilePrint);; 658 ; 659 //--- Edit menu; 660 fEditMenu = new TGPopupMenu(gClient->GetRoot());; 661 fEditMenu->AddEntry(""&Expression..."", kEditExpression);; 662 fEditMenu->AddEntry(""&Cut..."", kEditCut);; 663 fEditMenu->AddEntry(""&Macro..."", kEditMacro);; 664 fEditMenu->AddEntry(""E&Vent..."", kEditEvent);; 665 ; 666 fEditMenu->DisableEntry(kEditMacro);; 667 fEditMenu->DisableEntry(kEditEvent);; 668 //---Run menu; 669 fRunMenu = new TGPopupMenu(gClient->GetRoot());; 670 fRunMenu->AddEntry(""&Macro..."", kRunMacro);; 671 fRunMenu->DisableEntry(kRunMacro);; 672 //--- Options menu; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:23608,Load,Load,23608,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['Load'],['Load']
Performance,"63///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1575/// auto len = leaf->GetLen();; 1576/// ~~~; 1577///; 1578/// and the value in the BranchCount corresponding to that entry (can be obtained; 1579/// from `branch->GetBranchCount()`).; 1580///; 1581/// \note This interface is not meant to be exposed to end users, but rather it should; 1582/// be wrapped by higher-level interfaces.; 1583///; 1584/// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; 1585///; 1586Int_t TBranch::GetEntriesSerialized(Long64_t entry, TBuffer &user_buf, TBuffer *count_buf); 1587{; 1588 // TODO: Template this and TBranch::GetBulkEntries; only difference is the TLeaf function (ReadBasketFast vs; 1589 // ReadBasketSerialized; 1590 ; 1591 // TODO: eventually support multiple leaves.; 1592 if (R__unlikely(fNleaves != 1)) { return -1; }; 1593 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1594 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kDestructive)) {; 1595 Error(""GetEntriesSerialized"", ""Encountered a branch with destructive deserialization; failing."");; 1596 return -1;; 1597 }; 1598 ; 1599 // Remember which entry we are reading.; 1600 fReadEntry = entry;; 1601 ; 1602 bool enabled = !TestBit(kDoNotProcess);; 1603 if (R__unlikely(!enabled)) { return -1; }; 1604 TBasket *basket = nullptr;; 1605 Long64_t first;; 1606 Int_t result = GetBasketAndFirst(basket, first, &u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:57487,perform,performs,57487,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['perform'],['performs']
Performance,"6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:253129,Load,LoadTree,253129,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"64_t len);  Write a buffer into the file. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:35076,cache,cache,35076,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,5,['cache'],['cache']
Performance,"64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. Long64_t DrawSelect(TDSet* dset, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:31967,cache,cache,31967,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['cache']
Performance,"64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Learn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25430,cache,cache,25430,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476 ; 5477////////////////////////////////////////////////////////////////////////////////; 5478/// Return pointer to the current file.; 5479 ; 5480TFile* TTree::GetCurrentFile() const; 5481{; 5482 if (!fDirectory || fDirectory==",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:215817,cache,cacheSize,215817,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cacheSize']
Performance,"64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:137600,cache,cache,137600,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"65 b.WriteClassBuffer(pThis, object);; 6866 }; 6867}; 6868 ; 6869////////////////////////////////////////////////////////////////////////////////; 6870/// Default streaming in cases where either we have no way to know what to do; 6871/// or if Property() has not yet been called.; 6872 ; 6873void TClass::StreamerDefault(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class); 6874{; 6875 if (pThis->fProperty==(-1)) {; 6876 pThis->Property();; 6877 }; 6878 ; 6879 // We could get here because after this thread started StreamerDefault; 6880 // *and* before check fProperty, another thread might have call Property; 6881 // and this fProperty when we read it, is not -1 and fStreamerImpl is; 6882 // supposed to be set properly (no longer pointing to the default).; 6883 if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {; 6884 pThis->Fatal(""StreamerDefault"", ""fStreamerImpl not properly initialized (%d)"", pThis->fStreamerType);; 6885 } else {; 6886 (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);; 6887 }; 6888}; 6889 ; 6890////////////////////////////////////////////////////////////////////////////////; 6891/// Adopt a TClassStreamer object. Ownership is transfered to this TClass; 6892/// object.; 6893 ; 6894void TClass::AdoptStreamer(TClassStreamer *str); 6895{; 6896// // This code can be used to quickly test the STL Emulation layer; 6897// Int_t k = TClassEdit::IsSTLCont(GetName());; 6898// if (k==1||k==-1) { delete str; return; }; 6899 ; 6900 R__LOCKGUARD(gInterpreterMutex);; 6901 ; 6902 if (fStreamer) delete fStreamer;; 6903 if (str) {; 6904 fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );; 6905 fStreamer = str;; 6906 fStreamerImpl = &TClass::StreamerExternal;; 6907 } else if (fStreamer) {; 6908 // Case where there was a custom streamer and it is hereby removed,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:264274,load,load,264274,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"65////////////////////////////////////////////////////////////////////////////////; 466/// Return the rule that has 'name' as a source.; 467 ; 468const TSchemaRule* TSchemaRuleSet::TMatches::GetRuleWithSource( const TString& name ) const; 469{; 470 for( auto rule : *this ) {; 471 if( rule->HasSource( name ) ) return rule;; 472 }; 473 return nullptr;; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Return the rule that has 'name' as a target.; 478 ; 479const TSchemaRule* TSchemaRuleSet::TMatches::GetRuleWithTarget( const TString& name ) const; 480{; 481 for( auto rule : *this ) {; 482 if( rule->HasTarget( name ) ) return rule;; 483 }; 484 return nullptr;; 485}; 486 ; 487////////////////////////////////////////////////////////////////////////////////; 488/// Return true if the set of rules has at least one rule that has the data; 489/// member named 'name' as a source.; 490/// If needingAlloc is true, only the rule that requires the data member to; 491/// be cached will be taken in consideration.; 492 ; 493Bool_t TSchemaRuleSet::TMatches::HasRuleWithSource( const TString& name, Bool_t needingAlloc ) const; 494{; 495 for( auto rule : *this ) {; 496 if( rule->HasSource( name ) ) {; 497 if (needingAlloc) {; 498 const TObjArray *targets = rule->GetTarget();; 499 if (targets && (targets->GetEntriesFast() > 1 || targets->IsEmpty()) ) {; 500 return kTRUE;; 501 }; 502 if (targets && name != targets->UncheckedAt(0)->GetName() ) {; 503 return kTRUE;; 504 }; 505 // If the rule has the same source and target and does not; 506 // have any actions, then it does not need allocation.; 507 if (rule->GetReadFunctionPointer() || rule->GetReadRawFunctionPointer()) {; 508 return kTRUE;; 509 }; 510 } else {; 511 return kTRUE;; 512 }; 513 }; 514 }; 515 return kFALSE;; 516}; 517 ; 518////////////////////////////////////////////////////////////////////////////////; 519/// Return true if the set of rules has at least one rule that has the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html:17352,cache,cached,17352,doc/master/TSchemaRuleSet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html,1,['cache'],['cached']
Performance,"659////////////////////////////////////////////////////////////////////////////////; 1660/// Internal routine returning, and creating if necessary, the list; 1661/// of global function.; 1662 ; 1663TListOfFunctions *TROOT::GetGlobalFunctions(); 1664{; 1665 if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(nullptr);; 1666 return fGlobalFunctions;; 1667}; 1668 ; 1669////////////////////////////////////////////////////////////////////////////////; 1670/// Return the collection of functions named ""name"".; 1671 ; 1672TCollection *TROOT::GetListOfFunctionOverloads(const char* name) const; 1673{; 1674 return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Return pointer to global function by name.; 1679/// If params != 0 it will also resolve overloading other it returns the first; 1680/// name match.; 1681/// If params == 0 and load is true force reading of all currently defined; 1682/// global functions from Cling.; 1683/// The param string must be of the form: ""3189,\""aap\"",1.3"".; 1684 ; 1685TFunction *TROOT::GetGlobalFunction(const char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712//////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:64869,load,load,64869,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"65TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3866{; 3867 R__LOCKGUARD(gInterpreterMutex);; 3868 ; 3869 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3870 if (load) fFuncTemplate->Load();; 3871 return fFuncTemplate;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Return list containing the TMethods of a class.; 3876/// If load is true, the list is populated with all the defined function; 3877/// and currently instantiated function template.; 3878 ; 3879TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3880{; 3881 R__LOCKGUARD(gInterpreterMutex);; 3882 ; 3883 if (!fMethod.load()) GetMethodList();; 3884 if (load) {; 3885 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3886 (*fMethod).Load();; 3887 }; 3888 return fMethod;; 3889}; 3890 ; 3891////////////////////////////////////////////////////////////////////////////////; 3892/// Return the collection of functions named ""name"".; 3893 ; 3894TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3895{; 3896 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3897}; 3898 ; 3899 ; 3900////////////////////////////////////////////////////////////////////////////////; 3901/// Returns a list of all public methods of this class and its base classes.; 3902/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3903/// GetListOfAllPublicMethods()->Delete().; 3904/// Algorithm used to get the list is:; 3905/// - put all methods of the class in the list (also protected and private; 3906/// ones).; 3907/// - loop over all base classes and add only those methods not already in the; 3908/// list (also protected and private ones).; 3909/// - once finished, loop over resulting list and remove all private and; 3910/// protected methods.; 3911 ; 3912const TList *TClass::GetLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:147253,Load,Load,147253,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"671/// ch.Draw(""var:t1.v1:t2.v2"");; 672/// ~~~; 673/// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; 674/// connects the trees in the chain. When a chain is deleted, its friend; 675/// elements are also deleted.; 676///; 677/// The number of entries in the friend must be equal or greater to the number; 678/// of entries of the original chain. If the friend has fewer entries a warning; 679/// is given and the resulting histogram will have missing entries.; 680/// For additional information see TTree::AddFriend.; 681 ; 682TFriendElement* TChain::AddFriend(const char* chain, const char* dummy /* = """" */); 683{; 684 if (!fFriends) {; 685 fFriends = new TList();; 686 }; 687 TFriendElement* fe = new TFriendElement(this, chain, dummy);; 688 ; 689 R__ASSERT(fe); // There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null; 690 ; 691 fFriends->Add(fe);; 692 ; 693 if (fProofChain); 694 // This updates the proxy chain when we will really use PROOF; 695 ResetBit(kProofUptodate);; 696 ; 697 // We need to invalidate the loading of the current tree because its list; 698 // of real friends is now obsolete. It is repairable only from LoadTree.; 699 InvalidateCurrentTree();; 700 ; 701 TTree* tree = fe->GetTree();; 702 if (!tree) {; 703 Warning(""AddFriend"", ""Unknown TChain %s"", chain);; 704 }; 705 return fe;; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add the whole chain or tree as a friend of this chain.; 710 ; 711TFriendElement* TChain::AddFriend(const char* chain, TFile* dummy); 712{; 713 if (!fFriends) fFriends = new TList();; 714 TFriendElement *fe = new TFriendElement(this,chain,dummy);; 715 ; 716 R__ASSERT(fe); // There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null; 717 ; 718 fFriends->Add(fe);; 719 ; 720 if (fProofChain); 721 // This updates the proxy chain when we will really use PROOF; 722 ResetBit(kProofUptodat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:27127,load,loading,27127,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loading']
Performance,6; TBranchElement::fIDInt_t fIDelement serial number in fInfoDefinition TBranchElement.h:66; TBranchElement::GetAddresschar * GetAddress() const overrideGet the branch address.Definition TBranchElement.cxx:1923; TBranchElement::FillLeavesMemberCountervoid FillLeavesMemberCounter(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1697; TBranchElement::SetBranchCount2void SetBranchCount2(TBranchElement *bre)Definition TBranchElement.h:124; TBranchElement::FillLeavesCollectionSplitPtrMembervoid FillLeavesCollectionSplitPtrMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1499; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::GetInfoImpTStreamerInfo * GetInfoImp() constGet streamer info for the branch class.Definition TBranchElement.cxx:1011; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::ResetDeleteObjectvirtual void ResetDeleteObject()Release ownership of any allocated objects.Definition TBranchElement.cxx:4814; TBranchElement::GetParentNamevirtual const char * GetParentName() constDefinition TBranchElement.h:200; TBranchElement::ValidateAddressvoid ValidateAddress() constDefinition TBranchElement.h:264; TBranchElement::GetOnfileObjectTVirtualArray * GetOnfileObject() constDefinition TBranchElement.h:199; TBranchElement::fWriteIteratorsTVirtualCollectionIterators * fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.Definition TBranchElement.h:102; TBranchElement::PrintValuevoid PrintValue(Int_t i) constPrints values of leaves.Definition TBranchElement.cxx:3928; TBranchElement::fOnfileObjectTVirtualArray * fOnfileObject! Place holder for the onfile representation of data mem,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:262426,load,loaded,262426,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['load'],['loaded']
Performance,"6; TGeoManager::ClearAttributesvoid ClearAttributes()Reset all attributes to default ones.Definition TGeoManager.cxx:1455; TGeoManager::fgMaxDaughtersstatic Int_t fgMaxDaughtersMaximum level in geometry.Definition TGeoManager.h:53; TGeoManager::fUsePWNavBool_t fUsePWNavRaytrace mode: 0=normal, 1=pass through, 2=transparent.Definition TGeoManager.h:147; TGeoManager::SetRTmodevoid SetRTmode(Int_t mode)Change raytracing mode.Definition TGeoManager.cxx:3108; TGeoManager::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the current navigator.Definition TGeoManager.cxx:1715; TGeoManager::InspectStatevoid InspectState() constInspects path and all flags for the current state.Definition TGeoManager.cxx:2873; TGeoManager::ConvertReflectionsvoid ConvertReflections()Convert all reflections in geometry to normal rotations + reflected shapes.Definition TGeoManager.cxx:1723; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoManager::CountLevelsvoid CountLevels()Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices.Definition TGeoManager.cxx:1759; TGeoManager::fMaxThreadsInt_t fMaxThreadsDefinition TGeoManager.h:144; TGeoManager::fIsGeomReadingBool_t fIsGeomReadingDefinition TGeoManager.h:82; TGeoManager",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:192297,perform,performedDefinition,192297,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['perform'],['performedDefinition']
Performance,"6; TGeoManager::ClearAttributesvoid ClearAttributes()Reset all attributes to default ones.Definition TGeoManager.cxx:1455; TGeoManager::fgMaxDaughtersstatic Int_t fgMaxDaughtersMaximum level in geometry.Definition TGeoManager.h:53; TGeoManager::fUsePWNavBool_t fUsePWNavRaytrace mode: 0=normal, 1=pass through, 2=transparent.Definition TGeoManager.h:147; TGeoManager::SetRTmodevoid SetRTmode(Int_t mode)Change raytracing mode.Definition TGeoManager.cxx:3108; TGeoManager::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the current navigator.Definition TGeoManager.cxx:1715; TGeoManager::InspectStatevoid InspectState() constInspects path and all flags for the current state.Definition TGeoManager.cxx:2873; TGeoManager::ConvertReflectionsvoid ConvertReflections()Convert all reflections in geometry to normal rotations + reflected shapes.Definition TGeoManager.cxx:1723; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::SetMatrixTransformvoid SetMatrixTransform(Bool_t on=kTRUE)Definition TGeoManager.h:398; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; TGeoManager::MasterToLocalBombvoid MasterToLocalBomb(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:546; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoManager::CountLevelsvoid CountLevels()Count maximum number of nodes per volume, maximum dept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:59345,perform,performedDefinition,59345,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['perform'],['performedDefinition']
Performance,"6; TH3::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH3.cxx:264; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::FillInt_t Fill(const char *, const char *, Double_t)Definition TH3.h:63; TH3::BufferFillvirtual Int_t BufferFill(Double_t, Double_t, Double_t)Definition TH3.h:57; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8h_source.html:37116,perform,performing,37116,doc/master/TH3_8h_source.html,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html,1,['perform'],['performing']
Performance,6mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.00573 sec ; Factory : Test method: TMVA_DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.023 sec ; Factory : Test method: TMVA_CNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.149 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.175 sec ; Factory : Test method: PyTorch for Classification performance; : ; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; RecursiveScriptModule(; original_name=Sequential; (0): RecursiveScriptModule(original_name=Reshape); (1): RecursiveScriptModule(original_name=Conv2d); (2): RecursiveScriptModule(original_name=ReLU); (3): RecursiveScriptModule(original_name=BatchNorm2d); (4): RecursiveScriptModule(ori,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:38651,perform,performance,38651,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance,"6{; 6697 time_t now;; 6698 int n, total, allowed;; 6699 ; 6700 if (conn == NULL) {; 6701 return 0;; 6702 }; 6703 if (len > INT_MAX) {; 6704 return -1;; 6705 }; 6706 ; 6707 /* Mark connection as ""data sent"" */; 6708 conn->request_state = 10;; 6709#if defined(USE_HTTP2); 6710 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6711 http2_data_frame_head(conn, len, 0);; 6712 }; 6713#endif; 6714 ; 6715 if (conn->throttle > 0) {; 6716 if ((now = time(NULL)) != conn->last_throttle_time) {; 6717 conn->last_throttle_time = now;; 6718 conn->last_throttle_bytes = 0;; 6719 }; 6720 allowed = conn->throttle - conn->last_throttle_bytes;; 6721 if (allowed > (int)len) {; 6722 allowed = (int)len;; 6723 }; 6724 ; 6725 total = push_all(conn->phys_ctx,; 6726 NULL,; 6727 conn->client.sock,; 6728 conn->ssl,; 6729 (const char *)buf,; 6730 allowed);; 6731 ; 6732 if (total == allowed) {; 6733 ; 6734 buf = (const char *)buf + total;; 6735 conn->last_throttle_bytes += total;; 6736 while ((total < (int)len); 6737 && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6738 allowed = (conn->throttle > ((int)len - total)); 6739 ? (int)len - total; 6740 : conn->throttle;; 6741 ; 6742 n = push_all(conn->phys_ctx,; 6743 NULL,; 6744 conn->client.sock,; 6745 conn->ssl,; 6746 (const char *)buf,; 6747 allowed);; 6748 ; 6749 if (n != allowed) {; 6750 break;; 6751 }; 6752 sleep(1);; 6753 conn->last_throttle_bytes = allowed;; 6754 conn->last_throttle_time = time(NULL);; 6755 buf = (const char *)buf + n;; 6756 total += n;; 6757 }; 6758 }; 6759 } else {; 6760 total = push_all(conn->phys_ctx,; 6761 NULL,; 6762 conn->client.sock,; 6763 conn->ssl,; 6764 (const char *)buf,; 6765 (int)len);; 6766 }; 6767 if (total > 0) {; 6768 conn->num_bytes_sent += total;; 6769 }; 6770 return total;; 6771}; 6772 ; 6773 ; 6774/* Send a chunk, if ""Transfer-Encoding: chunked"" is used */; 6775int; 6776mg_send_chunk(struct mg_connection *conn,; 6777 const char *chunk,; 6778 unsigned int chunk_len); 6779{; 6780 char lenbuf[16];; 6781 siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:195503,throttle,throttle,195503,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['throttle'],['throttle']
Performance,"7 // The ntuple unique pointer goes out of scope here. On destruction, the ntuple flushes unwritten data to disk; 78 // and closes the attached ROOT file.; 79}; 80 ; 81void Analyze() {; 82 // Get a unique pointer to an empty RNTuple model; 83 auto model = RNTupleModel::Create();; 84 ; 85 // We only define the fields that are needed for reading; 86 std::shared_ptr<int> fldAge = model->MakeField<int>(""Age"");; 87 ; 88 // Create an ntuple and attach the read model to it; 89 auto ntuple = RNTupleReader::Open(std::move(model), ""Staff"", kNTupleFileName);; 90 ; 91 // Quick overview of the ntuple and list of fields.; 92 ntuple->PrintInfo();; 93 ; 94 std::cout << ""The first entry in JSON format:"" << std::endl;; 95 ntuple->Show(0);; 96 // In a future version of RNTuple, there will be support for ntuple->Scan(); 97 ; 98 auto c = new TCanvas(""c"", """", 200, 10, 700, 500);; 99 TH1I h(""h"", ""Age Distribution CERN, 1988"", 100, 0, 100);; 100 h.SetFillColor(48);; 101 ; 102 for (auto entryId : *ntuple) {; 103 // Populate fldAge; 104 ntuple->LoadEntry(entryId);; 105 h.Fill(*fldAge);; 106 }; 107 ; 108 h.DrawCopy();; 109}; 110 ; 111void ntpl001_staff() {; 112 Ingest();; 113 Analyze();; 114}; RNTupleModel.hxx; RNTupleReader.hxx; RNTupleWriter.hxx; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; TCanvas.h; TH1I.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; ROOT::Experimental::RNTupleModelThe RNTupleModel encapulates the schema of an ntuple.Definition RNTupleModel.hxx:136; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540. tutorialsv7ntuplentpl001_staff.C. ROOT master - Reference Guide Generated on Tue Nov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C_source.html:4267,Load,LoadEntry,4267,doc/master/ntpl001__staff_8C_source.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html,1,['Load'],['LoadEntry']
Performance,"7 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2.97 *; 12.5 Scan a Variable the Tree with TTree::Scan; The TTree::Scan method shows all values of the list of leaves separated by a colon.; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; 12.6 The Tree Viewer. Activating the tree viewer. The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a TTree and select StartViewer. You can also start the tree viewer from the command line. First load the viewer library.; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); If you want to start a tree viewer without a tree, you need to load the tree player library first:; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); The figure above shows how the tree viewer looks like for the example file cernstaff.root. The left panel contains the list of trees and their branches; in this case there is only one tree. You can add more trees with the File-Open command to open the file containing the new tree, then use the context menu on the right panel, select SetTreeName and enter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle the following:; Hist- the histogram drawing mode;; Scan- enables redirecting of TTree::Scancommand in an ASCII file;; Rec - enabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:525865,load,load,525865,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Load', 'load']","['Load', 'load']"
Performance,"7 if (fAddress || TestBit(kDecomposedObj)) {; 5898 // -- Do nothing if already setup or if we are a MakeClass branch.; 5899 return;; 5900 }; 5901 SetupAddressesImpl();; 5902}; 5903 ; 5904////////////////////////////////////////////////////////////////////////////////; 5905/// If the branch address is not set, we set all addresses starting with; 5906/// the top level parent branch. This is required to be done in order for; 5907/// GetOffset to be correct and for GetEntry to run.; 5908 ; 5909void TBranchElement::SetupAddressesImpl(); 5910{; 5911 if (TestBit((long)kDoNotProcess|(long)kAddressSet)) {; 5912 // -- Do nothing if we have been told not to.; 5913 // Or the data member in this branch is not longer part of the; 5914 // parent's layout.; 5915 return;; 5916 }; 5917 ; 5918 //--------------------------------------------------------------------------; 5919 // Check if we are splited STL collection of pointers; 5920 /////////////////////////////////////////////////////////////////////////////; 5921 ; 5922 if( fType == 41 && fSplitLevel >= TTree::kSplitCollectionOfPointers ); 5923 {; 5924 TBranchElement *parent = (TBranchElement *)GetMother()->GetSubBranch( this );; 5925 ; 5926 // Make sure the StreamerInfo is loaded and initialized.; 5927 GetInfoImp();; 5928 ; 5929 if( !parent->GetAddress() ); 5930 parent->SetAddress( nullptr );; 5931 return;; 5932 }; 5933 ; 5934 //--------------------------------------------------------------------------; 5935 // Any other case; 5936 /////////////////////////////////////////////////////////////////////////////; 5937 ; 5938 TBranchElement* mother = (TBranchElement*) GetMother();; 5939 if (!mother) {; 5940 return;; 5941 }; 5942 TClass* cl = TClass::GetClass(mother->GetClassName());; 5943 ; 5944 // Make sure the StreamerInfo is loaded and initialized.; 5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mothe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:222215,load,loaded,222215,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['loaded']
Performance,"7 obj.GetAllocator()->Destructor(obj.GetPtr(), dtorOnly);; 5588 } else {; 5589 Destructor(obj.GetPtr(), dtorOnly);; 5590 }; 5591}; 5592 ; 5593////////////////////////////////////////////////////////////////////////////////; 5594/// Explicitly call operator delete[] for an array.; 5595 ; 5596void TClass::DeleteArray(void *ary, Bool_t dtorOnly); 5597{; 5598 // Do nothing if passed a null pointer.; 5599 if (ary == nullptr) return;; 5600 ; 5601 // Make a copy of the address.; 5602 void* p = ary;; 5603 ; 5604 if (fDeleteArray) {; 5605 if (dtorOnly) {; 5606 Error(""DeleteArray"", ""Destructor only is not supported!"");; 5607 } else {; 5608 // We have the array delete wrapper, use it.; 5609 fDeleteArray(ary);; 5610 }; 5611 } else if (HasInterpreterInfo()) {; 5612 // We have the dictionary but do not have the; 5613 // array delete wrapper, so the dictionary was; 5614 // not generated by rootcint. Let's try to; 5615 // delete the array by having the interpreter; 5616 // call the array delete operator, hopefully; 5617 // the class library is loaded and there will be; 5618 // a destructor we can call.; 5619 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5620 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5621 // There is no dictionary at all, so this is an emulated; 5622 // class; however we do have the services of a collection proxy,; 5623 // so this is an emulated STL class.; 5624 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5625 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5626 // There is no dictionary at all and we do not have; 5627 // the services of a collection proxy available, so; 5628 // use the streamer info to approximate calling the; 5629 // array destructor.; 5630 ; 5631 Bool_t inRepo = kTRUE;; 5632 Bool_t currentVersion = kFALSE;; 5633 ; 5634 // Was this array object allocated through TClass?; 5635 Version_t objVer = -1;; 5636 {; 5637 R__LOCKGUARD2(fOVRMutex);; 5638 RepoCont_t::iterator iter = fObjectVersionRepository.find",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:215003,load,loaded,215003,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"7 settings.regularization = DNN::ERegularization::kL2;; 348 } else {; 349 settings.regularization = DNN::ERegularization::kNone;; 350 }; 351 ; 352 TString optimizer = fetchValueTmp(block, ""Optimizer"", TString(""ADAM""));; 353 settings.optimizerName = optimizer;; 354 if (optimizer == ""SGD"") {; 355 settings.optimizer = DNN::EOptimizer::kSGD;; 356 } else if (optimizer == ""ADAM"") {; 357 settings.optimizer = DNN::EOptimizer::kAdam;; 358 } else if (optimizer == ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optimizer = DNN::EOptimizer::kRMSProp;; 362 } else if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamName) > 0) {; 383 double defValue = defaultValues[optimParamName];; 384 double val = fetchValueTmp(block, optimParamName, defValue);; 385 // create entry in settings for this optimizer parameter; 386 settings.optimizerParams[optimParamName] = val;; 387 }; 388 }; 389 ; 390 fTrainingSettings.push_back(settings);; 391 }; 392 ; 393 // this set fInputShape[0] = batchSize; 394 this->SetBatchSize(fTrainingSettings.front().batchSize);; 395 ; 396 // case inputlayout and batc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:14358,optimiz,optimizerName,14358,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizer', 'optimizerName']"
Performance,"7 }; 4258 // We can not check at this point whether after the unload there will; 4259 // still be interpreter information about this class (as v5 was doing),; 4260 // instead this function must only be called if the definition is (about); 4261 // to be unloaded.; 4262 ; 4263 ResetCaches();; 4264 ; 4265 // We got here because the definition Decl is about to be unloaded.; 4266 if (fState != TClass::kHasTClassInit) {; 4267 if (fStreamerInfo->GetEntries() != 0) {; 4268 fState = TClass::kEmulated;; 4269 } else {; 4270 fState = TClass::kForwardDeclared;; 4271 }; 4272 } else {; 4273 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Resets the menu list to it's standard value.; 4309 ; 4310void TClass::ResetMenuList(); 4311{; 4312 if (fClassMenuList); 4313 fClassMenuList->Delete();; 4314 else; 4315 fClassMenuList = new TList();; 4316 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4317}; 4318 ; 4319/////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:162311,cache,caches,162311,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['cache', 'load']","['caches', 'loading']"
Performance,"7 }; 6648 if ((i > 0) && (lenbuf[i] == '\r'); 6649 && (lenbuf[i - 1] != '\r')) {; 6650 continue;; 6651 }; 6652 if ((i > 1) && (lenbuf[i] == '\n'); 6653 && (lenbuf[i - 1] == '\r')) {; 6654 lenbuf[i + 1] = 0;; 6655 chunkSize = strtoul(lenbuf, &end, 16);; 6656 if (chunkSize == 0) {; 6657 /* regular end of content */; 6658 conn->is_chunked = 3;; 6659 }; 6660 break;; 6661 }; 6662 if (!isxdigit((unsigned char)lenbuf[i])) {; 6663 /* illegal character for chunk length */; 6664 conn->is_chunked = 2;; 6665 return -1;; 6666 }; 6667 }; 6668 if ((end == NULL) || (*end != '\r')) {; 6669 /* chunksize not set correctly */; 6670 conn->is_chunked = 2;; 6671 return -1;; 6672 }; 6673 if (chunkSize == 0) {; 6674 /* try discarding trailer for keep-alive */; 6675 conn->content_len += 2;; 6676 if ((mg_read_inner(conn, lenbuf, 2) == 2); 6677 && (lenbuf[0] == '\r') && (lenbuf[1] == '\n')) {; 6678 conn->is_chunked = 4;; 6679 }; 6680 break;; 6681 }; 6682 ; 6683 /* append a new chunk */; 6684 conn->content_len += (int64_t)chunkSize;; 6685 }; 6686 }; 6687 ; 6688 return (int)all_read;; 6689 }; 6690 return mg_read_inner(conn, buf, len);; 6691}; 6692 ; 6693 ; 6694int; 6695mg_write(struct mg_connection *conn, const void *buf, size_t len); 6696{; 6697 time_t now;; 6698 int n, total, allowed;; 6699 ; 6700 if (conn == NULL) {; 6701 return 0;; 6702 }; 6703 if (len > INT_MAX) {; 6704 return -1;; 6705 }; 6706 ; 6707 /* Mark connection as ""data sent"" */; 6708 conn->request_state = 10;; 6709#if defined(USE_HTTP2); 6710 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6711 http2_data_frame_head(conn, len, 0);; 6712 }; 6713#endif; 6714 ; 6715 if (conn->throttle > 0) {; 6716 if ((now = time(NULL)) != conn->last_throttle_time) {; 6717 conn->last_throttle_time = now;; 6718 conn->last_throttle_bytes = 0;; 6719 }; 6720 allowed = conn->throttle - conn->last_throttle_bytes;; 6721 if (allowed > (int)len) {; 6722 allowed = (int)len;; 6723 }; 6724 ; 6725 total = push_all(conn->phys_ctx,; 6726 NULL,; 6727 conn->client.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:194839,throttle,throttle,194839,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['throttle'],['throttle']
Performance,"701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 475",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:190526,optimiz,optimized,190526,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,4,['optimiz'],['optimized']
Performance,"72 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 2273 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 2274 TIter next(sinfo->GetElements());; 2275 TStreamerElement *element;; 2276 while ((element = (TStreamerElement*)next())) {; 2277 if (element->IsA() == TStreamerBase::Class()) {; 2278 TClass *clbase = element->GetClassPointer();; 2279 if (!clbase) {; 2280 // If there is a missing base class, we can't split the immediate; 2281 // derived class.; 2282 fCanSplit = 0;; 2283 return kFALSE;; 2284 } else if (!clbase->CanSplitBaseAllow()) {; 2285 fCanSplit = 2;; 2286 return kFALSE;; 2287 }; 2288 }; 2289 }; 2290 }; 2291 ; 2292 // If we don't have data member info there is no more information; 2293 // we can find out.; 2294 if (!HasDataMemberInfo()) return kTRUE;; 2295 ; 2296 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2297 ; 2298 // Look at inheritance tree; 2299 while (lnk) {; 2300 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2301 TClass *c = base->GetClassPointer();; 2302 if(!c) {; 2303 // If there is a missing base class, we can't split the immediate; 2304 // derived class.; 2305 fCanSplit = 0;; 2306 return kFALSE;; 2307 } else if (!c->CanSplitBaseAllow()) {; 2308 fCanSplit = 2;; 2309 return kFALSE;; 2310 }; 2311 lnk = lnk->Next();; 2312 }; 2313 return kTRUE;; 2314}; 2315 ; 2316////////////////////////////////////////////////////////////////////////////////; 2317/// Return true if the data member of this TClass can be saved separately.; 2318 ; 2319Bool_t TClass::CanSplit() const; 2320{; 2321 // Note: add the possibility to set it for the class and the derived class.; 2322 // save the info in TVirtualStreamerInfo; 2323 // deal with the info in MakeProject; 2324 if (fCanSplit >= 0) {; 2325 // The user explicitly set the value; 2326 return (fCanSplit & 0x1) == 1;; 2327 }; 2328 ; 2329 R__LOCKGUARD(gInterpreterMutex);; 2330 TClass *This = const_cast<TClass*>(this);; 2331 ; 2332 if (this == TObject::Class()) { T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:86762,load,load,86762,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"72 if (!sinfo->IsCompiled()) {; 4673 // Streamer info has not been compiled, but exists.; 4674 // Therefore it was read in from a file and we have to do schema evolution?; 4675 // Or it didn't have a dictionary before, but does now?; 4676 sinfo->BuildOld();; 4677 }; 4678 }; 4679 ; 4680 // Cache the current info if we now have it.; 4681 if (version == fClassVersion); 4682 fCurrentInfo = sinfo;; 4683 ; 4684 // If the compilation succeeded, remember this StreamerInfo.; 4685 if (sinfo->IsCompiled()); 4686 fLastReadInfo = sinfo;; 4687 ; 4688 return sinfo;; 4689}; 4690 ; 4691////////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 472",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:178503,load,loaded,178503,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRootmapLoadPath) {; 5766 fRootmapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:223832,Load,LoadLibraryMap,223832,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"72{; 973 if (&other == this); 974 return kTRUE;; 975 const Double_t *rot = GetRotationMatrix();; 976 const Double_t *orot = other.GetRotationMatrix();; 977 for (auto i = 0; i < 9; i++); 978 if (TMath::Abs(rot[i] - orot[i]) > 1.E-10); 979 return kFALSE;; 980 return kTRUE;; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Return a temporary inverse of this.; 985 ; 986TGeoHMatrix TGeoRotation::Inverse() const; 987{; 988 TGeoHMatrix h;; 989 h = *this;; 990 h.ResetBit(kGeoRegistered);; 991 Double_t newrot[9];; 992 newrot[0] = fRotationMatrix[0];; 993 newrot[1] = fRotationMatrix[3];; 994 newrot[2] = fRotationMatrix[6];; 995 newrot[3] = fRotationMatrix[1];; 996 newrot[4] = fRotationMatrix[4];; 997 newrot[5] = fRotationMatrix[7];; 998 newrot[6] = fRotationMatrix[2];; 999 newrot[7] = fRotationMatrix[5];; 1000 newrot[8] = fRotationMatrix[8];; 1001 h.SetRotation(newrot);; 1002 return h;; 1003}; 1004 ; 1005////////////////////////////////////////////////////////////////////////////////; 1006/// Perform orthogonality test for rotation.; 1007 ; 1008Bool_t TGeoRotation::IsValid() const; 1009{; 1010 const Double_t *r = fRotationMatrix;; 1011 Double_t cij;; 1012 for (Int_t i = 0; i < 2; i++) {; 1013 for (Int_t j = i + 1; j < 3; j++) {; 1014 // check columns; 1015 cij = TMath::Abs(r[i] * r[j] + r[i + 3] * r[j + 3] + r[i + 6] * r[j + 6]);; 1016 if (cij > 1E-4); 1017 return kFALSE;; 1018 // check rows; 1019 cij = TMath::Abs(r[3 * i] * r[3 * j] + r[3 * i + 1] * r[3 * j + 1] + r[3 * i + 2] * r[3 * j + 2]);; 1020 if (cij > 1E-4); 1021 return kFALSE;; 1022 }; 1023 }; 1024 return kTRUE;; 1025}; 1026 ; 1027////////////////////////////////////////////////////////////////////////////////; 1028/// reset data members; 1029 ; 1030void TGeoRotation::Clear(Option_t *); 1031{; 1032 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 1033 ResetBit(kGeoRotation);; 1034}; 1035 ; 1036//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:34416,Perform,Perform,34416,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['Perform'],['Perform']
Performance,"73 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Resets the menu list to it's standard value.; 4309 ; 4310void TClass::ResetMenuList(); 4311{; 4312 if (fClassMenuList); 4313 fClassMenuList->Delete();; 4314 else; 4315 fClassMenuList = new TList();; 4316 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4317}; 4318 ; 4319////////////////////////////////////////////////////////////////////////////////; 4320/// The ls function lists the contents of a class on stdout. Ls output; 4321/// is typically much less verbose then Dump().; 4322/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4323/// and the list of conversion streamerInfos.; 4324 ; 4325void TClass::ls(Option_t *options) const; 4326{; 4327 TNamed::ls(options);; 4328 if (options==nullptr || options[0]==0) return;; 4329 ; 4330 if (strstr(options,""streamerinfo"")!=nullptr) {; 4331 GetStreamerInfos()->ls(options);; 4332 ; 4333 if (fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:162767,load,load,162767,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:142120,load,load,142120,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"75 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58228,cache,cache,58228,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"76 ; 377 // Check if the bins are the same.; 378 TList *h1pBins = h1p->GetBins();; 379 TH2PolyBin *thisBin, *h1pBin;; 380 for (bin = 1; bin <= GetNumberOfBins(); bin++) {; 381 thisBin = (TH2PolyBin *)fBins->At(bin - 1);; 382 h1pBin = (TH2PolyBin *)h1pBins->At(bin - 1);; 383 if (thisBin->GetXMin() != h1pBin->GetXMin() ||; 384 thisBin->GetXMax() != h1pBin->GetXMax() ||; 385 thisBin->GetYMin() != h1pBin->GetYMin() ||; 386 thisBin->GetYMax() != h1pBin->GetYMax()) {; 387 Error(""Add"", ""Attempt to add histograms with different bin limits"");; 388 return kFALSE;; 389 }; 390 }; 391 ; 392 ; 393 // Create Sumw2 if h1p has Sumw2 set; 394 if (fSumw2.fN == 0 && h1p->GetSumw2N() != 0) Sumw2();; 395 ; 396 // statistics can be preserved only in case of positive coefficients; 397 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 398 Bool_t resetStats = (c1 < 0);; 399 Double_t s1[kNstat] = {0};; 400 Double_t s2[kNstat] = {0};; 401 if (!resetStats) {; 402 // need to initialize to zero s1 and s2 since; 403 // GetStats fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:15806,Perform,Perform,15806,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['Perform'],['Perform']
Performance,"76 of file FitConfig.h. ◆ SetDefaultMinimizer(). void ROOT::Fit::FitConfig::SetDefaultMinimizer ; (; const char * ; type, . const char * ; algo = nullptr . ). static . static function to control default minimizer type and algorithm ; Definition at line 252 of file FitConfig.cxx. ◆ SetFromFitResult(). void ROOT::Fit::FitConfig::SetFromFitResult ; (; const FitResult & ; rhs). Definition at line 80 of file FitConfig.cxx. ◆ SetMinimizer(). void ROOT::Fit::FitConfig::SetMinimizer ; (; const char * ; type, . const char * ; algo = nullptr . ). inline . set minimizer type ; Definition at line 179 of file FitConfig.h. ◆ SetMinimizerOptions(). void ROOT::Fit::FitConfig::SetMinimizerOptions ; (; const ROOT::Math::MinimizerOptions & ; minopt). set all the minimizer options using class MinimizerOptions ; Definition at line 257 of file FitConfig.cxx. ◆ SetMinosErrors() [1/2]. void ROOT::Fit::FitConfig::SetMinosErrors ; (; bool ; on = true). inline . set Minos errors computation to be performed after fitting ; Definition at line 229 of file FitConfig.h. ◆ SetMinosErrors() [2/2]. void ROOT::Fit::FitConfig::SetMinosErrors ; (; const std::vector< unsigned int > & ; paramInd). inline . set parameter indices for running Minos this can be used for running Minos on a subset of parameters - otherwise is run on all of them if MinosErrors() is set ; Definition at line 237 of file FitConfig.h. ◆ SetNormErrors(). void ROOT::Fit::FitConfig::SetNormErrors ; (; bool ; on = true). inline . set the option to normalize the error on the result according to chi2/ndf ; Definition at line 223 of file FitConfig.h. ◆ SetParabErrors(). void ROOT::Fit::FitConfig::SetParabErrors ; (; bool ; on = true). inline . set parabolic errors ; Definition at line 226 of file FitConfig.h. ◆ SetParamsSettings() [1/2]. void ROOT::Fit::FitConfig::SetParamsSettings ; (; const std::vector< ROOT::Fit::ParameterSettings > & ; pars). inline . Definition at line 145 of file FitConfig.h. ◆ SetParamsSettings() [2/2]. void ROOT::Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html:9749,perform,performed,9749,doc/master/classROOT_1_1Fit_1_1FitConfig.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html,1,['perform'],['performed']
Performance,"767 ; 768////////////////////////////////////////////////////////////////////////////////; 769/// Creates histogram basic data structure.; 770 ; 771void TH1::Build(); 772{; 773 fDirectory = nullptr;; 774 fPainter = nullptr;; 775 fIntegral = nullptr;; 776 fEntries = 0;; 777 fNormFactor = 0;; 778 fTsumw = fTsumw2=fTsumwx=fTsumwx2=0;; 779 fMaximum = -1111;; 780 fMinimum = -1111;; 781 fBufferSize = 0;; 782 fBuffer = nullptr;; 783 fBinStatErrOpt = kNormal;; 784 fStatOverflows = EStatOverflows::kNeutral;; 785 fXaxis.SetName(""xaxis"");; 786 fYaxis.SetName(""yaxis"");; 787 fZaxis.SetName(""zaxis"");; 788 fYaxis.Set(1,0.,1.);; 789 fZaxis.Set(1,0.,1.);; 790 fXaxis.SetParent(this);; 791 fYaxis.SetParent(this);; 792 fZaxis.SetParent(this);; 793 ; 794 SetTitle(fTitle.Data());; 795 ; 796 fFunctions = new TList;; 797 ; 798 UseCurrentStyle();; 799 ; 800 if (TH1::AddDirectoryStatus()) {; 801 fDirectory = gDirectory;; 802 if (fDirectory) {; 803 fFunctions->UseRWLock();; 804 fDirectory->Append(this,kTRUE);; 805 }; 806 }; 807}; 808 ; 809////////////////////////////////////////////////////////////////////////////////; 810/// Performs the operation: `this = this + c1*f1`; 811/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 812///; 813/// By default, the function is computed at the centre of the bin.; 814/// if option ""I"" is specified (1-d histogram only), the integral of the; 815/// function in each bin is used instead of the value of the function at; 816/// the centre of the bin.; 817///; 818/// Only bins inside the function range are recomputed.; 819///; 820/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 821/// you should call Sumw2 before making this operation.; 822/// This is particularly important if you fit the histogram after TH1::Add; 823///; 824/// The function return kFALSE if the Add operation failed; 825 ; 826Bool_t TH1::Add(TF1 *f1, Double_t c1, Option_t *option); 827{; 828 if (!f1) {; 829 Error(""Add"",""Attempt to add a non-ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:32711,Perform,Performs,32711,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['Perform'],['Performs']
Performance,"77 }; 1178 HaveFullGlobalModuleIndex = true;; 1179 }; 1180 return GlobalIndex;; 1181}; 1182 ; 1183static void RegisterCxxModules(cling::Interpreter &clingInterp); 1184{; 1185 if (!clingInterp.getCI()->getLangOpts().Modules); 1186 return;; 1187 ; 1188 // Loading of a module might deserialize.; 1189 cling::Interpreter::PushTransactionRAII deserRAII(&clingInterp);; 1190 ; 1191 // Setup core C++ modules if we have any to setup.; 1192 ; 1193 // Load libc and stl first.; 1194 // Load vcruntime module for windows; 1195#ifdef R__WIN32; 1196 LoadModule(""vcruntime"", clingInterp);; 1197 LoadModule(""services"", clingInterp);; 1198#endif; 1199 ; 1200#ifdef R__MACOSX; 1201 LoadModule(""Darwin"", clingInterp);; 1202#else; 1203 LoadModule(""libc"", clingInterp);; 1204#endif; 1205 LoadModule(""std"", clingInterp);; 1206 ; 1207 LoadModule(""_Builtin_intrinsics"", clingInterp);; 1208 ; 1209 // Load core modules; 1210 // This should be vector in order to be able to pass it to LoadModules; 1211 std::vector<std::string> CoreModules = {""ROOT_Foundation_C"",; 1212 ""ROOT_Config"",; 1213 ""ROOT_Rtypes"",; 1214 ""ROOT_Foundation_Stage1_NoRTTI"",; 1215 ""Core"",; 1216 ""Rint"",; 1217 ""RIO""};; 1218 ; 1219 LoadModules(CoreModules, clingInterp);; 1220 ; 1221 // Take this branch only from ROOT because we don't need to preload modules in rootcling; 1222 if (!IsFromRootCling()) {; 1223 std::vector<std::string> CommonModules = {""MathCore""};; 1224 LoadModules(CommonModules, clingInterp);; 1225 ; 1226 // These modules should not be preloaded but they fix issues.; 1227 // FIXME: Hist is not a core module but is very entangled to MathCore and; 1228 // causes issues.; 1229 std::vector<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:43228,Load,Load,43228,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,11,['Load'],"['Load', 'LoadModule', 'LoadModules']"
Performance,"78 of file TTreeFormula.cxx. ◆ IsLeafString(). bool TTreeFormula::IsLeafString ; (; Int_t ; code); const. protectedvirtual . Return TRUE if the leaf or data member corresponding to code is a string. ; Definition at line 4748 of file TTreeFormula.cxx. ◆ IsQuickLoad(). bool TTreeFormula::IsQuickLoad ; (; ); const. inline . Definition at line 204 of file TTreeFormula.h. ◆ IsString() [1/2]. bool TTreeFormula::IsString ; (; ); const. virtual . Return TRUE if the formula is a string. ; Definition at line 4726 of file TTreeFormula.cxx. ◆ IsString() [2/2]. bool TTreeFormula::IsString ; (; Int_t ; oper); const. overrideprotectedvirtual . Return true if the expression at the index 'oper' is to be treated as as string. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 4736 of file TTreeFormula.cxx. ◆ LoadBranches(). void TTreeFormula::LoadBranches ; (; ). protected . Make sure that all the branches have been loaded properly. ; Definition at line 5369 of file TTreeFormula.cxx. ◆ LoadCurrentDim(). bool TTreeFormula::LoadCurrentDim ; (; ). protected . Calculate the actual dimension for the current entry. ; Definition at line 5393 of file TTreeFormula.cxx. ◆ Notify(). bool TTreeFormula::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 206 of file TTreeFormula.h. ◆ operator=(). TTreeFormula & TTreeFormula::operator= ; (; const TTreeFormula & ; ). privatedelete . ◆ ParseWithLeaf(). Int_t TTreeFormula::ParseWithLeaf ; (; TLeaf * ; leaf, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:44834,Load,LoadCurrentDim,44834,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['Load'],['LoadCurrentDim']
Performance,"78, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); ; # Save the plot; c.SaveAs(""df104_HiggsToTwoPhotons.png""); print(""Saved figure to df104_HiggsToTwoPhotons.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 19.9699; NDf = 26; Edm = 2.09182e-08; NCalls = 161; p0 = 94325 +/- 72.0525 ; p1 = -1777.22 +/- 0.778155 ; p2 = 11.5606 +/- 0.00536059 ; p3 = -0.0256281 +/- 2.66824e-05 ; p4 = 119.1 (fixed); p5 = 125 (fixed); p6 = 2.39 (fixed); Saved figure to df104_HiggsToTwoPhotons.png; DateFebruary 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df104_HiggsToTwoPhotons.py. tutorialsdataframedf104_HiggsToTwoPhotons.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:8716,concurren,concurrently,8716,doc/master/df104__HiggsToTwoPhotons_8py.html,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html,1,['concurren'],['concurrently']
Performance,"784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:51582,cache,cache,51582,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,4,['cache'],['cache']
Performance,"7void TMVA::MethodCuts::MakeClassSpecific( std::ostream& fout, const TString& className ) const; 1708{; 1709 fout << "" // not implemented for class: \"""" << className << ""\"""" << std::endl;; 1710 fout << ""};"" << std::endl;; 1711}; 1712 ; 1713////////////////////////////////////////////////////////////////////////////////; 1714/// get help message text; 1715///; 1716/// typical length of text line:; 1717/// ""|--------------------------------------------------------------|""; 1718 ; 1719void TMVA::MethodCuts::GetHelpMessage() const; 1720{; 1721 TString bold = gConfig().WriteOptionsReference() ? ""<b>"" : """";; 1722 TString resbold = gConfig().WriteOptionsReference() ? ""</b>"" : """";; 1723 TString brk = gConfig().WriteOptionsReference() ? ""<br>"" : """";; 1724 ; 1725 Log() << Endl;; 1726 Log() << gTools().Color(""bold"") << ""--- Short description:"" << gTools().Color(""reset"") << Endl;; 1727 Log() << Endl;; 1728 Log() << ""The optimisation of rectangular cuts performed by TMVA maximises "" << Endl;; 1729 Log() << ""the background rejection at given signal efficiency, and scans "" << Endl;; 1730 Log() << ""over the full range of the latter quantity. Three optimisation"" << Endl;; 1731 Log() << ""methods are optional: Monte Carlo sampling (MC), a Genetics"" << Endl;; 1732 Log() << ""Algorithm (GA), and Simulated Annealing (SA). GA and SA are"" << Endl;; 1733 Log() << ""expected to perform best."" << Endl;; 1734 Log() << Endl;; 1735 Log() << ""The difficulty to find the optimal cuts strongly increases with"" << Endl;; 1736 Log() << ""the dimensionality (number of input variables) of the problem."" << Endl;; 1737 Log() << ""This behavior is due to the non-uniqueness of the solution space.""<< Endl;; 1738 Log() << Endl;; 1739 Log() << gTools().Color(""bold"") << ""--- Performance optimisation:"" << gTools().Color(""reset"") << Endl;; 1740 Log() << Endl;; 1741 Log() << ""If the dimensionality exceeds, say, 4 input variables, it is "" << Endl;; 1742 Log() << ""advisable to scrutinize the separation power of the varia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:67231,perform,performed,67231,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['perform'],['performed']
Performance,"7{; 6698 time_t now;; 6699 int n, total, allowed;; 6700 ; 6701 if (conn == NULL) {; 6702 return 0;; 6703 }; 6704 if (len > INT_MAX) {; 6705 return -1;; 6706 }; 6707 ; 6708 /* Mark connection as ""data sent"" */; 6709 conn->request_state = 10;; 6710#if defined(USE_HTTP2); 6711 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6712 http2_data_frame_head(conn, len, 0);; 6713 }; 6714#endif; 6715 ; 6716 if (conn->throttle > 0) {; 6717 if ((now = time(NULL)) != conn->last_throttle_time) {; 6718 conn->last_throttle_time = now;; 6719 conn->last_throttle_bytes = 0;; 6720 }; 6721 allowed = conn->throttle - conn->last_throttle_bytes;; 6722 if (allowed > (int)len) {; 6723 allowed = (int)len;; 6724 }; 6725 ; 6726 total = push_all(conn->phys_ctx,; 6727 NULL,; 6728 conn->client.sock,; 6729 conn->ssl,; 6730 (const char *)buf,; 6731 allowed);; 6732 ; 6733 if (total == allowed) {; 6734 ; 6735 buf = (const char *)buf + total;; 6736 conn->last_throttle_bytes += total;; 6737 while ((total < (int)len); 6738 && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6739 allowed = (conn->throttle > ((int)len - total)); 6740 ? (int)len - total; 6741 : conn->throttle;; 6742 ; 6743 n = push_all(conn->phys_ctx,; 6744 NULL,; 6745 conn->client.sock,; 6746 conn->ssl,; 6747 (const char *)buf,; 6748 allowed);; 6749 ; 6750 if (n != allowed) {; 6751 break;; 6752 }; 6753 sleep(1);; 6754 conn->last_throttle_bytes = allowed;; 6755 conn->last_throttle_time = time(NULL);; 6756 buf = (const char *)buf + n;; 6757 total += n;; 6758 }; 6759 }; 6760 } else {; 6761 total = push_all(conn->phys_ctx,; 6762 NULL,; 6763 conn->client.sock,; 6764 conn->ssl,; 6765 (const char *)buf,; 6766 (int)len);; 6767 }; 6768 if (total > 0) {; 6769 conn->num_bytes_sent += total;; 6770 }; 6771 return total;; 6772}; 6773 ; 6774 ; 6775/* Send a chunk, if ""Transfer-Encoding: chunked"" is used */; 6776int; 6777mg_send_chunk(struct mg_connection *conn,; 6778 const char *chunk,; 6779 unsigned int chunk_len); 6780{; 6781 char lenbuf[16];; 6782 siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:195535,throttle,throttle,195535,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['throttle'],['throttle']
Performance,"8 Printf("" function will be evaluated. [See also MNContour.]"");; 3499 goto L99;; 3500 }; 3501//______________________________________________________________________________; 3502//; 3503// Command END; 3504//; 3505 if( !strncmp(comd.Data(),""END"",3) ) {; 3506 Printf("" ***>END"");; 3507 Printf("" Signals the end of a data block (i.e., the end of a fit),"");; 3508 Printf("" and implies that execution should continue, because another"");; 3509 Printf("" Data Block follows. A Data Block is a set of Minuit data"");; 3510 Printf("" consisting of"");; 3511 Printf("" (1) A Title,"");; 3512 Printf("" (2) One or more Parameter Definitions,"");; 3513 Printf("" (3) A blank line, and"");; 3514 Printf("" (4) A set of Minuit Commands."");; 3515 Printf("" The END command is used when more than one Data Block is to"");; 3516 Printf("" be used with the same FCN function. It first causes Minuit"");; 3517 Printf("" to issue a CALL FCN with IFLAG=3, in order to allow FCN to"");; 3518 Printf("" perform any calculations associated with the final fitted"");; 3519 Printf("" parameter values, unless a CALL FCN 3 command has already"");; 3520 Printf("" been executed at the current FCN value."");; 3521 goto L99;; 3522 }; 3523//______________________________________________________________________________; 3524//; 3525// Command EXIT; 3526//; 3527 if( !strncmp(comd.Data(),""EXI"",3) ) {; 3528 Printf("" ***>EXIT"");; 3529 Printf("" Signals the end of execution."");; 3530 Printf("" The EXIT command first causes Minuit to issue a CALL FCN"");; 3531 Printf("" with IFLAG=3, to allow FCN to perform any calculations"");; 3532 Printf("" associated with the final fitted parameter values, unless a"");; 3533 Printf("" CALL FCN 3 command has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:112003,perform,perform,112003,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['perform'],['perform']
Performance,"8 R__AddPath(adddictdep,rootCling);; 2679 adddictdep += "" "";; 2680 delete [] rootCling;; 2681 }; 2682 }; 2683 adddictdep += "" >> \""""+depfilename+""\"""";; 2684 ; 2685 TString addversiondep( ""echo "");; 2686 addversiondep += libname + version_var_prefix + "" \"""" + ROOT_RELEASE + ""\"" >> \""""+depfilename+""\"""";; 2687 ; 2688 if (gDebug > 4) {; 2689 ::Info(""ACLiC"", ""%s"", touch.Data());; 2690 ::Info(""ACLiC"", ""%s"", builddep.Data());; 2691 ::Info(""ACLiC"", ""%s"", adddictdep.Data());; 2692 }; 2693 ; 2694 Int_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all information output; 2725/// - d : debug ACLiC, keep all the output files.; 2726/// - - : if buildir is set, use a flat structure (see buildir below); 2727///; 2728/// If library_specified is specified, CompileMacro generates the file; 2729/// ""library_specified"".soext where soext is the shared library extension for; 2730/// the current platform.; 2731///; 2732/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:87586,load,loads,87586,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loads']
Performance,"8 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6039 ; 6040 fCollectionProxy->Reset();; 6041 TIter nextClass(gROOT->GetListOfClasses());; 6042 while (auto acl = (TClass*)nextClass()) {; 6043 if (acl == this) continue;; 6044 if (acl->fCollectionProxy && acl->fCollectionProxy->GetValueClass() == pcl) {; 6045 acl->fCollectionProxy->Reset();; 6046 }; 6047 }; 6048 ; 6049 TIter next(pcl->GetStreamerInfos());; 6050 while (auto info = (TVirtualStreamerInfo*)next()) {; 6051 if (info->IsBuilt()) {; 6052 info->Clear(""build"");; 6053 info->BuildOld();; 6054 }; 6055 }; 6056 fCollectionProxy->GetValueClass();; 6057 }; 6058 }; 6059 }; 6060}; 6061 ; 6062////////////////////////////////////////////////////////////////////////////////; 6063/// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; 6064///; 6065/// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); 6066///; 6067/// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; 6068/// class. The bits stored in `TObject::fBits` are; 6069/// ~~~ {.cpp}; 6070/// kIsTObject : the class inherits from TObject; 6071/// kStartWithTObject: TObject is the left-most class in the inheritance tree; 6072/// kIsForeign : the class doe not have a Streamer method; 6073/// ~~~; 6074/// The value of `fStreamerType` are; 6075/// ~~~ {.cpp}; 6076/// kTObject : the class inherits from TObject; 6077/// kForeign : the class does not have a Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:233259,cache,cache,233259,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['cache'],['cache']
Performance,"8 TTree *t = fe->GetTree();; 729 if (!t) {; 730 Warning(""AddFriend"",""Unknown TChain %s"",chain);; 731 }; 732 return fe;; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Add the whole chain or tree as a friend of this chain.; 737 ; 738TFriendElement* TChain::AddFriend(TTree* chain, const char* alias, bool /* warn = false */); 739{; 740 if (!chain) return nullptr;; 741 if (!fFriends) fFriends = new TList();; 742 TFriendElement *fe = new TFriendElement(this,chain,alias);; 743 R__ASSERT(fe);; 744 ; 745 fFriends->Add(fe);; 746 ; 747 if (fProofChain); 748 // This updates the proxy chain when we will really use PROOF; 749 ResetBit(kProofUptodate);; 750 ; 751 // We need to invalidate the loading of the current tree because its list; 752 // of real friend is now obsolete. It is repairable only from LoadTree; 753 InvalidateCurrentTree();; 754 ; 755 TTree *t = fe->GetTree();; 756 if (!t) {; 757 Warning(""AddFriend"",""Unknown TChain %s"",chain->GetName());; 758 }; 759 return fe;; 760}; 761 ; 762////////////////////////////////////////////////////////////////////////////////; 763/// Browse the contents of the chain.; 764 ; 765void TChain::Browse(TBrowser* b); 766{; 767 TTree::Browse(b);; 768}; 769 ; 770////////////////////////////////////////////////////////////////////////////////; 771/// When closing a file during the chain processing, the file; 772/// may be closed with option ""R"" if flag is set to true.; 773/// by default flag is true.; 774/// When closing a file with option ""R"", all TProcessIDs referenced by this; 775/// file are deleted.; 776/// Calling TFile::Close(""R"") might be necessary in case one reads a long list; 777/// of files having TRef, writing some of the referenced objects or TRef; 778/// to a new file. If the TRef or referenced objects of the file being closed; 779/// will not be referenced again, it is possible to minimize the size; 780/// of the TProcessID data structures in memory by forcing a delete of;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:29103,Load,LoadTree,29103,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"8 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 165",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:62806,load,load,62806,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['load']
Performance,"8 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline . Definition at line 503 of file TTree.h. ◆ GetPacketSize(). virtual Int_t TTree::GetPacketSize ; (; ); const. inlinevirtual . Definition at line 505 of file TTree.h. ◆ GetPerfStats(). virtual TVirtualPerfStats * TTree::GetPerfStats ; (; ); const. inlinevirtual . Definition at line 506 of file TTree.h. ◆ GetPlayer(). TVirtualTreePlayer * TTree::GetPlayer ; (; ). Load the TTreePlayer (if not already done). ; Definition at line 6305 of file TTree.cxx. ◆ GetReadCache() [1/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file); const. Find and return the TTreeCache registered with the file and which may contain branches for us. ; Definition at line 6318 of file TTree.cxx. ◆ GetReadCache() [2/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file, . bool ; create . ). Find and return the TTreeCache registered with the file and which may contain branches for us. ; If create is true and there is no cache a new cache is created with default size. ; Definition at line 6331 of file TTree.cxx. ◆ GetReadEntry(). virtual Long64_t TTree::GetReadEntry ; (; ); const. inlinevirtual . Reimplemented in TProofChain, and TChain.; Definition at line 509 of file TTree.h. ◆ GetReadEvent(). virtual Long64_t TTree::GetReadEvent ; (; ); const. inlinevirtual . Definition at line 510 of file TTree.h. ◆ GetScanField(). virtual Int_t TTree::GetScanField ; (; ); const. inlinevirtual . Definition at line 511 of file TTree.h. ◆ GetSelect(). TTreeFormula * TTree::GetSelect ; (; ). inline . Definition at line 512 of file TTree.h. ◆ GetSelectedRows(). virtual Long64_t TTree::GetSelectedRows ; (; ). inlinevirtual . Definition at line 513 of file TTree.h. ◆ GetTargetMemoryRatio(). Float_t TTree::GetTargetMemoryRatio ; (; ); const. inline . Definition at line 520 of file TTree.h. ◆ GetTimerInterval(). virtual Int_t TTree::GetTimerInterval ; (; ); const. inlinevirtual . Definition at line 514 of file TTree.h. ◆ GetTot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:163987,cache,cache,163987,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"8 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline . Definition at line 543 of file TTree.h. ◆ GetPacketSize(). virtual Int_t TTree::GetPacketSize ; (; ); const. inlinevirtual . Definition at line 545 of file TTree.h. ◆ GetPerfStats(). virtual TVirtualPerfStats * TTree::GetPerfStats ; (; ); const. inlinevirtual . Definition at line 546 of file TTree.h. ◆ GetPlayer(). TVirtualTreePlayer * TTree::GetPlayer ; (; ). Load the TTreePlayer (if not already done). ; Definition at line 6305 of file TTree.cxx. ◆ GetReadCache() [1/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file); const. Find and return the TTreeCache registered with the file and which may contain branches for us. ; Definition at line 6318 of file TTree.cxx. ◆ GetReadCache() [2/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file, . bool ; create . ). Find and return the TTreeCache registered with the file and which may contain branches for us. ; If create is true and there is no cache a new cache is created with default size. ; Definition at line 6331 of file TTree.cxx. ◆ GetReadEntry(). virtual Long64_t TTree::GetReadEntry ; (; ); const. inlinevirtual . Reimplemented in TProofChain, and TChain.; Definition at line 549 of file TTree.h. ◆ GetReadEvent(). virtual Long64_t TTree::GetReadEvent ; (; ); const. inlinevirtual . Definition at line 550 of file TTree.h. ◆ GetScanField(). virtual Int_t TTree::GetScanField ; (; ); const. inlinevirtual . Definition at line 551 of file TTree.h. ◆ GetSelect(). TTreeFormula * TTree::GetSelect ; (; ). inline . Definition at line 552 of file TTree.h. ◆ GetSelectedRows(). virtual Long64_t TTree::GetSelectedRows ; (; ). inlinevirtual . Definition at line 553 of file TTree.h. ◆ GetTargetMemoryRatio(). Float_t TTree::GetTargetMemoryRatio ; (; ); const. inline . Definition at line 560 of file TTree.h. ◆ GetTimerInterval(). virtual Int_t TTree::GetTimerInterval ; (; ); const. inlinevirtual . Definition at line 554 of file TTree.h. ◆ GetTot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:166175,cache,cache,166175,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"8 virtual void Setenv(const char *name, const char *value);; 469 virtual void Unsetenv(const char *name);; 470 virtual const char *Getenv(const char *env);; 471 ; 472 //---- System Logging; 473 virtual void Openlog(const char *name, Int_t options, ELogFacility facility);; 474 virtual void Syslog(ELogLevel level, const char *mess);; 475 virtual void Closelog();; 476 ; 477 //---- Standard Output redirection; 478 virtual Int_t RedirectOutput(const char *name, const char *mode = ""a"", RedirectHandle_t *h = nullptr);; 479 virtual void ShowOutput(RedirectHandle_t *h);; 480 ; 481 //---- Dynamic Loading; 482 virtual void AddDynamicPath(const char *pathname);; 483 virtual const char *GetDynamicPath();; 484 virtual void SetDynamicPath(const char *pathname);; 485 char *DynamicPathName(const char *lib, Bool_t quiet = kFALSE);; 486 virtual const char *FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE);; 487 virtual Func_t DynFindSymbol(const char *module, const char *entry);; 488 virtual int Load(const char *module, const char *entry = """", Bool_t system = kFALSE);; 489 virtual void Unload(const char *module);; 490 virtual UInt_t LoadAllLibraries();; 491 virtual void ListSymbols(const char *module, const char *re = """");; 492 virtual void ListLibraries(const char *regexp = """");; 493 virtual const char *GetLibraries(const char *regexp = """",; 494 const char *option = """",; 495 Bool_t isRegexp = kTRUE);; 496 ; 497 //---- RPC; 498 virtual TInetAddress GetHostByName(const char *server);; 499 virtual TInetAddress GetPeerName(int sock);; 500 virtual TInetAddress GetSockName(int sock);; 501 virtual int GetServiceByName(const char *service);; 502 virtual char *GetServiceByPort(int port);; 503 virtual int OpenConnection(const char *server, int port, int tcpwindowsize = -1, const char *protocol = ""tcp"");; 504 virtual int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1);; 505 virtual int AnnounceUdpService(int port, int backlog);; 506 virtual int AnnounceUnixS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:21674,Load,Load,21674,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['Load'],['Load']
Performance,"8 }; 6649 if ((i > 0) && (lenbuf[i] == '\r'); 6650 && (lenbuf[i - 1] != '\r')) {; 6651 continue;; 6652 }; 6653 if ((i > 1) && (lenbuf[i] == '\n'); 6654 && (lenbuf[i - 1] == '\r')) {; 6655 lenbuf[i + 1] = 0;; 6656 chunkSize = strtoul(lenbuf, &end, 16);; 6657 if (chunkSize == 0) {; 6658 /* regular end of content */; 6659 conn->is_chunked = 3;; 6660 }; 6661 break;; 6662 }; 6663 if (!isxdigit((unsigned char)lenbuf[i])) {; 6664 /* illegal character for chunk length */; 6665 conn->is_chunked = 2;; 6666 return -1;; 6667 }; 6668 }; 6669 if ((end == NULL) || (*end != '\r')) {; 6670 /* chunksize not set correctly */; 6671 conn->is_chunked = 2;; 6672 return -1;; 6673 }; 6674 if (chunkSize == 0) {; 6675 /* try discarding trailer for keep-alive */; 6676 conn->content_len += 2;; 6677 if ((mg_read_inner(conn, lenbuf, 2) == 2); 6678 && (lenbuf[0] == '\r') && (lenbuf[1] == '\n')) {; 6679 conn->is_chunked = 4;; 6680 }; 6681 break;; 6682 }; 6683 ; 6684 /* append a new chunk */; 6685 conn->content_len += (int64_t)chunkSize;; 6686 }; 6687 }; 6688 ; 6689 return (int)all_read;; 6690 }; 6691 return mg_read_inner(conn, buf, len);; 6692}; 6693 ; 6694 ; 6695int; 6696mg_write(struct mg_connection *conn, const void *buf, size_t len); 6697{; 6698 time_t now;; 6699 int n, total, allowed;; 6700 ; 6701 if (conn == NULL) {; 6702 return 0;; 6703 }; 6704 if (len > INT_MAX) {; 6705 return -1;; 6706 }; 6707 ; 6708 /* Mark connection as ""data sent"" */; 6709 conn->request_state = 10;; 6710#if defined(USE_HTTP2); 6711 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6712 http2_data_frame_head(conn, len, 0);; 6713 }; 6714#endif; 6715 ; 6716 if (conn->throttle > 0) {; 6717 if ((now = time(NULL)) != conn->last_throttle_time) {; 6718 conn->last_throttle_time = now;; 6719 conn->last_throttle_bytes = 0;; 6720 }; 6721 allowed = conn->throttle - conn->last_throttle_bytes;; 6722 if (allowed > (int)len) {; 6723 allowed = (int)len;; 6724 }; 6725 ; 6726 total = push_all(conn->phys_ctx,; 6727 NULL,; 6728 conn->client.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:194871,throttle,throttle,194871,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['throttle'],['throttle']
Performance,"8);; 353 SET(c, d, a, b, 7, 16, T39);; 354 SET(b, c, d, a, 10, 23, T40);; 355 SET(a, b, c, d, 13, 4, T41);; 356 SET(d, a, b, c, 0, 11, T42);; 357 SET(c, d, a, b, 3, 16, T43);; 358 SET(b, c, d, a, 6, 23, T44);; 359 SET(a, b, c, d, 9, 4, T45);; 360 SET(d, a, b, c, 12, 11, T46);; 361 SET(c, d, a, b, 15, 16, T47);; 362 SET(b, c, d, a, 2, 23, T48);; 363#undef SET; 364 ; 365/* Round 4. */; 366/* Let [abcd k s t] denote the operation; 367 a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */; 368#define I(x, y, z) ((y) ^ ((x) | ~(z))); 369#define SET(a, b, c, d, k, s, Ti) \; 370 t = (a) + I(b, c, d) + X[k] + (Ti); \; 371 (a) = ROTATE_LEFT(t, s) + (b); 372 ; 373 /* Do the following 16 operations. */; 374 SET(a, b, c, d, 0, 6, T49);; 375 SET(d, a, b, c, 7, 10, T50);; 376 SET(c, d, a, b, 14, 15, T51);; 377 SET(b, c, d, a, 5, 21, T52);; 378 SET(a, b, c, d, 12, 6, T53);; 379 SET(d, a, b, c, 3, 10, T54);; 380 SET(c, d, a, b, 10, 15, T55);; 381 SET(b, c, d, a, 1, 21, T56);; 382 SET(a, b, c, d, 8, 6, T57);; 383 SET(d, a, b, c, 15, 10, T58);; 384 SET(c, d, a, b, 6, 15, T59);; 385 SET(b, c, d, a, 13, 21, T60);; 386 SET(a, b, c, d, 4, 6, T61);; 387 SET(d, a, b, c, 11, 10, T62);; 388 SET(c, d, a, b, 2, 15, T63);; 389 SET(b, c, d, a, 9, 21, T64);; 390#undef SET; 391 ; 392 /* Then perform the following additions. (That is increment each; 393 of the four registers by the value it had before this block; 394 was started.) */; 395 pms->abcd[0] += a;; 396 pms->abcd[1] += b;; 397 pms->abcd[2] += c;; 398 pms->abcd[3] += d;; 399}; 400 ; 401MD5_STATIC void; 402md5_init(md5_state_t *pms); 403{; 404 pms->count[0] = pms->count[1] = 0;; 405 pms->abcd[0] = 0x67452301;; 406 pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;; 407 pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;; 408 pms->abcd[3] = 0x10325476;; 409}; 410 ; 411MD5_STATIC void; 412md5_append(md5_state_t *pms, const md5_byte_t *data, size_t nbytes); 413{; 414 const md5_byte_t *p = data;; 415 size_t left = nbytes;; 416 size_t offset = (pms->co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:14502,perform,perform,14502,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['perform'],['perform']
Performance,"8/// serv->AddLocation(""mydir/"", ""/home/user/specials"");; 329///; 330/// Than files from this directory could be addressed via server like `http://localhost:8080/mydir/myfile.root`; 331 ; 332void THttpServer::AddLocation(const char *prefix, const char *path); 333{; 334 if (!prefix || (*prefix == 0)); 335 return;; 336 ; 337 if (!path); 338 fLocations.erase(fLocations.find(prefix));; 339 else; 340 fLocations[prefix] = path;; 341}; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Set location of JSROOT to use with the server; 345///; 346/// One could specify address like:; 347///; 348/// * https://root.cern/js/7.6.0/; 349/// * https://jsroot.gsi.de/7.6.0/; 350///; 351/// This allows to get new JSROOT features with old server,; 352/// reduce load on THttpServer instance, also startup time can be improved; 353/// When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:11532,load,load,11532,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['load'],['load']
Performance,"8///; 499 ; 500TMVA::MethodBase *; 501TMVA::Factory::BookMethodWeightfile(DataLoader *loader, TMVA::Types::EMVA methodType, const TString &weightfile); 502{; 503 TString datasetname = loader->GetName();; 504 std::string methodTypeName = std::string(Types::Instance().GetMethodName(methodType).Data());; 505 DataSetInfo &dsi = loader->GetDataSetInfo();; 506 ; 507 IMethod *im = ClassifierFactory::Instance().Create(methodTypeName, dsi, weightfile);; 508 MethodBase *method = (dynamic_cast<MethodBase *>(im));; 509 ; 510 if (method == nullptr); 511 return nullptr;; 512 ; 513 if (method->GetMethodType() == Types::kCategory) {; 514 Log() << kERROR << ""Cannot handle category methods for now."" << Endl;; 515 }; 516 ; 517 TString fileDir;; 518 if (fModelPersistence) {; 519 // find prefix in fWeightFileDir;; 520 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 521 fileDir = prefix;; 522 if (!prefix.IsNull()); 523 if (fileDir[fileDir.Length() - 1] != '/'); 524 fileDir += ""/"";; 525 fileDir = loader->GetName();; 526 fileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 527 }; 528 ; 529 if (fModelPersistence); 530 method->SetWeightFileDir(fileDir);; 531 method->SetModelPersistence(fModelPersistence);; 532 method->SetAnalysisType(fAnalysisType);; 533 method->SetupMethod();; 534 method->SetFile(fgTargetFile);; 535 method->SetSilentFile(IsSilentFile());; 536 ; 537 method->DeclareCompatibilityOptions();; 538 ; 539 // read weight file; 540 method->ReadStateFromFile();; 541 ; 542 // method->CheckSetup();; 543 ; 544 TString methodTitle = method->GetName();; 545 if (HasMethod(datasetname, methodTitle) != 0) {; 546 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 547 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 548 }; 549 ; 550 Log() << kINFO << ""Booked classifier \"""" << method->GetMethodName() << ""\"" of type: \""""; 551 << method->GetMethodTypeName() << ""\"""" << Endl;; 552 ; 553 if (fMethodsMap.count(datase",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:21594,load,loader,21594,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is popul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:70399,load,load,70399,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"803 ; 3804////////////////////////////////////////////////////////////////////////////////; 3805/// Create the list containing the TDataMembers (of actual data members or members; 3806/// pulled in through using declarations) of a class.; 3807 ; 3808TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3809{; 3810 R__LOCKGUARD(gInterpreterMutex);; 3811 ; 3812 if (!data) {; 3813 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3814 // The members are in our ProtoClass; we don't need the class info.; 3815 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3816 if (proto && proto->FillTClass(this)); 3817 return data;; 3818 }; 3819 ; 3820 data = new TListOfDataMembers(this, selection);; 3821 }; 3822 if (IsClassStructOrUnion()) {; 3823 // If the we have a class or struct or union, the order; 3824 // of data members is the list is essential since it determines their; 3825 // order on file. So we must always load. Also, the list is fixed; 3826 // since the language does not allow to add members.; 3827 if (!(*data).IsLoaded()); 3828 (*data).Load();; 3829 ; 3830 } else if (load) (*data).Load();; 3831 return data;; 3832}; 3833 ; 3834////////////////////////////////////////////////////////////////////////////////; 3835/// Return list containing the TDataMembers of a class.; 3836 ; 3837TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3838{; 3839 // Fast path, no lock? Classes load at creation time.; 3840 if (IsClassStructOrUnion()) {; 3841 auto data = fData.load();; 3842 if (data && data->IsLoaded()); 3843 return data;; 3844 } else if (!load && fData); 3845 return fData;; 3846 ; 3847 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3848}; 3849 ; 3850////////////////////////////////////////////////////////////////////////////////; 3851/// Return list containing the TDataMembers of using declarations of a class.; 3852 ; 3853TList *T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:144871,load,load,144871,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"804 break;; 1805 }; 1806 switch (state) {; 1807 case 2:; 1808 rule.Append(c);; 1809 break;; 1810 }; 1811 }; 1812 return count;; 1813 }; 1814}; 1815 ; 1816////////////////////////////////////////////////////////////////////////////////; 1817/// Read the class.rules files from the default location:.; 1818/// $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules); 1819 ; 1820Int_t TClass::ReadRules(); 1821{; 1822 static const char *suffix = ""class.rules"";; 1823 TString sname = suffix;; 1824 gSystem->PrependPathName(TROOT::GetEtcDir(), sname);; 1825 ; 1826 Int_t res = -1;; 1827 ; 1828 FILE * f = fopen(sname,""r"");; 1829 if (f != nullptr) {; 1830 res = ReadRulesContent(f);; 1831 fclose(f);; 1832 } else {; 1833 ::Error(""TClass::ReadRules()"", ""Cannot find rules file %s"", sname.Data());; 1834 }; 1835 return res;; 1836}; 1837 ; 1838////////////////////////////////////////////////////////////////////////////////; 1839/// Read a class.rules file which contains one rule per line with comment; 1840/// starting with a #; 1841/// - Returns the number of rules loaded.; 1842/// - Returns -1 in case of error.; 1843 ; 1844Int_t TClass::ReadRules( const char *filename ); 1845{; 1846 if (!filename || !filename[0]) {; 1847 ::Error(""TClass::ReadRules"", ""no file name specified"");; 1848 return -1;; 1849 }; 1850 ; 1851 FILE * f = fopen(filename,""r"");; 1852 if (f == nullptr) {; 1853 ::Error(""TClass::ReadRules"",""Failed to open %s\n"",filename);; 1854 return -1;; 1855 }; 1856 Int_t count = ReadRulesContent(f);; 1857 ; 1858 fclose(f);; 1859 return count;; 1860 ; 1861}; 1862 ; 1863////////////////////////////////////////////////////////////////////////////////; 1864/// Add a schema evolution customization rule.; 1865/// The syntax of the rule can be either the short form:; 1866/// ~~~ {.cpp}; 1867/// [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; 1868/// ~~~; 1869/// or the long form; 1870/// ~~~ {.cpp}; 1871/// [type=Read] sourceClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:68978,load,loaded,68978,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"81 ; 3082 UInt_t R__s, R__c;; 3083 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 3084 if (R__v > 2) {; 3085 b.ReadClassBuffer(TChain::Class(), this, R__v, R__s, R__c);; 3086 } else {; 3087 //====process old versions before automatic schema evolution; 3088 TTree::Streamer(b);; 3089 b >> fTreeOffsetLen;; 3090 b >> fNtrees;; 3091 fFiles->Streamer(b);; 3092 if (R__v > 1) {; 3093 fStatus->Streamer(b);; 3094 fTreeOffset = new Long64_t[fTreeOffsetLen];; 3095 b.ReadFastArray(fTreeOffset,fTreeOffsetLen);; 3096 }; 3097 b.CheckByteCount(R__s, R__c, TChain::IsA());; 3098 //====end of old versions; 3099 }; 3100 // Re-add using the new name.; 3101 {; 3102 R__LOCKGUARD(gROOTMutex);; 3103 gROOT->GetListOfCleanups()->Add(this);; 3104 }; 3105 ; 3106 } else {; 3107 b.WriteClassBuffer(TChain::Class(),this);; 3108 }; 3109}; 3110 ; 3111////////////////////////////////////////////////////////////////////////////////; 3112/// Dummy function kept for back compatibility.; 3113/// The cache is now activated automatically when processing TTrees/TChain.; 3114 ; 3115void TChain::UseCache(Int_t /* maxCacheSize */, Int_t /* pageSize */); 3116{; 3117}; InternalTreeUtils.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Version_tshort Version_tDefinition RtypesCore.h:65; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBranch.h; TBrowser.h; TBuffer.h; TChainElement.h; TChain.h; TClass.h; TColor.h; TCut.h; EDataTypeEDataTypeDefinition TDataType.h:28; TEntryListFromFile.h; TEntryList.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TEventList.h; TFileInfo.h; TFilePrefetch.h; TFileStager.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:112815,cache,cache,112815,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['cache'],['cache']
Performance,"81 else; 3782 fEnums = new TListOfEnumsWithLock(this);; 3783 return fEnums;; 3784 }; 3785 ; 3786 R__LOCKGUARD(gInterpreterMutex);; 3787 if (fEnums.load()) {; 3788 (*fEnums).Load();; 3789 return fEnums.load();; 3790 }; 3791 if (fProperty == -1) Property();; 3792 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3793 // For this case, the list will be immutable; 3794 temp = new TListOfEnums(this);; 3795 } else {; 3796 //namespaces can have enums added to them; 3797 temp = new TListOfEnumsWithLock(this);; 3798 }; 3799 temp->Load();; 3800 fEnums = temp;; 3801 return temp;; 3802}; 3803 ; 3804////////////////////////////////////////////////////////////////////////////////; 3805/// Create the list containing the TDataMembers (of actual data members or members; 3806/// pulled in through using declarations) of a class.; 3807 ; 3808TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3809{; 3810 R__LOCKGUARD(gInterpreterMutex);; 3811 ; 3812 if (!data) {; 3813 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3814 // The members are in our ProtoClass; we don't need the class info.; 3815 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3816 if (proto && proto->FillTClass(this)); 3817 return data;; 3818 }; 3819 ; 3820 data = new TListOfDataMembers(this, selection);; 3821 }; 3822 if (IsClassStructOrUnion()) {; 3823 // If the we have a class or struct or union, the order; 3824 // of data members is the list is essential since it determines their; 3825 // order on file. So we must always load. Also, the list is fixed; 3826 // since the language does not allow to add members.; 3827 if (!(*data).IsLoaded()); 3828 (*data).Load();; 3829 ; 3830 } else if (load) (*data).Load();; 3831 return data;; 3832}; 3833 ; 3834////////////////////////////////////////////////////////////////////////////////; 3835/// Return list containing the TDataMembers of a class.; 3836 ; 3837TList *TClass::GetListOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:144239,load,load,144239,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"81 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:171921,cache,cachefile,171921,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cachefile']
Performance,"81 if (fClusterRange == fTree->fNClusterRange) {; 582 autoflush = fTree->fAutoFlush;; 583 } else {; 584 autoflush = fTree->fClusterSize[fClusterRange];; 585 }; 586 if (autoflush <= 0) {; 587 autoflush = GetEstimatedClusterSize();; 588 }; 589 fStartEntry = pedestal + entryInRange - entryInRange%autoflush;; 590 } else if ( fTree->GetAutoFlush() <= 0 ) {; 591 // Case of old files before November 9 2009 *or* small tree where AutoFlush was never set.; 592 fStartEntry = firstEntry;; 593 } else {; 594 fStartEntry = firstEntry - firstEntry%fTree->GetAutoFlush();; 595 }; 596 fNextEntry = fStartEntry; // Position correctly for the first call to Next(); 597}; 598 ; 599////////////////////////////////////////////////////////////////////////////////; 600/// Estimate the cluster size.; 601///; 602/// In almost all cases, this quickly returns the size of the auto-flush; 603/// in the TTree.; 604///; 605/// However, in the case where the cluster size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:23800,cache,cache,23800,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"81 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const static bool loadSuccess = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")? false : 0 <= gSystem->Load(""libImt"");; 404 if (loadSuccess) {; 405 if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {; 406 return sym;; 407 } else {; 408 Error(""GetSymInLibImt"", ""Cannot get symbol %s."", funcname);; 409 }; 410 }; 411 return nullptr;; 412 }; 413 ; 414 //////////////////////////////////////////////////////////////////////////////; 415 /// Globally enables the parallel branch processing, which is a case of; 416 /// implicit multi-threading (IMT) in ROOT, activating the required locks.; 417 /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; 418 /// each branch of the tree. Therefore, a task takes care of the reading,; 419 /// decompression and deserialisation of a given branch.; 420 void EnableParBranchProcessing(); 421 {; 422#ifdef R__USE_IMT; 423 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableParBranchProcessing"");; 424 if (sym); 425 sym();; 426#else; 427 ::Warning(""EnableParBranchProcessing"", ""Cannot enable parallel branch processing, please build ROOT with -Dimt=ON"");; 428#endif; 429 }; 430 ; 431 //////////////////////////////////////////////////////////////////////////////; 432 /// Globally disables the IMT use case of parallel branch processing,; 433 /// deactivating the corresponding locks.; 434 void DisableParBranchProcessing(); 435 {; 436#ifdef R__USE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:14450,multi-thread,multi-threading,14450,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance,"8136 of file TTree.cxx. ◆ SetAutoFlush(). void TTree::SetAutoFlush ; (; Long64_t ; autof = -30000000). virtual . This function may be called at the start of a program to change the default value for fAutoFlush. . CASE 1 : autof > 0; autof is the number of consecutive entries after which TTree::Fill will flush all branch buffers to disk. CASE 2 : autof < 0; When filling the Tree the branch buffers will be flushed to disk when more than autof bytes have been written to the file. At the first FlushBaskets TTree::Fill will replace fAutoFlush by the current value of fEntries.; Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.; The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0; The AutoFlush mechanism is disabled.; Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.; A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the TTreeCache will read. ; Definition at line 8191 of file TTree.cxx. ◆ SetAutoSave(). void TTree::SetAutoSave ; (; Long64_t ; autos = -300000000). virtual . In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; This function may be called before filling a TTree to specify when the branch buffers and TTree header are flushed to disk as part of TTree::Fill(). The default is -300000000, ie the TTree will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:200240,optimiz,optimize,200240,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['optimiz'],['optimize']
Performance,"8141 of file TTree.cxx. ◆ SetAutoFlush(). void TTree::SetAutoFlush ; (; Long64_t ; autof = -30000000). virtual . This function may be called at the start of a program to change the default value for fAutoFlush. . CASE 1 : autof > 0; autof is the number of consecutive entries after which TTree::Fill will flush all branch buffers to disk. CASE 2 : autof < 0; When filling the Tree the branch buffers will be flushed to disk when more than autof bytes have been written to the file. At the first FlushBaskets TTree::Fill will replace fAutoFlush by the current value of fEntries.; Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.; The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0; The AutoFlush mechanism is disabled.; Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.; A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the TTreeCache will read. ; Definition at line 8196 of file TTree.cxx. ◆ SetAutoSave(). void TTree::SetAutoSave ; (; Long64_t ; autos = -300000000). virtual . In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; This function may be called before filling a TTree to specify when the branch buffers and TTree header are flushed to disk as part of TTree::Fill(). The default is -300000000, ie the TTree will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:202731,optimiz,optimize,202731,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['optimiz'],['optimize']
Performance,"82 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58417,cache,cache,58417,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"825 ; 1826#ifdef G__WIN32; 1827 ; 1828 char leftname[_MAX_PATH];; 1829 char rightname[_MAX_PATH];; 1830 _fullpath( leftname, left, _MAX_PATH );; 1831 _fullpath( rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Len",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:59545,load,loading,59545,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['load'],"['loaded', 'loading']"
Performance,"828should be used.; 829 ; 830To control the bar offset (default is 0) `TH1::SetBarOffset()` should; 831be used.; 832 ; 833These two parameters are useful when several histograms are plotted using; 834the option `SAME`. They allow to plot the histograms next to each other.; 835 ; 836 ; 837\anchor HP11; 838### The SCATter plot option (legacy draw option); 839 ; 840\attention; 841Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 8423D histograms. The new default option is `COL` (heat-map).; 843 ; 844 ; 845For each cell (i,j) a number of points proportional to the cell content is; 846drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; 847`kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; 848If option is of the form `scat=ff`, (eg `scat=1.8`,; 849`scat=1e-3`), then `ff` is used as a scale factor to compute the; 850number of dots. `scat=1` is the default.; 851 ; 852By default the scatter plot is painted with a ""dot marker"" which not scalable; 853(see the `TAttMarker` documentation). To change the marker size, a scalable marker; 854type should be used. For instance a circle (marker style 20).; 855 ; 856Begin_Macro(source); 857{; 858 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 859 auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; 860 float px, py;; 861 for (Int_t i = 0; i < 25000; i++) {; 862 gRandom->Rannor(px,py);; 863 hscat->Fill(px,5*py);; 864 hscat->Fill(3+0.5*px,2*py-10.);; 865 }; 866 hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; 867}; 868End_Macro; 869 ; 870 ; 871\anchor HP12; 872### The ARRow option; 873 ; 874 ; 875Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; 876The orientation of the arrow follows the cell gradient.; 877 ; 878Begin_Macro(source); 879{; 880 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 881 auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:36235,scalab,scalable,36235,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['scalab'],['scalable']
Performance,"83 of file TSelVerifyDataSet.h. ◆ Init(). void TSelVerifyDataSet::Init ; (; TTree * ; ). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 77 of file TSelVerifyDataSet.h. ◆ InitMembers(). void TSelVerifyDataSet::InitMembers ; (; ). private . Initialize members. ; Definition at line 57 of file TSelVerifyDataSet.cxx. ◆ IsA(). TClass * TSelVerifyDataSet::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 87 of file TSelVerifyDataSet.h. ◆ Notify(). Bool_t TSelVerifyDataSet::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector.; Definition at line 78 of file TSelVerifyDataSet.h. ◆ Process(). Bool_t TSelVerifyDataSet::Process ; (; Long64_t ; entry). overridevirtual . Process a single entry. ; Reimplemented from TSelector.; Definition at line 228 of file TSelVerifyDataSet.cxx. ◆ SetInputList(). void TSelVerifyDataSet::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 82 of file TSelVerifyDataSet.h. ◆ SetObject(). void TSelVerifyDataSet::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 81 of file TSelVerifyDataSet.h. ◆ SetOption(). void TSelVerifyDataSet::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 80 of file TSelVerifyDataSet.h. ◆ SlaveBegin(). void TSelVerifyDataSet::Sla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelVerifyDataSet.html:15522,load,load,15522,doc/master/classTSelVerifyDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelVerifyDataSet.html,2,['load'],['load']
Performance,"831be used.; 832 ; 833These two parameters are useful when several histograms are plotted using; 834the option `SAME`. They allow to plot the histograms next to each other.; 835 ; 836 ; 837\anchor HP11; 838### The SCATter plot option (legacy draw option); 839 ; 840\attention; 841Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 8423D histograms. The new default option is `COL` (heat-map).; 843 ; 844 ; 845For each cell (i,j) a number of points proportional to the cell content is; 846drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; 847`kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; 848If option is of the form `scat=ff`, (eg `scat=1.8`,; 849`scat=1e-3`), then `ff` is used as a scale factor to compute the; 850number of dots. `scat=1` is the default.; 851 ; 852By default the scatter plot is painted with a ""dot marker"" which not scalable; 853(see the `TAttMarker` documentation). To change the marker size, a scalable marker; 854type should be used. For instance a circle (marker style 20).; 855 ; 856Begin_Macro(source); 857{; 858 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 859 auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; 860 float px, py;; 861 for (Int_t i = 0; i < 25000; i++) {; 862 gRandom->Rannor(px,py);; 863 hscat->Fill(px,5*py);; 864 hscat->Fill(3+0.5*px,2*py-10.);; 865 }; 866 hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; 867}; 868End_Macro; 869 ; 870 ; 871\anchor HP12; 872### The ARRow option; 873 ; 874 ; 875Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; 876The orientation of the arrow follows the cell gradient.; 877 ; 878Begin_Macro(source); 879{; 880 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 881 auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; 882 harr->SetLineColor(kRed);; 883 float px, py;; 884 for (Int_t i = 0; i < 25000; i++) {; 88",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:36315,scalab,scalable,36315,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['scalab'],['scalable']
Performance,"84 SetBit(kGeoReflection, kFALSE);; 1585}; 1586 ; 1587////////////////////////////////////////////////////////////////////////////////; 1588/// Set scale from other transformation; 1589 ; 1590void TGeoScale::SetScale(const TGeoMatrix &other); 1591{; 1592 SetBit(kGeoScale, other.IsScale());; 1593 SetBit(kGeoReflection, other.IsReflection());; 1594 memcpy(fScale, other.GetScale(), kN3);; 1595}; 1596 ; 1597////////////////////////////////////////////////////////////////////////////////; 1598/// Convert a local point to the master frame.; 1599 ; 1600void TGeoScale::LocalToMaster(const Double_t *local, Double_t *master) const; 1601{; 1602 master[0] = local[0] * fScale[0];; 1603 master[1] = local[1] * fScale[1];; 1604 master[2] = local[2] * fScale[2];; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Convert the local distance along unit vector DIR to master frame. If DIR; 1609/// is not specified perform a conversion such as the returned distance is the; 1610/// the minimum for all possible directions.; 1611 ; 1612Double_t TGeoScale::LocalToMaster(Double_t dist, const Double_t *dir) const; 1613{; 1614 Double_t scale;; 1615 if (!dir) {; 1616 scale = TMath::Abs(fScale[0]);; 1617 if (TMath::Abs(fScale[1]) < scale); 1618 scale = TMath::Abs(fScale[1]);; 1619 if (TMath::Abs(fScale[2]) < scale); 1620 scale = TMath::Abs(fScale[2]);; 1621 } else {; 1622 scale = fScale[0] * fScale[0] * dir[0] * dir[0] + fScale[1] * fScale[1] * dir[1] * dir[1] +; 1623 fScale[2] * fScale[2] * dir[2] * dir[2];; 1624 scale = TMath::Sqrt(scale);; 1625 }; 1626 return scale * dist;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Make a clone of this matrix.; 1631 ; 1632TGeoMatrix *TGeoScale::MakeClone() const; 1633{; 1634 TGeoMatrix *matrix = new TGeoScale(*this);; 1635 return matrix;; 1636}; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 163",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:56903,perform,perform,56903,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['perform'],['perform']
Performance,"84 TStreamerInfo *infoalloc = 0;; 1785 ; 1786 //---------------------------------------------------------------------------; 1787 // Get schema rules for this class; 1788 /////////////////////////////////////////////////////////////////////////////; 1789 ; 1790 ROOT::TSchemaRuleSet::TMatches rules;; 1791 const ROOT::TSchemaRuleSet* ruleSet = fClass->GetSchemaRules();; 1792 ; 1793 if (ruleSet) rules = ruleSet->FindRules( GetName(), fOnFileClassVersion, fCheckSum );; 1794 ; 1795 Bool_t shouldHaveInfoLoc = fClass->GetState() == TClass::kEmulated && !TClassEdit::IsStdClass(fClass->GetName());; 1796 Int_t virtualInfoLocAlloc = 0;; 1797 fNVirtualInfoLoc = 0;; 1798 delete [] fVirtualInfoLoc;; 1799 fVirtualInfoLoc = 0;; 1800 ; 1801 while ((element = (TStreamerElement*) next())) {; 1802 if (element->IsA()==TStreamerArtificial::Class(); 1803 || element->TestBit(TStreamerElement::kCache) ); 1804 {; 1805 // Prevent BuildOld from modifying existing ArtificialElement (We need to review when and why BuildOld; 1806 // needs to be re-run; it might be needed if the 'current' class change (for example from being an onfile; 1807 // version to being a version loaded from a shared library) and we thus may have to remove the artificial; 1808 // element at the beginning of BuildOld); 1809 ; 1810 continue;; 1811 };; 1812 ; 1813 element->SetNewType(element->GetType());; 1814 if (element->IsBase()) {; 1815 //---------------------------------------------------------------------; 1816 // Dealing with nonSTL bases; 1817 ///////////////////////////////////////////////////////////////////////; 1818 ; 1819 if (element->IsA() == TStreamerBase::Class()) {; 1820 TStreamerBase* base = (TStreamerBase*) element;; 1821#if defined(PROPER_IMPLEMEMANTION_OF_BASE_CLASS_RENAMING); 1822 TClassRef baseclass = fClass->GetBaseClass( base->GetName() );; 1823#else; 1824 // Currently the base class renaming does not work, so we use the old; 1825 // version of the code which essentially disable the next if(!baseclass .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:69644,load,loaded,69644,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"85 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; 1914 const char *deplib = ((TObjString*)tokens->At(i))->GetName();; 1915 if (strcmp(module,deplib)==0) {; 1916 continue;; 1917 }; 1918 if (gDebug > 0); 1919 Info(""Load"", ""loading dependent library %s for library %s"",; 1920 deplib, ((TObjString*)tokens->At(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());; 1936 }; 1937 }; 1938 ; 1939 gLibraryVersionIdx++;; 1940 if (gLibraryVersionIdx == gLibraryVersionMax) {; 1941 gLibraryVersionMax *= 2;; 1942 gLibraryVersion = TStorage::ReAllocInt(gLibraryVersion, gLibraryVersionMax, gLibraryVersionIdx);; 1943 }; 1944 ret = gInterpreter->Load(path, system);; 1945 if (ret < 0) ret = -1;; 1946 if (gDebug > 0); 1947 Info(""Load"", ""loaded library %s, status %d"", path, ret);; 1948 if (ret == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:61970,Load,Load,61970,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,3,"['Load', 'load']","['Load', 'loading']"
Performance,"865] - root commandline tools are not executable after installation; [ROOT-7872] - PyROOT: wrong return value when calling a c++ function returning short; [ROOT-7879] - Autoloader (parser?) tries to follow #includes from LinkDef.h; [ROOT-7881] - Uninitialized member access in TFormula => undefined behaviour; [ROOT-7891] - installation instructions for root notebooks incomplete; [ROOT-7892] - Incoherent version of Python when building tmva/pymva; [ROOT-7896] - CMake: visibility inconsistency; [ROOT-7901] - Double-free in TROOT::EndOfProcessCleanups redux; [ROOT-7912] - Failure with -Dbuiltin_davix=ON on 64bit Ubuntu; [ROOT-7916] - pyroot problem with std::vector of enum; [ROOT-7927] - TPluginHandler::CheckForExecPlugin is not thread safe; [ROOT-7935] - Need a better way stop PyROOT from reading .rootlogon.(py|C); [ROOT-7940] - Incorrect handling of LLVM Threading; [ROOT-8003] - Root 6.06 slow to; [ROOT-8015] - cmake not honoring -Dbuiltin_lzma=OFF; [ROOT-8019] - Warning with spaces in the binary name; [ROOT-8031] - TTree auto (read) cache setup during Fill; [ROOT-7776] - Integrate GSL 2.0 in ROOT. Release 6.06/04; Released on May 4, 2016; General. Significant update of the valgrind suppression file to hide intentional lack of delete of some entities at the end of the process.; Resolved several memory leaks. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. Interpreter Library. Resolve memory hoarding in some case of looking up functions ROOT-8145. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file ROOT-8055.; Repaired the automatic conversion on read back into an STL collection of a on file object of a class that was inheriting from the STL collection. Meta. Reduce au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:28592,cache,cache,28592,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['cache'],['cache']
Performance,"87 Int_t zfirst = fZaxis.GetFirst();; 8688 Int_t zlast = fZaxis.GetLast();; 8689 Double_t minimum = FLT_MAX, value;; 8690 locm = locmix = locmiy = locmiz = 0;; 8691 for (binz=zfirst;binz<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 873",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:341033,cache,cache,341033,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['cache'],['cache']
Performance,"871 break;; 1872 }; 1873 switch (state) {; 1874 case 2:; 1875 rule.Append(c);; 1876 break;; 1877 }; 1878 }; 1879 return count;; 1880 }; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Read the class.rules files from the default location:.; 1885/// $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules); 1886 ; 1887Int_t TClass::ReadRules(); 1888{; 1889 static const char *suffix = ""class.rules"";; 1890 TString sname = suffix;; 1891 gSystem->PrependPathName(TROOT::GetEtcDir(), sname);; 1892 ; 1893 Int_t res = -1;; 1894 ; 1895 FILE * f = fopen(sname,""r"");; 1896 if (f != nullptr) {; 1897 res = ReadRulesContent(f);; 1898 fclose(f);; 1899 } else {; 1900 ::Error(""TClass::ReadRules()"", ""Cannot find rules file %s"", sname.Data());; 1901 }; 1902 return res;; 1903}; 1904 ; 1905////////////////////////////////////////////////////////////////////////////////; 1906/// Read a class.rules file which contains one rule per line with comment; 1907/// starting with a #; 1908/// - Returns the number of rules loaded.; 1909/// - Returns -1 in case of error.; 1910 ; 1911Int_t TClass::ReadRules( const char *filename ); 1912{; 1913 if (!filename || !filename[0]) {; 1914 ::Error(""TClass::ReadRules"", ""no file name specified"");; 1915 return -1;; 1916 }; 1917 ; 1918 FILE * f = fopen(filename,""r"");; 1919 if (f == nullptr) {; 1920 ::Error(""TClass::ReadRules"",""Failed to open %s\n"",filename);; 1921 return -1;; 1922 }; 1923 Int_t count = ReadRulesContent(f);; 1924 ; 1925 fclose(f);; 1926 return count;; 1927 ; 1928}; 1929 ; 1930////////////////////////////////////////////////////////////////////////////////; 1931/// Add a schema evolution customization rule.; 1932/// The syntax of the rule can be either the short form:; 1933/// ~~~ {.cpp}; 1934/// [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; 1935/// ~~~; 1936/// or the long form; 1937/// ~~~ {.cpp}; 1938/// [type=Read] sourceClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:71729,load,loaded,71729,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"88 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:140697,Load,Load,140697,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"8e+00; : 2 : var1 : 2.336e+00; : ------------------------------------; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : ----------------------------------------; : Rank : Variable : Correlation Ratio (T); : ----------------------------------------; : 1 : var1 : 5.362e-01; : 2 : var2 : 5.109e-01; : ----------------------------------------; : Elapsed time for training with 9999 events: 5.01e-06 sec ; : Dataset[datasetcvreg] : Create results for training; : Dataset[datasetcvreg] : Evaluation of BDTG on training sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 9999 events: 0.369 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: datasetcvreg/weights/TMVACrossValidationRegression_BDTG.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG for Regression performance; : ; : Dataset[datasetcvreg] : Create results for testing; : Dataset[datasetcvreg] : Evaluation of BDTG on testing sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 9999 events: 0.37 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; <HEADER> Factory : Evaluate all methods; : Evaluate regression method: BDTG; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 9999 events: 0.37 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 9999 events: 0.369 sec ; <HEADER> TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 2.4948 1.4515 [ 0.00020069 5.0000 ]; : var2: 2.4837 1.4409 [ 0.00071490 5.0000 ]; : fvalue: 134.53 84.778 [ 1.6186 394.84 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by smallest RMS on test sample:; : (""Bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:12262,perform,performance,12262,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['perform'],['performance']
Performance,"9 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""Rty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:46233,Load,LoadModule,46233,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadModule']
Performance,"9 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of execution was; 2578 ; 2579 // unload UserLibrary; 2580 // call EndOfProcessCleanups; 2581 // Write the TFile; 2582 // attempt to write the user object.; 2583 // ....; 2584 ; 2585 // where what we nee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:97071,load,loaded,97071,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loaded']
Performance,"9 of file RooWorkspace.h. ◆ _classFileExportDir. string RooWorkspace::_classFileExportDir = "".wscode.%s.%s"". staticprivate . Definition at line 253 of file RooWorkspace.h. ◆ _classImplDirList. list< string > RooWorkspace::_classImplDirList. staticprivate . Definition at line 252 of file RooWorkspace.h. ◆ _dataList. RooLinkedList RooWorkspace::_dataList. private . List of owned datasets. ; Definition at line 262 of file RooWorkspace.h. ◆ _dir. WSDir* RooWorkspace::_dir = nullptr. private . ! Transient ROOT directory representation of workspace ; Definition at line 270 of file RooWorkspace.h. ◆ _doExport. bool RooWorkspace::_doExport. private . ! Export contents of workspace to CINT? ; Definition at line 276 of file RooWorkspace.h. ◆ _embeddedDataList. RooLinkedList RooWorkspace::_embeddedDataList. private . List of owned datasets that are embedded in pdfs. ; Definition at line 263 of file RooWorkspace.h. ◆ _eocache. RooExpensiveObjectCache RooWorkspace::_eocache. private . Cache for expensive objects. ; Definition at line 272 of file RooWorkspace.h. ◆ _exportNSName. std::string RooWorkspace::_exportNSName. private . ! Name of CINT namespace to which contents are exported ; Definition at line 277 of file RooWorkspace.h. ◆ _factory. std::unique_ptr<RooFactoryWSTool> RooWorkspace::_factory. private . ! Factory tool associated with workspace ; Definition at line 274 of file RooWorkspace.h. ◆ _genObjects. RooLinkedList RooWorkspace::_genObjects. private . List of generic objects. ; Definition at line 266 of file RooWorkspace.h. ◆ _namedSets. std::map<std::string, RooArgSet> RooWorkspace::_namedSets. private . Map of named RooArgSets. ; Definition at line 268 of file RooWorkspace.h. ◆ _openTrans. bool RooWorkspace::_openTrans = false. private . ! Is there a transaction open? ; Definition at line 279 of file RooWorkspace.h. ◆ _sandboxNodes. RooArgSet RooWorkspace::_sandboxNodes. private . ! Sandbox for incoming objects in a transaction ; Definition at line 280 of file RooWor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:52027,Cache,Cache,52027,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['Cache'],['Cache']
Performance,"9 }; 7200 llvm::StringRef SymName = SymNameErr.get();; 7201 if (SymName.empty()); 7202 continue;; 7203 ; 7204 if (BinObjFile->isELF()) {; 7205 // Skip the symbols which are part of the C/C++ runtime and have a; 7206 // fixed library version. See binutils ld VERSION. Those reside in; 7207 // 'system' libraries, which we avoid in FindLibraryForSymbol.; 7208 if (SymName.contains(""@GLIBCXX"") || SymName.contains(""@CXXABI"") ||; 7209 SymName.contains(""@GLIBC"") || SymName.contains(""@GCC"")); 7210 continue;; 7211 ; 7212 // Those are 'weak undefined' symbols produced by gcc. We can; 7213 // ignore them.; 7214 // FIXME: It is unclear whether we can ignore all weak undefined; 7215 // symbols:; 7216 // http://lists.llvm.org/pipermail/llvm-dev/2017-October/118177.html; 7217 static constexpr llvm::StringRef RegisterClasses(""_Jv_RegisterClasses"");; 7218 static constexpr llvm::StringRef RegisterCloneTable(""_ITM_registerTMCloneTable"");; 7219 static constexpr llvm::StringRef DeregisterCloneTable(""_ITM_deregisterTMCloneTable"");; 7220 if (SymName == RegisterClasses ||; 7221 SymName == RegisterCloneTable ||; 7222 SymName == DeregisterCloneTable); 7223 continue;; 7224 }; 7225 ; 7226 // If we can find the address of the symbol, we have loaded it. Skip.; 7227 if (skipLoadedLibs) {; 7228 std::string SymNameForDlsym = ROOT::TMetaUtils::DemangleNameForDlsym(SymName.str());; 7229 if (llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(SymNameForDlsym)); 7230 continue;; 7231 }; 7232 ; 7233 R__LOCKGUARD(gInterpreterMutex);; 7234 std::string found = interp->getDynamicLibraryManager()->searchLibrariesForSymbol(SymName, /*searchSystem*/false);; 7235 // The expected output is just filename without the full path, which; 7236 // is not very accurate, because our Dyld implementation might find; 7237 // a match in location a/b/c.so and if we return just c.so ROOT might; 7238 // resolve it to y/z/c.so and there we might not be ABI compatible.; 7239 // FIXME: Teach the users of GetSharedLibDeps to work with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:282776,load,loaded,282776,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"9""; ""BackSmoothing11""; ""BackSmoothing13""; ""BackSmoothing15""; - ""Compton"" if selected the estimation of Compton edge; will be included.; - ""same"" : if this option is specified, the resulting background; histogram is superimposed on the picture in the current pad. NOTE that the background is only evaluated in the current range of h.; ie, if h has a bin range (set via h->GetXaxis()->SetRange(binmin,binmax),; the returned histogram will be created with the same number of bins; as the input histogram h, but only bins from binmin to binmax will be filled; with the estimated background. void Print(Option_t* option = """") const; Print the array of positions. Int_t Search(const TH1* hist, Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.050000000000000003). TWO-DIMENSIONAL PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum in hin; The number of found peaks and their positions are written into; the members fNpeaks and fPositionX.; The search is performed in the current histogram range. Function parameters:; hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than; threshold*highest_peak are discarded. 0<threshold<1. By default, the background is removed before deconvolution.; Specify the option ""nobackground"" to not remove the background. //. By default the ""Markov"" chain algorithm is used.; Specify the option ""noMarkov"" to disable this algorithm; Note that by default the source spectrum is replaced by a new spectrum//. By default a polymarker object is created and added to the list of; functions of the histogram. The histogram is drawn with the specified; option and the polymarker object drawn on top of the histogram.; The polymarker coordinates correspond to the npeaks peaks found in; the histogram.; A pointer to the polymarker object can be retrieved later via:; TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2.html:12436,perform,performed,12436,root/html602/TSpectrum2.html,https://root.cern,https://root.cern/root/html602/TSpectrum2.html,2,['perform'],['performed']
Performance,"9.959183 a1=-1.484, ; prevFCN = 1899.958511 a1=-1.485, ; prevFCN = 1899.960007 a1=-1.485, y=0.0003051, ; prevFCN = 1899.958806 y=-0.0003051, ; prevFCN = 1899.958806 a1=-1.484, y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 y=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; y=0, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf315_projectpdf.py. tutorialsroofitrf315_projectpdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:5544,optimiz,optimization,5544,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,1,['optimiz'],['optimization']
Performance,"9/// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; 1130/// \param[in] rxmin lower fitting range; 1131/// \param[in] rxmax upper fitting range; 1132///; 1133/// \anchor GFitOpt; 1134/// ### Graph Fitting Options; 1135/// The list of fit options is given in parameter option.; 1136///; 1137/// option | description; 1138/// -------|------------; 1139/// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; 1140/// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; 1141/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 1142/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 1143/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 1144/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; 1145/// ""Q"" | Quiet mode (minimum printing); 1146/// ""V"" | Verbose mode (default is between Q and V); 1147/// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; 1148/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 1150/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 1151/// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:38664,Perform,Performs,38664,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['Perform'],['Performs']
Performance,"90] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with indirect file; [#14902] - compilation error; [#14863] - [hist] TH1::SaveAs missing default option argument causes compilation errors; [#14855] - TRatioPlot crashes if loaded from the file; [#14842] - TRatioplot gives “different” results with Web Graphics; [#14838] - Problems with Confidence Band of TRatioPlot; [#14801] - TEfficiency drawing to .C is broken; [#14793] - 6.26 cannot read file written with 6.30.4; [#14772] - [cling] Undocumented behaviour of root macro_C.so; [#14767] - rootn.exe instant crash on startup; [#14765] - TGenPhaseSpace weight normalization; [#14748] - [ntuple] Show and PrintInfo does not work for friend RNTuples; [#14601] - std::source_location not found when running with c++20 enabled; [#14599] - The example th2polyUSA.C needs re-labelling; [#14598] - A “printf” change the behaviour of a macro …; [#14595] - Problem when creating dictionary in Osx 12.7, Xcode 14.2; [#14594] - Provide file.root request in THttpServer; [#14593] - Build fails with CLING_DEBUG=1 set; [#14586] - [ROOT-6317] using namespace statement does not provoke autoload; [#14576] - [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:26829,load,loaded,26829,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['load'],['loaded']
Performance,"9140 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19141 * This is needed because if HTTP-level keep-alive; 19142 * is enabled, and client resets the connection, server won't get; 19143 * TCP FIN or RST and will keep the connection open forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's throughput (ie. operations per second); 19166 * when HTTP 1.1 persistent connections are used and the responses; 19167 * are relatively small (eg. less than 1400 bytes).; 19168 */; 19169 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19170 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19171 if (set_tcp_nodelay(&so, 1) != 0) {; 19172 mg_cry_ctx_internal(; 19173 ctx,; 19174 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19175 __func__,; 19176 strerror(ERRNO));; 19177 }; 19178 }; 19179 ; 19180 /* The ""non blocking"" property should already be; 19181 * inherited from the parent socket. Set it for; 19182 * non-compliant socket implementations. */; 19183 set_non_blocking_mode(so.sock);; 19184 ; 19185 so.in_use = 0;; 19186 produce_socket(ctx, &so);; 19187 }; 19188}; 19189 ; 19190 ; 19191static void; 19192master_thread_run(struct mg_context *ctx); 19193{; 19194 struct mg_workerTLS tls;; 19195 struct mg_pollfd *pfd;; 19196 unsigned int i;; 19197 unsigned int w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:571250,throughput,throughput,571250,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['throughput'],['throughput']
Performance,"9141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19176 __func__,; 19177 strerror(ERRNO));; 19178 }; 19179 }; 19180 ; 19181 /* The ""non blocking"" property should already be; 19182 * inherited from the parent socket. Set it for; 19183 * non-compliant socket implementations. */; 19184 set_non_blocking_mode(so.sock);; 19185 ; 19186 so.in_use = 0;; 19187 produce_socket(ctx, &so);; 19188 }; 19189}; 19190 ; 19191 ; 19192static void; 19193master_thread_run(struct mg_context *ctx); 19194{; 19195 struct mg_workerTLS tls;; 19196 struct mg_pollfd *pfd;; 19197 unsigned int i;; 19198 unsigned int w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:571283,throughput,throughput,571283,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['throughput'],['throughput']
Performance,"930 ; 1931////////////////////////////////////////////////////////////////////////////////; 1932/// Merge all the entries in the chain into a new tree in the current file.; 1933///; 1934/// Note: The ""file"" parameter is *not* the file where the new; 1935/// tree will be inserted. The new tree is inserted into; 1936/// gDirectory, which is usually the most recently opened; 1937/// file, or the directory most recently cd()'d to.; 1938///; 1939/// If option = ""C"" is given, the compression level for all branches; 1940/// in the new Tree is set to the file compression level. By default,; 1941/// the compression level of all branches is the original compression; 1942/// level in the old trees.; 1943///; 1944/// If basketsize > 1000, the basket size for all branches of the; 1945/// new tree will be set to basketsize.; 1946///; 1947/// Example using the file generated in $ROOTSYS/test/Event; 1948/// merge two copies of Event.root; 1949/// ~~~ {.cpp}; 1950/// gSystem.Load(""libEvent"");; 1951/// TChain ch(""T"");; 1952/// ch.Add(""Event1.root"");; 1953/// ch.Add(""Event2.root"");; 1954/// ch.Merge(""all.root"");; 1955/// ~~~; 1956/// If the chain is expecting the input tree inside a directory,; 1957/// this directory is NOT created by this routine.; 1958///; 1959/// So if you do:; 1960/// ~~~ {.cpp}; 1961/// TChain ch(""mydir/mytree"");; 1962/// ch.Merge(""newfile.root"");; 1963/// ~~~; 1964/// The resulting file will not have subdirectories. In order to; 1965/// preserve the directory structure do the following instead:; 1966/// ~~~ {.cpp}; 1967/// TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; 1968/// file->mkdir(""mydir"")->cd();; 1969/// ch.Merge(file, 0);; 1970/// ~~~; 1971/// If 'option' contains the word 'fast' the merge will be done without; 1972/// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; 1973/// bytes on disk).; 1974///; 1975/// When 'fast' is specified, 'option' can also contains a; 1976/// sorting order for the baskets in the output file.; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:69564,Load,Load,69564,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['Load']
Performance,"937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEntryListBlockUsed by TEntryList to store the entry numbers.Definition TEntryListBlock.h:44; TEntryListBlock::OptimizeStoragevoid OptimizeStorage()If there are < kBlockSize or >kBlockSize*15 entries, change to an array representation.Definition TEntryListBlock.cxx:546; TEntryListBlock::Removebool Remove(Int_t entry)Remove entry #entry If the block has already been optimized and the entries are stored as a list and ...Definition TEntryListBlock.cxx:165; TEntryListBlock::NextInt_t Next()Return the next non-zero entry Faster than GetEntry() function.Definition TEntryListBlock.cxx:446; TEntryListBlock::Enterbool Enter(Int_t entry)If the block has already been optimized and the entries are stored as a list and not as bits,...Definition TEntryListBlock.cxx:127; TEntryListBlock::GetNPassedInt_t GetNPassed()Returns the number of entries, passing the selection.Definition TEntryListBlock.cxx:369; TEntryListBlock::PrintWithShiftvoid PrintWithShift(Int_t shift) constPrint the indices of this block + shift (used from TEntryList::Print()) to print the current values.Definition TEntryListBlock.cxx:503; TEntryListBlock::ContainsInt_t Contains(Int_t entry)True if the block contains entry #entry.Definition TEntryListBlock.cxx:193; TEntryListBlock::GetEntryInt_t GetEntry(Int_t entry)Return entry #entry.Definition TEntryListBlock.cxx:381; TEntryListBlock::ResetIndicesvoid ResetIndices()Definition TEntryListBlock.h:74; TEntryListBlock::MergeInt_t Merge(TEntryListBlock *block)Merge with the other block Returns the resulting number of entries in the block.Definition TEntryListBlock.cxx:242; TEntryListA List of entry numbers in a TTree or TChain.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:60559,optimiz,optimized,60559,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value ||; 142 std::is_same<Function, int>::value),; 143 Function>::type>; 144 bool Fit(const Data &data, const Function &func,; 145 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential); 146 {; 147 SetFunction(func);; 148 return Fit(data, executionPolicy);; 149 }; 150 ; 151 /**; 152 Fit a binned data set using a least square fit.; 153 Note that the provided input data are copied in the Fitter class.; 154 Use the next func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:4385,perform,performed,4385,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['perform'],['performed']
Performance,"94 he was in charge of the Application Software group in the computing division. In 1995, at a time when the majority of software gurus had decided to follow a dead-end line, he created the ROOT system while working for the NA49 heavy ion experiment at the SPS. Rene has led the ROOT project from 1995-2010.; ; . Fons Rademakers ; ; Fons received his Ph.D. in particle physics from the Univ. of Amsterdam in 1991 for his work on event displays and data analysis for the DELPHI experiment at CERN's LEP collider. Since then he has worked at CERN and been involved in designing and developing data analysis programs. In 1991 he joined the PAW project where he developed the column wise-ntuples (a column-oriented storage system) and PIAF, a parallel data analysis system. In 1995, while working as Linux evangelist for Hewlett-Packard at CERN, he started with Rene Brun the ROOT project and has been involved in all aspects of the system since then. In 2001 Fons joined the ALICE collaboration and has worked as software architect on the initial version of the AliRoot framework. In recent years his special attention has gone to high performance parallel computing using PROOF. Fons took over from Rene Brun as ROOT project leader in 2011 and has led the project till 2014, culminating in the release of ROOT 6.; ; . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/project-founders.html:3652,perform,performance,3652,d/project-founders.html,https://root.cern,https://root.cern/d/project-founders.html,1,['perform'],['performance']
Performance,"94///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:39971,cache,cache,39971,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,3,['cache'],['cache']
Performance,"94939 a=0.0002833, ; prevFCN = 1659.944972 a=-0.0002833, ; prevFCN = 1659.919376 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001207, ; prevFCN = 1659.902797 a=-0.001266, ; prevFCN = 1659.902798 [#1] INFO:Minimization -- Command timer: Real time 0:00:02, CP time 2.710; [#1] INFO:Minimization -- Session timer: Real time 0:00:02, CP time 2.710; a=-0.001237, ; prevFCN = 1659.902781 a=-0.001207, ; prevFCN = 1659.902797 a=-0.001266, ; prevFCN = 1659.902798 a=-0.001231, ; prevFCN = 1659.902782 a=-0.001243, ; prevFCN = 1659.902782 [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.960; [#1] INFO:Minimization -- Session timer: Real time 0:00:03, CP time 3.670, 2 slices; a=-0.001237, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] WARNING:NumericIntegration -- RooAdaptiveIntegratorND::dtor(model) WARNING: Number of suppressed warningings about integral evaluations where target precision was not reached is 17; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y,z); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y,z]_Norm[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(y,z); [#0] WARNING:NumericIntegration -- RooAdaptiveIntegratorND::dtor(model) WARNING: Number of suppressed warningings about integral evaluations where target precision was not reached is 1; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf903_numintcache.py. tutorialsroofitrf903_numintcache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:5580,optimiz,optimization,5580,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,1,['optimiz'],['optimization']
Performance,"95 ; 996////////////////////////////////////////////////////////////////////////////////; 997/// Return pointer to object identified by namecycle.; 998///; 999/// The returned object may or may not derive from TObject.; 1000///; 1001/// - namecycle has the format name;cycle; 1002/// - name = * is illegal, cycle = * is illegal; 1003/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1004///; 1005/// ## Very important note; 1006/// The calling application must cast the returned object to; 1007/// the final type, e.g.; 1008///; 1009/// auto objPtr = (MyClass*)directory->GetObject(""some object of MyClass"");; 1010 ; 1011void *TDirectoryFile::GetObjectUnchecked(const char *namecycle); 1012{; 1013 return GetObjectChecked(namecycle,(TClass*)nullptr);; 1014}; 1015 ; 1016////////////////////////////////////////////////////////////////////////////////; 1017/// See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl); 1018 ; 1019void *TDirectoryFile::GetObjectChecked(const char *namecycle, const char* classname); 1020{; 1021 return GetObjectChecked(namecycle,TClass::GetClass(classname));; 1022}; 1023 ; 1024 ; 1025////////////////////////////////////////////////////////////////////////////////; 1026/// Return pointer to object identified by namecycle if and only if the actual; 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:34709,perform,performed,34709,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['perform'],['performed']
Performance,"954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::Dy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64255,load,load,64255,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['load']
Performance,"968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64619,load,loadedlibs,64619,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loadedlibs']
Performance,"97372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:21978,cache,cache,21978,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x2744ab0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x95fa7c0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x9805940 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf705_linearmorph.py. tutorialsroofitrf705_linearmorph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8py.html:7997,optimiz,optimization,7997,doc/master/rf705__linearmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"97{; 1698 auto listOfKeys = pcmFile.GetListOfKeys();; 1699 ; 1700 // This is an empty pcm; 1701 if (listOfKeys && ((listOfKeys->GetSize() == 0) || // Nothing here, or; 1702 ((listOfKeys->GetSize() == 1) && // only one, and; 1703 !strcmp(((TKey *)listOfKeys->At(0))->GetName(), ""EMPTY"") // name is EMPTY; 1704 ))) {; 1705 return;; 1706 }; 1707 ; 1708 TObjArray *protoClasses;; 1709 if (gDebug > 1); 1710 ::Info(""TCling::LoadPCMImpl"", ""reading protoclasses for %s \n"", pcmFile.GetName());; 1711 ; 1712 TObjArray *enums;; 1713 pcmFile.GetObject(""__Enums"", enums);; 1714 if (enums) {; 1715 // Cache the pointers; 1716 auto listOfGlobals = gROOT->GetListOfGlobals();; 1717 auto listOfEnums = dynamic_cast<THashList *>(gROOT->GetListOfEnums());; 1718 // Loop on enums and then on enum constants; 1719 for (auto selEnum : *enums) {; 1720 const char *enumScope = selEnum->GetTitle();; 1721 const char *enumName = selEnum->GetName();; 1722 if (strcmp(enumScope, """") == 0) {; 1723 // This is a global enum and is added to the; 1724 // list of enums and its constants to the list of globals; 1725 if (!listOfEnums->THashList::FindObject(enumName)) {; 1726 ((TEnum *)selEnum)->SetClass(nullptr);; 1727 listOfEnums->Add(selEnum);; 1728 }; 1729 for (auto enumConstant : *static_cast<TEnum *>(selEnum)->GetConstants()) {; 1730 if (!listOfGlobals->FindObject(enumConstant)) {; 1731 listOfGlobals->Add(enumConstant);; 1732 }; 1733 }; 1734 } else {; 1735 // This enum is in a namespace. A TClass entry is bootstrapped if; 1736 // none exists yet and the enum is added to it; 1737 TClass *nsTClassEntry = TClass::GetClass(enumScope);; 1738 if (!nsTClassEntry) {; 1739 nsTClassEntry = new TClass(enumScope, 0, TClass::kNamespaceForMeta, true);; 1740 }; 1741 auto listOfEnums = nsTClassEntry->fEnums.load();; 1742 if (!listOfEnums) {; 1743 if ((kIsClass | kIsStruct | kIsUnion) & nsTClassEntry->Property()) {; 1744 // For this case, the list will be immutable once constructed; 1745 // (i.e. in this case, by the end of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:64207,Cache,Cache,64207,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Cache'],['Cache']
Performance,"98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 122};; 123 ; 124//////////////////////////////////////////////////////////////////////////; 125// //; 126// class TGenBitsetProxy; 127//; 128// Local optimization class.; 129//; 130// Collection proxies get copied. On copy we switch the type of the; 131// proxy to the concrete STL type. The concrete types are optimized; 132// for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:3956,optimiz,optimized,3956,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"98 if (templist) {; 2799 listfound++;; 2800 templist->SetTreeNumber(ie);; 2801 }; 2802 }; 2803 ; 2804 if (listfound == 0){; 2805 Error(""SetEntryList"", ""No list found for the trees in this chain"");; 2806 fEntryList = nullptr;; 2807 return;; 2808 }; 2809 fEntryList = elist;; 2810 TList *elists = elist->GetLists();; 2811 bool shift = false;; 2812 TIter next(elists);; 2813 ; 2814 //check, if there are sub-lists in the entry list, that don't; 2815 //correspond to any trees in the chain; 2816 while((templist = (TEntryList*)next())){; 2817 if (templist->GetTreeNumber() < 0){; 2818 shift = true;; 2819 break;; 2820 }; 2821 }; 2822 fEntryList->SetShift(shift);; 2823 ; 2824}; 2825 ; 2826////////////////////////////////////////////////////////////////////////////////; 2827/// Set the input entry list (processing the entries of the chain will then be; 2828/// limited to the entries in the list). This function creates a special kind; 2829/// of entry list (TEntryListFromFile object) that loads lists, corresponding; 2830/// to the chain elements, one by one, so that only one list is in memory at a time.; 2831///; 2832/// If there is an error opening one of the files, this file is skipped and the; 2833/// next file is loaded; 2834///; 2835/// File naming convention:; 2836///; 2837/// - by default, filename_elist.root is used, where filename is the; 2838/// name of the chain element; 2839/// - xxx$xxx.root - $ sign is replaced by the name of the chain element; 2840///; 2841/// If the list name is not specified (by passing filename_elist.root/listname to; 2842/// the TChain::SetEntryList() function, the first object of class TEntryList; 2843/// in the file is taken.; 2844///; 2845/// It is assumed, that there are as many list files, as there are elements in; 2846/// the chain and they are in the same order; 2847 ; 2848void TChain::SetEntryListFile(const char *filename, Option_t * /*opt*/); 2849{; 2850 ; 2851 if (fEntryList){; 2852 //check, if the chain is the owner of the previous en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:102428,load,loads,102428,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loads']
Performance,"98TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods not already in the; 3841/// list (also protected and private ones).; 3842/// - once finished, loop over resulting list and remove all private and; 3843/// protected methods.; 3844 ; 3845const TList *TClass::GetLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:144502,Load,Load,144502,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"99.958577 a1=-1.485, ; prevFCN = 1899.959183 a1=-1.484, ; prevFCN = 1899.958511 a1=-1.485, ; prevFCN = 1899.960007 a1=-1.485, y=0.0003051, ; prevFCN = 1899.958806 y=-0.0003051, ; prevFCN = 1899.958806 a1=-1.484, y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 y=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; y=0, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf315_projectpdf.C. tutorialsroofitrf315_projectpdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:9971,optimiz,optimization,9971,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,1,['optimiz'],['optimization']
Performance,"99// -----------------------------------------------------; 7400// UNKNOWN COMMAND; 7401L1900:; 7402 Printf("" THE COMMAND:%10s IS UNKNOWN."",(const char*)fCword);; 7403 goto L2100;; 7404// -----------------------------------------------------; 7405// HELP SHOW, HELP SET, SHOW SET, or SHOW SHOW; 7406L2000:; 7407 ckind = ""SET "";; 7408 ctemp2 = fCword(3,7);; 7409 if (strcmp(ctemp2.Data(), ""SHO"")) ckind = ""SHOW"";; 7410L2100:; 7411 Printf("" THE FORMAT OF THE %4s COMMAND IS:"",(const char*)ckind);; 7412 Printf("" %s xxx [numerical arguments if any]"",(const char*)ckind);; 7413 Printf("" WHERE xxx MAY BE ONE OF THE FOLLOWING:"");; 7414 for (kk = 1; kk <= nname; ++kk) {; 7415 Printf("" %s"",cname[kk-1]);; 7416 }; 7417 return;; 7418// -----------------------------------------------------; 7419// ILLEGAL COMMAND; 7420L3000:; 7421 Printf("" ABOVE COMMAND IS ILLEGAL. IGNORED"");; 7422 ; 7423}; 7424 ; 7425////////////////////////////////////////////////////////////////////////////////; 7426/// Minimization using the simplex method of Nelder and Mead; 7427///; 7428/// Performs a minimization using the simplex method of Nelder; 7429/// and Mead (ref. -- Comp. J. 7,308 (1965)).; 7430 ; 7431void TMinuit::mnsimp(); 7432{; 7433 /* Initialized data */; 7434 ; 7435 static constexpr Double_t alpha = 1;; 7436 static constexpr Double_t beta = .5;; 7437 static constexpr Double_t gamma = 2;; 7438 static constexpr Double_t rhomin = 4;; 7439 static constexpr Double_t rhomax = 8;; 7440 ; 7441 /* Local variables */; 7442 Double_t dmin_, dxdi, yrho, f, ynpp1, aming, ypbar;; 7443 Double_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:237688,Perform,Performs,237688,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['Perform'],['Performs']
Performance,"994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7f45240 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x84ccbe0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[mean]_Norm[mean,x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[mean]_Norm[mean,x]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.2; sigma=0.5, [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:6094,optimiz,optimization,6094,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,1,['optimiz'],['optimization']
Performance,"9999999996, const RooCmdArg* formatCmd = 0); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; vector<RooAbsReal*>processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; voidrearrangeProduct(RooProdPdf::CacheElem&) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidsetCacheAndTrackHints(RooArgSet&); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; RooAbsReal*specializeIntegral(RooAbsReal& orig, const char* targetRangeName) const; RooAbsReal*specializeRatio(RooFormulaVar& input, const char* targetRangeName) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:39840,Cache,CacheElem,39840,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['Cache'],['CacheElem']
Performance,"9; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:158247,load,load,158247,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"9; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::GetEditorModeInt_t GetEditorMode() constDefinition TROOT.h:219; TROOT::ClassSavedBool_t ClassSaved",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:43486,load,load,43486,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"9; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:158423,load,load,158423,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"9; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::GetEditorModeInt_t GetEditorMode() constDefinition TROOT.h:219; TROOT::ClassSavedBool_t ClassSaved",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:43485,load,load,43485,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,": ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_CNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:Va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:3697,Optimiz,Optimizer,3697,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,": 0.629 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Training Model Summary; custom objects for loading model : {'optimizer': <class 'torch.optim.adam.Adam'>, 'criterion': BCELoss(), 'train_func': <function fit at 0x7fe43c5d1b80>, 'predict_func': <function predict at 0x7fe43c5d1ca0>}; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2) 514 ; ; =================================================================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:16736,load,loading,16736,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,2,"['load', 'optimiz']","['loading', 'optimizer']"
Performance,": ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45623,perform,performance,45623,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,: Elapsed time for evaluation of 9000 events: 0.0705 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: KNN for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of KNN on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.0918 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: LD for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of LD on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.00483 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: DNN_CPU for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of DNN_CPU on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.231 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: BDTG for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of BDTG on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 2.1 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate regression method: PDEFoam; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 9000 events: 0.0447 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time fo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:128319,perform,performance,128319,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,": Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:20848,load,loaded,20848,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['load'],['loaded']
Performance,": if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:24599,Cache,Cache,24599,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['Cache'],['Cache']
Performance,": try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooProjectedPdf() [1/3]. RooProjectedPdf::RooProjectedPdf ; (; ). Default constructor. ; Definition at line 44 of file RooProjectedPdf.cxx. ◆ RooProjectedPdf() [2/3]. RooProjectedPdf::RooProjectedPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _intpdf, . const RooArgSet & ; intObs . ). Construct projection of input pdf '_intpdf' over observables 'intObs'. ; Definition at line 53 of file RooProjectedPdf.cxx. ◆ RooProjectedPdf() [3/3]. RooProjectedPdf::RooProjectedPdf ; (; const RooProjectedPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 80 of file RooProjectedPdf.cxx. Member Function Documentation. ◆ analyticalIntegralWN(). double RooProjectedPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Return analytical integral represent by appropriate element of projection cache. ; Reimplemented from RooAbsPdf.; Definition at line 185 of file RooProjectedPdf.cxx. ◆ Class(). static TClass * RooProjectedPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooProjectedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooProjectedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file RooProjectedPdf.h. ◆ clone(). TObject * RooProjectedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Reimplemented in xRooProjectedPdf.; Definition at line 27 of file RooProjectedPdf.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooProjectedPdf::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsPdf.; Definition at line 283 of file RooP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:75545,cache,cache,75545,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['cache'],['cache']
Performance,": try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Mirror. enum RooKeysPdf::Mirror. EnumeratorNoMirror ; MirrorLeft ; MirrorRight ; MirrorBoth ; MirrorAsymLeft ; MirrorAsymLeftRight ; MirrorAsymRight ; MirrorLeftAsymRight ; MirrorAsymBoth . Definition at line 26 of file RooKeysPdf.h. Constructor & Destructor Documentation. ◆ RooKeysPdf() [1/4]. RooKeysPdf::RooKeysPdf ; (; ). coverity[UNINIT_CTOR] ; Definition at line 55 of file RooKeysPdf.cxx. ◆ RooKeysPdf() [2/4]. RooKeysPdf::RooKeysPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooDataSet & ; data, . Mirror ; mirror = NoMirror, . double ; rho = 1 . ). cache stuff about x ; Definition at line 63 of file RooKeysPdf.cxx. ◆ RooKeysPdf() [3/4]. RooKeysPdf::RooKeysPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooRealVar & ; xdata, . RooDataSet & ; data, . Mirror ; mirror = NoMirror, . double ; rho = 1 . ). cache stuff about x ; Definition at line 71 of file RooKeysPdf.cxx. ◆ RooKeysPdf() [4/4]. RooKeysPdf::RooKeysPdf ; (; const RooKeysPdf & ; other, . const char * ; name = nullptr . ). Definition at line 93 of file RooKeysPdf.cxx. ◆ ~RooKeysPdf(). RooKeysPdf::~RooKeysPdf ; (; ). override . Definition at line 126 of file RooKeysPdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooKeysPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented from RooAbsReal.; Definition at line 308 of file RooKeysPdf.cxx. ◆ Class(). static TClass * RooKeysPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooKeysPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:76018,cache,cache,76018,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['cache'],['cache']
Performance,": tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ; ****",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TestBinomial_8C.html:989,perform,performing,989,doc/master/TestBinomial_8C.html,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html,1,['perform'],['performing']
Performance,": tutorials/tmva/keras/ClassificationKeras.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ClassificationKeras.py. Go to the documentation of this file. 1#!/usr/bin/env python; 2## \file; 3## \ingroup tutorial_tmva_keras; 4## \notebook -nodraw; 5## This tutorial shows how to do classification in TMVA with neural networks; 6## trained with keras.; 7##; 8## \macro_code; 9##; 10## \date 2017; 11## \author TMVA Team; 12 ; 13from ROOT import TMVA, TFile, TTree, TCut; 14from subprocess import call; 15from os.path import isfile; 16 ; 17from tensorflow.keras.models import Sequential; 18from tensorflow.keras.layers import Dense, Activation; 19from tensorflow.keras.optimizers import SGD; 20 ; 21# Setup TMVA; 22TMVA.Tools.Instance(); 23TMVA.PyMethodBase.PyInitialize(); 24 ; 25output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); 26factory = TMVA.Factory('TMVAClassification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); 56",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py_source.html:1051,Load,Load,1051,doc/master/ClassificationKeras_8py_source.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html,1,['Load'],['Load']
Performance,": vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types: Stores the coordinates and the DataOptions ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ;  CSparseData;  CUnBinDataClass describing the unbinned data sets (just x coordinates values) of any dimensions ;  ►NInternal;  ►NExecutorUtils;  CResultCaster;  CResultCaster< TObject *, F >;  ►NTDF;  CCacheColumnHolder;  CTAction;  CTActionBase;  CTColumnValueHelper class that updates and returns TTree branches as well as TDataFrame temporary columns ;  CTMinReturnTypeThe contained type alias is double if T == TInferType, U if T == std::container<U>, T otherwise ;  CTMinReturnType< T, true >;  CTMinReturnType< TDFDetail::TInferType, false >;  CTSlotStack;  CTTDFValueTupl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:23662,perform,performing,23662,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['perform'],['performing']
Performance,: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.012 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00146 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0456 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.101 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: Higgs_trained_model.h5; Py,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:50395,perform,performance,50395,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performance']
Performance,":(anonymous)TObject::kNotDeleted; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:15021,optimiz,optimization,15021,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,1,['optimiz'],['optimization']
Performance,":(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooRealIntegral*_acceptRejectFuncProjection function to be passed to accept/reject sampler; Double_t_areaMaximum probability, p.d.f area and normalization; RooArgSet*_cloneSetClone of all nodes of input p.d.f; Int_t_codeInternal generation code; RooArgSet_directVarsList of observables generated internally, randomly, and by accept/reject sampling; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsNumGenerator*_generatorMC sampling generation engine; Bool_tRooAbsGenContext::_isValidIs context in valid state?; Double_t_maxProbMaximum probability, p.d.f area and normalization; RooRealVar*_maxVarVariable holding maximum value of p.d.f; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; Double_t_normMaximum probability, p.d.f area and normalization; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet_otherVarsList of observables generated internally, randomly, and by accept/reject sampling; RooAbsPdf*_pdfCloneClone of input p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniformVarsList of observables generated internally, randomly, and by accept/reject sampling; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenContext.html:9856,load,load,9856,root/html602/RooGenContext.html,https://root.cern,https://root.cern/root/html602/RooGenContext.html,2,['load'],['load']
Performance,":(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMCStudyModule.html:8236,perform,performed,8236,root/html602/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html,2,['perform'],['performed']
Performance,":. TQCanvasMenu(const TQCanvasMenu& c); TQCanvasMenu&operator=(const TQCanvasMenu&). Data Members; protected:. TObject*fCurrObjcurrent selected object; TQRootDialog*fDialogthe TQRootDialog which is used to prompt for; TListfMethodslist of Root metheds associated with the selected object; doublefMousePosXmouse position in user coordinate; doublefMousePosYmouse position in user coordinate; QWidget*fParent; QPopupMenu*fPopupQt popup menu; QWidget*fTabWinparents widgets; TCanvas*fcpointer to the ROOT canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQCanvasMenu(QWidget* parent = 0, TCanvas* canvas = 0); ctor, create the popup menu. TQCanvasMenu(QWidget* parent, QWidget* tabWin, TCanvas* canvas); ctor, create the popup menu. ~TQCanvasMenu(); dtor. char * CreateDialogTitle(TObject* object, TMethod* method); Create title for dialog box retrieving argument values. char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). void Popup(TObject* obj, double x, double y, QMouseEvent* e); Perform the corresponding selected TObject popup; in the position defined; by x, y coordinates (in user coordinate system).; @param obj (TObject*); @param p (QPoint&). void Execute(int id); Slot defined to execute a method from a selected TObject; using TObject::Execute() function. void Dialog(TObject* obj, TMethod* method); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""method"". TQCanvasMenu(const TQCanvasMenu& c). TQCanvasMenu& operator=(const TQCanvasMenu& ); {return *this;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQCanvasMenu.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCanvasMenu.html:1975,Perform,Perform,1975,root/html528/TQCanvasMenu.html,https://root.cern,https://root.cern/root/html528/TQCanvasMenu.html,1,['Perform'],['Perform']
Performance,":. TQCanvasMenu(const TQCanvasMenu& c); TQCanvasMenu&operator=(const TQCanvasMenu&). Data Members; protected:. TObject*fCurrObjcurrent selected object; TQRootDialog*fDialogthe TQRootDialog which is used to prompt for; TListfMethodslist of Root metheds associated with the selected object; doublefMousePosXmouse position in user coordinate; doublefMousePosYmouse position in user coordinate; QWidget*fParent; QPopupMenu*fPopupQt popup menu; QWidget*fTabWinparents widgets; TCanvas*fcpointer to the ROOT canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQCanvasMenu(QWidget* parent = 0, TCanvas* canvas = 0); ctor, create the popup menu. TQCanvasMenu(QWidget* parent, QWidget* tabWin, TCanvas* canvas); ctor, create the popup menu. ~TQCanvasMenu(); dtor. char * CreateDialogTitle(TObject* object, TMethod* method); Create title for dialog box retrieving argument values. char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). void Popup(TObject* obj, double x, double y, QMouseEvent* e); Perform the corresponding selected TObject popup; in the position defined; by x, y coordinates (in user coordinate system).; @param obj (TObject*); @param p (QPoint&). void Execute(int id); Slot defined to execute a method from a selected TObject; using TObject::Execute() function. void Dialog(TObject* obj, TMethod* method); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""method"". TQCanvasMenu(const TQCanvasMenu& c). TQCanvasMenu& operator=(const TQCanvasMenu& ); {return *this;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQCanvasMenu.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCanvasMenu.html:1975,Perform,Perform,1975,root/html532/TQCanvasMenu.html,https://root.cern,https://root.cern/root/html532/TQCanvasMenu.html,1,['Perform'],['Perform']
Performance,":. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Mon Jul 4 15:19:11 2011 » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PyROOT__TPyROOTApplication.html:13393,load,loaded,13393,root/html530/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html530/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,":. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Thu Nov 3 20:04:29 2011 » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PyROOT__TPyROOTApplication.html:13393,load,loaded,13393,root/html532/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html532/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,":101; RooMomentMorphFuncNDDefinition RooMomentMorphFuncND.h:33. Definition at line 125 of file RooMomentMorphFuncND.h. ◆ sij(). int RooMomentMorphFuncND::sij ; (; const int & ; i, . const int & ; j . ); const. inlineprotected . Definition at line 160 of file RooMomentMorphFuncND.h. ◆ Streamer(). void RooMomentMorphFuncND::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooMomentMorphFuncND::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 162 of file RooMomentMorphFuncND.h. ◆ sumFunc(). RooMomentMorphFuncND::Base_t * RooMomentMorphFuncND::sumFunc ; (; const RooArgSet * ; nset). protected . Definition at line 522 of file RooMomentMorphFuncND.cxx. ◆ useHorizontalMorphing(). void RooMomentMorphFuncND::useHorizontalMorphing ; (; bool ; val). inline . Definition at line 127 of file RooMomentMorphFuncND.h. Friends And Related Symbol Documentation. ◆ CacheElem. friend class CacheElem. friend . Definition at line 140 of file RooMomentMorphFuncND.h. ◆ Grid2. friend class Grid2. friend . Definition at line 141 of file RooMomentMorphFuncND.h. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooMomentMorphFuncND::_cacheMgr. mutableprotected . ! Transient cache manager ; Definition at line 143 of file RooMomentMorphFuncND.h. ◆ _curNormSet. RooArgSet* RooMomentMorphFuncND::_curNormSet = nullptr. mutableprotected . ! Transient cache manager ; Definition at line 144 of file RooMomentMorphFuncND.h. ◆ _isPdfMode. bool RooMomentMorphFuncND::_isPdfMode = false. protected . Definition at line 158 of file RooMomentMorphFuncND.h. ◆ _M. std::unique_ptr<TMatrixD> RooMomentMorphFuncND::_M. mutableprotected . Definition at line 151 of file RooMomentMorphFuncND.h. ◆ _MSqr. std::unique_ptr<TMatrixD> RooMomentMorphFuncND::_MSqr. mutableprotected . Definition at line 152 of file RooMomentMorphFuncND.h. ◆ _obsList. RooSetProxy RooMomentMorphFuncND::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:67660,Cache,CacheElem,67660,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['Cache'],['CacheElem']
Performance,":127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrvoid SetDeclAttr(DeclId_t, const char *) finalDefinition TCling.cxx:8725; TCling::HandleNewDeclvoid HandleNewDecl(const void *DV, bool isDeserialized, std::set< TClass * > &modifiedClasses)Definition TCling.cxx:496; TCling::InvalidateCachedDeclvoid InvalidateCachedDecl(const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > &Lists, const clang::Decl *D)Invalidate cached TCling information for the given declaration, and removed it from the appropriate o...Definition TCling.cxx:6891; TCling::MethodInfo_PropertyLong_t MethodInfo_Property(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9091; TCling::LoadFunctionTemplatesvirtual void LoadFunctionTemplates(TClass *cl) const finalCreate list of pointers to function templates for TClass cl.Definition TCling.cxx:4442; TCling::ClassInfo_IsValidMethodbool ClassInfo_IsValidMethod(ClassInfo_t *info, const char *method, const char *proto, Longptr_t *offset, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) const finalDefinition TCling.cxx:8336; TCling::DataMemberInfo_PropertyLong_t DataMemberInfo_Property(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8658; TCling::SetClassAutoparsingint SetClassAutoparsing(int) finalEnable/Disable the Autoparsing of headers.Definition TCling.cxx:7585; TCling::fCurExecutingMacrosstd::vector< const char * > fCurExecutingMacrosDefinition TCling.h:149; TCling::CreateListOfDataMembersvoid CreateListOfDataMembers(TClass *cl) const finalCreate list of pointers to data members for TClass cl.Definition TCling.cxx:4489; TCling::RewindDictionaryvoid RewindDictionary() finalRewind Cling dictionary to the point where it was before executing the current macro.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:419979,Load,LoadFunctionTemplatesvirtual,419979,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,4,['Load'],"['LoadFunctionTemplates', 'LoadFunctionTemplatesvirtual']"
Performance,":237; TGraphDelaunay::GetXNmaxDouble_t GetXNmax() constDefinition TGraphDelaunay.h:93; TGraphDelaunay::fYNminDouble_t fYNmin! Minimum value of fYNDefinition TGraphDelaunay.h:49; TGraphDelaunay::fTriedSizeInt_t fTriedSize! Real size of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::operator=TGraphDelaunay & operator=(const TGraphDelaunay &)=delete; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::TGraphDelaunayTGraphDelaunay(const TGraphDelaunay &)=delete; TGraphDelaunay::GetXNDouble_t * GetXN() constDefinition TGraphDelaunay.h:90; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::GetPTriedInt_t * GetPTried() constDefinition TGraphDelaunay.h:87; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::GetNTriedInt_t * GetNTried() constDefinition TGraphDelaunay.h:88; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::GetYNminDouble_t GetYNmin() constDefinition TGraphDelaunay.h:94; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the tria",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8h_source.html:8212,perform,performed,8212,doc/master/TGraphDelaunay_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html,1,['perform'],['performed']
Performance,":407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:33993,cache,cache,33993,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['cache'],['cache']
Performance,":46; Double_tdouble Double_tDefinition RtypesCore.h:59; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVARegGui.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::SetWeightExpressionvoid SetWeightExpression(const TString &variable, const TString &className="""")Definition DataLoader.cxx:563; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:147894,cache,cacheDir,147894,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,4,['cache'],"['cache', 'cacheDir']"
Performance,":725; RooFit::EvalErrorValueRooCmdArg EvalErrorValue(double value)Definition RooGlobalFunc.cxx:284; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf606_nllerrorhandlingDefinition rf606_nllerrorhandling.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6225,optimiz,optimization,6225,doc/master/rf606__nllerrorhandling_8C.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html,1,['optimiz'],['optimization']
Performance,"::"", ""@@"");; 6087 // convert ""-"" to "" "", since class names may have; 6088 // blanks and TEnv considers a blank a terminator; 6089 key.ReplaceAll("" "", ""-"");; 6090 ; 6091 R__LOCKGUARD(gInterpreterMutex);; 6092 if (!fMapfile) {; 6093 fMapfile = new TEnv();; 6094 fMapfile->IgnoreDuplicates(kTRUE);; 6095 ; 6096 fRootmapFiles = new TObjArray;; 6097 fRootmapFiles->SetOwner();; 6098 ; 6099 InitRootmapFile("".rootmap"");; 6100 }; 6101 //fMapfile->SetValue(key, libs);; 6102 fMapfile->SetValue(cls, libs);; 6103 return 1;; 6104}; 6105 ; 6106////////////////////////////////////////////////////////////////////////////////; 6107/// Demangle the name (from the typeinfo) and then request the class; 6108/// via the usual name based interface (TClass::GetClass).; 6109 ; 6110TClass *TCling::GetClass(const std::type_info& typeinfo, Bool_t load) const; 6111{; 6112 int err = 0;; 6113 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6114 if (err) return nullptr;; 6115 TClass* theClass = TClass::GetClass(demangled_name, load, kTRUE);; 6116 free(demangled_name);; 6117 return theClass;; 6118}; 6119 ; 6120////////////////////////////////////////////////////////////////////////////////; 6121/// Load library containing the specified class. Returns 0 in case of error; 6122/// and 1 in case if success.; 6123 ; 6124Int_t TCling::AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded /* = kFALSE */); 6125{; 6126 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6127 ; 6128 int err = 0;; 6129 char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6130 if (err) {; 6131 return 0;; 6132 }; 6133 ; 6134 std::string demangled_name(demangled_name_c);; 6135 free(demangled_name_c);; 6136 ; 6137 // AutoLoad expects (because TClass::GetClass already prepares it that way) a; 6138 // shortened name.; 6139 TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );; 6140 sp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:236776,load,load,236776,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,3,"['Load', 'load']","['Load', 'load']"
Performance,"::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArray*fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*fCurrent! currently filled entry list; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesToProcessused on proof to set the number of entries to process in a packet; TStringfFileNamename of the file, where the tree is; Long64_tfLastIndexQueried! used to optimize GetEntry() function from a loop; Long64_tfLastIndexReturned! used to optimize GetEntry() function from a loop; TList*fListsa list of underlying entry lists for each tree of a chain; Long64_tfNnumber of entries in the list; Int_tfNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tfReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tfShift! true when some sub-lists don't correspond to trees; ULong_tfStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringfTreeNamename of the tree; Int_tfTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryList(); default c-tor. TEntryList(const char* name, const char* title); c-tor with name and title. TEntryList(const char* name, const char* title, const TTree* tree); constructor with name and title, which also sets the tree. TEntryList(const char* name, const char* title, const char* treename, const char* filename); c-tor with name and title, which also sets the treename and the filena",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryList.html:17240,optimiz,optimize,17240,root/html602/TEntryList.html,https://root.cern,https://root.cern/root/html602/TEntryList.html,4,['optimiz'],['optimize']
Performance,"::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TList* GetStaged(TCollection* pathlist); Retrieves the staging (online) status for a list of path names. Path names; must be of type TUrl, TFileInfo or TObjString. The returned list is the list; of staged files as TObjString (we use TObjString, because you can do a FindObject; on that list using the file name, which is not possible with TUrl objects. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue a stage request for a list of files.; Return the '&' of all single Prepare commands. TFileStager * Open(const char* stager); Open a stager, after having loaded the relevant plug-in.; The format of 'stager' depends on the plug-in. Bool_t IsStaged(const char* ); Just check if the file exists locally. Int_t Locate(const char* u, TString& f); Just check if the file exists locally. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Massive location of files. Returns < 0 on error, or number of files; processed. Results are returned on the TFileCollection itself. TString GetPathName(TObject* o); Return the path name contained in object 'o' allowing for; TUrl, TObjString or TFileInfo. TFileStager(const char* stager); { }. virtual ~TFileStager(); { }. Bool_t Matches(const char* s); { return ((s && (fName == s)) ? kTRUE : kFALSE); }. Bool_t Stage(const char* , Option_t* = 0); { return kTRUE; }. Bool_t IsValid() const; { return kTRUE; }. » Author: A. Peters, G. Ganis 7/2/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 14:49; Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileStager.html:7395,load,loaded,7395,root/html602/TFileStager.html,https://root.cern,https://root.cern/root/html602/TFileStager.html,1,['load'],['loaded']
Performance,"::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TList* GetStaged(TCollection* pathlist); Retrieves the staging (online) status for a list of path names. Path names; must be of type TUrl, TFileInfo or TObjString. The returned list is the list; of staged files as TObjString (we use TObjString, because you can do a FindObject; on that list using the file name, which is not possible with TUrl objects. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue a stage request for a list of files.; Return the '&' of all single Prepare commands. TFileStager * Open(const char* stager); Open a stager, after having loaded the relevant plug-in.; The format of 'stager' depends on the plug-in. Bool_t IsStaged(const char* ); Just check if the file exists locally. Int_t Locate(const char* u, TString& f); Just check if the file exists locally. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Massive location of files. Returns < 0 on error, or number of files; processed. Results are returned on the TFileCollection itself. TString GetPathName(TObject* o); Return the path name contained in object 'o' allowing for; TUrl, TObjString or TFileInfo. TFileStager(const char* stager); { }. virtual ~TFileStager(); { }. Bool_t Matches(const char* s); { return ((s && (fName == s)) ? kTRUE : kFALSE); }. Bool_t Stage(const char* , Option_t* = 0); { return kTRUE; }. Bool_t IsValid() const; { return kTRUE; }. » Author: A. Peters, G. Ganis 7/2/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:43; Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFileStager.html:7395,load,loaded,7395,root/html604/TFileStager.html,https://root.cern,https://root.cern/root/html604/TFileStager.html,1,['load'],['loaded']
Performance,"::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>_boolAttribBoolean attributes; set<string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape; TIterator*_clientValueIter! Iterator over _clientListValue; Bool_t_deleteWatch! Delete watch flag; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_isConstant! Cached isConstant status; Bool_t_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<string,string>_stringAttribString attributes; Bool_t_valueD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:18676,cache,caches,18676,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,6,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* ot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:2844,Cache,CacheModeRooAbsArg,2844,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,3,['Cache'],['CacheModeRooAbsArg']
Performance,"::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:3180,Cache,CacheModeRooAbsArg,3180,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"::BrowseDataSets ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . UInt_t ; option, . TObject * ; target . ). protected . Adds the dataset in the folder of group, user to the list in target. ; If dsName is defined, only the information about the specified dataset is processed.; The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet. Available options (to be .or.ed): kPrint print the dataset content kQuotaUpdate update quotas kExport use export naming kList get a list of dataset names; NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. ; Definition at line 577 of file TDataSetManagerFile.cxx. ◆ CheckLocalCache(). Int_t TDataSetManagerFile::CheckLocalCache ; (; const char * ; group, . const char * ; user, . const char * ; dsName = ""ls"", . UInt_t ; option = 0 . ). private . Check if the local cache information for group, user, dsName is up-to-date If not, make the relevant updates Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. ; Definition at line 1085 of file TDataSetManagerFile.cxx. ◆ ChecksumDataSet(). Int_t TDataSetManagerFile::ChecksumDataSet ; (; const char * ; path, . const char * ; md5path, . TString & ; checksum . ). protected . Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ; The MD5 string is returned in 'md5sum'. Return 0 on success, -1 on error. ; Definition at line 1512 of file TDataSetManagerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetMan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:22315,cache,cache,22315,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['cache'],['cache']
Performance,"::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition RWebWindow.cxx:1260; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:37398,queue,queue,37398,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:37787,queue,queue,37787,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveTrackPropagator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 348 of file TEveTrackPropagator.h. ◆ ClosestPointBetweenLines(). Bool_t TEveTrackPropagator::ClosestPointBetweenLines ; (; const TEveVectorD & ; p0, . const TEveVectorD & ; u, . const TEveVectorD & ; q0, . const TEveVectorD & ; v, . TEveVectorD & ; out . ). protected . Get closest point on line defined with vector p0 and u. ; Return false if the point is forced on the line segment. ; Definition at line 983 of file TEveTrackPropagator.cxx. ◆ ClosestPointFromVertexToLineSegment(). void TEveTrackPropagator::ClosestPointFromVertexToLineSegment ; (; const TEveVectorD & ; v, . const TEveVectorD & ; s, . const TEveVectorD & ; r, . Double_t ; rMagInv, . TEveVectorD & ; c . ). protected . Get closest point from given vertex v to line segment defined with s and r. ; Argument rMagInv is cached. rMagInv= 1./rMag() ; Definition at line 956 of file TEveTrackPropagator.cxx. ◆ DeclFileName(). static const char * TEveTrackPropagator::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 348 of file TEveTrackPropagator.h. ◆ DistributeOffset(). void TEveTrackPropagator::DistributeOffset ; (; const TEveVectorD & ; off, . Int_t ; first_point, . Int_t ; np, . TEveVectorD & ; p . ). private . Distribute offset between first and last point index and rotate momentum. ; Definition at line 777 of file TEveTrackPropagator.cxx. ◆ ElementChanged(). void TEveTrackPropagator::ElementChanged ; (; Bool_t ; update_scenes = kTRUE, . Bool_t ; redraw = kFALSE . ). overridevirtual . Element-change notification. ; Stamp all tracks as requiring display-list regeneration. Virtual from TEveElement. ; Reimplemented from TEveElement.; Definition at line 308 of file TEveTrackPropagator.cxx. ◆ FillPointSet(). void TEveTrackPropagator::F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:46088,cache,cached,46088,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['cache'],['cached']
Performance,"::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThreshfraction thresholds; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimSplitGenContext.html:9417,load,load,9417,root/html602/RooSimSplitGenContext.html,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html,2,['load'],['load']
Performance,"::DefaultMinimizerType(). . AttentionThis overrides the default fitter of this RooMinimizer. ; Parameters. [in]algFit algorithm to use. (Optional) . Definition at line 281 of file RooMinimizer.cxx. ◆ minimizerType(). std::string const & RooMinimizer::minimizerType ; (; ); const. inline . Definition at line 175 of file RooMinimizer.h. ◆ minos() [1/2]. int RooMinimizer::minos ; (; ). Execute MINOS. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 376 of file RooMinimizer.cxx. ◆ minos() [2/2]. int RooMinimizer::minos ; (; const RooArgSet & ; minosParamList). Execute MINOS for given list of parameters. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 393 of file RooMinimizer.cxx. ◆ optimizeConst(). void RooMinimizer::optimizeConst ; (; int ; flag). If flag is true, perform constant term optimization on function being minimized. ; Definition at line 489 of file RooMinimizer.cxx. ◆ profileStart(). void RooMinimizer::profileStart ; (; ). private . Start profiling timer. ; Definition at line 698 of file RooMinimizer.cxx. ◆ profileStop(). void RooMinimizer::profileStop ; (; ). private . Stop profiling timer and report results of last session. ; Definition at line 710 of file RooMinimizer.cxx. ◆ save(). RooFit::OwningPtr< RooFitResult > RooMinimizer::save ; (; const char * ; userName = nullptr, . const char * ; userTitle = nullptr . ). Save and return a RooFitResult snapshot of current minimizer status. ; This snapshot contains the values of all constant parameters, the value of all floating parameters at RooMinimizer construction and after the last MINUIT operation, the MINUIT status, variance quality, EDM setting, number of calls with evaluation problems, the minimized function value and the full correlation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:24930,optimiz,optimizeConst,24930,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['optimiz'],['optimizeConst']
Performance,"::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassGenerator.html:2142,load,load,2142,root/html526/TClassGenerator.html,https://root.cern,https://root.cern/root/html526/TClassGenerator.html,7,['load'],['load']
Performance,"::DeleteItem(Bool_t force, void* ptr) const; voidExpand(UInt_t nCurr, UInt_t left); TGenCollectionProxy*TGenCollectionProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:4436,cache,cache,4436,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,1,['cache'],['cache']
Performance,"::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE) overrideIf ignore is true ignore the specified signal, else restore previous behaviour.Definition TUnixSystem.cxx:895; TUnixSystem::ListSymbolsvoid ListSymbols(const char *module, const char *re="""") overrideList symbols in a shared library.Definition TUnixSystem.cxx:2840; TUnixSystem::Loadint Load(const char *module, const char *entry="""", Bool_t system=kFALSE) overrideLoad a shared library.Definition TUnixSystem.cxx:2824; TUnixSystem::StackTracevoid StackTrace() overridePrint a stack trace.Definition TUnixSystem.cxx:2281; TUnixSystem::GetHostByNameTInetAddress GetHostByName(const char *server) overrideGet Internet Protocol (IP) address of host.Definition TUnixSystem.cxx:3046; TUnixSystem::SendBufint SendBuf(int sock, const void *buffer, int length) overrideSend a buffer headed by a length indicator.Definition TUnixSystem.cxx:3341; TUnixSystem::HostNameconst char * HostName() overrideReturn the system's host name.Definition TUnixSystem.cxx:762; TUnixSystem::CheckChildsvoid CheckChilds()Check if children have finished.Definition TUnixSystem.cxx:1317; TUnixSystem::RecvBufint RecvBuf(int sock, void *buffer, int length) overrideReceive a buffer headed by a length indicator.Definition TUnixSystem.cxx:3316; TUnixSystem::UnixUnixServicestatic int UnixUnixService(int port, int backlog)Open a socket, bind to it and s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:211016,Load,Loadint,211016,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,4,['Load'],"['Load', 'Loadint']"
Performance,"::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20428,perform,perform,20428,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"::DoDerivative ; (; const T * ; x, . unsigned int ; icoord . ); const. privatepure virtual . Function to evaluate the derivative with respect each coordinate. To be implemented by the derived class. . ◆ DoDerivativeWithPrevResult(). template<class T > . virtual T ROOT::Math::IGradientFunctionMultiDimTempl< T >::DoDerivativeWithPrevResult ; (; const T * ; x, . unsigned int ; icoord, . T * ; , . T * ; , . T * ;  . ); const. inlineprivatevirtual . In some cases, the derivative algorithm will use information from the previous step, these can be passed in with this overload. ; The previous_* arrays can also be used to return second derivative and step size so that these can be passed forward again as well at the call site, if necessary. ; Definition at line 231 of file IFunction.h. ◆ FdF(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::FdF ; (; const T * ; x, . T & ; f, . T * ; df . ); const. inlinevirtual . Optimized method to evaluate at the same time the function value and derivative at a point x. ; Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time ; Definition at line 202 of file IFunction.h. ◆ Gradient(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::Gradient ; (; const T * ; x, . T * ; grad . ); const. inlinevirtual . Evaluate all the vector of function derivatives (gradient) at a point x. ; Derived classes must re-implement it if more efficient than evaluating one at a time ; Definition at line 177 of file IFunction.h. ◆ GradientWithPrevResult(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::GradientWithPrevResult ; (; const T * ; x, . T * ; grad, . T * ; previous_grad, . T * ; previous_g2, . T * ; previous_gstep . ); const. inlinevirtual . In some",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html:6261,Optimiz,Optimized,6261,doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,1,['Optimiz'],['Optimized']
Performance,"::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTree.cxx:1142; TTree::Fitvirtual Int_t Fit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Fit a projected item(s) from a tree.Definition TTree.cxx:5079; TTree::fClusterRangeEndLong64_t * fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.Definition TTree.h:103; TTree::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TTree.cxx:9545; TTree::fIMTZipBytesstd::atomic< Long64_t > fIMTZipBytes! Zip bytes for the IMT flush baskets.Definition TTree.h:161; TTree::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:441085,Load,Load,441085,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['Load']
Performance,"::EvalContext & ; ctx); const. overrideprotectedvirtual . Compute multiple values of Crystal ball Shape distribution. ; Reimplemented from RooAbsReal.; Definition at line 74 of file RooCBShape.cxx. ◆ evaluate(). double RooCBShape::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 62 of file RooCBShape.cxx. ◆ getAnalyticalIntegral(). Int_t RooCBShape::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 82 of file RooCBShape.cxx. ◆ getMaxVal(). Int_t RooCBShape::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise that we know the maximum of self for given (m0,alpha,n,sigma) ; Reimplemented from RooAbsReal.; Definition at line 108 of file RooCBShape.cxx. ◆ IsA(). TClass * RooCBShape::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 62 of file RooCBShape.h. ◆ maxVal(). double RooCBShape::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 120 of file RooCBShape.cxx. ◆ Streamer(). void RooCBShape::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooCBShape::Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:77078,perform,performed,77078,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,1,['perform'],['performed']
Performance,"::Factory::Factory ; (; TString ; jobName, . TFile * ; theTargetFile, . TString ; theOption = """" . ). Standard constructor. . jobname : this name will appear in all weight file names produced by the MVAs; theTargetFile : output ROOT file; the test tree and all evaluation plots will be stored here; theOption : option string; currently: ""V"" for verbose . Definition at line 113 of file Factory.cxx. ◆ Factory() [2/2]. TMVA::Factory::Factory ; (; TString ; theJobName, . TString ; theOption = """" . ). Constructor. ; Definition at line 204 of file Factory.cxx. ◆ ~Factory(). TMVA::Factory::~Factory ; (; void ; ). virtual . Destructor. ; Definition at line 306 of file Factory.cxx. Member Function Documentation. ◆ BookMethod() [1/3]. MethodBase * TMVA::Factory::BookMethod ; (; DataLoader * ; , . TMVA::Types::EMVA ; , . TString ; , . TString ; , . TMVA::Types::EMVA ; , . TString ;  . ). inline . Definition at line 102 of file Factory.h. ◆ BookMethod() [2/3]. TMVA::MethodBase * TMVA::Factory::BookMethod ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . TString ; methodTitle, . TString ; theOption = """" . ). Book a classifier or regression method. ; Definition at line 352 of file Factory.cxx. ◆ BookMethod() [3/3]. TMVA::MethodBase * TMVA::Factory::BookMethod ; (; TMVA::DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . TString ; theOption = """" . ). Books MVA method. ; The option configuration string is custom for each MVA the TString field ""theNameAppendix"" serves to define (and distinguish) several instances of a given MVA, eg, when one wants to compare the performance of various configurations ; Definition at line 487 of file Factory.cxx. ◆ BookMethodWeightfile(). TMVA::MethodBase * TMVA::Factory::BookMethodWeightfile ; (; DataLoader * ; loader, . TMVA::Types::EMVA ; methodType, . const TString & ; weightfile . ). private . Adds an already constructed method to be managed by this factory. ; NotePrivate. . Know what you are doing when using t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:21767,load,loader,21767,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:5227,load,load,5227,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,1,['load'],['load']
Performance,"::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:4630,load,load,4630,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,1,['load'],['load']
Performance,"::GetInfo()Definition RNTupleReader.hxx:43; ROOT::Experimental::ENTupleInfo::kMetrics@ kMetrics. Definition at line 364 of file RNTupleReader.hxx. ◆ end(). RIterator ROOT::Experimental::RNTupleReader::end ; (; ). inline . Definition at line 343 of file RNTupleReader.hxx. ◆ GetCollectionView() [1/2]. RNTupleCollectionView ROOT::Experimental::RNTupleReader::GetCollectionView ; (; DescriptorId_t ; fieldId). inline . Definition at line 337 of file RNTupleReader.hxx. ◆ GetCollectionView() [2/2]. RNTupleCollectionView ROOT::Experimental::RNTupleReader::GetCollectionView ; (; std::string_view ; fieldName). inline . Raises an exception if: . there is no field with the given name or,; the field is not a collection . Definition at line 327 of file RNTupleReader.hxx. ◆ GetDescriptor(). const ROOT::Experimental::RNTupleDescriptor & ROOT::Experimental::RNTupleReader::GetDescriptor ; (; ). Returns a cached copy of the page source descriptor. ; The returned pointer remains valid until the next call to LoadEntry or to any of the views returned from the reader. ; Definition at line 230 of file RNTupleReader.cxx. ◆ GetDirectAccessView() [1/2]. template<typename T > . RNTupleDirectAccessView< T > ROOT::Experimental::RNTupleReader::GetDirectAccessView ; (; DescriptorId_t ; fieldId). inline . Definition at line 317 of file RNTupleReader.hxx. ◆ GetDirectAccessView() [2/2]. template<typename T > . RNTupleDirectAccessView< T > ROOT::Experimental::RNTupleReader::GetDirectAccessView ; (; std::string_view ; fieldName). inline . Definition at line 311 of file RNTupleReader.hxx. ◆ GetDisplayReader(). ROOT::Experimental::RNTupleReader * ROOT::Experimental::RNTupleReader::GetDisplayReader ; (; ). private . Definition at line 201 of file RNTupleReader.cxx. ◆ GetEntryRange(). RNTupleGlobalRange ROOT::Experimental::RNTupleReader::GetEntryRange ; (; ). inline . Returns an iterator over the entry indices of the RNTuple. ; Example: iterate over all entries and print each entry in JSON format #include <R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:9146,Load,LoadEntry,9146,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['Load'],['LoadEntry']
Performance,"::GetW(); virtual Double_tTTree::GetWeight() const; Float_t*GetX(); virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitBranches(Long64_t entry); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); char*MakeX(Int_t nvars); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookTree.html:11258,Load,LoadTreeFriend,11258,root/html528/THbookTree.html,https://root.cern,https://root.cern/root/html528/THbookTree.html,1,['Load'],['LoadTreeFriend']
Performance,"::GetW(); virtual Double_tTTree::GetWeight() const; Float_t*GetX(); virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitBranches(Long64_t entry); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); char*MakeX(Int_t nvars); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THbookTree.html:11380,Load,LoadTreeFriend,11380,root/html530/THbookTree.html,https://root.cern,https://root.cern/root/html530/THbookTree.html,3,['Load'],['LoadTreeFriend']
Performance,"::GetW(); virtual Double_tTTree::GetWeight() const; Float_t*GetX(); virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitBranches(Long64_t entry); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); char*MakeX(Int_t nvars); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THbookTree.html:11799,Load,LoadTreeFriend,11799,root/html602/THbookTree.html,https://root.cern,https://root.cern/root/html602/THbookTree.html,2,['Load'],['LoadTreeFriend']
Performance,"::GetXwho ; (; ); const. inline . Definition at line 301 of file THtml.h. ◆ HaveDot(). Bool_t THtml::HaveDot ; (; ). Check whether dot is available in $PATH or in the directory set by SetDotPath() ; Definition at line 1411 of file THtml.cxx. ◆ HelperDeleted(). void THtml::HelperDeleted ; (; THtml::THelperBase * ; who). Inform the THtml object that one of its helper objects was deleted. ; Called by THtml::HelperBase::~HelperBase(). ; Definition at line 1438 of file THtml.cxx. ◆ IsA(). TClass * THtml::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 426 of file THtml.h. ◆ IsBatch(). Bool_t THtml::IsBatch ; (; ); const. inline . Definition at line 353 of file THtml.h. ◆ IsNamespace(). Bool_t THtml::IsNamespace ; (; const TClass * ; cl). static . Check whether cl is a namespace. ; Definition at line 2202 of file THtml.cxx. ◆ LoadAllLibs(). void THtml::LoadAllLibs ; (; ). static . Load all libraries known to ROOT via the rootmap system. ; Definition at line 2210 of file THtml.cxx. ◆ MakeAll(). void THtml::MakeAll ; (; Bool_t ; force = kFALSE, . const char * ; filter = ""*"", . int ; numthreads = 1 . ). Produce documentation for all the classes specified in the filter (by default ""*"") To process all classes having a name starting with XX, do: html.MakeAll(kFALSE,""XX*""); If force=kFALSE (default), only the classes that have been modified since the previous call to this function will be generated. ; If force=kTRUE, all classes passing the filter will be processed. If numthreads is != -1, use numthreads threads, else decide automatically based on the number of CPUs. ; Definition at line 2226 of file THtml.cxx. ◆ MakeClass() [1/2]. void THtml::MakeClass ; (; const char * ; className, . Bool_t ; force = kFALSE . ). Make HTML files for a single class. ; Input: className - name of the class to process ; Definition at line 2292 of file THtml.cxx. ◆ MakeClass() [2/2]. void THtml::MakeClass ; (; void *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml.html:48669,Load,Load,48669,doc/master/classTHtml.html,https://root.cern,https://root.cern/doc/master/classTHtml.html,2,['Load'],['Load']
Performance,"::HasConnection(const char* signal_name) const; virtual ULong_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTProof::IsDataReady(Long64_t& totalbytes, Long64_t& bytesready); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTProof::IsFolder() const; Bool_tTProof::IsIdle() const; Bool_tTProof::IsLite() const; Bool_tTProof::IsMaster() const; Bool_tTObject::IsOnHeap() const; Bool_tTProof::IsParallel() const; Bool_tTProof::IsProofd() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTProof::IsValid() const; Bool_tTProof::IsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tTProof::Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidTProof::LogMessage(const char* msg, Bool_t all)SIGNAL ; static voidTProof::LogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*TProof::Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static TProof*TProof::Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator dele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:10995,Load,Load,10995,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,2,['Load'],['Load']
Performance,"::HasConnection(const char* signal_name) const; virtual ULong_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTProof::IsDataReady(Long64_t& totalbytes, Long64_t& bytesready); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTProof::IsFolder() const; Bool_tTProof::IsIdle() const; Bool_tTProof::IsLite() const; Bool_tTProof::IsMaster() const; Bool_tTObject::IsOnHeap() const; Bool_tTProof::IsParallel() const; Bool_tTProof::IsProofd() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTProof::IsValid() const; Bool_tTProof::IsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tTProof::Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidTProof::LogMessage(const char* msg, Bool_t all)SIGNAL ; static voidTProof::LogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*TProof::Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static TProof*TProof::Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:11060,Load,Load,11060,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,4,['Load'],['Load']
Performance,"::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingMacro() const; virtual Bool_tIsFolder() const; Bool_tIsInterrupted() const; Bool_tIsLineProcessing() const; virtual Bool_tTDirectory::IsModified() const; Bool_tTObject::IsOnHeap() const; Bool_tIsProofServ() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectory::IsWritable() const; Bool_tTObject::IsZombie() const; TClass*LoadClass(const char* name, Bool_t silent = kFALSE) const; Int_tLoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Int_tLoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); virtual voidls(Option_t* option = """") const; Long_tMacro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); TCanvas*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:10065,Load,LoadClass,10065,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['Load'],['LoadClass']
Performance,"::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingMacro() const; virtual Bool_tIsFolder() const; Bool_tIsInterrupted() const; Bool_tIsLineProcessing() const; virtual Bool_tTDirectory::IsModified() const; Bool_tTObject::IsOnHeap() const; Bool_tIsProofServ() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectory::IsWritable() const; Bool_tTObject::IsZombie() const; TClass*LoadClass(const char* name, Bool_t silent = kFALSE) const; Int_tLoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Int_tLoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); virtual voidls(Option_t* option = """") const; Long_tMacro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); TCanvas*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:10123,Load,LoadClass,10123,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['Load'],['LoadClass']
Performance,"::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double * x , const double * p, double * grad ). Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double * x, const double * p, unsigned int ipar = 0). Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(double x, const double* p, unsigned int ipar) const. void ParameterGradient(const double * x , double * grad ). Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double * x, unsigned int ipar = 0). Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x , const double * p, double * grad ). Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double * p, unsigned int ipar = 0). Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0). Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionOneDim.html:3391,cache,cached,3391,root/html526/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionOneDim.html,2,['cache'],['cached']
Performance,"::IParametricGradFunctionMultiDimTempl< T >;  ~IParametricGradFunctionMultiDimTempl () override;  Virtual Destructor (no operations) ;  ; virtual bool HasParameterHessian () const;  ; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  ; T ParameterDerivative (const T *x, const double *p, unsigned int ipar=0) const;  Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ;  ; T ParameterDerivative (const T *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; virtual bool ParameterG2 (const T *, const double *, T *) const;  Evaluate all the second derivatives (diagonal ones) of the function with respect to the parameters at a point x. ;  ; virtual void ParameterGradient (const T *x, const double *p, T *grad) const;  Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (const T *x, T *grad) const;  Evaluate all derivatives using cached parameter values. ;  ; virtual bool ParameterHessian (const T *, const double *, T *) const;  Evaluate the all the Hessian (second derivatives matrix) of the function with respect to the parameters at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html:4184,cache,cached,4184,doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html,1,['cache'],['cached']
Performance,"::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNtuple.html:12313,Optimiz,OptimizeBaskets,12313,root/html530/TNtuple.html,https://root.cern,https://root.cern/root/html530/TNtuple.html,6,['Optimiz'],['OptimizeBaskets']
Performance,"::IsATClass * IsA() const overrideDefinition TClass.h:618; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TPyClassGeneratorDefinition TPyClassGenerator.h:18; TPyReturnDefinition TPyReturn.h:30; TPythonAccessing the Python interpreter from C++.Definition TPython.h:44; TPython::ExecScriptstatic void ExecScript(const char *name, int argc=0, const char **argv=nullptr)Execute a python stand-alone script, with argv CLI arguments.Definition TPython.cxx:381; TPython::Importstatic Bool_t Import(const char *name)Import the named python module and create Cling equivalents for its classes and methods.Definition TPython.cxx:237; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TPython::Execstatic Bool_t Exec(const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"")Executes a Python command within the current Python environment.Definition TPython.cxx:425; TPython::Evalstatic const TPyReturn Eval(const char *expr) R__DEPRECATED(6Evaluate a python expression (e.g.Definition TPython.cxx:465; TPython::Initializestatic Bool_t Initialize()Initialization method: setup the python interpreter and load the ROOT module.Definition TPython.cxx:137; bool; CPyCppyy::Instance_CheckExactCPYCPPYY_EXTERN bool Instance_CheckExact(PyObject *pyobject)Definition API.cxx:177; CPyCppyy::Overload_CheckCPYCPPYY_EXTERN bool Overload_Check(PyObject *pyobject)Definition API.cxx:236; CPyCppyy::Overload_CheckExactCPYCPPYY_EXTERN bool Overload_CheckExact(PyObject *pyobject)Definition API.cxx:247; CPyCppyy::ImportCPYCPPYY_EXTERN bool Import(const std::string ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:23613,Load,LoadMacrostatic,23613,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,2,['Load'],"['LoadMacro', 'LoadMacrostatic']"
Performance,"::IsClassStructOrUnionbool IsClassStructOrUnion() constDefinition TClass.h:354; TClass::kHasLocalHashMember@ kHasLocalHashMemberDefinition TClass.h:96; TClass::kHasNameMapNode@ kHasNameMapNodeDefinition TClass.h:105; TClass::kIgnoreTObjectStreamer@ kIgnoreTObjectStreamerDefinition TClass.h:97; TClass::kUnloaded@ kUnloadedDefinition TClass.h:98; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; TClass::fUsingDatastd::atomic< TListOfDataMembers * > fUsingDataDefinition TClass.h:203; TClass::GetMethodListTListOfFunctions * GetMethodList()Return (create an empty one if needed) the list of functions.Definition TClass.cxx:4355; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4243; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6779; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClonesArray::Classstatic TClass * Class(); TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::Classstatic TClass * Class(); TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:344083,load,load,344083,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"::IsClassStructOrUnionbool IsClassStructOrUnion() constDefinition TClass.h:354; TClass::kHasLocalHashMember@ kHasLocalHashMemberDefinition TClass.h:96; TClass::kHasNameMapNode@ kHasNameMapNodeDefinition TClass.h:105; TClass::kIgnoreTObjectStreamer@ kIgnoreTObjectStreamerDefinition TClass.h:97; TClass::kUnloaded@ kUnloadedDefinition TClass.h:98; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; TClass::fUsingDatastd::atomic< TListOfDataMembers * > fUsingDataDefinition TClass.h:203; TClass::GetMethodListTListOfFunctions * GetMethodList()Return (create an empty one if needed) the list of functions.Definition TClass.cxx:4422; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4310; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5868; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClonesArray::Classstatic TClass * Class(); TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::Classstatic TClass * Class(); TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:346721,load,load,346721,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"::IsInterrupted ; (; ); const. inline . Definition at line 282 of file TROOT.h. ◆ IsLineProcessing(). Bool_t TROOT::IsLineProcessing ; (; ); const. inline . Definition at line 284 of file TROOT.h. ◆ IsProofServ(). Bool_t TROOT::IsProofServ ; (; ); const. inline . Definition at line 285 of file TROOT.h. ◆ IsRootFile(). Bool_t TROOT::IsRootFile ; (; const char * ; filename); const. Return true if the file is local and is (likely) to be a ROOT file. ; Definition at line 2230 of file TROOT.cxx. ◆ IsWebDisplay(). Bool_t TROOT::IsWebDisplay ; (; ); const. inline . Definition at line 287 of file TROOT.h. ◆ IsWebDisplayBatch(). Bool_t TROOT::IsWebDisplayBatch ; (; ); const. inline . Definition at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:66297,load,load,66297,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['load'],['load']
Performance,::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MinuitFitter.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MinuitFitter.html:7818,perform,performs,7818,root/html532/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html532/TMVA__MinuitFitter.html,2,['perform'],['performs']
Performance,"::MakeZombie(). private:. TBaseClass(const TBaseClass&); TBaseClass&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClass*fClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TBaseClass.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBaseClass.html:6439,load,load,6439,root/html526/TBaseClass.html,https://root.cern,https://root.cern/root/html526/TBaseClass.html,1,['load'],['load']
Performance,"::MethodCFMlpANNMethodCFMlpANN(const TMVA::MethodCFMlpANN&); TMVA::MethodCFMlpANNMethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodCFMlpANNMethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodCFMlpANN&operator=(const TMVA::MethodCFMlpANN&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html:11272,Optimiz,OptimizeTuningParameters,11272,root/html602/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMappedCategory&operator=(const RooMappedCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:11238,optimiz,optimizeCacheMode,11238,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"::PaintPaveArc ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2, . Int_t ; bordersize = 4, . Option_t * ; option = ""br"" . ). virtual . Draw this pave with rounded corners. ; Definition at line 414 of file TPave.cxx. ◆ Print(). void TPave::Print ; (; Option_t * ; option = """"); const. overridevirtual . Dump this pave with its attributes. ; Reimplemented from TBox.; Reimplemented in TPaveText.; Definition at line 616 of file TPave.cxx. ◆ SavePrimitive(). void TPave::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save primitive as a C++ statement(s) on output stream out. ; Reimplemented from TBox.; Reimplemented in TPaveClass, TPaveLabel, TPaveStats, TPavesText, and TPaveText.; Definition at line 624 of file TPave.cxx. ◆ SetBorderSize(). virtual void TPave::SetBorderSize ; (; Int_t ; bordersize = 4). inlinevirtual . Sets the border size of the TPave box and shadow. ; Parameters. bordersize0: disable shadow and box, 1: disable only shadow, 2+: tunes the shadow border size . Definition at line 77 of file TPave.h. ◆ SetCornerRadius(). virtual void TPave::SetCornerRadius ; (; Double_t ; rad = 0.2). inlinevirtual . Definition at line 78 of file TPave.h. ◆ SetName(). virtual void TPave::SetName ; (; const char * ; name = """"). inlinevirtual . Definition at line 79 of file TPave.h. ◆ SetOption(). virtual void TPave::SetOption ; (; Option_t * ; option = ""br""). inlinevirtual . Definition at line 80 of file TPave.h. ◆ SetShadowColor(). virtual void TPave::SetShadowColor ; (; Int_t ; color). inlinevirtual . Definition at line 81 of file TPave.h. ◆ SetX1(). void TPave::SetX1 ; (; Double_t ; x1). overridevirtual . Set the X1 value. ; Reimplemented from TBox.; Definition at line 653 of file TPave.cxx. ◆ SetX1NDC(). virtual void TPave::SetX1NDC ; (; Double_t ; x1). inlinevirtual . Definition at line 82 of file TPave.h. ◆ SetX2(). void TPave::SetX2 ; (; Double_t ; x2). overridevirtual . Set the X2 value. ; Reimplemented fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPave.html:28055,tune,tunes,28055,doc/master/classTPave.html,https://root.cern,https://root.cern/doc/master/classTPave.html,1,['tune'],['tunes']
Performance,"::Register ; (; RDFInternal::RVariationBase * ; varPtr). Definition at line 995 of file RLoopManager.cxx. ◆ Register() [4/5]. void RLoopManager::Register ; (; RFilterBase * ; filterPtr). Definition at line 959 of file RLoopManager.cxx. ◆ Register() [5/5]. void RLoopManager::Register ; (; RRangeBase * ; rangePtr). Definition at line 974 of file RLoopManager.cxx. ◆ RegisterCallback(). void RLoopManager::RegisterCallback ; (; ULong64_t ; everyNEvents, . std::function< void(unsigned int)> && ; f . ). Definition at line 1033 of file RLoopManager.cxx. ◆ Report(). void RLoopManager::Report ; (; ROOT::RDF::RCutFlowReport & ; rep); const. finalvirtual . Call FillReport on all booked filters. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 1012 of file RLoopManager.cxx. ◆ Run(). void RLoopManager::Run ; (; bool ; jit = true). Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source. ; Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...). The jitting phase is skipped if the jit parameter is false (unsafe, use with care). ; Definition at line 889 of file RLoopManager.cxx. ◆ RunAndCheckFilters(). void RLoopManager::RunAndCheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). private . Execute actions and make sure named filters are called for each event. ; Named filters must be called even if the analysis logic would not require it, lest they report confusing results. ; Definition at line 708 of file RLoopManager.cxx. ◆ RunDataSource(). void RLoopManager::RunDataSource ; (; ). private . Run event loop over data accessed through a DataSource, in sequence. ; Definition at line 635 of file RLoopManager.cxx. ◆ RunDataSourceMT(). void RLoopManager::RunDataSourceMT ; (; ). private . Run event loop over data accessed through a DataSource, in parallel. ; Definition at line 666 of file RLoopManager.cxx. ◆ RunEmptySource(). void RLoopManager::RunEmptySource ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:23847,perform,perform,23847,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['perform'],['perform']
Performance,::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:25370,cache,cached,25370,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['cache'],['cached']
Performance,::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:25038,cache,cached,25038,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['cache'],['cached']
Performance,"::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2571 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2613 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2441 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2640 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """" (default): both the file names of the chain ele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:96823,cache,cachesize,96823,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['cache'],"['cache', 'cachesize']"
Performance,"::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2597 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2639 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2666 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:97377,cache,cachesize,97377,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,2,['cache'],"['cache', 'cachesize']"
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html:13647,tune,tuneParameters,13647,root/html602/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html,2,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDERS.html:13560,tune,tuneParameters,13560,root/html602/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDERS.html,2,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodRuleFit.html:12972,tune,tuneParameters,12972,root/html602/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodRuleFit.html,2,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBayesClassifier.html:12270,tune,tuneParameters,12270,root/html602/TMVA__MethodBayesClassifier.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBayesClassifier.html,20,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); voidTrainMonoTargetRegression(); voidTrainMultiClassification(); voidTrainMultiTargetRegression(); voidTrainSeparatedClassification(); voidTrainUnifiedClassification",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDEFoam.html:12971,tune,tuneParameters,12971,root/html602/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDEFoam.html,2,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCFMlpANN.html:13006,tune,tuneParameters,13006,root/html534/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCFMlpANN.html,1,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodPDERS.html:12933,tune,tuneParameters,12933,root/html534/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodPDERS.html,1,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodRuleFit.html:12336,tune,tuneParameters,12336,root/html534/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodRuleFit.html,1,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBayesClassifier.html:11594,tune,tuneParameters,11594,root/html534/TMVA__MethodBayesClassifier.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBayesClassifier.html,10,['tune'],['tuneParameters']
Performance,"::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); voidTrainMonoTargetRegression(); voidTrainMultiClassification(); voidTrainMultiTargetRegression(); voidTrainSeparatedClassification(); voidTrainUnifiedClassification(); TMVA::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodPDEFoam.html:12334,tune,tuneParameters,12334,root/html534/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodPDEFoam.html,1,['tune'],['tuneParameters']
Performance,"::SetBatchSize ; (; Scalar_t ; rate). inline . Definition at line 156 of file DLMinimizers.h. ◆ SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetConvergenceSteps ; (; size_t ; steps). inline . Setters. ; Definition at line 153 of file DLMinimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 155 of file DLMinimizers.h. ◆ SetTestInterval(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetTestInterval ; (; size_t ; interval). inline . Definition at line 154 of file DLMinimizers.h. ◆ Step() [1/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 182 of file DLMinimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; master, . std::vector< DeepNet_t > & ; nets, . std::vector< TTensorBatch< Architecture_t > > & ; batches . ). Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 246 of file DLMinimizers.h. ◆ StepLoss(). template<typename Architecture_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:8034,Perform,Perform,8034,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,"::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:49725,cache,cache,49725,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:49795,cache,cache,49795,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"::SetIsInCache ; (; Int_t ; basketNumber). inline . Mark if the basket is currently in the cache. ; Definition at line 89 of file TBranchCacheInfo.h. ◆ SetState(). void ROOT::Internal::TBranchCacheInfo::SetState ; (; Int_t ; basketNumber, . EStates ; what . ). inlineprivate . Mark if the basket has been marked has the 'what' state. ; Definition at line 68 of file TBranchCacheInfo.h. ◆ SetUsed(). void ROOT::Internal::TBranchCacheInfo::SetUsed ; (; Int_t ; basketNumber). inline . Mark if the basket has been marked as 'used'. ; Definition at line 79 of file TBranchCacheInfo.h. ◆ TestState(). bool ROOT::Internal::TBranchCacheInfo::TestState ; (; Int_t ; basketNumber, . EStates ; what . ); const. inlineprivate . Return true if the basket has been marked as having the 'what' state. ; Definition at line 60 of file TBranchCacheInfo.h. ◆ UpdatePedestal(). void ROOT::Internal::TBranchCacheInfo::UpdatePedestal ; (; Int_t ; basketNumber). inlineprivate . Update the pedestal to be less or equal to basketNumber, shift the bits if needed. ; Definition at line 48 of file TBranchCacheInfo.h. ◆ Veto(). void ROOT::Internal::TBranchCacheInfo::Veto ; (; Int_t ; basketNumber). inline . Mark if the basket should be vetoed in the next round. ; This happens when the basket was loaded in the previous round and was not used and is overlapping to the next round/cluster ; Definition at line 98 of file TBranchCacheInfo.h. Member Data Documentation. ◆ fBasketPedestal. Int_t ROOT::Internal::TBranchCacheInfo::fBasketPedestal {-1}. private . Definition at line 44 of file TBranchCacheInfo.h. ◆ fInfo. TBits ROOT::Internal::TBranchCacheInfo::fInfo. private . Definition at line 45 of file TBranchCacheInfo.h. Libraries for ROOT::Internal::TBranchCacheInfo:. [legend]; The documentation for this class was generated from the following file:; tree/tree/inc/TBranchCacheInfo.h. ROOTInternalTBranchCacheInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html:4914,load,loaded,4914,doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchCacheInfo.html,1,['load'],['loaded']
Performance,"::SetWeight); Long64_tfZipBytesTotal number of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:33369,cache,cache,33369,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['cache'],['cache']
Performance,"::ShowPeaks(Double_t sigma, Option_t *option, Double_t threshold); 2696{; 2697 ; 2698 return (Int_t)gROOT->ProcessLineFast(TString::Format(""TSpectrum2::StaticSearch((TH1*)0x%zx,%g,\""%s\"",%g)"",; 2699 (size_t)this, sigma, option, threshold).Data());; 2700}; 2701 ; 2702 ; 2703////////////////////////////////////////////////////////////////////////////////; 2704/// Smooth bin contents of this 2-d histogram using kernel algorithms; 2705/// similar to the ones used in the raster graphics community.; 2706/// Bin contents in the active range are replaced by their smooth values.; 2707/// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; 2708/// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; 2709/// normalization accordingly.; 2710/// If Errors are defined via Sumw2, they are also scaled and computed.; 2711/// However, note the resulting errors will be correlated between different-bins, so; 2712/// the errors should not be used blindly to perform any calculation involving several bins,; 2713/// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; 2714///; 2715/// 3 kernels are proposed k5a, k5b and k3a.; 2716/// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); 2717/// k5b is a bit more stronger in smoothing; 2718/// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; 2719/// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; 2720/// via the option argument.; 2721/// If TAxis::SetRange has been called on the x or/and y axis, only the bins; 2722/// in the specified range are smoothed.; 2723/// In the current implementation if the first argument is not used (default value=1).; 2724///; 2725/// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun; 2726 ; 2727void TH2::Smooth(Int_t ntimes, Option_t *option); 2728{; 2729 Double_t k5a[5][5] = { { 0, 0, 1, 0, 0 },; 2730 { 0, 2, 2, 2, 0 },",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:111221,perform,perform,111221,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['perform'],['perform']
Performance,"::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Int_t_nCat; Int_t_nEntries; Int_t_nReal; Int_t_nRealF; vector<RealVector*>_realStoreList; vector<RealFullVector*>_realfStoreList; Double_t_sumWeight; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooVectorDataStore(). RooVectorDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). void setAllBuffersNative(). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName); Utility function for cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:10480,Optimiz,Optimization,10480,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,3,"['Cache', 'Optimiz', 'cache']","['Cache', 'Optimization', 'cache']"
Performance,::TActionSequence;; 63 ; 64public:; 65 // make the opaque pointer public.; 66 typedef TCompInfo TCompInfo_t;; 67 ; 68protected:; 69 //---------------------------------------------------------------------------; 70 // Adapter class used to handle streaming collection of pointers; 71 //---------------------------------------------------------------------------; 72 class TPointerCollectionAdapter; 73 {; 74 public:; 75 TPointerCollectionAdapter( TVirtualCollectionProxy *proxy ):; 76 fProxy( proxy ) {}; 77 ; 78 char* operator[]( UInt_t idx ) const; 79 {; 80 char **el = (char**)fProxy->At(idx);; 81 return *el;; 82 }; 83 private:; 84 TVirtualCollectionProxy *fProxy;; 85 };; 86 ; 87private:; 88 UInt_t fCheckSum; ///<Checksum of original class; 89 Int_t fClassVersion; ///<Class version identifier; 90 Int_t fOnFileClassVersion;///<!Class version identifier as stored on file.; 91 Int_t fNumber; ///<!Unique identifier; 92 Int_t fSize; ///<!size of the persistent class; 93 Int_t fNdata; ///<!number of optimized elements; 94 Int_t fNfulldata; ///<!number of elements; 95 Int_t fNslots; ///<!total number of slots in fComp.; 96 TCompInfo *fComp; ///<![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; 97 TCompInfo **fCompOpt; ///<![fNdata]; 98 TCompInfo **fCompFull; ///<![fElements->GetEntries()]; 99 TClass *fClass; ///<!pointer to class; 100 TObjArray *fElements; ///<Array of TStreamerElements; 101 Version_t fOldVersion; ///<! Version of the TStreamerInfo object read from the file; 102 Int_t fNVirtualInfoLoc; ///<! Number of virtual info location to update.; 103 ULong_t *fVirtualInfoLoc; ///<![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated); 104 TStreamerInfoActions::TActionSequence *fReadObjectWise; ///<! List of read action resulting from the compilation.; 105 TStreamerInfoActions::TActionSequence *fReadMemberWise; ///<! List of read action resulting from the compilation for use in member wise streaming.; 106 TS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:3086,optimiz,optimized,3086,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['optimiz'],['optimized']
Performance,"::ToLower(); voidTString::ToUpper(); static TStringTString::UItoa(UInt_t value, Int_t base); static TStringTString::ULLtoa(ULong64_t value, Int_t base); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. static TString::EStripTypeTString::kBoth; static TString::ECaseCompareTString::kExact; static TString::ECaseCompareTString::kIgnoreCase; static TString::EStripTypeTString::kLeading; static const Ssiz_tTString::kNPOS; static TString::EStripTypeTString::kTrailing. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache); TString::Rep_tTString::fRep! String data; static TString::(anonymous)TString::kAlignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:51; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGHotString.html:9016,cache,cache,9016,root/html604/TGHotString.html,https://root.cern,https://root.cern/root/html604/TGHotString.html,2,['cache'],['cache']
Performance,"::ToLower(); voidTString::ToUpper(); static TStringTString::UItoa(UInt_t value, Int_t base); static TStringTString::ULLtoa(ULong64_t value, Int_t base); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. static TString::EStripTypeTString::kBoth; static TString::ECaseCompareTString::kExact; static TString::ECaseCompareTString::kIgnoreCase; static TString::EStripTypeTString::kLeading; static const Ssiz_tTString::kNPOS; static TString::EStripTypeTString::kTrailing. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache); TString::Rep_tTString::fRep! String data; static TString::(anonymous)TString::kAlignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHotString.html:8960,cache,cache,8960,root/html602/TGHotString.html,https://root.cern,https://root.cern/root/html602/TGHotString.html,2,['cache'],['cache']
Performance,"::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfCPUParList of par files to be loaded for CPU benchmarks; TStringfCPUSelSelector to be used for CPU benchmarks; TProofBenchDataSet*fDSInstance to handle datasets operations; TStringfDataGenParList of par files to be loaded to generate data for benchmarks; TStringfDataGenSelSelector to be used for generate data for benchmarks; TStringfDataParList of par files to be loaded for data benchmarks; TStringfDataSelSelector to be used for data benchmarks; TStringfDataSetName of the dataset; Bool_tfDebugDebug switch; TPBHistType*fHistTypeType of histograms for CPU runs; Int_tfNHistNumber of histograms to be created in default CPU runs; Int_tfNtriesNumber of times a measurement is repeated; TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBench.html:6621,load,loaded,6621,root/html530/TProofBench.html,https://root.cern,https://root.cern/root/html530/TProofBench.html,3,['load'],['loaded']
Performance,"::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfArrXArrow X position; Double_tfArrYArrow Y position; GVizAgedge_t*fGVEdgeGraphviz edge; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_t*fNnumber of edge points (GV); TGraphNode*fNode1First node; TGraphNode*fNode2Second node; Double_t*fXX edge points (GV); Double_t*fYX edge points (GV). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphEdge(); Graph Edge default constructor. TGraphEdge(TGraphNode* n1, TGraphNode* n2); Graph Edge normal constructor. ~TGraphEdge(); Graph Edge default destructor. void CreateGVEdge(GVizAgraph_t* gv); Create the GraphViz edge into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an edge. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this edge in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this edge with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& , const char* ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& ). TGraphEdge(). void SetGVEdge(GVizAgedge_t* gve); {fGVEdge = gve;}. GVizAgedge_t * GetGVEdge(); {return fGVEdge;}. TGraphNode * GetNode1(); {return fNode1;}. TGraphNode * GetNode2(); {return fNode2;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphEdge.html:7157,perform,performed,7157,root/html534/TGraphEdge.html,https://root.cern,https://root.cern/root/html534/TGraphEdge.html,1,['perform'],['performed']
Performance,"::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Preven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:41880,cache,cache,41880,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,1,['cache'],['cache']
Performance,"::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooListProxy_gamma; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistConstraint.html:40010,cache,cache,40010,root/html534/RooHistConstraint.html,https://root.cern,https://root.cern/root/html534/RooHistConstraint.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooArgSet*_curNormSet!; Double_t_cutOffCutoff parameter for running product; RooArgSet_defNormSetDefault normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Int_t_extendedIndexIndex of extended PDF (if any); Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAICRegistry_genCode! Registry of composite direct generator codes; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:45418,cache,cache,45418,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:35608,cache,cache,35608,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,2,['cache'],['cache']
Performance,::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of observables mapped onto histogram observables; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:33809,cache,cache,33809,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_highIter! Iterator over highSet; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TIterator*_lowIter! Iterator over lowSet; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; RooRealProxy_nominalThe nominal value; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPd,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:31488,cache,cache,31488,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:36320,cache,cache,36320,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNonCPEigenDecay.html:43163,cache,cache,43163,root/html534/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html534/RooNonCPEigenDecay.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:38053,cache,cache,38053,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,1,['cache'],['cache']
Performance,::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMomentMorph.html:38435,cache,cache,38435,root/html528/RooMomentMorph.html,https://root.cern,https://root.cern/root/html528/RooMomentMorph.html,1,['cache'],['cache']
Performance,::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Settin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMomentMorph.html:38904,cache,cache,38904,root/html530/RooMomentMorph.html,https://root.cern,https://root.cern/root/html530/RooMomentMorph.html,1,['cache'],['cache']
Performance,::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Se,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMomentMorph.html:39307,cache,cache,39307,root/html532/RooMomentMorph.html,https://root.cern,https://root.cern/root/html532/RooMomentMorph.html,1,['cache'],['cache']
Performance,"::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindOffset.html:32677,cache,cache,32677,root/html526/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html526/RooUnblindOffset.html,4,['cache'],['cache']
Performance,"::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdf. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendedBinding(const char* name, const char* title, RooAbsPdf& _pdf). RooExtendedBinding(const RooExtendedBinding& other, const char* name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExtendedBinding.html:34419,cache,cache,34419,root/html534/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html534/RooExtendedBinding.html,2,['cache'],['cache']
Performance,"::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useWindowSwitch to activate window convolution; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Int_t_verboseThreshCall count threshold for verbose printing; RooListProxy_windowParamHolder for optional convolution integration window scaling parameter; Double_t_windowScaleScale factor for window parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:35279,cache,cache,35279,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,2,['cache'],['cache']
Performance,"::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_double_int_.html:35232,cache,cache,35232,root/html534/RooCFunction2Binding_double_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_double_int_.html,2,['cache'],['cache']
Performance,"::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_int_double_.html:35232,cache,cache,35232,root/html534/RooCFunction2Binding_double_int_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_int_double_.html,2,['cache'],['cache']
Performance,"::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstraintSum(); Default constructor. RooConstraintSum(const char* name, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:36338,cache,cache,36338,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,4,['cache'],['cache']
Performance,"::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets ; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:38902,cache,cache,38902,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,2,['cache'],['cache']
Performance,"::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; map<pair<string,int>,BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_t>_sigma; Double_t_sigmaAvgR; TVectorD*_sigmaR; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Double_t_sqrt2pi; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNDKeysPdf.html:41662,cache,cache,41662,root/html530/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html530/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,"::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProdPdf.html:42877,cache,cache,42877,root/html530/RooProdPdf.html,https://root.cern,https://root.cern/root/html530/RooProdPdf.html,1,['cache'],['cache']
Performance,"::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:41126,cache,cache,41126,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,20,['cache'],['cache']
Performance,"::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDecay.html:41571,cache,cache,41571,root/html530/RooDecay.html,https://root.cern,https://root.cern/root/html530/RooDecay.html,2,['cache'],['cache']
Performance,"::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddModel.html:42063,cache,cache,42063,root/html530/RooAddModel.html,https://root.cern,https://root.cern/root/html530/RooAddModel.html,1,['cache'],['cache']
Performance,"::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const char* name, const char* title, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const char* name, const char* title, RooAbsReal& pdfConvVar, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const RooFFTConvPdf& other, const char* name = 0); Copy constructor. ~RooFFTConvPdf(); Destructor. const char* inputBaseName() const; Return base name component for cache components in this case 'PDF1_CONV_PDF2'. TString histNameSuffix() const; Suffix for cache histogram (added in addition to suffix for cache name). void fillCacheObject(RooAbsCachedPdf::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:52350,cache,cache,52350,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['cache'],['cache']
Performance,"::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const char* name, const char* title, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const char* name, const char* title, RooAbsReal& pdfConvVar, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const RooFFTConvPdf& other, const char* name = 0); Copy constructor. ~RooFFTConvPdf(); Destructor. const char* inputBaseName() const; Return base name component for cache components in this case 'PDF1_CONV_PDF2'. TString histNameSuffix() const; Suffix for cache histogram (added in addition to suffix for cache name). void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the contents of the cache the FFT convolution output. void fillCacheSlice(RooFFTConvPdf::FFTCacheElem& cache, const RooArgSet& slicePosition) const; Fill a slice of cachePdf with the output of the FFT convolution calculation. Double_t* scanPdf(RooRealVar& obs, RooAbsPdf& pdf, const RooDataHist& hist, const RooArgSet& slicePos, Int_t& N, Int_t& N2, Int_t& zeroBin, Double_t shift) const; Scan the values of 'pdf' in ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:47197,cache,cache,47197,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['cache'],['cache']
Performance,"::accumulate(std::begin(fSum), std::end(fSum), 0.);; 242 }; 243 ; 244 /// \return Compensated sum.; 245 T Result() const {; 246 return Sum();; 247 }; 248 ; 249 /// \return The sum used for compensation.; 250 T Carry() const {; 251 return std::accumulate(std::begin(fCarry), std::end(fCarry), 0.);; 252 }; 253 ; 254 /// Add `arg` into accumulator. Does not vectorise.; 255 KahanSum<T, N>& operator+=(T arg) {; 256 Add(arg);; 257 return *this;; 258 }; 259 ; 260 /// Add other KahanSum into accumulator. Does not vectorise.; 261 ///; 262 /// Based on KahanIncrement from:; 263 /// Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12.; 264 /// Note that while Tian et al. add the carry in the first step, we subtract; 265 /// the carry, in accordance with the Add(Indexed) implementation(s) above.; 266 /// This is purely an implementation choice that has no impact on performance.; 267 ///; 268 /// \note Take care when using += (and -=) to add other KahanSums into a zero-initialized; 269 /// KahanSum. The operator behaves correctly in this case, but the result may be slightly; 270 /// off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum; 271 /// and x another KahanSum). In particular, x's carry term may get lost. This doesn't; 272 /// just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry; 273 /// test case in the testKahan unittest for other examples. This behavior is internally; 274 /// consistent: the carry also gets lost if you switch the operands and it also happens with; 275 /// other KahanSum operators.; 276 template<typename U, unsigned int M>; 277 KahanSum<T, N>& operator+=(const KahanSum<U, M>& other) {; 278 U corrected_arg_sum = other.Sum() - (fCarry[0] + other.Carry());; 279 U sum = fSum[0] + corrected_arg_sum;; 280 U correction = (sum - fSum[0]) - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:10462,perform,performance,10462,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['perform'],['performance']
Performance,"::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:2212,cache,cacheUniqueSuffix,2212,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['cache'],['cacheUniqueSuffix']
Performance,"::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tRooAbsMoment::central() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:2063,Cache,CacheModeRooAbsArg,2063,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,6,['Cache'],['CacheModeRooAbsArg']
Performance,"::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tcentral() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:2182,Cache,CacheModeRooAbsArg,2182,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DMomentMorphFunction.html:1931,Cache,CacheModeRooAbsArg,1931,root/html602/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo1DMomentMorphFunction.html,96,['Cache'],['CacheModeRooAbsArg']
Performance,"::customEvent(QEvent*); voidQObject::destroyed(QObject* = 0); virtual voidQObject::disconnectNotify(const char* signal); voidError(int error); intQObject::receivers(const char* signal) const; QObject*QObject::sender() const; intQObject::senderSignalIndex() const; virtual voidQObject::timerEvent(QTimerEvent*); TQtRootSlot(). private:. voidoperator=(const TQtRootSlot&); static voidqt_static_metacall(QObject*, QMetaObject::Call, int, void**); TQtRootSlot(const TQtRootSlot&). Data Members; public:. static const QMetaObjectstaticMetaObject; static const QMetaObjectQObject::staticMetaObject. protected:. QScopedPointer<QObjectData>QObject::d_ptr; static TQtRootSlot*fgTQtRootSlot; static const QMetaObjectQObject::staticQtMetaObject. private:. static const QMetaObjectExtraDatastaticMetaObjectExtraData. Class Charts. Inheritance Chart:. QObject. ←; TQtRootSlot. Function documentation; TQtRootSlot * CintSlot(); create and return the singleton. void EndOfLine(); slot to perform the standard ""EndOfLine"" ROOT action; it used to update the current gPad. void ProcessLine(const QString& ); execute the arbitrary ROOT /CINt command via; CINT C++ interpreter and emit the result. void ProcessLine(const char* ); execute the arbitrary ROOT /CINt command via; CINT C++ interpreter and emit the result. void Terminate(int status) const; the dedicated slot to terminate the ROOT application; with ""status"". void Terminate() const; the dedicated slot to terminate the ROOT application; and return the ""0"" status. void TerminateAndQuit() const; the dedicated slot to terminate the ROOT application; and quit the Qt Application if any. TQtRootSlot(const TQtRootSlot& ). void operator=(const TQtRootSlot& ). TQtRootSlot(); {}. virtual ~TQtRootSlot(); {}. void Error(int error). » Author: Valery Fine 18/01/2007 » Copyright (C) 2007 by Valeri Fine. Brookhaven National Laboratory.; » Last changed: root/qt:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or sugg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtRootSlot.html:4037,perform,perform,4037,root/html602/TQtRootSlot.html,https://root.cern,https://root.cern/root/html602/TQtRootSlot.html,1,['perform'],['perform']
Performance,"::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TUrlTNetFile::fEndpointUrlURL of realfile (after possible redirection); Int_tTNetFile::fErrorCodeerror code returned by rootd (matching gRootdErrStr); TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tTNetFile::fNetoptinitial network options (used for ReOpen()); Bool_tTFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXNetFile.html:20846,Cache,Cached,20846,root/html534/TXNetFile.html,https://root.cern,https://root.cern/root/html534/TXNetFile.html,1,['Cache'],['Cached']
Performance,"::fCanDeleteRefsbool fCanDeleteRefs! If true, TProcessIDs are deleted when closing a fileDefinition TChain.h:40; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t *opt="""") overrideSet the input entry list (processing the entries of the chain will then be limited to the entries in ...Definition TChain.cxx:2703; TChain::fNtreesInt_t fNtreesNumber of trees.Definition TChain.h:37; TChain::AddFriendTFriendElement * AddFriend(const char *chainname, const char *dummy="""") overrideAdd a TFriendElement to the list of friends of this chain.Definition TChain.cxx:682; TChain::DirectoryAutoAddvoid DirectoryAutoAdd(TDirectory *) overrideOverride the TTree::DirectoryAutoAdd behavior: we never auto add.Definition TChain.cxx:804; TChain::GetListOfFilesTObjArray * GetListOfFiles() constDefinition TChain.h:111; TChain::FillInt_t Fill() overrideFill all branches.Definition TChain.h:91; TChain::~TChain~TChain() overrideDestructor.Definition TChain.cxx:173; TChain::LoadBasketsInt_t LoadBaskets(Long64_t maxmemory) overrideDummy function.Definition TChain.cxx:1296; TChain::SetMakeClassvoid SetMakeClass(Int_t make) overrideSet all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TChain.h:166; TChain::GetEntriesLong64_t GetEntries(const char *sel) overrideReturn the number of entries matching the selection.Definition TChain.h:101; TChain::GetTreeTTree * GetTree() const overrideDefinition TChain.h:119; TChain::Printvoid Print(Option_t *option="""") const overridePrint the header information of each tree in the chain.Definition TChain.cxx:2242; TChain::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TChain.cxx:2305; TChain::GetAliasconst char * GetAlias(const char *aliasName) const overrideReturns the expanded value of the alias. Search in the friends if any.Definition TChain.cxx:900; TChain::TChainTChain(const TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8h_source.html:14171,Load,LoadBaskets,14171,doc/master/TChain_8h_source.html,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html,1,['Load'],['LoadBaskets']
Performance,"::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; TTreePerfStats::BasketInfo::fMissedUInt_t fMissedNumber of times the basket was read directly from the file.Definition TTreePerfStats.h:45; TTreePerfStats::BasketInfo::fLoadedUInt_t fLoadedNumber of times the basket was put in the primary TTreeCache.Definition TTreePerfStats.h:43; TTreePerfStats::BasketInfo::fLoadedMissUInt_t fLoadedMissNumber of times the basket was put in the secondary cache.Definition TTreePerfStats.h:44; TTreePerfStats::BasketInfo::fUsedUInt_t fUsedNumber of times the basket was requested from the disk.Definition TTreePerfStats.h:42; Drawth1 Draw(). treetreeplayerincTTreePerfStats.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:21928,perform,performance,21928,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['perform'],['performance']
Performance,"::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset used by remote file classes; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:19927,cache,cache,19927,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['cache'],['cache']
Performance,"::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tfUseIndexes! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables; Bool_tfUseSuffixes! use suffixes in column names like fValue:Int_t or fObject:pointer; Int_tfUseTransactions! use transaction statements for writing data into the tables; TStringfUserName! user name, used to access objects from database; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:32550,cache,cache,32550,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,9,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance,"::fgEigenVectors[]; Double_t <classname>::fgMeanValues[]; Double_t <classname>::fgSigmaValues[]; are initialized, and assumed to exist. The class declaration is assumed to be in <classname>.h and assumed to be provided by the user.; See TPrincipal::MakeRealCode for a list of options; The minimal class definition is: class <classname> {; public:; static Int_t fgNVariables;; static Double_t fgEigenVectors[];; static Double_t fgEigenValues[];; static Double_t fgMeanValues[];; static Double_t fgSigmaValues[];; ; void X2P(Double_t *x, Double_t *p);; void P2X(Double_t *p, Double_t *x, Int_t nTest);; };; Whether the methods <classname>::X2P and <classname>::P2X should be static or not, is up to the user. ; Definition at line 871 of file TPrincipal.cxx. ◆ MakeNormalised(). void TPrincipal::MakeNormalised ; (; ). protected . Normalize the covariance matrix. ; Definition at line 809 of file TPrincipal.cxx. ◆ MakePrincipals(). void TPrincipal::MakePrincipals ; (; ). virtual . Perform the principal components analysis. ; This is done in several stages in the TMatrix::EigenVectors method:; Transform the covariance matrix into a tridiagonal matrix.; Find the eigenvalues and vectors of the tridiagonal matrix. . Definition at line 884 of file TPrincipal.cxx. ◆ MakeRealCode(). void TPrincipal::MakeRealCode ; (; const char * ; filename, . const char * ; classname, . Option_t * ; option = """" . ). protected . This is the method that actually generates the code for the transformations to and from feature space and pattern space It's called by TPrincipal::MakeCode and TPrincipal::MakeMethods. ; The options are: NONE so far ; Definition at line 906 of file TPrincipal.cxx. ◆ operator=(). TPrincipal & TPrincipal::operator= ; (; const TPrincipal & ; pr). protected . Assignment operator. ; Definition at line 337 of file TPrincipal.cxx. ◆ P2X(). void TPrincipal::P2X ; (; const Double_t * ; p, . Double_t * ; x, . Int_t ; nTest . ). virtual . Calculate x as a function of nTest of the most signifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPrincipal.html:29957,Perform,Perform,29957,doc/master/classTPrincipal.html,https://root.cern,https://root.cern/doc/master/classTPrincipal.html,1,['Perform'],['Perform']
Performance,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8py.html:5367,cache,cache,5367,doc/master/rf705__linearmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; nset); const. private . Look up projection cache and per-PDF norm sets. ; If a PDF doesn't have a special norm set, use the defaultNorm. If defaultNorm == nullptr, use the member _normSet. ; Definition at line 458 of file RooAddPdf.cxx. ◆ getProjCache(). AddCacheElem * RooAddPdf::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Manager of cache with coefficient projections and transformations. ; Retrieve cache element for the computation of the PDF normalisation.; Parameters. [in]nsetCurrent normalisation set (integration over these variables yields 1). ; [in]isetIntegration set. Variables to be integrated over (if integrations are performed). If a cache element does not exist, create and fill it on the fly. The cache also contains; Supplemental normalization terms (in case not all added p.d.f.s have the same observables); Projection integrals to calculate transformed fraction coefficients when a frozen reference frame is provided; Projection integrals for similar transformations when a frozen reference range is provided. . Definition at line 406 of file RooAddPdf.cxx. ◆ getValV(). double RooAddPdf::getValV ; (; const RooArgSet * ; set = nullptr); const. overrideprotectedvirtual . Calculate and return the current value. ; Reimplemented from RooAbsPdf.; Definition at line 515 of file RooAddPdf.cxx. ◆ IsA(). TClass * RooAddPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 153 of file RooAddPdf.h. ◆ isBinnedDistribution(). bool RooAddPdf::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:88690,perform,performed,88690,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,2,['perform'],['performed']
Performance,"::getNormIntegral ; (; const RooArgSet & ; nset); const. inline . Definition at line 255 of file RooAbsPdf.h. ◆ getNormObj(). const RooAbsReal * RooAbsPdf::getNormObj ; (; const RooArgSet * ; set, . const RooArgSet * ; iset, . const TNamed * ; rangeName = nullptr . ); const. virtual . Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ; Definition at line 443 of file RooAbsPdf.cxx. ◆ getValV(). double RooAbsPdf::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Return current value, normalized by integrating over the observables in nset. ; If nset is 0, the unnormalized value is returned. All elements of nset must be lvalues.; Unnormalized values are not cached. Doing so would be complicated as _norm->getVal() could spoil the cache and interfere with returning the cached return value. Since unnormalized calls are typically done in integration calls, there is no performance hit. ; Reimplemented from RooAbsReal.; Reimplemented in RooNormalizedPdf, RooResolutionModel, RooMomentMorph, and RooAddPdf.; Definition at line 319 of file RooAbsPdf.cxx. ◆ initGenerator(). void RooAbsPdf::initGenerator ; (; Int_t ; code). virtual . Interface for one-time initialization to setup the generator for the specified code. ; Reimplemented in RooBCPEffDecay, RooBCPGenDecay, RooBMixDecay, RooNonCPEigenDecay, RooBinSamplingPdf, RooMultiVarGaussian, RooProdPdf, and RooProjectedPdf.; Definition at line 1532 of file RooAbsPdf.cxx. ◆ IsA(). TClass * RooAbsPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1PdfBinding< VO, VI >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3PdfBinding< VO, VI1, VI2, V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:130259,perform,performance,130259,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['performance']
Performance,"::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7937fb0 with pdf gx_CONV_model_mean_CACHE_Obs[mean,x]_NORM_mean for nset (mean) with code 0; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:3657,cache,cache,3657,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,1,['cache'],['cache']
Performance,"::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsDataStore.html:10015,cache,cached,10015,root/html602/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html,4,"['cache', 'load']","['cached', 'loading']"
Performance,"::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MinuitFitter.html:8978,perform,performs,8978,root/html604/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html604/TMVA__MinuitFitter.html,2,['perform'],['performs']
Performance,"::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). MinuitFitter(TMVA::IFitterTarget& target, const TString& name, vector<TMVA::Interval*>& ranges, const TString& theOption). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MinuitFitter.html:8970,perform,performs,8970,root/html602/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html602/TMVA__MinuitFitter.html,2,['perform'],['performs']
Performance,"::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TSlave::EStatusBitskOutputRequested; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TSlave::ESlaveTypekSlave; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tfBytesReadbytes read by slave (info is obtained from slave); Float_tfCpuTimeCPU time spent executing commands (info obtained from slave); TStringfGroupslave's group id; TStringfImageslave's image name; TFileHandler*fInputinput handler related to this slave; TStringfMsdmass storage domain of slave; TStringfNameslave's hostname; TStringfOrdinalslave's ordinal number; Int_tfParallelnumber of active slaves; Int_tfPerfIdxrelative CPU performance index; Int_tfPortslave's port number; TProof*fProofproof cluster to which slave belongs; TStringfProofWorkDirbase proofserv working directory (info obtained from slave); Int_tfProtocolslave's protocol level; TStringfROOTVersROOT version run by worker; Float_tfRealTimereal time spent executing commands (info obtained from slave); TStringfSessionTagunique tag for ths worker process; TSlave::ESlaveTypefSlaveTypetype of slave (either kMaster or kSlave); TSocket*fSocketsocket to slave; Int_tfStatusremote return status; TStringfUserslave's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance Chart:. TObject. ←; TSlave. ←. TSlaveLite. TXSlave. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:8329,perform,performance,8329,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,2,['perform'],['performance']
Performance,"::kZombie. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; Float_tfMergeTimeMerging time (seconds) (millisec precision); TStringTNamed::fNameobject identifier; Int_tfNumMergersNumber of submergers; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfPrepTimePrepare time (seconds) (millisec precision); Float_tfProcTimeProcessing time (seconds) (millisec precision); Float_tfRecvTimeTransfer-to-client time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; Float_tfTermTimeTerminate time (seconds) (millisec precision); TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TQueryResult. ←. TProofQueryResult. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQueryResult.html:8291,load,loaded,8291,root/html604/TQueryResult.html,https://root.cern,https://root.cern/root/html604/TQueryResult.html,2,['load'],['loaded']
Performance,"::map<TString,MVector*> fMethodsMap;//all methods for every dataset with the same name; 86 ; 87 // no default constructor; 88 Factory( TString theJobName, TFile* theTargetFile, TString theOption = """" );; 89 ; 90 // constructor to work without file; 91 Factory( TString theJobName, TString theOption = """" );; 92 ; 93 // default destructor; 94 virtual ~Factory();; 95 ; 96 // use TName::GetName and define correct name in constructor; 97 //virtual const char* GetName() const { return ""Factory""; }; 98 ; 99 ; 100 MethodBase* BookMethod( DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption = """" );; 101 MethodBase* BookMethod( DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption = """" );; 102 MethodBase* BookMethod( DataLoader *, TMVA::Types::EMVA /*theMethod*/,; 103 TString /*methodTitle*/,; 104 TString /*methodOption*/,; 105 TMVA::Types::EMVA /*theComposite*/,; 106 TString /*compositeOption = """"*/ ) { return nullptr; }; 107 ; 108 // optimize all booked methods (well, if desired by the method); 109 std::map<TString,Double_t> OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 110 void OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 111 void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 112 ; 113 // training for all booked methods; 114 void TrainAllMethods ();; 115 void TrainAllMethodsForClassification( void ) { TrainAllMethods(); }; 116 void TrainAllMethodsForRegression ( void ) { TrainAllMethods(); }; 117 ; 118 // testing; 119 void TestAllMethods();; 120 ; 121 // performance evaluation; 122 void EvaluateAllMethods( void );; 123 void EvaluateAllVariables(DataLoader *loader, TString options = """" );; 124 ; 125 TH1F* EvaluateImportance( DataLoader *loader,VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:4064,optimiz,optimize,4064,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['optimiz'],['optimize']
Performance,"::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooJeffreysPrior.html:21425,optimiz,optimizeCacheMode,21425,root/html528/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html528/RooJeffreysPrior.html,2,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooArgusBG&operator=(const RooArgusBG&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgusBG.html:22874,optimiz,optimizeCacheMode,22874,root/html602/RooArgusBG.html,https://root.cern,https://root.cern/root/html602/RooArgusBG.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCBShape&operator=(const RooCBShape&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCBShape.html:22819,optimiz,optimizeCacheMode,22819,root/html602/RooCBShape.html,https://root.cern,https://root.cern/root/html602/RooCBShape.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDstD0BG&operator=(const RooDstD0BG&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDstD0BG.html:22896,optimiz,optimizeCacheMode,22896,root/html602/RooDstD0BG.html,https://root.cern,https://root.cern/root/html602/RooDstD0BG.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooEffProd&operator=(const RooEffProd&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:23284,optimiz,optimizeCacheMode,23284,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistPdf&operator=(const RooHistPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:23077,optimiz,optimizeCacheMode,23077,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooKeysPdf&operator=(const RooKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooKeysPdf.html:23539,optimiz,optimizeCacheMode,23539,root/html602/RooKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooKeysPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPoisson&operator=(const RooPoisson&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPoisson.html:22774,optimiz,optimizeCacheMode,22774,root/html602/RooPoisson.html,https://root.cern,https://root.cern/root/html602/RooPoisson.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProdPdf&operator=(const RooProdPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:23706,optimiz,optimizeCacheMode,23706,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUniform&operator=(const RooUniform&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUniform.html:22801,optimiz,optimizeCacheMode,22801,root/html602/RooUniform.html,https://root.cern,https://root.cern/root/html602/RooUniform.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,unsigned int,double,double>&operator=(const RooCFunction3PdfBinding<double,unsigned int,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html:23620,optimiz,optimizeCacheMode,23620,root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:48379,Optimiz,Optimize,48379,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance,"::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConvCoefVar&operator=(const RooConvCoefVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:19445,optimiz,optimizeCacheMode,19445,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFirstMoment&operator=(const RooFirstMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:19366,optimiz,optimizeCacheMode,19366,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,2,['optimiz'],['optimizeCacheMode']
Performance,"::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGenProdProj&operator=(const RooGenProdProj&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:19596,optimiz,optimizeCacheMode,19596,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,2,['optimiz'],['optimizeCacheMode']
Performance,::operator= ; (; const TGraphDelaunay & ; ). privatedelete . ◆ SetMarginBinsContent(). void TGraphDelaunay::SetMarginBinsContent ; (; Double_t ; z = 0.). Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin. ; Definition at line 943 of file TGraphDelaunay.cxx. ◆ SetMaxIter(). void TGraphDelaunay::SetMaxIter ; (; Int_t ; n = 100000). Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoning the search. ; Definition at line 932 of file TGraphDelaunay.cxx. ◆ Streamer(). void TGraphDelaunay::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGraphDelaunay::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TGraphDelaunay.h. Member Data Documentation. ◆ fAllTri. Bool_t TGraphDelaunay::fAllTri. protected . ! True if FindAllTriangles() has been performed on fGraph2D ; Definition at line 64 of file TGraphDelaunay.h. ◆ fDist. Double_t* TGraphDelaunay::fDist. protected . ! Array used to order mass points by distance ; Definition at line 56 of file TGraphDelaunay.h. ◆ fGraph2D. TGraph2D* TGraphDelaunay::fGraph2D. protected . ! 2D graph containing the user data ; Definition at line 66 of file TGraphDelaunay.h. ◆ fHullPoints. Int_t* TGraphDelaunay::fHullPoints. protected . ! Hull points of size fNhull ; Definition at line 62 of file TGraphDelaunay.h. ◆ fInit. Bool_t TGraphDelaunay::fInit. protected . ! True if CreateTrianglesDataStructure() and FindHull() have been performed ; Definition at line 65 of file TGraphDelaunay.h. ◆ fMaxIter. Int_t TGraphDelaunay::fMaxIter. protected . ! Maximum number of iterations to find Delaunay triangles ; Definition at line 57 of file TGraphDelaunay.h. ◆ fMTried. Int_t* TGraphDelaunay::fMTried. protected . ! ; Definition at line 61 of file TGraphDelaunay.h. ◆ fNdt. Int_t TGraphDelaunay::fNdt. protected . ! Number ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphDelaunay.html:23095,perform,performed,23095,doc/master/classTGraphDelaunay.html,https://root.cern,https://root.cern/doc/master/classTGraphDelaunay.html,1,['perform'],['performed']
Performance,"::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsCategoryLValue::volume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:17507,cache,cache,17507,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['cache'],['cache']
Performance,"::setRange(y) new range named 'fit_nll_model_modelData' created with bounds [-10,0]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB2' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB2' created with bounds [0,10]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 16261.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf312__multirangefit_8C.html:6884,optimiz,optimization,6884,doc/master/rf312__multirangefit_8C.html,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html,6,['optimiz'],['optimization']
Performance,"::shared_ptr< RWebWindow > fMaster;  ! master window where this window is embedded ;  ; std::vector< MasterConn > fMasterConns;  ! master connections ;  ; unsigned fMaxQueueLength {10};  ! maximal number of queue entries ;  ; std::shared_ptr< RWebWindowsManager > fMgr;  ! display manager ;  ; bool fNativeOnlyConn {false};  ! only native connection are allowed, created by Show() method ;  ; float fOperationTmout {50.};  ! timeout in seconds to perform synchronous operation, default 50s ;  ; std::string fPanelName;  ! panel name which should be shown in the window ;  ; ConnectionsList_t fPendingConn;  ! list of pending connection with pre-assigned keys ;  ; bool fProcessMT {false};  ! if window event processing performed in dedicated thread ;  ; std::string fProtocol;  ! protocol ;  ; int fProtocolCnt {-1};  ! counter for protocol recording ;  ; unsigned fProtocolConnId {0};  ! connection id, which is used for writing protocol ;  ; std::string fProtocolFileName;  ! local file where communication protocol will be written ;  ; std::string fProtocolPrefix;  ! prefix for created files names ;  ; bool fRequireAuthKey {true};  ! defines if authentication key always required when connect to the widget ;  ; bool fSendMT {false};  ! true is special threads should be used for sending data ;  ; bool fUseCurrentDir {false};  ! if window can access local files via currentdir/ path of http server ;  ; bool fUseProcessEvents {false};  ! all window functionality will run through process events ;  ; std::string fUserArgs;  ! arbitrary JSON code, which is accessible via conn.getUserArgs() method ;  ; bool fUseServerThreads {false};  ! indicates that server thread is using, no special window thread ;  ; unsigned fWidth {0};  ; std::thread fWindowThrd;  ! special thread for that window ;  ; std::shared_ptr< RWebWindowWSHandler > fWSHandler;  ! specialize websocket handler for all incoming connections ;  ; int fX {-1};  ; int fY {-1};  ! initial window position, -1 ignored ;  . Static Priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:19850,perform,perform,19850,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,4,['perform'],"['perform', 'performed']"
Performance,"::string &)> WebWindowDataCallback_tfunction signature for call-backs from the window clients first argument is connection id,...Definition RWebWindow.hxx:39; ROOT::WebWindowConnectCallback_tstd::function< void(unsigned)> WebWindowConnectCallback_tfunction signature for connect/disconnect call-backs argument is connection idDefinition RWebWindow.hxx:35; ROOT::WebWindowWaitFunc_tstd::function< int(double)> WebWindowWaitFunc_tfunction signature for waiting call-backs Such callback used when calling thread need to waits for so...Definition RWebWindow.hxx:46; ROOT::RWebWindow::MasterConnDefinition RWebWindow.hxx:118; ROOT::RWebWindow::MasterConn::channelint channelDefinition RWebWindow.hxx:120; ROOT::RWebWindow::MasterConn::MasterConnMasterConn(unsigned _connid, int _channel)Definition RWebWindow.hxx:121; ROOT::RWebWindow::MasterConn::connidunsigned connidDefinition RWebWindow.hxx:119; ROOT::RWebWindow::QueueEntryDefinition RWebWindow.hxx:126; ROOT::RWebWindow::QueueEntry::fDatastd::string fData! data for given connectionDefinition RWebWindow.hxx:129; ROOT::RWebWindow::QueueEntry::fKindEQueueEntryKind fKind! kind of dataDefinition RWebWindow.hxx:128; ROOT::RWebWindow::QueueEntry::fConnIdunsigned fConnId! connection idDefinition RWebWindow.hxx:127; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry()=default; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&data)Definition RWebWindow.hxx:131; ROOT::RWebWindow::QueueItemDefinition RWebWindow.hxx:62; ROOT::RWebWindow::QueueItem::QueueItemQueueItem(int chid, bool txt, std::string &&data)Definition RWebWindow.hxx:66; ROOT::RWebWindow::QueueItem::fDatastd::string fData! text or binary dataDefinition RWebWindow.hxx:65; ROOT::RWebWindow::QueueItem::fChIDint fChID! channelDefinition RWebWindow.hxx:63; ROOT::RWebWindow::QueueItem::fTextbool fText! is text dataDefinition RWebWindow.hxx:64; ROOT::RWebWindow::WebConnDefinition RWebWindow.hxx:69; ROOT::RWebWindow::WebConn::fReady",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:46628,Queue,QueueEntry,46628,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['Queue'],['QueueEntry']
Performance,"::string &)> WebWindowDataCallback_tfunction signature for call-backs from the window clients first argument is connection id,...Definition RWebWindow.hxx:41; ROOT::WebWindowConnectCallback_tstd::function< void(unsigned)> WebWindowConnectCallback_tfunction signature for connect/disconnect call-backs argument is connection idDefinition RWebWindow.hxx:37; ROOT::WebWindowWaitFunc_tstd::function< int(double)> WebWindowWaitFunc_tfunction signature for waiting call-backs Such callback used when calling thread need to waits for so...Definition RWebWindow.hxx:48; ROOT::RWebWindow::MasterConnDefinition RWebWindow.hxx:121; ROOT::RWebWindow::MasterConn::channelint channelDefinition RWebWindow.hxx:123; ROOT::RWebWindow::MasterConn::MasterConnMasterConn(unsigned _connid, int _channel)Definition RWebWindow.hxx:124; ROOT::RWebWindow::MasterConn::connidunsigned connidDefinition RWebWindow.hxx:122; ROOT::RWebWindow::QueueEntryDefinition RWebWindow.hxx:129; ROOT::RWebWindow::QueueEntry::fDatastd::string fData! data for given connectionDefinition RWebWindow.hxx:132; ROOT::RWebWindow::QueueEntry::fKindEQueueEntryKind fKind! kind of dataDefinition RWebWindow.hxx:131; ROOT::RWebWindow::QueueEntry::fConnIdunsigned fConnId! connection idDefinition RWebWindow.hxx:130; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry()=default; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&data)Definition RWebWindow.hxx:134; ROOT::RWebWindow::QueueItemDefinition RWebWindow.hxx:64; ROOT::RWebWindow::QueueItem::QueueItemQueueItem(int chid, bool txt, std::string &&data)Definition RWebWindow.hxx:68; ROOT::RWebWindow::QueueItem::fDatastd::string fData! text or binary dataDefinition RWebWindow.hxx:67; ROOT::RWebWindow::QueueItem::fChIDint fChID! channelDefinition RWebWindow.hxx:65; ROOT::RWebWindow::QueueItem::fTextbool fText! is text dataDefinition RWebWindow.hxx:66; ROOT::RWebWindow::WebConnDefinition RWebWindow.hxx:71; ROOT::RWebWindow::WebConn::fReady",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:46912,Queue,QueueEntry,46912,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['Queue'],['QueueEntry']
Performance,"::string RGeomDescription::MakeDrawingJson(RGeomDrawing &drawing, bool has_shapes); 1827{; 1828 int comp = GetJsonComp();; 1829 ; 1830 if (!has_shapes || (comp < TBufferJSON::kSkipTypeInfo)); 1831 return TBufferJSON::ToJSON(&drawing, comp).Data();; 1832 ; 1833 comp = comp % TBufferJSON::kSkipTypeInfo; // no typeinfo skipping; 1834 ; 1835 TBufferJSON json;; 1836 json.SetCompact(comp);; 1837 json.SetSkipClassInfo(TClass::GetClass<RGeomDrawing>());; 1838 json.SetSkipClassInfo(TClass::GetClass<RGeomNode>());; 1839 json.SetSkipClassInfo(TClass::GetClass<RGeomVisible>());; 1840 json.SetSkipClassInfo(TClass::GetClass<RGeomShapeRenderInfo>());; 1841 json.SetSkipClassInfo(TClass::GetClass<RGeomRawRenderInfo>());; 1842 ; 1843 return json.StoreObject(&drawing, TClass::GetClass<RGeomDrawing>()).Data();; 1844}; 1845 ; 1846/////////////////////////////////////////////////////////////////////////////////; 1847/// Change visibility for specified element; 1848/// Returns true if changes was performed; 1849 ; 1850bool RGeomDescription::ChangeNodeVisibility(const std::vector<std::string> &path, bool selected); 1851{; 1852 TLockGuard lock(fMutex);; 1853 ; 1854 RGeomBrowserIter giter(*this);; 1855 if (!giter.Navigate(path)); 1856 return false;; 1857 ; 1858 auto nodeid = giter.GetNodeId();; 1859 ; 1860 auto &dnode = fDesc[nodeid];; 1861 ; 1862 auto vol = GetVolume(nodeid);; 1863 ; 1864 // nothing changed; 1865 if (vol->IsVisible() == selected); 1866 return false;; 1867 ; 1868 dnode.vis = selected ? 99 : 0;; 1869 vol->SetVisibility(selected);; 1870 if (!dnode.chlds.empty()) {; 1871 if (selected); 1872 dnode.vis = 1; // visibility disabled when any child; 1873 vol->SetVisDaughters(selected);; 1874 }; 1875 ; 1876 int id = 0;; 1877 for (auto &desc : fDesc); 1878 if (GetVolume(id++) == vol); 1879 desc.vis = dnode.vis;; 1880 ; 1881 auto stack = MakeStackByIds(giter.CurrentIds());; 1882 ; 1883 // any change in logical node visibility erase individual physical node settings; 1884 for (auto iter =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:56160,perform,performed,56160,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['perform'],['performed']
Performance,"::string_view wName)Fill and return a one-dimensional histogram with the weighted values of a column (lazy action).Definition RInterface.hxx:1866; ROOT::RDF::RInterface::CacheImplRInterface< RLoopManager > CacheImpl(const ColumnNames_t &columnList, std::index_sequence< S... >)Implementation of cache.Definition RInterface.hxx:3200; ROOT::RDF::RInterface::RangeRInterface< RDFDetail::RRange< Proxied >, DS_t > Range(unsigned int end)Creates a node that filters entries based on range.Definition RInterface.hxx:1591; ROOT::RDF::RInterface::FilterMissingRInterface< RDFDetail::RFilterWithMissingValues< Proxied >, DS_t > FilterMissing(std::string_view column)Keep only the entries that have missing values.Definition RInterface.hxx:388; ROOT::RDF::RInterface::TakeRResultPtr< COLL > Take(std::string_view column="""")Return a collection of values of a column (lazy action, returns a std::vector by default).Definition RInterface.hxx:1761; ROOT::RDF::RInterface::CacheRInterface< RLoopManager > Cache(std::initializer_list< std::string > columnList)Save selected columns in memory.Definition RInterface.hxx:1546; ROOT::RDF::RInterface::Profile2DRResultPtr<::TProfile2D > Profile2D(const TProfile2DModel &model, std::string_view v1Name="""", std::string_view v2Name="""", std::string_view v3Name="""")Fill and return a two-dimensional profile (lazy action).Definition RInterface.hxx:2426; ROOT::RDF::RInterface::GetProxiedPtrconst std::shared_ptr< Proxied > & GetProxiedPtr() constDefinition RInterface.hxx:3318; ROOT::RDF::RInterface::JittedVaryImplRInterface< Proxied, DS_t > JittedVaryImpl(const std::vector< std::string > &colNames, std::string_view expression, const std::vector< std::string > &variationTags, std::string_view variationName, bool isSingleColumn)Definition RInterface.hxx:3255; ROOT::RDF::RInterface::Histo3DRResultPtr<::TH3D > Histo3D(const TH3DModel &model, std::string_view v1Name="""", std::string_view v2Name="""", std::string_view v3Name="""")Fill and return a three-dimensional histogram (la",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:209228,Cache,CacheRInterface,209228,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,['Cache'],"['Cache', 'CacheRInterface']"
Performance,"::unique_ptr< Internal::RPageSource > ; source, . const RNTupleReadOptions & ; options . ). explicitprivate . The model is generated from the ntuple metadata on storage. ; Definition at line 76 of file RNTupleReader.cxx. ◆ ~RNTupleReader(). ROOT::Experimental::RNTupleReader::~RNTupleReader ; (; ). default . Member Function Documentation. ◆ begin(). RIterator ROOT::Experimental::RNTupleReader::begin ; (; ). inline . Definition at line 342 of file RNTupleReader.hxx. ◆ Clone(). std::unique_ptr< RNTupleReader > ROOT::Experimental::RNTupleReader::Clone ; (; ). inline . Definition at line 167 of file RNTupleReader.hxx. ◆ ConnectModel(). void ROOT::Experimental::RNTupleReader::ConnectModel ; (; RNTupleModel & ; model). private . Definition at line 28 of file RNTupleReader.cxx. ◆ EnableMetrics(). void ROOT::Experimental::RNTupleReader::EnableMetrics ; (; ). inline . Enable performance measurements (decompression time, bytes read from storage, etc.) ; Example: inspect the reader metrics after loading every entry #include <ROOT/RNTupleReader.hxx>; using ROOT::Experimental::ENTupleInfo;; using ROOT::Experimental::RNTupleReader;; ; #include <iostream>; ; auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; // metrics must be turned on beforehand; ntuple->EnableMetrics();; ; for (auto i : ntuple->GetEntryRange()) {; ntuple->LoadEntry(i);; }; ntuple->PrintInfo(ENTupleInfo::kMetrics);; ROOT::Experimental::RNTupleReader::GetEntryRangeRNTupleGlobalRange GetEntryRange()Returns an iterator over the entry indices of the RNTuple.Definition RNTupleReader.hxx:246; ROOT::Experimental::ENTupleInfoENTupleInfoListing of the different options that can be printed by RNTupleReader::GetInfo()Definition RNTupleReader.hxx:43; ROOT::Experimental::ENTupleInfo::kMetrics@ kMetrics. Definition at line 364 of file RNTupleReader.hxx. ◆ end(). RIterator ROOT::Experimental::RNTupleReader::end ; (; ). inline . Definition at line 343 of file RNTupleReader.hxx. ◆ GetCollectionView() [1/2]. RNTupleC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:7451,load,loading,7451,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['load'],['loading']
Performance,"::unique_ptr<ROOT::Internal::TNamedBranchProxy>>;; 274 void Initialize();; 275 ROOT::Internal::TNamedBranchProxy* FindProxy(const char* branchname) const; 276 {; 277 const auto proxyIt = fProxies.find(branchname);; 278 return fProxies.end() != proxyIt ? proxyIt->second.get() : nullptr;; 279 }; 280 ; 281 void AddProxy(std::unique_ptr<ROOT::Internal::TNamedBranchProxy> p); 282 {; 283 auto bpName = p->GetName();; 284#ifndef NDEBUG; 285 if (fProxies.end() != fProxies.find(bpName)) {; 286 std::string err = ""A proxy with key "" + std::string(bpName) + "" was already stored!"";; 287 throw std::runtime_error(err);; 288 }; 289#endif; 290 ; 291 fProxies[bpName] = std::move(p);; 292 }; 293 ; 294 ROOT::Internal::TFriendProxy &AddFriendProxy(std::size_t friendIdx);; 295 ; 296 bool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase* reader);; 297 void DeregisterValueReader(ROOT::Internal::TTreeReaderValueBase* reader);; 298 ; 299 EEntryStatus SetEntryBase(Long64_t entry, bool local);; 300 ; 301 bool SetProxies();; 302 ; 303private:; 304 std::string GetProxyKey(const char *branchname); 305 {; 306 std::string key(branchname);; 307 //key += reinterpret_cast<std::uintptr_t>(fTree);; 308 return key;; 309 }; 310 ; 311 enum EStatusBits {; 312 kBitIsChain = BIT(14), ///< our tree is a chain; 313 kBitHaveWarnedAboutEntryListAttachedToTTree = BIT(15), ///< the tree had a TEntryList and we have warned about that; 314 kBitSetEntryBaseCallingLoadTree = BIT(16), ///< SetEntryBase is in the process of calling TChain/TTree::%LoadTree.; 315 kBitIsExternalTree = BIT(17) ///< we do not own the tree; 316 };; 317 ; 318 TTree* fTree = nullptr; ///< tree that's read; 319 TEntryList* fEntryList = nullptr; ///< entry list to be used; 320 EEntryStatus fEntryStatus = kEntryNotLoaded; ///< status of most recent read request; 321 ELoadTreeStatus fLoadTreeStatus = kNoTree; ///< Indicator on how LoadTree was called 'last' time.; 322 /// TTree and TChain will notify this object upon LoadTree, leading to a cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:12310,Load,LoadTree,12310,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['Load'],['LoadTree']
Performance,"::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &ofilename);  ; bool IsCorrectClingArgument (const std::string &argument);  Check if the argument is a sane cling argument. ;  ; bool IsGoodForAutoParseMap (const clang::RecordDecl &rcd);  Check if the class good for being an autoparse key. ;  ; bool IsGoodLibraryName (const std::string &name);  ; bool IsImplementationName (const std::string &filename);  ; bool IsLinkdefFile (const clang::PresumedLoc &PLoc);  ; bool isPointerToPointer (const clang::FieldDecl &m);  ; bool IsSelectionFile (const char *filename);  ; bool IsSelectionXml (const char *filename);  ; bool IsSupportedClassName (const char *name);  ; void LoadLibraryMap (const std::string &fileListName, map< string, string > &autoloads);  Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ;  ; static void MaybeSuppressWin32CrashDialogs ();  ; static bool ModuleContainsHeaders (TModuleGenerator &modGen, clang::HeaderSearch &headerSearch, clang::Module *module, std::vector< std::array< std::string, 2 > > &missingHeaders);  Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ;  ; bool Namespace__HasMethod (const clang::NamespaceDecl *cl, const char *name, const cling::Interpreter &interp);  ; bool NeedsSelection (const char *name);  ; bool ParsePragmaLine (const std::string &line, const char *expectedTokens[], size_t *end=nullptr);  Check whether the #pragma line contains expectedTokens (0-terminated array). ;  ; void ParseRoot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:23528,Load,LoadLibraryMap,23528,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,2,"['Load', 'load']","['LoadLibraryMap', 'loaded']"
Performance,":; <file>.root are considered ROOT files and added to the InputFiles() list; <macro>.C are considered ROOT macros and also added to the InputFiles() list; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; last one will prevail; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplication.html:15354,Load,LoadGraphicsLibs,15354,root/html526/TApplication.html,https://root.cern,https://root.cern/root/html526/TApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance,":; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooBrentRootFinder. class RooBrentRootFinder: public RooAbsRootFinder. Implement the abstract 1-dimensional root finding interface using; the Brent-Decker method. This implementation is based on the one; in the GNU scientific library (v0.99).; . Function Members (Methods); public:. RooBrentRootFinder(const RooAbsFunc& function); RooBrentRootFinder(const RooBrentRootFinder&); virtual~RooBrentRootFinder(); static TClass*Class(); virtual Bool_tfindRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; virtual TClass*IsA() const; voidsetTol(Double_t tol); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { MaxIterations; };. protected:. const RooAbsFunc*RooAbsRootFinder::_functionPointer to input function; Double_t_tol; Bool_tRooAbsRootFinder::_validTrue if current state is valid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBrentRootFinder(const RooAbsFunc& function); Constructor taking function binding as input. Bool_t findRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; Do the root finding using the Brent-Decker method. Returns a boolean status and; loads 'result' with our best guess at the root if true.; Prints a warning if the initial interval does not bracket a single; root or if the root is not found after a fixed number of iterations. RooBrentRootFinder(const RooAbsFunc& function). virtual ~RooBrentRootFinder(); { }. void setTol(Double_t tol); Set convergence tolerance parameter. » Last changed: Mon Jul 4 15:21:46 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBrentRootFinder.html:1522,load,loads,1522,root/html530/RooBrentRootFinder.html,https://root.cern,https://root.cern/root/html530/RooBrentRootFinder.html,1,['load'],['loads']
Performance,":; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooBrentRootFinder. class RooBrentRootFinder: public RooAbsRootFinder. Implement the abstract 1-dimensional root finding interface using; the Brent-Decker method. This implementation is based on the one; in the GNU scientific library (v0.99).; . Function Members (Methods); public:. RooBrentRootFinder(const RooAbsFunc& function); RooBrentRootFinder(const RooBrentRootFinder&); virtual~RooBrentRootFinder(); static TClass*Class(); virtual Bool_tfindRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; virtual TClass*IsA() const; voidsetTol(Double_t tol); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { MaxIterations; };. protected:. const RooAbsFunc*RooAbsRootFinder::_functionPointer to input function; Double_t_tol; Bool_tRooAbsRootFinder::_validTrue if current state is valid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBrentRootFinder(const RooAbsFunc& function); Constructor taking function binding as input. Bool_t findRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; Do the root finding using the Brent-Decker method. Returns a boolean status and; loads 'result' with our best guess at the root if true.; Prints a warning if the initial interval does not bracket a single; root or if the root is not found after a fixed number of iterations. RooBrentRootFinder(const RooAbsFunc& function). virtual ~RooBrentRootFinder(); { }. void setTol(Double_t tol); Set convergence tolerance parameter. » Last changed: Thu Nov 3 20:07:06 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBrentRootFinder.html:1522,load,loads,1522,root/html532/RooBrentRootFinder.html,https://root.cern,https://root.cern/root/html532/RooBrentRootFinder.html,1,['load'],['loads']
Performance,":AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:1510,cache,cacheUniqueSuffix,1510,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,":Apply(TF2 *f); 659{; 660 //if (fHistogram) SetBit(kResetHisto);; 661 ; 662 for (Int_t i = 0; i < fNpoints; i++) {; 663 fZ[i] = f->Eval(fX[i], fY[i], fZ[i]);; 664 }; 665 if (gPad) gPad->Modified();; 666}; 667 ; 668////////////////////////////////////////////////////////////////////////////////; 669/// Browse; 670 ; 671void TGraph2D::Browse(TBrowser *); 672{; 673 Draw(""p0"");; 674 gPad->Update();; 675}; 676 ; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Free all memory allocated by this object.; 680 ; 681void TGraph2D::Clear(Option_t * /*option = """" */); 682{; 683 if (fX) delete [] fX;; 684 fX = nullptr;; 685 if (fY) delete [] fY;; 686 fY = nullptr;; 687 if (fZ) delete [] fZ;; 688 fZ = nullptr;; 689 fSize = fNpoints = 0;; 690 if (fHistogram && !fUserHisto) {; 691 delete fHistogram;; 692 fHistogram = nullptr;; 693 fDelaunay = nullptr;; 694 }; 695 if (fFunctions) {; 696 fFunctions->SetBit(kInvalidObject);; 697 fFunctions->Delete();; 698 delete fFunctions;; 699 fFunctions = nullptr;; 700 }; 701 if (fDirectory) {; 702 fDirectory->Remove(this);; 703 fDirectory = nullptr;; 704 }; 705}; 706 ; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Perform the automatic addition of the graph to the given directory; 710///; 711/// Note this function is called in place when the semantic requires; 712/// this object to be added to a directory (I.e. when being read from; 713/// a TKey or being Cloned); 714 ; 715void TGraph2D::DirectoryAutoAdd(TDirectory *dir); 716{; 717 Bool_t addStatus = TH1::AddDirectoryStatus();; 718 if (addStatus) {; 719 SetDirectory(dir);; 720 if (dir) {; 721 ResetBit(kCanDelete);; 722 }; 723 }; 724}; 725 ; 726 ; 727////////////////////////////////////////////////////////////////////////////////; 728/// Computes distance from point px,py to a graph; 729 ; 730Int_t TGraph2D::DistancetoPrimitive(Int_t px, Int_t py); 731{; 732 Int_t distance = 9999;; 733 if (fHistogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:22708,Perform,Perform,22708,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['Perform'],['Perform']
Performance,":BookMethod ; (; DataLoader * ; , . TMVA::Types::EMVA ; , . TString ; , . TString ; , . TMVA::Types::EMVA ; , . TString ;  . ). inline . Definition at line 102 of file Factory.h. ◆ BookMethod() [2/3]. TMVA::MethodBase * TMVA::Factory::BookMethod ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . TString ; methodTitle, . TString ; theOption = """" . ). Book a classifier or regression method. ; Definition at line 352 of file Factory.cxx. ◆ BookMethod() [3/3]. TMVA::MethodBase * TMVA::Factory::BookMethod ; (; TMVA::DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . TString ; theOption = """" . ). Books MVA method. ; The option configuration string is custom for each MVA the TString field ""theNameAppendix"" serves to define (and distinguish) several instances of a given MVA, eg, when one wants to compare the performance of various configurations ; Definition at line 487 of file Factory.cxx. ◆ BookMethodWeightfile(). TMVA::MethodBase * TMVA::Factory::BookMethodWeightfile ; (; DataLoader * ; loader, . TMVA::Types::EMVA ; methodType, . const TString & ; weightfile . ). private . Adds an already constructed method to be managed by this factory. ; NotePrivate. . Know what you are doing when using this method. The method that you are loading could be trained already. ; Definition at line 501 of file Factory.cxx. ◆ Class(). static TClass * TMVA::Factory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Factory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::Factory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 227 of file Factory.h. ◆ DeclFileName(). static const char * TMVA::Factory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 227 of file Factory.h. ◆ DeleteAllMethods(). void TMVA::Factory::DeleteAllMethods ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:22529,load,loader,22529,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,":Cache ; (; std::string_view ; columnNameRegexp = """"). inline . Save selected columns in memory. ; Parameters. [in]columnNameRegexpThe regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns. . Returnsa RDataFrame that wraps the cached dataset.; The existing columns are matched against the regular expression. If the string provided is empty, all columns are selected. See the previous overloads for more information. ; Definition at line 1520 of file RInterface.hxx. ◆ CacheImpl(). template<typename Proxied , typename DataSource = void> . template<typename... ColTypes, std::size_t... S> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::CacheImpl ; (; const ColumnNames_t & ; columnList, . std::index_sequence< S... > ;  . ). inlineprivate . Implementation of cache. ; Definition at line 3200 of file RInterface.hxx. ◆ CallCreateActionWithoutColsIfPossible() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename Helper , typename ActionResultType , typename... Others> . RResultPtr< ActionResultType > ROOT::RDF::RInterface< Proxied, DataSource >::CallCreateActionWithoutColsIfPossible ; (; const std::shared_ptr< ActionResultType > & ; , . const std::shared_ptr< Helper > & ; , . Others... ;  . ). inlineprivate . Definition at line 3301 of file RInterface.hxx. ◆ CallCreateActionWithoutColsIfPossible() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename Helper , typename ActionResultType > . auto ROOT::RDF::RInterface< Proxied, DataSource >::CallCreateActionWithoutColsIfPossible ; (; const std::shared_ptr< ActionResultType > & ; resPtr, . const std::shared_ptr< Helper > & ; hPtr, . TTraits::TypeList< RDFDetail::RInferredType > ;  . ); -> decltype(hPtr->Exec(0u), RResultPtr<ActionResu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:45439,cache,cache,45439,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['cache'],['cache']
Performance,":Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooGenContext::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooGenContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file RooGenContext.h. ◆ DeclFileName(). static const char * RooGenContext::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 of file RooGenContext.h. ◆ generateEvent(). void RooGenContext::generateEvent ; (; RooArgSet & ; theEvent, . Int_t ; remaining . ). overrideprotectedvirtual . Generate one event. ; The 'remaining' integer is not used other than for printing messages ; Implements RooAbsGenContext.; Definition at line 347 of file RooGenContext.cxx. ◆ initGenerator(). void RooGenContext::initGenerator ; (; const RooArgSet & ; theEvent). overrideprotectedvirtual . Perform one-time initialization of the generator context. ; Reimplemented from RooAbsGenContext.; Definition at line 324 of file RooGenContext.cxx. ◆ IsA(). TClass * RooGenContext::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsGenContext.; Definition at line 54 of file RooGenContext.h. ◆ printMultiline(). void RooGenContext::printMultiline ; (; std::ostream & ; os, . Int_t ; content, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Printing interface. ; Reimplemented from RooAbsGenContext.; Definition at line 399 of file RooGenContext.cxx. ◆ Streamer(). void RooGenContext::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsGenContext. ◆ StreamerNVirtual(). void RooGenContext::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 54 of file RooGenContext.h. Member Data Documentation. ◆ _acceptRejectFunc. std::unique_ptr<Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenContext.html:20161,Perform,Perform,20161,doc/master/classRooGenContext.html,https://root.cern,https://root.cern/doc/master/classRooGenContext.html,1,['Perform'],['Perform']
Performance,":Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TEnum.h. ◆ DeclFileName(). static const char * TEnum::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file TEnum.h. ◆ GetClass(). TClass * TEnum::GetClass ; (; ); const. inline . Definition at line 62 of file TEnum.h. ◆ GetConstant(). const TEnumConstant * TEnum::GetConstant ; (; const char * ; name); const. inline . Definition at line 64 of file TEnum.h. ◆ GetConstants(). const TSeqCollection * TEnum::GetConstants ; (; ); const. inline . Definition at line 63 of file TEnum.h. ◆ GetDeclId(). TDictionary::DeclId_t TEnum::GetDeclId ; (; ); const. Definition at line 146 of file TEnum.cxx. ◆ GetEnum() [1/2]. TEnum * TEnum::GetEnum ; (; const char * ; enumName, . ESearchAction ; sa = kALoadAndInterpLookup . ). static . Static function to retrieve enumerator from the ROOT's typesystem. ; It has no side effect, except when the load flag is true. In this case, the load of the library containing the scope of the enumerator is attempted. There are two top level code paths: the enumerator is scoped or isn't. If it is not, a lookup in the list of global enums is performed. If it is, two lookups are carried out for its scope: one in the list of classes and one in the list of protoclasses. If a scope with the desired name is found, the enum is searched. If the scope is not found, and the load flag is true, the aforementioned two steps are performed again after an autoload attempt with the name of the scope as key is tried out. If the interpreter lookup flag is false, the ListOfEnums objects are not treated as such, but rather as THashList objects. This prevents any flow of information from the interpreter into the ROOT's typesystem: a snapshot of the typesystem status is taken. ; Definition at line 209 of file TEnum.cxx. ◆ GetEnum() [2/2]. TEnum * TEnum::GetEnum ; (; const std::type_info & ; ti, . ESear",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTEnum.html:17267,load,load,17267,doc/v632/classTEnum.html,https://root.cern,https://root.cern/doc/v632/classTEnum.html,2,['load'],['load']
Performance,":Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBaseClass.html:2007,load,load,2007,root/html532/TBaseClass.html,https://root.cern,https://root.cern/root/html532/TBaseClass.html,1,['load'],['load']
Performance,":Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBaseClass.html:2007,load,load,2007,root/html526/TBaseClass.html,https://root.cern,https://root.cern/root/html526/TBaseClass.html,3,['load'],['load']
Performance,":ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofSuperMaster.html:20740,cache,cachedir,20740,root/html530/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofSuperMaster.html,2,['cache'],['cachedir']
Performance,":ConvergenceTest::SetConvergenceParameters(Int_t steps, Double_t improvement); voidTMVA::ConvergenceTest::SetCurrentValue(Float_t value); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; Float_tTMVA::ConvergenceTest::SpeedControl(UInt_t ofSteps); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodMLP.html:13815,tune,tuneParameters,13815,root/html602/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodMLP.html,2,['tune'],['tuneParameters']
Performance,":CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21252,perform,perform,21252,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,":DeclContext * TCling__DEBUG__getDeclContext (clang::Decl *D);  ; void TCling__DEBUG__printName (clang::Decl *D);  ; const char * TCling__GetClassSharedLibs (const char *className, bool skipCore);  ; void TCling__GetNormalizedContext (const ROOT::TMetaUtils::TNormalizedCtxt *&normCtxt);  ; TObject * TCling__GetObjectAddress (const char *Name, void *&LookupCtx);  ; const Decl * TCling__GetObjectDecl (TObject *obj);  ; void TCling__InvalidateGlobal (const clang::Decl *D);  ; int TCling__IsAutoLoadNamespaceCandidate (const clang::NamespaceDecl *nsDecl);  ; void TCling__LibraryLoadedRTTI (const void *dyLibHandle, const char *canonicalName);  ; bool TCling__LibraryLoadingFailed (const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved);  Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by error messages we get from callback from cling. ;  ; void TCling__LibraryUnloadedRTTI (const void *dyLibHandle, const char *canonicalName);  ; int TCling__LoadLibrary (const char *library);  Load a library. ;  ; void * TCling__LockCompilationDuringUserCodeExecution ();  Lock the interpreter. ;  ; void TCling__PrintStackTrace ();  Print a StackTrace! ;  ; void TCling__RegisterRdictForLoadPCM (const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);  ; void * TCling__ResetInterpreterMutex ();  Reset the interpreter lock to the state it had before interpreter-related calls happened. ;  ; void TCling__RestoreInterpreterMutex (void *delta);  Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused. ;  ; void TCling__SplitAclicMode (const char *fileName, string &mode, string &args, string &io, string &fname);  ; bool TCling__TEST_isInvalidDecl (clang::Decl *D);  ; bool TCling__TEST_isInvalidDecl (ClassInfo_t *input);  ; void TCling__TransactionRollback (const cling::Transaction &T);  ; void TCling__UnlockCompilationDuringUserCodeExecution (void *);  Unlock the interpreter. ;  ; static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:8614,Load,Load,8614,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['Load'],['Load']
Performance,":ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCaloDataHist(); Constructor. ~TEveCaloDataHist(); Destructor. void DataChanged(); Update limits and notify data users. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; Get list of cell IDs in given eta and phi range. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const; Get cell geometry and value from cell ID. Int_t AddHistogram(TH2F* hist); Add new slice to calo tower. Updates cached variables fMaxValE; and fMaxValEt; Return last index in the vector of slice infos. TH2F* GetHist(Int_t slice) const; Get histogram in given slice. void GetEtaLimits(Double_t& min, Double_t& max) const; Get eta limits. void GetPhiLimits(Double_t& min, Double_t& max) const; Get phi limits. TEveCaloData& operator=(const TEveCaloDataHist& ). TEveCaloDataHist(const TEveCaloDataHist& ). THStack* GetStack(); { return fHStack; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveCaloDataHist.html:22211,cache,cached,22211,root/html604/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html604/TEveCaloDataHist.html,1,['cache'],['cached']
Performance,":ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCaloDataHist(); Constructor. ~TEveCaloDataHist(); Destructor. void DataChanged(); Update limits and notify data users. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; Get list of cell IDs in given eta and phi range. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const; Get cell geometry and value from cell ID. Int_t AddHistogram(TH2F* hist); Add new slice to calo tower. Updates cached variables fMaxValE; and fMaxValEt; Return last index in the vector of slice infos. TH2F* GetHist(Int_t slice) const; Get histogram in given slice. void GetEtaLimits(Double_t& min, Double_t& max) const; Get eta limits. void GetPhiLimits(Double_t& min, Double_t& max) const; Get phi limits. TEveCaloData& operator=(const TEveCaloDataHist& ). TEveCaloDataHist(const TEveCaloDataHist& ). THStack* GetStack(); { return fHStack; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloDataHist.html:22211,cache,cached,22211,root/html602/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html602/TEveCaloDataHist.html,1,['cache'],['cached']
Performance,":EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Long64_tfBytesRead!track bytes read of main file; TH2D*fCpuTimeHist!histogram of cpu time spent processing packets; TDSet*fDSet!Saved pointer to the TDSet object; TStringfDataSet!Dataset string; Int_tfDataSetLen!Maximum size of the dataset string fDataSet; Int_tfDataSetSize!# of files in the dataset; Bool_tfDoHist!Fill histos; Bool_tfDoQuota!Save stats on SQL server for quota management; Bool_tfDoSlaveTrace!Full tracing in workers; Bool_tfDoTrace!Trace details in master; Bool_tfDoTraceRate!Trace processing rate in master; TH1D*fEventsHist!histogram of events processed per slave; TH2D*fLatencyHist!histogram of latency due to packet requests; TObjArrayfMonSenders!Monitoring engines; Bool_tfMonitorPerPacket!Whether to send the full entry per each packet; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TList*fOutput!Saved pointer to the output list; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH1I*fProcPcktHist!histogram of packets being processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPerfStats.html:8129,latency,latency,8129,root/html602/TPerfStats.html,https://root.cern,https://root.cern/root/html602/TPerfStats.html,2,['latency'],['latency']
Performance,:ESetBranchAddressStatuskMissingCompiledCollectionProxy; static TObject::EStatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatuskNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatuskVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tfAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:32854,cache,cache,32854,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['cache'],['cache']
Performance,":EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoNode**fArray![fMaxLevel] Array of nodes; TObject*fClientClient object to notify; Int_tfLevelBranch depth; TGeoHMatrix*fMatrixGlobal matrix (owned); Int_tfMaxLevelArray length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. ~TGeoBranchArray(); Destructor. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. void AddLevel(Int_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. void Init(TGeoNode** branch, TGeoMatrix* global, Int_t level); Init the branch array from an array of nodes, the global matrix for the path and; the level. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBranchArray.html:7550,perform,performed,7550,root/html602/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html602/TGeoBranchArray.html,1,['perform'],['performed']
Performance,":GetSelectedRowsvirtual Long64_t GetSelectedRows()Definition TTree.h:553; TTree::AddAllocationCountvoid AddAllocationCount(UInt_t count)Definition TTree.h:337; TTree::SetMaxEntryLoopvirtual void SetMaxEntryLoop(Long64_t maxev=kMaxEntries)Definition TTree.h:663; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; TTree::fDebugMinLong64_t fDebugMin! First entry number to debugDefinition TTree.h:112; TTree::SetEntriesvirtual Long64_t SetEntries(Long64_t n=-1)Change number of entries in the tree.Definition TTree.cxx:9011; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definition TTree.cxx:2074; TTree::GetCacheAutoSizeLong64_t GetCacheAutoSize(bool withDefault=false)Used for automatic sizing of the cache.Definition TTree.cxx:5407; TTree::BranchRefvirtual TBranch * BranchRef()Build the optional branch supporting the TRefTable.Definition TTree.cxx:2328; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetNotifyTObject * GetNotify() constDefinition TTree.h:543; TTree::fAliasesTList * fAliasesList of aliases for expressions based on the tree branches.Definition TTree.h:124; TTree::BranchTBranch * Branch(const char *name, Longptr_t address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:384; TTree::CopyTreevirtual TTree * CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Copy a tree with selection.Definition TTree.cxx:3719; TTree::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:59127,cache,cache,59127,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,":GetStatStyleStyle_t GetStatStyle() constDefinition TStyle.h:262; TStyle::GetStatWFloat_t GetStatW() constDefinition TStyle.h:266; TStyle::GetFitFormatconst char * GetFitFormat() constDefinition TStyle.h:199; TStyle::GetStatFormatconst char * GetStatFormat() constDefinition TStyle.h:263; TStyle::GetNumberOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::GetNumberContoursInt_t GetNumberContours() constDefinition TStyle.h:241; TStyle::GetPaintTextFormatconst char * GetPaintTextFormat() constDefinition TStyle.h:250; TStyle::GetStatFontStyle_t GetStatFont() constDefinition TStyle.h:260; TStyle::GetTitleFontSizeFloat_t GetTitleFontSize() constDefinition TStyle.h:274; TStyle::GetTitleAlignInt_t GetTitleAlign() constDefinition TStyle.h:270; TStyle::GetTitleWFloat_t GetTitleW() constDefinition TStyle.h:282; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TTextBase class for several text objects.Definition TText.h:22; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::Classstatic TClass * Class(); TViewSee TView3D.Definition TView.h:25; TView::GetPsivirtual Double_t GetPsi()=0; TView::GetRmaxvirtual Double_t * GetRmax()=0; TView::SetAxisNDCvirtual void SetAxisNDC(const Double_t *x1, const Double_t *x2, const Double_t *y1, const Double_t *y2, const Double_t *z1, const Double_t *z2)=0; TView::GetRminvirtual Double_t * GetRmin()=0; TView::WCtoNDCvirtual void WCtoNDC(const Float_t *pw, Float_t *pn)=0; TView::SetOutlineToCubevirtual void SetOutlineToCube()=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::GetTnormvirtual Double_t * GetTnorm()=0; TView::ExecuteRotateViewvirtual void ExecuteRotateView(Int_t event, Int_t px, Int_t py)=0; TView::GetOutlinevirtual TSeqCollection * GetOutli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:491490,Load,Loadvirtual,491490,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,3,['Load'],"['Load', 'Loadvirtual']"
Performance,":GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeSQL.html:9610,Load,LoadTreeFriend,9610,root/html528/TTreeSQL.html,https://root.cern,https://root.cern/root/html528/TTreeSQL.html,1,['Load'],['LoadTreeFriend']
Performance,":GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeSQL.html:9736,Load,LoadTreeFriend,9736,root/html530/TTreeSQL.html,https://root.cern,https://root.cern/root/html530/TTreeSQL.html,3,['Load'],['LoadTreeFriend']
Performance,":GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeSQL.html:10388,Load,LoadTreeFriend,10388,root/html602/TTreeSQL.html,https://root.cern,https://root.cern/root/html602/TTreeSQL.html,2,['Load'],['LoadTreeFriend']
Performance,":IsStartingWithTObject ; (; ); const. Returns true if this class inherits from TObject and if the start of the TObject parts is at the very beginning of the objects. ; Concretely this means that the following code is proper for this class: ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from TObject. ; Definition at line 5929 of file TClass.cxx. ◆ IsSyntheticPair(). Bool_t TClass::IsSyntheticPair ; (; ); const. inline . Definition at line 521 of file TClass.h. ◆ IsTObject(). Bool_t TClass::IsTObject ; (; ); const. Return kTRUE is the class inherits from TObject. ; Definition at line 5938 of file TClass.cxx. ◆ IsVersioned(). Bool_t TClass::IsVersioned ; (; ); const. inline . Definition at line 522 of file TClass.h. ◆ Load(). TClass * TClass::Load ; (; TBuffer & ; b). static . Load class description from I/O buffer and return class object. ; Definition at line 5715 of file TClass.cxx. ◆ LoadClass(). TClass * TClass::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5749 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:101558,Load,LoadClass,101558,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['Load'],['LoadClass']
Performance,":IsStartingWithTObject ; (; ); const. Returns true if this class inherits from TObject and if the start of the TObject parts is at the very beginning of the objects. ; Concretely this means that the following code is proper for this class: ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from TObject. ; Definition at line 5996 of file TClass.cxx. ◆ IsSyntheticPair(). Bool_t TClass::IsSyntheticPair ; (; ); const. inline . Definition at line 521 of file TClass.h. ◆ IsTObject(). Bool_t TClass::IsTObject ; (; ); const. Return kTRUE is the class inherits from TObject. ; Definition at line 6005 of file TClass.cxx. ◆ IsVersioned(). Bool_t TClass::IsVersioned ; (; ); const. inline . Definition at line 522 of file TClass.h. ◆ Load(). TClass * TClass::Load ; (; TBuffer & ; b). static . Load class description from I/O buffer and return class object. ; Definition at line 5782 of file TClass.cxx. ◆ LoadClass(). TClass * TClass::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5816 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:101559,Load,LoadClass,101559,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['Load'],['LoadClass']
Performance,":Math::DistSampler::SetRange ; (; const std::vector< double > & ; xmin, . const std::vector< double > & ; xmax . ). inline . Set the range for all dimensions (use std::vector) ; Definition at line 140 of file DistSampler.h. ◆ SetRange() [4/4]. void ROOT::Math::DistSampler::SetRange ; (; double ; xmin, . double ; xmax, . int ; icoord = 0 . ). Set the range in a given dimension. ; Definition at line 40 of file DistSampler.cxx. ◆ SetSeed(). virtual void ROOT::Math::DistSampler::SetSeed ; (; unsigned int ; ). inlinevirtual . Set the random seed for the TRandom instances used by the sampler classes. ; To be implemented by the derived classes who provides random sampling ; Reimplemented in TFoamSampler, and TUnuranSampler.; Definition at line 125 of file DistSampler.h. ◆ SetUseLogPdf(). virtual void ROOT::Math::DistSampler::SetUseLogPdf ; (; bool ; = true). inlinevirtual . Use the log of the provided pdf. ; Implemented by the derived classes ; Reimplemented in TUnuranSampler.; Definition at line 162 of file DistSampler.h. Member Data Documentation. ◆ fData. std::vector<double> ROOT::Math::DistSampler::fData. mutableprivate . ! internal array used to cached the sample data ; Definition at line 286 of file DistSampler.h. ◆ fFunc. const ROOT::Math::IMultiGenFunction* ROOT::Math::DistSampler::fFunc. private . internal function (ND) ; Definition at line 288 of file DistSampler.h. ◆ fOwnFunc. bool ROOT::Math::DistSampler::fOwnFunc. private . flag to indicate if the function is owned ; Definition at line 285 of file DistSampler.h. ◆ fRange. ROOT::Fit::DataRange* ROOT::Math::DistSampler::fRange. private . data range ; Definition at line 287 of file DistSampler.h. Libraries for ROOT::Math::DistSampler:. [legend]; The documentation for this class was generated from the following files:; math/mathcore/inc/Math/DistSampler.h; math/mathcore/src/DistSampler.cxx. ROOTMathDistSampler. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DistSampler.html:16056,cache,cached,16056,doc/master/classROOT_1_1Math_1_1DistSampler.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DistSampler.html,1,['cache'],['cached']
Performance,":Math::GSLMinimizer1D&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; doublefUp; doublefXlow; doublefXmin; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit GSLMinimizer1D(Minim1D::Type type=Minim1D::kBRENT). Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration. virtual ~GSLMinimizer1D(). Destructor: free allocated resources. GSLMinimizer1D(const GSLMinimizer1D &); usually copying is non trivial, so we make this unaccessible. void SetFunction( const UserFunc & f, double xmin, double xlow, double xup). Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. int Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMinimizer1D.html:2670,Perform,Perform,2670,root/html526/ROOT__Math__GSLMinimizer1D.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMinimizer1D.html,1,['Perform'],['Perform']
Performance,":Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:2989,cache,cached,2989,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,":MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodFisherMethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodFisherMethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTMVA::MethodBase::Reset(); voidTObject::ResetBit(UInt_t f); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:10834,Optimiz,OptimizeTuningParameters,10834,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,":MergeFunc_t fMerge;  saved info to call a IsA member function ;  ; std::atomic< TListOfFunctions * > fMethod;  ; ROOT::NewFunc_t fNew;  ; ROOT::NewArrFunc_t fNewArray;  ; RepoCont_t fObjectVersionRepository;  ; Longptr_t fOffsetStreamer;  Properties that can only be evaluated at run-time. ;  ; UInt_t fOnHeap;  ; TVirtualMutex * fOVRMutex = nullptr;  ; std::atomic< TClass ** > fPersistentRef;  ; std::atomic< Long_t > fProperty;  ; TList * fRealData;  ; TVirtualRefProxy * fRefProxy;  cached streamer info used in the last read. ;  ; ROOT::ResetAfterMergeFunc_t fResetAfterMerge;  ; std::atomic< UChar_t > fRuntimeProperties;  ; ROOT::Detail::TSchemaRuleSet * fSchemaRules;  Pointer to reference proxy if this class represents a reference. ;  ; TString fSharedLibs;  ; ShowMembersFunc_t fShowMembers;  ; Int_t fSizeof;  ; EState fState;  cached of the streaming method to use ;  ; TClassStreamer * fStreamer;  ; ClassStreamerFunc_t fStreamerFunc;  ; std::atomic< StreamerImpl_t > fStreamerImpl;  ; TObjArray * fStreamerInfo;  ; Int_t fStreamerType;  saved info to call Streamer ;  ; const std::type_info * fTypeInfo;  ; std::atomic< TListOfDataMembers * > fUsingData;  ; std::atomic< Bool_t > fVersionUsed;  saved remember if fOffsetStreamer has been set. ;  . Static Private Attributes; static std::atomic< Int_t > fgClassCount;  ; static THashTable * fgClassTypedefHash = nullptr;  ; static TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistry;  . Friends; bool operator& (UChar_t l, ERuntimeProperties r);  ; class ROOT::Internal::TCheckHashRecursiveRemoveConsistency;  ; void ROOT::ResetClassVersion (TClass *, const char *, Short_t);  ; class ROOT::TGenericClassInfo;  ; class TCling;  ; class TProtoClass;  ; class TStreamerInfo;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TClass.h>. Inheritance diagram for TClass:. This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:45923,cache,cached,45923,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['cache'],['cached']
Performance,:MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<TMVA::MethodCuts::EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC optimisation method; vector<Int_t>*fRangeSignused to match cuts to fit parameters (and vice versa); vector<Double_t>*fRmsBRMSs of variables (background); vector<Double_t>*fRmsSRMSs of variables (signal); Double_tfTestSignalEffused to test optimized signal efficiency; Double_t*fTmpCutMaxtemporary maximum requirement; Double_t*fTmpCutMintemporary minimum requirement; vector<TH1*>*fVarHistBreference histograms (background); vector<TH1*>*fVarHistB_smoothsmoothed reference histograms (background); vector<TH1*>*fVarHistSreference histograms (signal); vector<TH1*>*fVarHistS_smoothsmoothed reference histograms (signal); vector<TMVA::PDF*>*fVarPdfBreference PDFs (background); vector<TMVA::PDF*>*fVarPdfSreference PDFs (signal); static TMVA::MethodCuts::EFitParameterskForceMax; static TMVA::MethodCuts::EFitParameterskForceMin; static TMVA::MethodCuts::EFitParameterskForceSmart; static TMVA::MethodCuts::EFitParameterskNotEnforced; static TMVA::MethodCuts::EFitMethodTypekUseEventScan; static TMVA::MethodCuts::EEffMethodkUseEventSelection; static TMVA::MethodCuts::EFitMethodTypekUseGeneticAlgorithm; static TMVA::MethodCuts::EFitMethodTypekUseMinuit; static TMVA::MethodCuts::EFitMethodTypekUseMonteCarlo; static TMVA::MethodCuts::EFitMethod,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCuts.html:21618,optimiz,optimized,21618,root/html602/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCuts.html,2,['optimiz'],['optimized']
Performance,":Minuit2::MnStrategy ; ROOT::Minuit2::MnTraceObject ; ROOT::Minuit2::MnUserParameterState ; ROOT::Minuit2::MnUserParameters ; ROOT::Minuit2::ModularFunctionMinimizer ; ROOT::Minuit2::ScanMinimizer ; ROOT::Minuit2::SimplexMinimizer ; ROOT::Minuit2::VariableMetricMinimizer ; ROOT::TArrayProxy<ROOT::TArrayType<Long64_t,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<ULong64_t,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<bool,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<char,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<double,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<float,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<int,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<long,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<short,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned char,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned int,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned long,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned short,0> > ; ROOT::TBranchProxy ; ROOT::TBranchProxyClassDescriptor Class to cache the information we gathered about the branch and its content; ROOT::TBranchProxyDescriptor Describe the proxy for a branch; ROOT::TBranchProxyDirector ; ROOT::TClaArrayProxy<ROOT::TArrayType<Long64_t,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<ULong64_t,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<bool,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<char,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<double,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<float,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<int,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<long,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<short,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<unsigned char,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<unsigned int,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<unsigned long,0> > ; ROOT::TClaArrayProxy<ROOT::TArrayType<unsigned short,0> > ; ROOT::TClaImpProxy<Long64_t> ; ROOT::TClaImpProxy<ULong64_t> ; ROOT::TClaImpProxy<bool> ; ROOT::TClaImpProxy<char> ; ROOT::TClaImpProxy<double> ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:21993,cache,cache,21993,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['cache'],['cache']
Performance,":NTrees=1000:BoostType=Grad:Shrinkage=0.10:UseBaggedBoost:BaggedSampleFraction=0.50:nCuts=20:MaxDepth=2"");; 129 if (Use[""MLP""]) // neural network; 130 factory->BookMethod( dataloader, TMVA::Types::kMLP, ""MLP"", ""!H:!V:NeuronType=tanh:NCycles=1000:HiddenLayers=N+5,5:TestRate=5:EstimatorType=MSE"");; 131 if (Use[""FDA_GA""]) // functional discriminant with GA minimizer; 132 factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_GA"", ""H:!V:Formula=(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3:ParRanges=(-1,1);(-10,10);(-10,10);(-10,10);(-10,10):FitMethod=GA:PopSize=300:Cycles=3:Steps=20:Trim=True:SaveBestGen=1"" );; 133 if (Use[""PDEFoam""]) // PDE-Foam approach; 134 factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"", ""!H:!V:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Nmin=100:Kernel=None:Compress=T"" );; 135 ; 136 ; 137 if (Use[""DL_CPU""]) {; 138 TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; 139 TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; 140 ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; 141 TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; 142 ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; 143 nnOptions.Append("":"");; 144 nnOptions.Append(layoutString);; 145 nnOptions.Append("":"");; 146 nnOptions.Append(trainingStrategyString);; 147 factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_CPU"", nnOptions);; 148 }; 149 if (Use[""DL_GPU""]) {; 150 TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; 151 TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; 152 ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; 153 TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; 154 ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; 155 nnOptions.Append("":"");; 156 nnOptions.Append(layoutString);; 157 nnOptions.Append("":"");; 158 nnOptions.Append(trainingStrategyString);; 159 factor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:5555,Optimiz,Optimizer,5555,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['Optimiz'],['Optimizer']
Performance,":NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. Bool_tCheckDuplicateName(TObject* obj); Bool_tUnsetDirectory(TObject* obj). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t UnsetDirectory(TObject* obj); If the class of obj has the SetDirectory(TDirectory*) method; call it to unset the directory assiciation. The objects in the; selector list or owned by the list and not by the directory that; was active when they were created. Returns true in case of success. Bool_t CheckDuplicateName(TObject* obj); Check for duplicate object names in the list. If an object with; the same name is added then the merge function will fail that will; look up objects in different output lists by name. Returns true; in case name is unique. void AddFirst(TObject* obj); Add at the start of the list. void AddFirst(TObject* obj, Option_t* opt); Add at the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorList.html:9638,cache,cache,9638,root/html528/TSelectorList.html,https://root.cern,https://root.cern/root/html528/TSelectorList.html,3,['cache'],['cache']
Performance,":Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:18288,optimiz,optimizeCacheMode,18288,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,":Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExpensiveObjectCache.html:4504,cache,cacheObject,4504,root/html530/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html530/RooExpensiveObjectCache.html,2,['cache'],['cacheObject']
Performance,":Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); Int_tsize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExpensiveObjectCache.html:4504,cache,cacheObject,4504,root/html534/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html534/RooExpensiveObjectCache.html,1,['cache'],['cacheObject']
Performance,":Open( outfileName, ""RECREATE"" );; ; // Create the factory object (see TMVAClassification.C for more information); ; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D"" );; if (batchMode) factoryOptions += "":!Color:!DrawProgressBar"";; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAClassificationCategory"", outputFile, factoryOptions );; ; // Create DataLoader; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; // Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""eta"" );; ; // Load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"")) {; // if directory data not found try using tutorials dir; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; if (!gSystem->AccessPathName( fname )) {; // first we try to find tmva_example.root in the local directory; std::cout << ""--- TMVAClassificationCategory: Accessing "" << fname << std::endl;; input = TFile::Open( fname );; }; ; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:29660,Load,Load,29660,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['Load'],['Load']
Performance,":OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:24657,cache,cache,24657,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,104,['cache'],['cache']
Performance,":OptimizeConfigParameters:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::OptimizeConfigParameters ; (; MethodBase *const ; method, . std::map< TString, TMVA::Interval * > ; tuneParameters, . TString ; fomType = ""Separation"", . TString ; optimizationType = ""GA"" . ). Constructor which sets either ""Classification or Regression"". ; Definition at line 60 of file OptimizeConfigParameters.cxx. ◆ ~OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::~OptimizeConfigParameters ; (; ). virtual . the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it) ; Definition at line 96 of file OptimizeConfigParameters.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::OptimizeConfigParameters::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::OptimizeConfigParameters::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::OptimizeConfigParameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ DeclFileName(). static const char * TMVA::OptimizeConfigParameters::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ EstimatorFunction(). Double_t TMVA::OptimizeConfigParameters::EstimatorFunction ; (; std::vector< Double_t > & ; pars). privatevirtual . return the estimator (from current FOM) for the fitting interface ; Implements TMVA::IFitterTarget.; Definition at line 307 of file OptimizeConfigParameters.cxx. ◆ GetBkgEffAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgEffAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:5296,Optimiz,OptimizeConfigParameters,5296,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,":RRange<Proxied>, DS_t> newInterface(std::move(rangePtr), *fLoopManager, fColRegister);; 1580 return newInterface;; 1581 }; 1582 ; 1583 // clang-format off; 1584 ////////////////////////////////////////////////////////////////////////////; 1585 /// \brief Creates a node that filters entries based on range.; 1586 /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 1587 /// \return a node of the computation graph for which the range is defined.; 1588 ///; 1589 /// See the other Range overload for a detailed description.; 1590 // clang-format on; 1591 RInterface<RDFDetail::RRange<Proxied>, DS_t> Range(unsigned int end) { return Range(0, end, 1); }; 1592 ; 1593 // clang-format off; 1594 ////////////////////////////////////////////////////////////////////////////; 1595 /// \brief Execute a user-defined function on each entry (*instant action*).; 1596 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; 1597 /// \param[in] columns Names of the columns/branches in input to the user function.; 1598 ///; 1599 /// The callable `f` is invoked once per entry. This is an *instant action*:; 1600 /// upon invocation, an event loop as well as execution of all scheduled actions; 1601 /// is triggered.; 1602 /// Users are responsible for the thread-safety of this callable when executing; 1603 /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; 1604 ///; 1605 /// ### Example usage:; 1606 /// ~~~{.cpp}; 1607 /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; 1608 /// ~~~; 1609 // clang-format on; 1610 template <typename F>; 1611 void Foreach(F f, const ColumnNames_t &columns = {}); 1612 {; 1613 using arg_types = typename TTraits::CallableTraits<decltype(f)>::arg_types_nodecay;; 1614 using ret_type = typename TTraits::CallableTraits<decltype(f)>::ret_type;; 1615 ForeachSlot(RDFInterna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:89477,perform,performing,89477,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['perform'],['performing']
Performance,":RegisterContext(TContext *ctxt) {; 1366 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1367 ; 1368 if (!IsBuilt() || this == ROOT::Internal::gROOTLocal); 1369 return;; 1370 if (fContext) {; 1371 TContext *current = fContext;; 1372 while(current->fNext) {; 1373 current = current->fNext;; 1374 }; 1375 current->fNext = ctxt;; 1376 ctxt->fPrevious = current;; 1377 } else {; 1378 fContext = ctxt;; 1379 }; 1380}; 1381 ; 1382////////////////////////////////////////////////////////////////////////////////; 1383/// Register a std::atomic<TDirectory*> that will soon be pointing to this TDirectory object; 1384 ; 1385void TDirectory::RegisterGDirectory(TDirectory::SharedGDirectory_t &gdirectory_ptr); 1386{; 1387 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1388 if (std::find(fGDirectories.begin(), fGDirectories.end(), gdirectory_ptr) == fGDirectories.end()) {; 1389 fGDirectories.emplace_back(gdirectory_ptr);; 1390 }; 1391 // FIXME:; 1392 // globalptr->load()->fGDirectories will still contain globalptr, but we cannot; 1393 // know whether globalptr->load() has been deleted by another thread in the meantime.; 1394}; 1395 ; 1396 ; 1397////////////////////////////////////////////////////////////////////////////////; 1398/// \copydoc TDirectory::WriteObject(const T*,const char*,Option_t*,Int_t).; 1399 ; 1400Int_t TDirectory::WriteTObject(const TObject *obj, const char *name, Option_t * /*option*/, Int_t /*bufsize*/); 1401{; 1402 const char *objname = ""no name specified"";; 1403 if (name) objname = name;; 1404 else if (obj) objname = obj->GetName();; 1405 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1406 return 0;; 1407}; 1408 ; 1409////////////////////////////////////////////////////////////////////////////////; 1410/// UnRegister a TContext pointing to this TDirectory object; 1411 ; 1412void TDirectory::UnregisterContext(TContext *ctxt) {; 1413 ; 1414 ROOT::Internal::TSpinLockGuard slg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:48344,load,load,48344,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,2,['load'],['load']
Performance,":ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:27636,cache,cache,27636,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,3,['cache'],['cache']
Performance,":ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:27639,cache,cache,27639,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,":ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMode(const RooMomentMorph::Setting& setting); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMomentMorph.html:26994,cache,cache,26994,root/html528/RooMomentMorph.html,https://root.cern,https://root.cern/root/html528/RooMomentMorph.html,1,['cache'],['cache']
Performance,":SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8711 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 649 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:211048,cache,cacheSize,211048,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],"['cache', 'cacheSize']"
Performance,":StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSetProxy.html:13122,Perform,Perform,13122,root/html532/RooSetProxy.html,https://root.cern,https://root.cern/root/html532/RooSetProxy.html,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,":Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:172994,load,loaded,172994,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,":Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h:385; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:40267,load,loaded,40267,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['load'],['loaded']
Performance,":TInitBehaviorDefinition Rtypes.h:147; ROOT::Internal::TInitBehavior::Unregistervirtual void Unregister(const char *classname, TClass *cl) const =0; ROOT::Internal::TInitBehavior::CreateClassvirtual TClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:153; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h_source.html:27882,load,load,27882,doc/v632/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h_source.html,1,['load'],['load']
Performance,":TInitBehaviorDefinition Rtypes.h:152; ROOT::Internal::TInitBehavior::Unregistervirtual void Unregister(const char *classname, TClass *cl) const =0; ROOT::Internal::TInitBehavior::CreateClassvirtual TClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:158; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h_source.html:29419,load,load,29419,doc/master/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html,1,['load'],['load']
Performance,":TSGD< Architecture_t, Layer_t, DeepNet_t >. ◆ UpdateWeights(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . virtual void TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::UpdateWeights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedpure virtual . Update the weights, given the current weight gradients. ; Implemented in TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >, and TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >. Member Data Documentation. ◆ fDeepNet. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . DeepNet_t& TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::fDeepNet. protected . The reference to the deep net. ; Definition at line 53 of file Optimizer.h. ◆ fGlobalStep. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . size_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::fGlobalStep. protected . The current global step count during training. ; Definition at line 52 of file Optimizer.h. ◆ fLearningRate. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::fLearningRate. protected . The learning rate used for training. ; Definition at line 51 of file Optimizer.h. tmva/tmva/inc/TMVA/DNN/Optimizer.h. TMVADNNVOptimizer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:47 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:7584,Optimiz,Optimizer,7584,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,4,['Optimiz'],['Optimizer']
Performance,":TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tDeleteParameters(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFillPerfStatProfiles(TTree* t, Int_t nactive); voidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCPerfProfilescanvas for performance profile histograms; TProofBenchDataSet*fDSdataset operations handler; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfFilesPerWrk# of files to be processed per worker; TH2*fHist_perfstat_IO; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events per file; Int_tfNTriesnumber of tries; TStringfNamename of this run; TProofNodes*fNodeslist of nodes information; TLegend*fNormLegend_evtLegend for norms evts; TLegend*fNormLegend_mbLegend for norms mbs; TProfile*fNorm_perfstat_IOmax; TProfile*fNorm_perfstat_evtmax; TProfile*fNorm_queryresult_IO; TProfile*fNorm_queryresult_event; TLegend*fProfLegend_evtLegend for profiles evts; TLegend*fProfLegend_mbLegend for profiles mbs; TProfile*fProfile_cpu_eff; TProfile*fProfile_perfstat_IO; TProfile*fProfile_perfstat_IOmax; TProfile*fPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchRunDataRead.html:7030,load,loaded,7030,root/html534/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html534/TProofBenchRunDataRead.html,1,['load'],['loaded']
Performance,":TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tDeleteParameters(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFillPerfStatProfiles(TTree* t, Int_t nactive); voidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCPerfProfilescanvas for performance profile histograms; TProofBenchDataSet*fDSdataset operations handler; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfFilesPerWrk# of files to be processed per worker; TH2*fHist_perfstat_IO; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events per file; Int_tfNTriesnumber of tries; TStringfNamename of this run; TProofNodes*fNodeslist of nodes information; TProfile*fNorm_queryresult_IO; TProfile*fNorm_queryresult_event; TProfile*fProfile_perfstat_IO; TProfile*fProfile_perfstat_event; TProfile*fProfile_queryresult_IO; TProfile*fProfile_queryresult_event; TProof*fProofpointer to proof; TPBReadType*fReadTyperead type; Int_tfStartstart number of workers; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers. Class Charts. Inheritance; Inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunDataRead.html:6971,load,loaded,6971,root/html530/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunDataRead.html,2,['load'],['loaded']
Performance,":TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set ; RooArgSetfAsimovGlobObssnapshot of Asimov global observables ; RooArgSetfBestFitParamssnapshot of all best fitted Parameter values; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__AsymptoticCalculator.html:5761,perform,perform,5761,root/html534/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__AsymptoticCalculator.html,1,['perform'],['perform']
Performance,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoNodeCache(const TGeoNodeCache&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoNodeCache&operator=(const TGeoNodeCache&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. TGeoNodeCache(const TGeoNodeCache& ); Copy constructor. TGeoNodeCache& operator=(const TGeoNodeCache& ); Assignment operator. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNodeCache.html:7207,cache,cache,7207,root/html528/TGeoNodeCache.html,https://root.cern,https://root.cern/root/html528/TGeoNodeCache.html,3,['cache'],['cache']
Performance,":_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_pidPID of child process; Int_t_pipeToClient[2]Pipe to client process; Int_t_pipeToServer[2]Pipe to server process; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:31492,cache,cache,31492,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,3,['cache'],['cache']
Performance,":_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:30620,cache,cache,30620,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,4,['cache'],['cache']
Performance,:_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:39644,cache,cache,39644,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['cache'],['cache']
Performance,:_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:40026,cache,cache,40026,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,3,['cache'],['cache']
Performance,":_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of dependents defining dimensions of histogram; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:31317,cache,cache,31317,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,2,['cache'],['cache']
Performance,:_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of dependents defining dimensions of histogram; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration spec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:31984,cache,cache,31984,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['cache'],['cache']
Performance,:_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:38912,cache,cache,38912,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,1,['cache'],['cache']
Performance,:_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of pl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBDecay.html:39294,cache,cache,39294,root/html528/RooBDecay.html,https://root.cern,https://root.cern/root/html528/RooBDecay.html,3,['cache'],['cache']
Performance,":_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction1Binding_double_int_.html:32387,cache,cache,32387,root/html526/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction1Binding_double_int_.html,2,['cache'],['cache']
Performance,":_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,double>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction1Binding_double_double_.html:33175,cache,cache,33175,root/html530/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction1Binding_double_double_.html,1,['cache'],['cache']
Performance,":_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUnblindOffset.html:33814,cache,cache,33814,root/html532/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html532/RooUnblindOffset.html,2,['cache'],['cache']
Performance,":_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,bool>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction3Binding_double_double_double_bool_.html:33331,cache,cache,33331,root/html530/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html530/RooCFunction3Binding_double_double_double_bool_.html,1,['cache'],['cache']
Performance,":_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_double_int_int_.html:33670,cache,cache,33670,root/html532/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_double_int_int_.html,1,['cache'],['cache']
Performance,":_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Heaviside(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _c). Heaviside(const RooStats::Heaviside& other, const char* name =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__Heaviside.html:35985,cache,cache,35985,root/html602/RooStats__Heaviside.html,https://root.cern,https://root.cern/root/html602/RooStats__Heaviside.html,4,['cache'],['cache']
Performance,":_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo1DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Roo1DMomentMorphFunction(). Roo1DMomentMorphFunction(const char* name, const char* title, RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DMomentMorphFunction.html:36612,cache,cache,36612,root/html602/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo1DMomentMorphFunction.html,4,['cache'],['cache']
Performance,":_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumCdf.html:37724,cache,cache,37724,root/html602/RooNumCdf.html,https://root.cern,https://root.cern/root/html602/RooNumCdf.html,4,['cache'],['cache']
Performance,":_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProjectedPdf.html:43314,cache,cache,43314,root/html534/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html534/RooProjectedPdf.html,1,['cache'],['cache']
Performance,":_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:45001,cache,cache,45001,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,":_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPGenDecay.html:44860,cache,cache,44860,root/html534/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,":_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,double>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction1PdfBinding_double_double_.html:39295,cache,cache,39295,root/html528/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html528/RooCFunction1PdfBinding_double_double_.html,2,['cache'],['cache']
Performance,":_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; Bool_t_protectNegative; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPoisson.html:40130,cache,cache,40130,root/html532/RooPoisson.html,https://root.cern,https://root.cern/root/html532/RooPoisson.html,2,['cache'],['cache']
Performance,":_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyp.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgusBG.html:39751,cache,cache,39751,root/html530/RooArgusBG.html,https://root.cern,https://root.cern/root/html530/RooArgusBG.html,2,['cache'],['cache']
Performance,":_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBDecay.html:41888,cache,cache,41888,root/html530/RooBDecay.html,https://root.cern,https://root.cern/root/html530/RooBDecay.html,2,['cache'],['cache']
Performance,":_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:43233,cache,cache,43233,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,2,['cache'],['cache']
Performance,":_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddPdf.html:42236,cache,cache,42236,root/html530/RooAddPdf.html,https://root.cern,https://root.cern/root/html530/RooAddPdf.html,2,['cache'],['cache']
Performance,":_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill cache with sampling of p.d.f as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Tue Mar 10 17:14:12 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:45382,cache,cache,45382,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,":_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:34186,cache,cache,34186,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,5,['cache'],['cache']
Performance,":_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const char* name, const char* title, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const char* name, const char* title, RooAbsReal& pdfConvVar, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const RooFFTConvPdf& other, const char* name = 0); Copy constructor. ~RooFFTConvPdf(); Destructor. const char* inputBaseName() const; Return base name component for cache components in this case 'PDF1_CONV_PDF2'. TString histNameSuffix() const; Suffix for cache histogram (added in addition to suffix for cache name). void fillCacheObject(RooAbsCachedPdf::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:50604,cache,cache,50604,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,1,['cache'],['cache']
Performance,":_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:39400,cache,cache,39400,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,":analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; doublebinVolume() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:1893,Cache,CacheModeRooAbsArg,1893,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,":defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(RooCatType value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); Bool_tsetType(const RooCatType* type, Bool_t prinError = kTRUE); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSuperCategory.html:18573,optimiz,optimizeDirtyHook,18573,root/html526/RooSuperCategory.html,https://root.cern,https://root.cern/root/html526/RooSuperCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,:fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:16811,cache,cache,16811,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,2,['cache'],['cache']
Performance,:fMaxEntries. protected . Maximum number of entries in case of circular buffers. ; Definition at line 97 of file TTree.h. ◆ fMaxEntryLoop. Long64_t TTree::fMaxEntryLoop. protected . Maximum number of entries to process. ; Definition at line 98 of file TTree.h. ◆ fMaxVirtualSize. Long64_t TTree::fMaxVirtualSize. protected . Maximum total size of buffers kept in memory. ; Definition at line 99 of file TTree.h. ◆ fNClusterRange. Int_t TTree::fNClusterRange. protected . Number of Cluster range in addition to the one defined by 'AutoFlush'. ; Definition at line 95 of file TTree.h. ◆ fNEntriesSinceSorting. UInt_t TTree::fNEntriesSinceSorting. protected . ! Number of entries processed since the last re-sorting of branches ; Definition at line 143 of file TTree.h. ◆ fNfill. Int_t TTree::fNfill. protected . ! Local for EntryLoop ; Definition at line 110 of file TTree.h. ◆ fNotify. TObject* TTree::fNotify. protected . Object to be notified when loading a Tree. ; TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify(). Usually points to a TNotifyLink if this is a TChain. ; Definition at line 120 of file TTree.h. ◆ fPacketSize. Int_t TTree::fPacketSize. protected . ! Number of entries in one packet for parallel root ; Definition at line 109 of file TTree.h. ◆ fPerfStats. TVirtualPerfStats* TTree::fPerfStats. protected . ! pointer to the current perf stats object ; Definition at line 132 of file TTree.h. ◆ fPlayer. TVirtualTreePlayer* TTree::fPlayer. protected . ! Pointer to current Tree player ; Definition at line 134 of file TTree.h. ◆ fReadEntry. Long64_t TTree::fReadEntry. protected . ! Number of the entry being processed ; Definition at line 107 of file TTree.h. ◆ fSavedBytes. Long64_t TTree::fSavedBytes. protected . Number of autosaved bytes. ; Definition at line 88 of file TTree.h. ◆ fScanField. Int_t TTree::fScanField. protected . Number of runs before prompting in Scan. ; Definition at line 92 of file TTree.h. ◆ fSeqBranches. std::vector<TBranch*> TTree::fS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:233618,Load,LoadTree,233618,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,4,['Load'],['LoadTree']
Performance,":fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads; static TProof::ESlavesTProof::kActive; static TProof::ESlavesTProof::kAll; static TProof::ESlavesTProof::kAllUnique; static TProof::ESlavesTProof::kUnique. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; TDataSetManagerFile*fDataSetStgRepoDataset manager for staging requests; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TPMERegexp*fReInvalidRegular expression matching invalid dataset URIs; TStringfSandboxPROOF sandbox root dir; TStringfSelectionInternal variable to pass drawing options; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; TStringfVarExpInternal variable to pass drawing options; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:27771,cache,cache,27771,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['cache']
Performance,":fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TInterpreter.html:18774,Load,Load,18774,root/html534/TInterpreter.html,https://root.cern,https://root.cern/root/html534/TInterpreter.html,1,['Load'],['Load']
Performance,":fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(char *(*)(const char* prompt) getlineFunc, void (*)(char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInterpreter.html:18174,Load,Load,18174,root/html528/TInterpreter.html,https://root.cern,https://root.cern/root/html528/TInterpreter.html,1,['Load'],['Load']
Performance,":fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TInterpreter.html:18294,Load,Load,18294,root/html530/TInterpreter.html,https://root.cern,https://root.cern/root/html530/TInterpreter.html,2,['Load'],['Load']
Performance,":fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0, const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:17735,perform,performs,17735,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,1,['perform'],['performs']
Performance,":fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7ef8390 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7f39580 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x80caf20 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:5573,optimiz,optimization,5573,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,3,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,":kGetAlias@ kGetAliasDefinition TTree.h:214; TTree::GetV4virtual Double_t * GetV4()Definition TTree.h:582; TTree::BranchTBranch * Branch(const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:395; TTree::GetVar3TTreeFormula * GetVar3()Definition TTree.h:570; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:83732,cache,cache,83732,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,":kZombie. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<RooVectorDataStore::CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Bool_t_forcedUpdate! Request for forced cache update; Int_t_nCat; Int_t_nEntries; Int_t_nReal; Int_t_nRealF; vector<RooVectorDataStore::RealVector*>_realStoreList; vector<RooVectorDataStore::RealFullVector*>_realfStoreList; Double_t_sumWeight; Double_t_sumWeightCarry; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooVectorDataStore(). RooVectorDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). void setAllBuffersNative(). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVectorDataStore.html:11744,Optimiz,Optimization,11744,root/html602/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html602/RooVectorDataStore.html,8,"['Cache', 'Optimiz', 'cache']","['Cache', 'Optimization', 'cache']"
Performance,":kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:33729,cache,cache,33729,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,14,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,":list<std::string> includes;; 4828 GetRuleIncludes(includes);; 4829 for (auto & incFile : includes) {; 4830 dictStream << ""#include <"" << incFile << "">"" << std::endl;; 4831 }; 4832 dictStream << std::endl;; 4833 }; 4834 ; 4835 selectionRules.SearchNames(interp);; 4836 ; 4837 int scannerVerbLevel = 0;; 4838 {; 4839 using namespace ROOT::TMetaUtils;; 4840 scannerVerbLevel = GetErrorIgnoreLevel() == kInfo; // 1 if true, 0 if false; 4841 if (isGenreflex){; 4842 scannerVerbLevel = GetErrorIgnoreLevel() < kWarning;; 4843 }; 4844 }; 4845 ; 4846 // Select the type of scan; 4847 auto scanType = RScanner::EScanType::kNormal;; 4848 if (gOptGeneratePCH); 4849 scanType = RScanner::EScanType::kOnePCM;; 4850 if (dictSelection); 4851 scanType = RScanner::EScanType::kTwoPasses;; 4852 ; 4853 RScanner scan(selectionRules,; 4854 scanType,; 4855 interp,; 4856 normCtxt,; 4857 scannerVerbLevel);; 4858 ; 4859 // If needed initialize the autoloading hook; 4860 if (!gOptLibListPrefix.empty()) {; 4861 LoadLibraryMap(gOptLibListPrefix + "".in"", gAutoloads);; 4862 scan.SetRecordDeclCallback(RecordDeclCallback);; 4863 }; 4864 ; 4865 scan.Scan(CI->getASTContext());; 4866 ; 4867 bool has_input_error = false;; 4868 ; 4869 if (genreflex::verbose); 4870 selectionRules.PrintSelectionRules();; 4871 ; 4872 if (ROOT::TMetaUtils::GetErrorIgnoreLevel() != ROOT::TMetaUtils::kFatal &&; 4873 !gOptGeneratePCH &&; 4874 !dictSelRulesPresent &&; 4875 !selectionRules.AreAllSelectionRulesUsed()) {; 4876 ROOT::TMetaUtils::Warning(nullptr, ""Not all selection rules are used!\n"");; 4877 }; 4878 ; 4879 if (!gOptGeneratePCH){; 4880 rootclingRetCode += CheckForUnsupportedClasses(scan.fSelectedClasses);; 4881 if (rootclingRetCode) return rootclingRetCode;; 4882 }; 4883 ; 4884 // SELECTION LOOP; 4885 // Check for error in the class layout before doing anything else.; 4886 for (auto const & annRcd : scan.fSelectedClasses) {; 4887 if (ROOT::TMetaUtils::ClassInfo__HasMethod(annRcd, ""Streamer"", interp)) {; 4888 if (annRcd.Reques",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:198727,Load,LoadLibraryMap,198727,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,":make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Remove object from the list.; 819 ; 820TObject *TList::Remove(TObject *obj); 821{; 822 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:23965,cache,cached,23965,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,":model ; (; ); const. inline . Definition at line 57 of file RooNumConvolution.h. ◆ pdf(). RooAbsReal & RooNumConvolution::pdf ; (; ); const. inline . Definition at line 56 of file RooNumConvolution.h. ◆ printCompactTreeHook(). void RooNumConvolution::printCompactTreeHook ; (; std::ostream & ; os, . const char * ; indent = """" . ). overrideprotectedvirtual . Hook function to intercept printCompactTree() calls so that it can print out the content of its private cache in the print sequence. ; Reimplemented from RooAbsArg.; Definition at line 350 of file RooNumConvolution.cxx. ◆ profileData(). const TH2 * RooNumConvolution::profileData ; (; ); const. inline . Definition at line 52 of file RooNumConvolution.h. ◆ redirectServersHook(). bool RooNumConvolution::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. ; Reimplemented from RooAbsReal.; Definition at line 262 of file RooNumConvolution.cxx. ◆ setCallProfiling(). void RooNumConvolution::setCallProfiling ; (; bool ; flag, . Int_t ; nbinX = 40, . Int_t ; nbinCall = 40, . Int_t ; nCallHigh = 1000 . ). Activate call profile if flag is set to true. ; A 2-D histogram is kept that stores the required number of function calls versus the value of x, the convolution variable; All clones of RooNumConvolution objects will keep logging to the histogram of the original class so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating are all logged in a single place.; Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor; Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram ; Definition at line 324 of file RooNumConvolution.cxx. ◆ setCallWarning(). voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:68952,cache,cache,68952,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,2,['cache'],['cache']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:21166,optimiz,optimizeCacheMode,21166,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAddition&operator=(const RooAddition&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:19365,optimiz,optimizeCacheMode,19365,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,2,['optimiz'],['optimizeCacheMode']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConstVar&operator=(const RooConstVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstVar.html:19142,optimiz,optimizeCacheMode,19142,root/html602/RooConstVar.html,https://root.cern,https://root.cern/root/html602/RooConstVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooErrorVar&operator=(const RooErrorVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:22908,optimiz,optimizeCacheMode,22908,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistFunc&operator=(const RooHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:19262,optimiz,optimizeCacheMode,19262,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,2,['optimiz'],['optimizeCacheMode']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLegendre&operator=(const RooLegendre&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:19058,optimiz,optimizeCacheMode,19058,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,2,['optimiz'],['optimizeCacheMode']
Performance,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:20038,optimiz,optimizeCacheMode,20038,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['optimiz'],['optimizeCacheMode']
Performance,":observableOverlaps ; (; const RooArgSet * ; depList, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 924 of file RooAbsArg.cxx. ◆ operator=(). RooAbsArg & RooAbsArg::operator= ; (; const RooAbsArg & ; other). delete . ◆ operator==(). virtual bool RooAbsArg::operator== ; (; const RooAbsArg & ; other); const. pure virtual . Implemented in RooAbsCategory, RooAbsReal, and RooStringVar. ◆ operMode(). OperMode RooAbsArg::operMode ; (; ); const. inline . Query the operation mode of this node. ; Definition at line 456 of file RooAbsArg.h. ◆ operModeHook(). virtual void RooAbsArg::operModeHook ; (; ). inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:78048,cache,cache,78048,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,":observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; virtual Double_toffsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:20500,optimiz,optimizeCacheMode,20500,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['optimiz'],['optimizeCacheMode']
Performance,":observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,unsigned int,double,unsigned int>&operator=(const RooCFunction3Binding<double,unsigned int,double,unsigned int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:19994,optimiz,optimizeCacheMode,19994,root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,2,['optimiz'],['optimizeCacheMode']
Performance,":observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,unsigned int,unsigned int,double>&operator=(const RooCFunction3Binding<double,unsigned int,unsigned int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:19994,optimiz,optimizeCacheMode,19994,root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,":ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooDirItem; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void initialize (const char *wgtVarName);  Initialize the dataset. ;  ; std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) const override;  Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ;  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:30980,cache,cached,30980,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['cache'],['cached']
Performance,":plotOn() call. See that function for allowed options. RooPlot* makeFrameAndPlotCmd(const RooRealVar& param, RooLinkedList& cmdList, Bool_t symRange = kFALSE) const; Internal function. Construct RooPlot from given parameter and modify the list of named; arguments 'cmdList' to only contain the plot arguments that should be forwarded to; RooAbsData::plotOn(). RooPlot* plotNLL(Double_t lo, Double_t hi, Int_t nBins = 100); Create a RooPlot of the -log(L) distribution in the range lo-hi; with 'nBins' bins. RooPlot* plotError(const RooRealVar& param, Double_t lo, Double_t hi, Int_t nbins = 100); Create a RooPlot of the distribution of the fitted errors of the given parameter.; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins. RooPlot* plotPull(const RooRealVar& param, Double_t lo = -3., Double_t hi = 3., Int_t nbins = 25, Bool_t fitGauss = kFALSE); Create a RooPlot of the pull distribution for the given; parameter. The range lo-hi is plotted in nbins. If fitGauss is; set, an unbinned ML fit of the distribution to a Gaussian p.d.f; is performed. The fit result is overlaid on the returned RooPlot; and a box with the fitted mean and sigma is added. RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()). const RooDataSet* genParDataSet() const; Return dataset with generator parameters for each toy. When constraints are used these; may generally not be the same. » Last changed: Tue Jun 2 15:31:59 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMCStudy.html:27274,perform,performed,27274,root/html604/RooMCStudy.html,https://root.cern,https://root.cern/root/html604/RooMCStudy.html,1,['perform'],['performed']
Performance,":setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); Double_ttraceEval(const RooArgSet* set) const; virtual Bool_ttraceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). private:. Bool_tmatchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const. Data Members; public:. enum ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_t_boolValue! Transient cache for bool values from tree branches ; UChar_t_byteValue! Transient cache for byte values from tree branches ; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:29907,Cache,CacheMode,29907,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,1,['Cache'],['CacheMode']
Performance,":setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:34155,cache,cache,34155,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,2,['cache'],['cache']
Performance,":size_t i) const;  Return weight of i-th bin. ;  ; double const * weightArray () const;  ; void weightError (double &lo, double &hi, ErrorType etype=Poisson) const override;  Return the asymmetric errors on the current weight. ;  ; double weightError (ErrorType etype=Poisson) const override;  Return the symmetric error on the current weight. ;  ; double weightFast (const RooArgSet &bin, int intOrder, bool correctForBinSize, bool cdfBoundaries);  A faster version of RooDataHist::weight that assumes the passed arguments are aligned with the histogram variables. ;  ; void weights (double *output, std::span< double const > xVals, int intOrder, bool correctForBinSize, bool cdfBoundaries);  A vectorized version of RooDataHist::weight() for one dimensional histograms with up to one dimensional interpolation. ;  ; double weightSquared (std::size_t i) const;  Return squared weight sum of i-th bin. ;  ; double const * wgtErrHiArray () const;  ; double const * wgtErrLoArray () const;  ; Deprecated functions; These functions rely on the fact that an event has been loaded before they are called.; It is advised to switch to their counterparts that take bin numbers as arguments. In this way, code like, const RooArgSet* coordinates = dataHist.get(i); // Need this to achieve side effect on next call of weight() - bad.; const double weight = dataHist.weight();; processEvent(coordinates, weight);; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooDataHist::weightdouble weight(std::size_t i) constReturn weight of i-th bin.Definition RooDataHist.h:110; becomes processEvent(dataHist.get(i), dataHist.weight(i));; The index of a set of coordinates can be computed using getIndex(). . double weight () const override;  Return weight of last bin that was requested with get(). ;  ; double weightSquared () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:11381,load,loaded,11381,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['load'],['loaded']
Performance,":string &name) const override;  get index of variable given a variable given a name return always -1 . ;  ; std::string VariableName (unsigned int ivar) const override;  return reference to the objective function virtual const ROOT::Math::IGenFunction & Function() const; ;  ; const double * X () const override;  return pointer to X values at the minimum ;  ;  Public Member Functions inherited from ROOT::Math::Minimizer;  Minimizer ();  Default constructor. ;  ;  Minimizer (Minimizer &&)=delete;  ;  Minimizer (Minimizer const &)=delete;  ; virtual ~Minimizer ();  Destructor (no operations). ;  ; virtual void Clear ();  reset for consecutive minimization - implement if needed ;  ; virtual double Correlation (unsigned int i, unsigned int j) const;  return correlation coefficient between variable i and j. ;  ; double ErrorDef () const;  return the statistical scale used for calculate the error is typically 1 for Chi2 and 0.5 for likelihood minimization ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; virtual bool SetCovariance (std::span< const double > cov, unsigned int nrow);  set initial covariance matrix ;  ; virtual bool SetCovarianceDiag (std::span< const double > d2, unsigned int n);  set initial second derivat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuitMinimizer.html:7357,perform,performed,7357,doc/master/classTMinuitMinimizer.html,https://root.cern,https://root.cern/doc/master/classTMinuitMinimizer.html,1,['perform'],['performed']
Performance,":string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; returns true on success.; 1695 ; 1696void TCling::LoadPCMImpl(TFile &pcmFile); 1697{; 1698 auto listOfKeys = pcmFile.GetListOfKeys();; 1699 ; 1700 // This is an empty pcm; 1701 if (listOfKeys && ((listOfKeys->GetSize() == 0) || // Nothing here, or; 1702 ((listOfKeys->GetSize() == 1) && // only one, and; 1703 !strcmp(((TKey *)listOfKeys->At(0))->GetName(), ""EMPTY"") // name is EMPTY; 1704 ))) {; 1705 return;; 1706 }; 1707 ; 1708 TObjArray *protoClasses;; 1709 if (gDebug > 1); 1710 ::Info(""TCling::LoadPCMImpl"", ""reading protoclasses for %s \n"", pcmFile.GetName());; 1711 ; 1712 TObjArray *enums;; 1713 pcmFile.GetObject(""__Enums"", enums);; 1714 if (enums) {; 1715 // Cache the pointers; 1716 auto listOfGlobals = gROOT->GetListOfGlobals();; 1717 auto listOfEnums = dynamic_cast<THashList *>(gROOT->GetListOfEnums());; 1718 // Loop on enums and then on enum constants; 1719 for (auto selEnum : *enums) {; 1720 const char *enumScope = selEnum->GetTitle();; 1721 const char *enumName = selEnum->GetName();; 1722 if (strcmp(enumScope, """") == 0) {; 1723 // This is a global enum and is added to the; 1724 // list of enums and its constants to the list of globals; 1725 if (!listOfEnums->THashList::FindObject(enumName)) {; 1726 ((TEnum *)selEnum)->SetClass(nullptr);; 1727 listOfEnums->Add(selEnum);; 1728 }; 1729 for (auto enumConstant : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:64037,Load,LoadPCMImpl,64037,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadPCMImpl']
Performance,":string &res, Bool_t asjson=kTRUE);  Produce JSON/XML for specified item. ;  ; virtual Bool_t ProduceJson (const std::string &path, const std::string &options, std::string &res);  Produce JSON data for specified item For object conversion TBufferJSON is used. ;  ; virtual Bool_t ProduceMulti (const std::string &path, const std::string &options, std::string &res, Bool_t asjson=kTRUE);  Process several requests, packing all results into binary or JSON buffer. ;  ; virtual Bool_t ProduceRootFile (const std::string &path, const std::string &options, std::string &res);  Produce ROOT file for specified item. ;  ; virtual Bool_t ProduceXml (const std::string &path, const std::string &options, std::string &res);  Produce XML data for specified item. ;  ; void ScanCollection (TRootSnifferScanRec &rec, TCollection *lst, const char *foldername=nullptr, TCollection *keys_lst=nullptr);  Scan collection content. ;  ; virtual void ScanKeyProperties (TRootSnifferScanRec &rec, TKey *key, TObject *&obj, TClass *&obj_class);  Scans TKey properties in special cases load objects from the file. ;  ; virtual void ScanObjectChilds (TRootSnifferScanRec &rec, TObject *obj);  scans object childs (if any) here one scans collection, branches, trees and so on ;  ; void ScanObjectMembers (TRootSnifferScanRec &rec, TClass *cl, char *ptr);  scan object data members some members like enum or static members will be excluded ;  ; virtual void ScanObjectProperties (TRootSnifferScanRec &rec, TObject *obj);  Scans object properties here such fields as _autoload or _icon properties depending on class or object name could be assigned By default properties, coded in the Class title are scanned. ;  ; virtual void ScanRoot (TRootSnifferScanRec &rec);  scan complete ROOT objects hierarchy For the moment it includes objects in gROOT directory and list of canvases and files Also all registered objects are included. ;  ; Int_t WithCurrentUserName (const char *option);  return 2 when option match to current user n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:17022,load,load,17022,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['load'],['load']
Performance,":string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:36982,cache,cache,36982,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,3,['cache'],['cache']
Performance,":string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:41591,cache,cache,41591,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,":string_view name, std::string_view expression, RLoopManager &lm, const RColumnRegister &colRegister, std::shared_ptr< RNodeBase > *upcastNodeOnHeap);  Book the jitting of a DefinePerSample call. ;  ; std::shared_ptr< RDFDetail::RJittedFilter > BookFilterJit (std::shared_ptr< RDFDetail::RNodeBase > *prevNodeOnHeap, std::string_view name, std::string_view expression, const ColumnNames_t &branches, const RColumnRegister &colRegister, TTree *tree, RDataSource *ds);  Book the jitting of a Filter call. ;  ; std::shared_ptr< RJittedVariation > BookVariationJit (const std::vector< std::string > &colNames, std::string_view variationName, const std::vector< std::string > &variationTags, std::string_view expression, RLoopManager &lm, RDataSource *ds, const RColumnRegister &colRegister, const ColumnNames_t &branches, std::shared_ptr< RNodeBase > *upcastNodeOnHeap, bool isSingleColumn);  Book the jitting of a Vary call. ;  ; template<typename T > ; constexpr std::size_t CacheLineStep ();  Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line. ;  ; void ChangeEmptyEntryRange (const ROOT::RDF::RNode &node, std::pair< ULong64_t, ULong64_t > &&newRange);  ; void ChangeSpec (const ROOT::RDF::RNode &node, ROOT::RDF::Experimental::RDatasetSpec &&spec);  Changes the input dataset specification of an RDataFrame. ;  ; void CheckForDefinition (const std::string &where, std::string_view definedColView, const RColumnRegister &colRegister, const ColumnNames_t &treeColumns, const ColumnNames_t &dataSourceColumns);  Throw if column definedColView is not already there. ;  ; void CheckForDuplicateSnapshotColumns (const ColumnNames_t &cols);  ; void CheckForNoVariations (const std::string &where, std::string_view definedColView, const RColumnRegister &colRegister);  Throw if the column has systematic variations attached. ;  ; void CheckForRedefinition (const std::string &where, std::string_view definedColView, const RColumnRegister &colRegister, const ColumnNames_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:7131,Cache,CacheLineStep,7131,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,3,"['Cache', 'cache']","['CacheLineStep', 'cache']"
Performance,":~RooProdPdf ; (; ). override . Destructor. ; Definition at line 349 of file RooProdPdf.cxx. Member Function Documentation. ◆ addPdfs(). void RooProdPdf::addPdfs ; (; RooAbsCollection const & ; pdfs). Add some full PDFs to the factors of this RooProdPdf. ; Definition at line 1862 of file RooProdPdf.cxx. ◆ analyticalIntegralWN(). double RooProdPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Return analytical integral defined by given scenario code. ; Reimplemented from RooAbsPdf.; Definition at line 1622 of file RooProdPdf.cxx. ◆ binBoundaries(). std::list< double > * RooProdPdf::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; Reimplemented from RooAbsReal.; Definition at line 2141 of file RooProdPdf.cxx. ◆ calculate(). double RooProdPdf::calculate ; (; const RooProdPdf::CacheElem & ; cache, . bool ; verbose = false . ); const. private . Calculate running product of pdfs terms, using the supplied normalization set in 'normSetList' for each component. ; Definition at line 382 of file RooProdPdf.cxx. ◆ canNodeBeCached(). CacheMode RooProdPdf::canNodeBeCached ; (; ); const. inlineoverrideprivatevirtual . Reimplemented from RooAbsArg.; Definition at line 131 of file RooProdPdf.h. ◆ Class(). static TClass * RooProdPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooProdPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooProdPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 190 of file RooProdPdf.h. ◆ clone(). TObject * RooProdPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 55 of file RooProdPdf.h. ◆ compileForNormSet()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:86201,Cache,CacheElem,86201,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"; ""BackSmoothing9""; ""BackSmoothing11""; ""BackSmoothing13""; ""BackSmoothing15""; - ""Compton"" if selected the estimation of Compton edge; will be included.; - ""same"" : if this option is specified, the resulting background; histogram is superimposed on the picture in the current pad. NOTE that the background is only evaluated in the current range of h.; ie, if h has a bin range (set via h->GetXaxis()->SetRange(binmin,binmax),; the returned histogram will be created with the same number of bins; as the input histogram h, but only bins from binmin to binmax will be filled; with the estimated background. void Print(Option_t* option = """") const; Print the array of positions. Int_t Search(const TH1* hist, Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05). TWO-DIMENSIONAL PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum in hin; The number of found peaks and their positions are written into; the members fNpeaks and fPositionX.; The search is performed in the current histogram range. Function parameters:; hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than; threshold*highest_peak are discarded. 0<threshold<1. By default, the background is removed before deconvolution.; Specify the option ""nobackground"" to not remove the background. //. By default the ""Markov"" chain algorithm is used.; Specify the option ""noMarkov"" to disable this algorithm; Note that by default the source spectrum is replaced by a new spectrum//. By default a polymarker object is created and added to the list of; functions of the histogram. The histogram is drawn with the specified; option and the polymarker object drawn on top of the histogram.; The polymarker coordinates correspond to the npeaks peaks found in; the histogram.; A pointer to the polymarker object can be retrieved later via:; TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2.html:11673,perform,performed,11673,root/html528/TSpectrum2.html,https://root.cern,https://root.cern/root/html528/TSpectrum2.html,4,['perform'],['performed']
Performance,"; # --------------------------------------------------------------; ; # ROOT.RooDataSet is an unbinned dataset (a collection of points in; # N-dimensional space); d = ROOT.RooDataSet(""d"", ""d"", {x, y, c}); ; # Unlike ROOT.RooAbsArgs (ROOT.RooAbsPdf, ROOT.RooFormulaVar,....) datasets are not attached to; # the variables they are constructed from. Instead they are attached to an internal; # clone of the supplied set of arguments; ; # Fill d with dummy values; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is specified. In that case a null ptr is returned; d.get(900).Print(""v""); print(""""); ; # Reducing, appending and merging; # -------------------------------------------------------------; ; # The reduce() function returns a dataset which is a subset of the; # original; print(""\n >> d1 has only columns x,c""); d1 = d.reduce({x, c}); d1.Print(""v""); ; print(""\n >> d2 has only column y""); d2 = d.reduce({y}); d2.Print(""v""); ; print(""\n >> d3 has only the points with y>5.17""); d3 = d.reduce(""y>5.17""); d3.Print(""v""); ; print(""\n >> d4 has only columns x, for data points with y>5.17""); d4 = d.reduce({x, c}, ""y>5.17""); d4.Print(""v""); ; # The merge() function adds two data set column-wise; print(""\n >> merge d2(y) with d1(x,c) to form d1(x,c,y)""); d1.merge(d2); d1.Print(""v""); ; # The append() function adds two datasets row-wise; print(""\n >> append data points of d3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:1852,load,loads,1852,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['load'],['loads']
Performance,"; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf607_fitresult.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf607__fitresult_8py.html:4420,optimiz,optimization,4420,doc/master/rf607__fitresult_8py.html,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html,2,['optimiz'],['optimization']
Performance,"; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/CrossValidation.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Factory.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; ; // Helper function to load data into TTrees.; TTree *genTree(Int_t nPoints, Double_t offset, Double_t scale, UInt_t seed = 100); {; TRandom3 rng(seed);; Float_t x = 0;; Float_t y = 0;; UInt_t eventID = 0;; ; TTree *data = new TTree();; data->Branch(""x"", &x, ""x/F"");; data->Branch(""y"", &y, ""y/F"");; data->Branch(""eventID"", &eventID, ""eventID/I"");; ; for (Int_t n = 0; n < nPoints; ++n) {; x = rng.Gaus(offset, scale);; y = rng.Gaus(offset, scale);; ; // For our simple example it is enough that the id's are uniformly; // distributed and independent of the data.; ++eventID;; ; data->Fill();; }; ; // Important: Disconnects the tree from the memory locations of x and y.; data->ResetBranchAddresses();; return data;; }; ; int TMVACrossValidation(bool useRandomSplitting = false); {; // This loads the library; TMVA::Tools::Instance();; ; // --------------------------------------------------------------------------; ; // Load the data into TTrees. If you load data from file you can use a; // variant of; // ```; // TString filename = ""/path/to/file"";; // TFile * input = TFile::Open( filename );; // TTree * signalTree = (TTree*)input->Get(""TreeName"");; // ```; TTree *sigTree = genTree(1000, 1.0, 1.0, 100);; TTree *bkgTree = genTree(1000, -1.0, 1.0, 101);; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVACV.root"");; TFile *outputFile = TFile::Open(outfileName, ""RECREATE"");; ; // DataLoader definitions; We declare variables in the tree so that TMVA can; // find them. For more information see TMVAClassification tutorial.; TMVA::DataLoader *dataloader = new TMVA::DataLoader(""datasetcv"");; ; // Data variables; dataloader->AddVariable(""x"", 'F');; dataloader->AddVariable(""y"", 'F');; ; // Spectator used for split; dataloader->AddSpectator(""eventI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:19819,load,loads,19819,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,2,"['Load', 'load']","['Load', 'loads']"
Performance,"; (; ). Method to get a R prompt to work interactively with tab completion support. ; Definition at line 161 of file TRInterface.cxx. ◆ IsA(). virtual TClass * ROOT::R::TRInterface::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 320 of file TRInterface.h. ◆ IsInstalled(). Bool_t TRInterface::IsInstalled ; (; TString ; pkg). Method to verify if a package is installed. ; Parameters. pkgR's pkg name . Returnstrue or false if the package is installed or not ; Definition at line 193 of file TRInterface.cxx. ◆ operator[](). TRInterface::Binding TRInterface::operator[] ; (; const TString & ; name). Definition at line 142 of file TRInterface.cxx. ◆ ProcessEventsLoop(). void TRInterface::ProcessEventsLoop ; (; ). Init event loop in a thread to support actions in windows from R graphics system. ; Definition at line 219 of file TRInterface.cxx. ◆ Require(). Bool_t TRInterface::Require ; (; TString ; pkg). Method to load an R's package. ; Parameters. pkgR's pkg name . Returnstrue or false if the package was loaded or not ; Definition at line 200 of file TRInterface.cxx. ◆ SetVerbose(). void TRInterface::SetVerbose ; (; Bool_t ; status). Method to set verbose mode, that produce extra output. ; Notesome time can produce so much noise in the output ; Parameters. statusboolean to enable of disable . Definition at line 134 of file TRInterface.cxx. ◆ Streamer(). virtual void ROOT::R::TRInterface::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ROOT::R::TRInterface::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 320 of file TRInterface.h. Member Data Documentation. ◆ fR. RInside* ROOT::R::TRInterface::fR. protected . Definition at line 138 of file TRInterface.h. ◆ th. TThread* ROOT::R::TRInterface::th. protected . Definition at line 139 of file TRInterface.h. Libraries for ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:23855,load,load,23855,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['load'],['load']
Performance,"; (; ). inlineprivate . Get the slot number for this threadID, make a slot if needed. ; Definition at line 338 of file TThreadedObject.hxx. ◆ Merge(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::Merge ; (; TThreadedObjectUtils::MergeFunctionType< T > ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called once: it does not create any new object but destroys the present bookkeping collapsing all objects into the one at slot 0. ; Definition at line 294 of file TThreadedObject.hxx. ◆ operator->(). template<class T > . T * ROOT::TThreadedObject< T >::operator-> ; (; ). inline . Access the wrapped object and allow to call its methods. ; Definition at line 286 of file TThreadedObject.hxx. ◆ SetAtSlot(). template<class T > . void ROOT::TThreadedObject< T >::SetAtSlot ; (; unsigned ; i, . std::shared_ptr< T > ; v . ). inline . Set the value of a particular slot. ; This method is thread-safe as long as concurrent calls access different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of SetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 227 of file TThreadedObject.hxx. ◆ SnapshotMerge(). template<class T > . std::unique_ptr< T > ROOT::TThreadedObject< T >::SnapshotMerge ; (; TThreadedObjectUtils::MergeFunctionType< T > ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called many times. It does create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. ◆ fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:8624,concurren,concurrent,8624,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['concurren'],['concurrent']
Performance,"; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3211 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to type with name. ; Definition at line 1562 of file TROOT.cxx. ◆ GetUUIDs(). TProcessUUID * TROOT::GetUUIDs ; (; ); const. inline . Definition at line 275 of file TROOT.h. ◆ GetVersion(). const char * TROOT::GetVersion ; (; ); const. inline . Definition at line 230 of file TROOT.h. ◆ GetVersionCode(). Int_t TROOT::GetVersionCode ; (; ); const. inline . Definition at line 229 of file TROOT.h. ◆ GetVersionDate(). Int_t TROOT::GetVersionDate ; (; ); const. inline . Definition at line 226 of file TROOT.h. ◆ GetVersionInt(). Int_t TROOT::GetVersionInt ; (; ); const. inline . Definition at line 228 of file TROOT.h. ◆ GetVersionTime(). Int_t TROOT::GetVersionTime ; (; ); const. inline . Definition at line 227 of file TROOT.h. ◆ GetWebDisplay(). const TString & TROOT::GetWebDisplay ; (; ); const. inline . Definition at line 276 of file TROOT.h. ◆ Idle(). void TROOT::Idle ; (; UInt_t ; idleTimeInSec, . const char * ; command = nullptr . ). Execute command ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:61946,load,load,61946,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['load'],['load']
Performance,"; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3151 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3193 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3119 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3215 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to type with name. ; Definition at line 1562 of file TROOT.cxx. ◆ GetUUIDs(). TProcessUUID * TROOT::GetUUIDs ; (; ); const. inline . Definition at line 275 of file TROOT.h. ◆ GetVersion(). const char * TROOT::GetVersion ; (; ); const. inline . Definition at line 230 of file TROOT.h. ◆ GetVersionCode(). Int_t TROOT::GetVersionCode ; (; ); const. inline . Definition at line 229 of file TROOT.h. ◆ GetVersionDate(). Int_t TROOT::GetVersionDate ; (; ); const. inline . Definition at line 226 of file TROOT.h. ◆ GetVersionInt(). Int_t TROOT::GetVersionInt ; (; ); const. inline . Definition at line 228 of file TROOT.h. ◆ GetVersionTime(). Int_t TROOT::GetVersionTime ; (; ); const. inline . Definition at line 227 of file TROOT.h. ◆ GetWebDisplay(). const TString & TROOT::GetWebDisplay ; (; ); const. inline . Definition at line 276 of file TROOT.h. ◆ Idle(). void TROOT::Idle ; (; UInt_t ; idleTimeInSec, . const char * ; command = nullptr . ). Execute command ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:61915,load,load,61915,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['load'],['load']
Performance,"; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 124 of file TSelEvent.h. ◆ Notify(). virtual Bool_t TSelEvent::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Process(). Bool_t TSelEvent::Process ; (; Long64_t ; entry). virtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 201 of file TSelEvent.cxx. ◆ SetInputList(). virtual void TSelEvent::SetInputList ; (; TList * ; input). inlinevirtual . Reimplemented from TSelector.; Definition at line 113 of file TSelEvent.h. ◆ SetObject(). virtual void TSelEvent::SetObject ; (; TObject * ; obj). inlinevirtual . Reimplemented from TSelector.; Definition at line 112 of file TSelEvent.h. ◆ SetOption(). virtual void TSelEvent::SetOption ; (; const char * ; option). inlinevirtual . Reimplemented from TSelector.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEvent.html:17703,load,loaded,17703,doc/master/classTSelEvent.html,https://root.cern,https://root.cern/doc/master/classTSelEvent.html,1,['load'],['loaded']
Performance,"; (; ); const. virtual . Get full type description of global variable, e,g.: ""class TDirectory*"". ; Reimplemented in TEnumConstant, and TGlobalMappedFunction.; Definition at line 124 of file TGlobal.cxx. ◆ GetMaxIndex(). Int_t TGlobal::GetMaxIndex ; (; Int_t ; dim); const. virtual . Return maximum index for array dimension ""dim"". ; Reimplemented in TGlobalMappedFunction.; Definition at line 105 of file TGlobal.cxx. ◆ GetTypeName(). const char * TGlobal::GetTypeName ; (; ); const. virtual . Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"". ; Result needs to be used or copied immediately. ; Reimplemented in TEnumConstant, and TGlobalMappedFunction.; Definition at line 115 of file TGlobal.cxx. ◆ IsA(). TClass * TGlobal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDictionary.; Definition at line 49 of file TGlobal.h. ◆ IsValid(). Bool_t TGlobal::IsValid ; (; ). virtual . Return true if this global object is pointing to a currently loaded global. ; If a global is unloaded after the TGlobal is created, the TGlobal will be set to be invalid. ; Definition at line 135 of file TGlobal.cxx. ◆ operator=(). TGlobal & TGlobal::operator= ; (; const TGlobal & ; rhs). Assignment operator. ; Definition at line 53 of file TGlobal.cxx. ◆ Property(). Long_t TGlobal::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Reimplemented in TGlobalMappedFunction.; Definition at line 152 of file TGlobal.cxx. ◆ Streamer(). void TGlobal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TDictionary. ◆ StreamerNVirtual(). void TGlobal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file TGlobal.h. ◆ Update(). Bool_t TGlobal::Update ; (; DataMemberInfo_t * ; info). virtual . Update the TFunction to reflect the new info. ; This ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGlobal.html:17093,load,loaded,17093,doc/master/classTGlobal.html,https://root.cern,https://root.cern/doc/master/classTGlobal.html,1,['load'],['loaded']
Performance,"; (; Int_t ; ix, . Int_t ; iy, . Window_t ; id = 0 . ). overridevirtual . Sets the pointer position. ; Parameters. [in]ixnew X coordinate of pointer ; [in]iynew Y coordinate of pointer ; [in]idwindow identifier. Coordinates are relative to the origin of the window id or to the origin of the current window if id == 0. ; Reimplemented from TVirtualX. ◆ WMDeleteNotify(). void TGWin32VirtualXProxy::WMDeleteNotify ; (; Window_t ; id). overridevirtual . Tells WM to send message when window is closed via WM. ; Reimplemented from TVirtualX. ◆ WriteGIF(). Int_t TGWin32VirtualXProxy::WriteGIF ; (; char * ; name). overridevirtual . Writes the current window into GIF file. ; Returns 1 in case of success, 0 otherwise. ; Reimplemented from TVirtualX. ◆ WritePixmap(). void TGWin32VirtualXProxy::WritePixmap ; (; Int_t ; wid, . UInt_t ; w, . UInt_t ; h, . char * ; pxname . ). overridevirtual . Writes the pixmap ""wid"" in the bitmap file ""pxname"". ; Parameters. [in]widthe pixmap address ; [in]w,hthe width and height of the pixmap. ; [in]pxnamethe file name . Reimplemented from TVirtualX. ◆ XorRegion(). void TGWin32VirtualXProxy::XorRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Calculates the difference between the union and intersection of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented from TVirtualX. Friends And Related Symbol Documentation. ◆ TGWin32. friend class TGWin32. friend . Definition at line 32 of file TGWin32VirtualXProxy.h. Member Data Documentation. ◆ fgRealObject. TVirtualX * TGWin32VirtualXProxy::fgRealObject = 0. staticprotected . Definition at line 35 of file TGWin32VirtualXProxy.h. graf2d/win32gdk/inc/TGWin32VirtualXProxy.h; graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx. TGWin32VirtualXProxy. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:42 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:125269,perform,perform,125269,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['perform'],['perform']
Performance,"; (; Option_t * ; option = """"). overridevirtual . Performs redo action. Move cursor position forward in history stack. ; Reimplemented from TQCommand.; Definition at line 1053 of file TQCommand.cxx. ◆ SetLimit(). void TQUndoManager::SetLimit ; (; UInt_t ; limit). virtual . Returns a maximum number of commands which could be located in stack. ; Definition at line 1137 of file TQCommand.cxx. ◆ SetLogging(). void TQUndoManager::SetLogging ; (; Bool_t ; on = kTRUE). virtual . Start logging. ; Delete all previous log records Note: logging is not implemented yet ; Definition at line 938 of file TQCommand.cxx. ◆ Streamer(). void TQUndoManager::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TQCommand. ◆ StreamerNVirtual(). void TQUndoManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 133 of file TQCommand.h. ◆ Undo(). void TQUndoManager::Undo ; (; Option_t * ; option = """"). overridevirtual . Performs undo action. Move cursor position backward in history stack. ; Reimplemented from TQCommand.; Definition at line 1021 of file TQCommand.cxx. Member Data Documentation. ◆ fCurrent. TQCommand* TQUndoManager::fCurrent. protected . Definition at line 107 of file TQCommand.h. ◆ fCursor. TObjLink* TQUndoManager::fCursor. protected . Definition at line 106 of file TQCommand.h. ◆ fLimit. UInt_t TQUndoManager::fLimit. protected . Definition at line 108 of file TQCommand.h. ◆ fLogBook. TList* TQUndoManager::fLogBook. protected . Definition at line 109 of file TQCommand.h. ◆ fLogging. Bool_t TQUndoManager::fLogging. protected . Definition at line 110 of file TQCommand.h. Libraries for TQUndoManager:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TQCommand.h; core/base/src/TQCommand.cxx. TQUndoManager. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:32999,Perform,Performs,32999,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['Perform'],['Performs']
Performance,"; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsArg.; Definition at line 1179 of file RooRealIntegral.cxx. ◆ createIntegral(). RooFit::OwningPtr< RooAbsReal > RooRealIntegral::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. overridevirtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented from RooAbsReal.; Definition at line 746 of file RooRealIntegral.cxx. ◆ DeclFileName(). static const char * RooRealIntegral::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 150 of file RooRealIntegral.h. ◆ evaluate(). double RooRealIntegral::evaluate ; (; ); const. overrideprotectedvirtual . Perform the integration and return the result. ; Implements RooAbsReal.; Definition at line 802 of file RooRealIntegral.cxx. ◆ funcNormSet(). RooArgSet const * RooRealIntegral::funcNormSet ; (; ); const. inline . Definition at line 83 of file RooRealIntegral.h. ◆ getAllowComponentSelection(). bool RooRealIntegral::getAllowComponentSelection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:67981,perform,performed,67981,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,2,['perform'],['performed']
Performance,"; (; TFile * ; file). Constructor. ; Definition at line 54 of file TFilePrefetch.cxx. ◆ ~TFilePrefetch(). TFilePrefetch::~TFilePrefetch ; (; ). override . Destructor. ; Definition at line 72 of file TFilePrefetch.cxx. Member Function Documentation. ◆ AddPendingBlock(). void TFilePrefetch::AddPendingBlock ; (; TFPBlock * ; block). Safe method to add a block to the pendingList. ; Definition at line 223 of file TFilePrefetch.cxx. ◆ AddReadBlock(). void TFilePrefetch::AddReadBlock ; (; TFPBlock * ; block). Safe method to add a block to the readList. ; Definition at line 259 of file TFilePrefetch.cxx. ◆ BinarySearchReadList(). Bool_t TFilePrefetch::BinarySearchReadList ; (; TFPBlock * ; blockObj, . Long64_t ; offset, . Int_t ; len, . Int_t * ; index . ). Search for a requested element in a block and return the index. ; Definition at line 144 of file TFilePrefetch.cxx. ◆ CheckBlockInCache(). Bool_t TFilePrefetch::CheckBlockInCache ; (; char *& ; path, . TFPBlock * ; block . ). Test if the block is in cache. ; Definition at line 395 of file TFilePrefetch.cxx. ◆ Class(). static TClass * TFilePrefetch::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFilePrefetch::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFilePrefetch::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 84 of file TFilePrefetch.h. ◆ CreateBlockObj(). TFPBlock * TFilePrefetch::CreateBlockObj ; (; Long64_t * ; offset, . Int_t * ; len, . Int_t ; noblock . ). Create a new block or recycle an old one. ; Definition at line 281 of file TFilePrefetch.cxx. ◆ DeclFileName(). static const char * TFilePrefetch::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 84 of file TFilePrefetch.h. ◆ GetBlockFromCache(). char * TFilePrefetch::GetBlockFromCache ; (; const char * ; path, . Int_t ; length . ). Return a b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:14495,cache,cache,14495,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['cache'],['cache']
Performance,"; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedReal.; Definition at line 165 of file RooCachedReal.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ; If this p.d.f is operated in automatic mode, return the parameters of the external input p.d.f ; Implements RooAbsCachedReal.; Definition at line 178 of file RooCachedReal.cxx. ◆ cacheSource(). bool RooCachedReal::cacheSource ; (; ); const. inline . Definition at line 42 of file RooCachedReal.h. ◆ Class(). static TClass * RooCachedReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCachedReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCachedReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 72 of file RooCachedReal.h. ◆ clone(). TObject * RooCachedReal::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 28 of file RooCachedReal.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooCachedReal::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Interface function to create an internal cache object that represent each cached function configuration. ; This interface allows to create and return a class derived from RooAbsCachedReal::FuncCacheElem so th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:66001,cache,cacheSource,66001,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cacheSource']
Performance,"; (; const TObject * ; obj, . Bool_t ; cacheReuse . ). virtual . Implements TBuffer. ◆ WriteObject() [3/3]. void TBufferIO::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; Implements TBuffer.; Definition at line 530 of file TBufferIO.cxx. ◆ WriteObjectAny(). Int_t TBufferIO::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; This function assumes that the value in 'obj' is the value stored in a pointer to a ""ptrClass"". The actual type of the object pointed to can be any class derived from ""ptrClass"". Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). If 'cacheReuse' is true (default) upon seeing an object address a second time, we record the offset where its was written the first time rather than streaming the object a second time. If 'cacheReuse' is false, we always stream the object. This allows the (re)use of temporary object to store different data in the same buffer. ; Implements TBuffer.; Definition at line 492 of file TBufferIO.cxx. ◆ WriteObjectClass(). virtual void TBufferIO::WriteObjectClass ; (; const void * ; actualObjStart, . const TClass * ; actualClass, . Bool_t ; cacheReuse . ). protectedpure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ WriteProcessID(). UShort_t TBufferIO::WriteProcessID ; (; TProcessID * ; pid). overridevirtual . Check if the ProcessID pid is already in the file. ; If not, add it and return the index number in the local file list. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 456 of file TBufferIO.cxx. Member Data Documentation. ◆ fClassMap. TExMap* TBufferIO::fClassMap {nullptr}. protected . Map containing object,class pairs for reading. ; Definition at line 40 of file TBufferIO.h. ◆ fDisplacement. Int_t TBufferIO::fDisplacement {0}. protected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:43412,cache,cacheReuse,43412,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance,"; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5749 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:102590,Load,LoadClassDefault,102590,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['Load'],['LoadClassDefault']
Performance,"; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5816 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:102591,Load,LoadClassDefault,102591,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['Load'],['LoadClassDefault']
Performance,"; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 181 of file RooTreeDataStore.h. ◆ Draw(). void RooTreeDataStore::Draw ; (; Option_t * ; option = """"). overridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 1133 of file RooTreeDataStore.cxx. ◆ Fill(). Int_t RooTreeDataStore::Fill ; (; ). Interface function to TTree::Fill. ; Definition at line 1113 of file RooTreeDataStore.cxx. ◆ fill(). Int_t RooTreeDataStore::fill ; (; ). overridevirtual . Interface function to TTree::Fill. ; Implements RooAbsDataStore.; Definition at line 541 of file RooTreeDataStore.cxx. ◆ get() [1/3]. virtual const RooArgSet * RooAbsDataStore::get ; (; ); const. inlinevirtual . Reimplemented from RooAbsDataStore.; Definition at line 60 of file RooAbsDataStore.h. ◆ get() [2/3]. const RooArgSet * RooTreeDataStore::get ; (; Int_t ; index); const. overridevirtual . Load the n-th data point (n='index') in memory and return a pointer to the internal RooArgSet holding its coordinates. ; Implements RooAbsDataStore.; Definition at line 553 of file RooTreeDataStore.cxx. ◆ get() [3/3]. virtual const RooArgSet * RooAbsDataStore::get ; (; Int_t ; index); const. virtual . Implements RooAbsDataStore. ◆ getBatches(). RooAbsData::RealSpans RooTreeDataStore::getBatches ; (; std::size_t ; first, . std::size_t ; len . ); const. inlineoverridevirtual . Retrieve batches for all observables in this data store. ; Implements RooAbsDataStore.; Definition at line 76 of file RooTreeDataStore.h. ◆ getBranchBufferSize(). Int_t RooTreeDataStore::getBranchBufferSize ; (; ); const. inlineprivate . Definition at line 153 of file RooTreeDataStore.h. ◆ GetEntries(). Stat_t RooTreeDataStore::GetEntries ; (; ); const. Interface function to TTree::GetEntries. ; Definition at line 1095 of file RooTreeDataStore.cxx. ◆ GetEntry(). Int_t RooTreeDataStore::GetEntry ; (; Int_t ; entry = 0, . Int_t ; getall = 0 . ). Interface function to TTree::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:31210,Load,Load,31210,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['Load'],['Load']
Performance,"; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file RegressionVariance.h. ◆ DeclFileName(). static const char * TMVA::RegressionVariance::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file RegressionVariance.h. ◆ GetName(). TString TMVA::RegressionVariance::GetName ; (; ). inline . Definition at line 88 of file RegressionVariance.h. ◆ GetSeparationGain(). Double_t TMVA::RegressionVariance::GetSeparationGain ; (; const Double_t ; nLeft, . const Double_t ; targetLeft, . const Double_t ; target2Left, . const Double_t ; nTot, . const Double_t ; targetTot, . const Double_t ; target2Tot . ). Separation Gain: the measure of how the quality of separation of the sample increases by splitting the sample e.g. ; into a ""left-node"" and a ""right-node"" (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) this is then the quality criteria which is optimized for when trying to increase the information in the system for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)) which is used as a ""separation"" index should be as small as possible. the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... ; Definition at line 69 of file RegressionVariance.cxx. ◆ GetSeparationIndex(). Double_t TMVA::RegressionVariance::GetSeparationIndex ; (; const Double_t ; n, . const Double_t ; target, . const Double_t ; target2 . ). virtual . Separation Index: a simple Variance. ; Definition at line 88 of file RegressionVariance.cxx. ◆ IsA(). virtual TClass * TMVA::RegressionVariance::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 94 of file RegressionVariance.h. ◆ Streamer(). virtual void TMVA::RegressionVariance::Streamer ; (; TBuffer & ; ). virtual . ◆ StreamerNVirtual(). void TMVA::RegressionVariance::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 94 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RegressionVariance.html:3869,optimiz,optimized,3869,doc/master/classTMVA_1_1RegressionVariance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RegressionVariance.html,1,['optimiz'],['optimized']
Performance,"; ). privatedelete . ◆ RecursiveRemove(). void THashList::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 310 of file THashList.cxx. ◆ Rehash(). void THashList::Rehash ; (; Int_t ; newCapacity). Rehash the hashlist. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. ; Definition at line 368 of file THashList.cxx. ◆ Remove() [1/2]. TObject * THashList::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 378 of file THashList.cxx. ◆ Remove() [2/2]. TObject * THashList::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 391 of file THashList.cxx. ◆ Streamer(). void THashList::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:32167,perform,performance,32167,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['perform'],['performance']
Performance,"; ); const. Return the wrapper around Merge. ; Definition at line 7431 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . const char * ; params, . Bool_t ; objectIsConst = kFALSE . ). Find the best method (if there is one) matching the parameters. ; The params string must contain argument values, like ""3189, \""aap\"", 1.3"". The function invokes GetClassMethod to search for a possible method in the class itself or in its base classes. Returns 0 in case method is not found. ; Definition at line 4411 of file TClass.cxx. ◆ GetMethodAllAny(). TMethod * TClass::GetMethodAllAny ; (; const char * ; method). Return pointer to method without looking at parameters. ; Does look in all base classes. ; Definition at line 4384 of file TClass.cxx. ◆ GetMethodAny(). TMethod * TClass::GetMethodAny ; (; const char * ; method). Return pointer to method without looking at parameters. ; Does not look in (possible) base classes. Has the side effect of loading all the TMethod object in the list of the class. ; Definition at line 4374 of file TClass.cxx. ◆ GetMethodList(). TListOfFunctions * TClass::GetMethodList ; (; ). private . Return (create an empty one if needed) the list of functions. ; The major difference with GetListOfMethod is that this returns the internal type of fMethod and thus can not be made public. It also never 'loads' the content of the list. ; Definition at line 4355 of file TClass.cxx. ◆ GetMethodWithPrototype(). TMethod * TClass::GetMethodWithPrototype ; (; const char * ; method, . const char * ; proto, . Bool_t ; objectIsConst = kFALSE, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Find the method with a given prototype. ; The proto string must be of the form: ""char*,int,double"". Returns 0 in case method is not found. ; Definition at line 4456 of file TClass.cxx. ◆ GetMissingDictionaries(). void TClass::GetMissingDictionaries ; (; THashTable & ; result, . bool ; recurse = false . ). Get the classes that have ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:85530,load,loading,85530,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loading']
Performance,"; ); const. Return the wrapper around Merge. ; Definition at line 7498 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . const char * ; params, . Bool_t ; objectIsConst = kFALSE . ). Find the best method (if there is one) matching the parameters. ; The params string must contain argument values, like ""3189, \""aap\"", 1.3"". The function invokes GetClassMethod to search for a possible method in the class itself or in its base classes. Returns 0 in case method is not found. ; Definition at line 4478 of file TClass.cxx. ◆ GetMethodAllAny(). TMethod * TClass::GetMethodAllAny ; (; const char * ; method). Return pointer to method without looking at parameters. ; Does look in all base classes. ; Definition at line 4451 of file TClass.cxx. ◆ GetMethodAny(). TMethod * TClass::GetMethodAny ; (; const char * ; method). Return pointer to method without looking at parameters. ; Does not look in (possible) base classes. Has the side effect of loading all the TMethod object in the list of the class. ; Definition at line 4441 of file TClass.cxx. ◆ GetMethodList(). TListOfFunctions * TClass::GetMethodList ; (; ). private . Return (create an empty one if needed) the list of functions. ; The major difference with GetListOfMethod is that this returns the internal type of fMethod and thus can not be made public. It also never 'loads' the content of the list. ; Definition at line 4422 of file TClass.cxx. ◆ GetMethodWithPrototype(). TMethod * TClass::GetMethodWithPrototype ; (; const char * ; method, . const char * ; proto, . Bool_t ; objectIsConst = kFALSE, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Find the method with a given prototype. ; The proto string must be of the form: ""char*,int,double"". Returns 0 in case method is not found. ; Definition at line 4523 of file TClass.cxx. ◆ GetMissingDictionaries(). void TClass::GetMissingDictionaries ; (; THashTable & ; result, . bool ; recurse = false . ). Get the classes that have ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:85531,load,loading,85531,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loading']
Performance,"; ); const. inline . Definition at line 237 of file TProofServ.h. ◆ GetProtocol(). Int_t TProofServ::GetProtocol ; (; ); const. inline . Definition at line 252 of file TProofServ.h. ◆ GetQuerySeqNum(). Int_t TProofServ::GetQuerySeqNum ; (; ); const. inline . Definition at line 260 of file TProofServ.h. ◆ GetRealTime(). Float_t TProofServ::GetRealTime ; (; ); const. inline . Definition at line 258 of file TProofServ.h. ◆ GetResMemMax(). Long_t TProofServ::GetResMemMax ; (; ). static . ResMemMax getter. ; Definition at line 6927 of file TProofServ.cxx. ◆ GetService(). const char * TProofServ::GetService ; (; ); const. inline . Definition at line 238 of file TProofServ.h. ◆ GetSessionDir(). const char * TProofServ::GetSessionDir ; (; ); const. inline . Definition at line 247 of file TProofServ.h. ◆ GetSessionStatus(). Int_t TProofServ::GetSessionStatus ; (; ). protected . Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ; Definition at line 6786 of file TProofServ.cxx. ◆ GetSessionTag(). const char * TProofServ::GetSessionTag ; (; ); const. inline . Definition at line 245 of file TProofServ.h. ◆ GetSocket(). TSocket * TProofServ::GetSocket ; (; ); const. inline . Definition at line 257 of file TProofServ.h. ◆ GetTopSessionTag(). const char * TProofServ::GetTopSessionTag ; (; ); const. inline . Definition at line 246 of file TProofServ.h. ◆ GetTotSessions(). Int_t TProofServ::GetTotSessions ; (; ); const. inline . Definition at line 262 of file TProofServ.h. ◆ GetUser(). const char * TProofServ::GetUser ; (; ); const. inline . Definition at line 241 of file TProofServ.h. ◆ GetVirtMemMax(). Long_t TProofServ::GetVirtMemMax ; (; ). static . VirtMemMax getter. ; Definition at line 6920 of file TProofServ.cxx. ◆ GetWorkDir(). const char * TProofServ::GetWorkDir ; (; ); const. inline . Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:42393,queue,queued,42393,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['queue'],['queued']
Performance,"; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24524,cache,cache,24524,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22633,cache,cache,22633,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Z axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad,; the histogram is reset and filled again with the projected contents of the TH3. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3.html:43808,perform,performing,43808,root/html534/TH3.html,https://root.cern,https://root.cern/root/html534/TH3.html,1,['perform'],['performing']
Performance,"; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:47214,Perform,Performs,47214,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['Perform'],['Performs']
Performance,"; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:1000,perform,performance,1000,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['perform'],['performance']
Performance,"; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMVA::SeparationBase Class ReferenceabstractTMVA. ; An interface to calculate the ""SeparationGain"" for different separation criteria used in various training algorithms. ; There are two things: the Separation Index, and the Separation Gain Separation Index: Measure of the ""purity"" of a sample. If all elements (events) in the sample belong to the same class (e.g. signal or background), than the separation index is 0 (meaning 100% purity (or 0% purity as it is symmetric. The index becomes maximal, for perfectly mixed samples eg. purity=50% , N_signal = N_bkg; Separation Gain: the measure of how the quality of separation of the sample increases by splitting the sample e.g. into a ""left-node"" and a ""right-node"" (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) this is then the quality criterion which is optimized for when trying to increase the information in the system (making the best selection ; Definition at line 82 of file SeparationBase.h. Public Member Functions;  SeparationBase ();  Constructor. ;  ;  SeparationBase (const SeparationBase &s);  Copy constructor. ;  ; virtual ~SeparationBase ();  ; const TString & GetName ();  ; virtual Double_t GetSeparationGain (const Double_t nSelS, const Double_t nSelB, const Double_t nTotS, const Double_t nTotB);  Separation Gain: the measure of how the quality of separation of the sample increases by splitting the sample e.g. ;  ; virtual Double_t GetSeparationIndex (const Double_t s, const Double_t b)=0;  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SeparationBase.html:1087,optimiz,optimized,1087,doc/master/classTMVA_1_1SeparationBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SeparationBase.html,1,['optimiz'],['optimized']
Performance,"; // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:68711,load,load,68711,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; // In PROOF option ""useList"" is processed in SlaveBegin and we do not need; // to do anything here; } else {; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; void h1analysisTreeReader::SlaveBegin(TTree *myTree){; ; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Init(myTree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.Data(), myTree);; ; //create histograms; hdmd = new TH1F(""hdmd"",""Dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs Dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:3961,perform,performs,3961,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['perform'],['performs']
Performance,"; 1014 // owned by a directory. (Otherwise we would need to make sure that a; 1015 // TDirectoryFile that has a TTree in it does a 'slow' TList::Delete.; 1016 delete fEntryList;; 1017 fEntryList=nullptr;; 1018 }; 1019 }; 1020 delete fTreeIndex;; 1021 fTreeIndex = nullptr;; 1022 delete fBranchRef;; 1023 fBranchRef = nullptr;; 1024 delete [] fClusterRangeEnd;; 1025 fClusterRangeEnd = nullptr;; 1026 delete [] fClusterSize;; 1027 fClusterSize = nullptr;; 1028 ; 1029 if (fTransientBuffer) {; 1030 delete fTransientBuffer;; 1031 fTransientBuffer = nullptr;; 1032 }; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:37778,cache,cache,37778,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"; 1024 psumw += pass->GetBinContent(i);; 1025 psumw2 += pass->GetSumw2()->At(i);; 1026 }; 1027 } else {; 1028 psumw = pass->GetSumOfWeights();; 1029 psumw2 = psumw;; 1030 }; 1031 if (TMath::Abs(psumw - psumw2) > 1e-6); 1032 bEffective = true;; 1033 ; 1034 Double_t tsumw = 0;; 1035 Double_t tsumw2 = 0;; 1036 if (total->GetSumw2()->fN > 0) {; 1037 for (int i = 0; i < total->GetNbinsX(); ++i) {; 1038 tsumw += total->GetBinContent(i);; 1039 tsumw2 += total->GetSumw2()->At(i);; 1040 }; 1041 } else {; 1042 tsumw = total->GetSumOfWeights();; 1043 tsumw2 = tsumw;; 1044 }; 1045 if (TMath::Abs(tsumw - tsumw2) > 1e-6); 1046 bEffective = true;; 1047 ; 1048 // we do not want to ignore the weights; 1049 // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; 1050 // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the; 1051 // histogram. Error calculation is performed ignoring the weights""); bEffective = false;; 1052 // }; 1053 ; 1054 // parse option; 1055 TString option = opt;; 1056 option.ToLower();; 1057 ; 1058 Bool_t bVerbose = false;; 1059 // pointer to function returning the boundaries of the confidence interval; 1060 //(is only used in the frequentist cases.); 1061 // Double_t (*pBound)(Int_t,Int_t,Double_t,Bool_t) = &TEfficiency::ClopperPearson; // default method; 1062 Double_t (*pBound)(Double_t, Double_t, Double_t, Bool_t) = &TEfficiency::ClopperPearson; // default method; 1063 // confidence level; 1064 Double_t conf = 0.682689492137;; 1065 // values for bayesian statistics; 1066 Bool_t bIsBayesian = false;; 1067 Double_t alpha = 1;; 1068 Double_t beta = 1;; 1069 ; 1070 // verbose mode; 1071 if (option.Contains(""v"")) {; 1072 option.ReplaceAll(""v"", """");; 1073 bVerbose = true;; 1074 if (bEffective); 1075 Info(""Divide"", ""weight will be considered in the Histogram Ratio"");; 1076 }; 1077 ; 1078 // confidence level; 1079 if (option.Contains(""cl="")) {; 1080 Double_t level = -1;; 1081 // cover",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:36389,perform,performed,36389,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['perform'],['performed']
Performance,"; 1057 fCurrent->fLastIndexQueried = -1;; 1058 }; 1059 }; 1060 ; 1061 //find the list with the next non-zero entry; 1062 while (result<0 && fCurrent!=((TEntryList*)fLists->Last())){; 1063 if (!fCurrent) return 0;; 1064 fCurrent->fLastIndexQueried = -1;; 1065 fCurrent->fLastIndexReturned = 0;; 1066 fCurrent = (TEntryList*)fLists->After(fCurrent);; 1067 // fCurrent is guarantee to be non-zero because it is not the 'last'; 1068 // element of the list.; 1069 if (!fCurrent) return 0;; 1070 if (!fShift); 1071 result = fCurrent->Next();; 1072 else {; 1073 if (fCurrent->GetTreeNumber() >= 0); 1074 result = fCurrent->Next();; 1075 }; 1076 }; 1077 fLastIndexQueried++;; 1078 fLastIndexReturned = result;; 1079 return result;; 1080 }; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Checks if the array representation is more economical and if so, switches to it; 1086 ; 1087void TEntryList::OptimizeStorage(); 1088{; 1089 if (fBlocks){; 1090 TEntryListBlock *block = nullptr;; 1091 for (Int_t i=0; i<fNBlocks; i++){; 1092 block = (TEntryListBlock*)fBlocks->UncheckedAt(i);; 1093 block->OptimizeStorage();; 1094 }; 1095 }; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Print this list; 1100/// - option = """" - default - print the name of the tree and file; 1101/// - option = ""all"" - print all the entry numbers; 1102 ; 1103void TEntryList::Print(const Option_t* option) const; 1104{; 1105 TString opt = option;; 1106 opt.ToUpper();; 1107 if (fBlocks) {; 1108 Printf(""%s %s %lld"", fTreeName.Data(), fFileName.Data(), fN);; 1109 if (opt.Contains(""A"")){; 1110 TEntryListBlock* block = nullptr;; 1111 for (Int_t i=0; i<fNBlocks; i++){; 1112 block = (TEntryListBlock*)fBlocks->UncheckedAt(i);; 1113 Int_t shift = i*kBlockSize;; 1114 block->PrintWithShift(shift);; 1115 }; 1116 }; 1117 }; 1118 else {; 1119 TEntryList *elist = nullptr;; 1120 if (fN>0){; 1121 TIter next(fLists);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:36489,Optimiz,OptimizeStorage,36489,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,2,['Optimiz'],['OptimizeStorage']
Performance,"; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:40543,cache,cache,40543,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"; 133 if (Use[""PDEFoam""]) // PDE-Foam approach; 134 factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"", ""!H:!V:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Nmin=100:Kernel=None:Compress=T"" );; 135 ; 136 ; 137 if (Use[""DL_CPU""]) {; 138 TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; 139 TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; 140 ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; 141 TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; 142 ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; 143 nnOptions.Append("":"");; 144 nnOptions.Append(layoutString);; 145 nnOptions.Append("":"");; 146 nnOptions.Append(trainingStrategyString);; 147 factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_CPU"", nnOptions);; 148 }; 149 if (Use[""DL_GPU""]) {; 150 TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; 151 TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; 152 ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; 153 TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; 154 ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; 155 nnOptions.Append("":"");; 156 nnOptions.Append(layoutString);; 157 nnOptions.Append("":"");; 158 nnOptions.Append(trainingStrategyString);; 159 factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; 160 }; 161 ; 162 ; 163 // Train MVAs using the set of training events; 164 factory->TrainAllMethods();; 165 ; 166 // Evaluate all MVAs using the set of test events; 167 factory->TestAllMethods();; 168 ; 169 // Evaluate and compare performance of all configured MVAs; 170 factory->EvaluateAllMethods();; 171 ; 172 // --------------------------------------------------------------; 173 ; 174 // Save the output; 175 outputFile->Close();; 176 ; 177 std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; 178 std::cout",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:6171,Optimiz,Optimizer,6171,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['Optimiz'],['Optimizer']
Performance,"; 1372 clingArgsStorage.push_back(""-I"" + interpInclude + ""/cling/plugins/include"");; 1373 ; 1374 // Add the root include directory and etc/ to list searched by default.; 1375 clingArgsStorage.push_back(std::string((""-I"" + TROOT::GetIncludeDir()).Data()));; 1376 ; 1377 // Add the current path to the include path; 1378 // TCling::AddIncludePath(""."");; 1379 ; 1380 // Attach the PCH (unless we have C++ modules enabled which provide the; 1381 // same functionality).; 1382 if (!fCxxModulesEnabled) {; 1383 std::string pchFilename = interpInclude + ""/allDict.cxx.pch"";; 1384 if (gSystem->Getenv(""ROOT_PCH"")) {; 1385 pchFilename = gSystem->Getenv(""ROOT_PCH"");; 1386 }; 1387 ; 1388 clingArgsStorage.push_back(""-include-pch"");; 1389 clingArgsStorage.push_back(pchFilename);; 1390 }; 1391 ; 1392 clingArgsStorage.push_back(""-Wno-undefined-inline"");; 1393 clingArgsStorage.push_back(""-fsigned-char"");; 1394 // The -O1 optimization flag has nasty side effects on Windows (32 and 64 bit); 1395 // See the GitHub issues #9809 and #9944; 1396 // TODO: to be reviewed after the upgrade of LLVM & Clang; 1397#ifndef _MSC_VER; 1398 clingArgsStorage.push_back(""-O1"");; 1399 // Disable optimized register allocation which is turned on automatically; 1400 // by -O1, but seems to require -O2 to not explode in run time.; 1401 clingArgsStorage.push_back(""-mllvm"");; 1402 clingArgsStorage.push_back(""-optimize-regalloc=0"");; 1403#endif; 1404 }; 1405 ; 1406 // Process externally passed arguments if present.; 1407 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(""EXTRA_CLING_ARGS"");; 1408 if (EnvOpt.has_value()) {; 1409 StringRef Env(*EnvOpt);; 1410 while (!Env.empty()) {; 1411 StringRef Arg;; 1412 std::tie(Arg, Env) = Env.split(' ');; 1413 clingArgsStorage.push_back(Arg.str());; 1414 }; 1415 }; 1416 ; 1417 auto GetEnvVarPath = [](const std::string &EnvVar, std::vector<std::string> &Paths) {; 1418 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(EnvVar);; 1419 if (EnvOpt.has_value())",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:50729,optimiz,optimization,50729,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" ("";; 1413 optimParameters += TString::Format(""%s=%g"", key.Data(), value);; 1414 }; 1415 if (!optimParameters.IsNull()); 1416 optimParameters += "")"";; 1417 return optimParameters;; 1418 };; 1419 ; 1420 Log() << ""Training phase "" << trainingPhase << "" of "" << this->GetTrainingSettings().size() << "": ""; 1421 << "" Optimizer "" << settings.optimizerName; 1422 << optimParametersString(); 1423 << "" Learning rate = "" << settings.learningRate << "" regularization "" << (char)settings.regularization; 1424 << "" minimum error = "" << minValError << Endl;; 1425 if (!fInteractive) {; 1426 std::string separator(62, '-');; 1427 Log() << separator << Endl;; 1428 Log() << std::setw(10) << ""Epoch""; 1429 << "" | "" << std::setw(12) << ""Train Err."" << std::setw(12)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:55780,optimiz,optimizerParams,55780,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerParams']
Performance,"; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" ("";; 1413 optimParameters += TString::Format(""%s=%g"", key.Data(), value);; 1414 }; 1415 if (!optimParameters.IsNull()); 1416 optimParameters += "")"";; 1417 return optimParameters;; 1418 };; 1419 ; 1420 Log() << ""Training phase "" << trainingPhase << "" of "" << this->GetTrainingSettings().size() << "": ""; 1421 << "" Optimizer "" << settings.optimizerName; 1422 << optimParametersString(); 1423 << "" Learning rate = "" << settings.learningRate << "" regularization "" << (char)settings.regularization; 1424 << "" minimum error = "" << minValError << Endl;; 1425 if (!fInteractive) {; 1426 std::string separator(62, '-');; 1427 Log() << separator << Endl;; 1428 Log() << std::setw(10) << ""Epoch""; 1429 << "" | "" << std::setw(12) << ""Train Err."" << std::setw(12) << ""Val. Err."" << std::setw(12); 1430 << ""t(s)/epoch"" << std::setw(12) << ""t(s)/Loss"" << std::setw(12) << ""nEvents/s"" << std::setw(12); 1431 << ""Conv. Steps"" << Endl;; 1432 Log() << separator << Endl;; 1433 }; 1434 ; 1435 // set up generator for shuffling the batches; 1436 // if seed is zero we have always a different order in the batches; 1437 size_t shuffleSeed = 0;; 1438 if (fRandomSeed != 0) shuffleSeed = fRandomSeed + trainingPhase;; 1439 RandomGenerator<TRandom3> rng(shuffleSeed);; 1440 ; 1441 // print weights before; 1442 if (fBuildNet && debug) {; 1443 Log() << ""Initial Deep Net Weights "" << Endl;; 1444 auto & weigh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:56392,optimiz,optimizerName,56392,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerName']
Performance,"; 1402 GetBasket(i);; 1403 }; 1404 }; 1405 // Getting the next basket might reset the current one and; 1406 // cause a reset of the first / next basket entries back to -1.; 1407 fFirstBasketEntry = first;; 1408 fNextBasketEntry = updatedNext;; 1409 if (user_buffer) {; 1410 // Disassociate basket from memory buffer for bulk IO; 1411 // When the user provides a memory buffer (i.e., for bulk IO), we should; 1412 // make sure to drop all references to that buffer in the TTree afterward.; 1413 fCurrentBasket = nullptr;; 1414 fBaskets[fReadBasket] = nullptr;; 1415 } else {; 1416 fCurrentBasket = basket;; 1417 }; 1418 } else {; 1419 fCurrentBasket = basket;; 1420 }; 1421 return fReadBasket;; 1422 }; 1423}; 1424 ; 1425////////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeType() != TLeaf::DeserializeType::kExternal);; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// \brief Read a basket of events into the given buffer with byte swapping.; 1438///; 1439/// \return On success, the number of events of the type held by this branch; 1440/// that have been read into the buffer. -1 on failure.; 1441///; 1442/// On success, the caller should be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:50875,perform,perform,50875,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,2,"['load', 'perform']","['loaded', 'perform']"
Performance,"; 1445 /// ~~~{.cpp}; 1446 /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; 1447 /// ~~~; 1448 ///; 1449 /// **Types inferred and columns specified (this invocation relies on jitting):**; 1450 /// ~~~{.cpp}; 1451 /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; 1452 /// ~~~; 1453 ///; 1454 /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; 1455 /// ~~~{.cpp}; 1456 /// auto cache_all_cols_df = df.Cache(myRegexp);; 1457 /// ~~~; 1458 template <typename... ColumnTypes>; 1459 RInterface<RLoopManager> Cache(const ColumnNames_t &columnList); 1460 {; 1461 auto staticSeq = std::make_index_sequence<sizeof...(ColumnTypes)>();; 1462 return CacheImpl<ColumnTypes...>(columnList, staticSeq);; 1463 }; 1464 ; 1465 ////////////////////////////////////////////////////////////////////////////; 1466 /// \brief Save selected columns in memory.; 1467 /// \param[in] columnList columns to be cached in memory; 1468 /// \return a `RDataFrame` that wraps the cached dataset.; 1469 ///; 1470 /// See the previous overloads for more information.; 1471 RInterface<RLoopManager> Cache(const ColumnNames_t &columnList); 1472 {; 1473 // Early return: if the list of columns is empty, just return an empty RDF; 1474 // If we proceed, the jitted call will not compile!; 1475 if (columnList.empty()) {; 1476 auto nEntries = *this->Count();; 1477 RInterface<RLoopManager> emptyRDF(std::make_shared<RLoopManager>(nEntries));; 1478 return emptyRDF;; 1479 }; 1480 ; 1481 std::stringstream cacheCall;; 1482 auto upcastNode = RDFInternal::UpcastNode(fProxiedPtr);; 1483 RInterface<TTraits::TakeFirstParameter_t<decltype(upcastNode)>> upcastInterface(fProxiedPtr, *fLoopManager,; 1484 fColRegister);; 1485 // build a string equivalent to; 1486 // ""(RInterface<nodetype*>*)(this)->Cache<Ts...>(*(ColumnNames_t*)(&columnList))""; 1487 RInterface<RLoopManager> resRDF(std::make_shared<ROOT::Detail::RDF::RLoopManager>(0));; 1488 ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:81796,cache,cached,81796,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,['cache'],['cached']
Performance,"; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full clusters.; 1491 if (R__unlikely(entry != first)) {; 1492 //printf(""Failed to read from full cluster; first entry is %ld; requested entry is %ld.\n"", first, entry);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:52772,perform,perform,52772,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['perform'],['perform']
Performance,"; 1481 // typical length of text line:; 1482 // ""|--------------------------------------------------------------|""; 1483 TString col = gConfig().WriteOptionsReference() ? TString() : gTools().Color(""bold"");; 1484 TString colres = gConfig().WriteOptionsReference() ? TString() : gTools().Color(""reset"");; 1485 ; 1486 Log() << Endl;; 1487 Log() << col << ""--- Short description:"" << colres << Endl;; 1488 Log() << Endl;; 1489 Log() << ""The DNN neural network is a feedforward"" << Endl;; 1490 Log() << ""multilayer perceptron implementation. The DNN has a user-"" << Endl;; 1491 Log() << ""defined hidden layer architecture, where the number of input (output)"" << Endl;; 1492 Log() << ""nodes is determined by the input variables (output classes, i.e., "" << Endl;; 1493 Log() << ""signal and one background, regression or multiclass). "" << Endl;; 1494 Log() << Endl;; 1495 Log() << col << ""--- Performance optimisation:"" << colres << Endl;; 1496 Log() << Endl;; 1497 ; 1498 const char* txt = ""The DNN supports various options to improve performance in terms of training speed and \n \; 1499reduction of overfitting: \n \; 1500\n \; 1501 - different training settings can be stacked. Such that the initial training \n\; 1502 is done with a large learning rate and a large drop out fraction whilst \n \; 1503 in a later stage learning rate and drop out can be reduced. \n \; 1504 - drop out \n \; 1505 [recommended: \n \; 1506 initial training stage: 0.0 for the first layer, 0.5 for later layers. \n \; 1507 later training stage: 0.1 or 0.0 for all layers \n \; 1508 final training stage: 0.0] \n \; 1509 Drop out is a technique where a at each training cycle a fraction of arbitrary \n \; 1510 nodes is disabled. This reduces co-adaptation of weights and thus reduces overfitting. \n \; 1511 - L1 and L2 regularization are available \n \; 1512 - Minibatches \n \; 1513 [recommended 10 - 150] \n \; 1514 Arbitrary mini-batch sizes can be chosen. \n \; 1515 - Multithreading \n \; 1516 [recommended: True] \n \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:54317,Perform,Performance,54317,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"; 1573 ~TConfigurationUseCache() override {}; 1574 TConfiguration *Copy() override; 1575 {; 1576 TConfigurationUseCache *copy = new TConfigurationUseCache(*this);; 1577 fAction.fConfiguration = copy->fAction.fConfiguration->Copy(); // since the previous allocation did a 'move' of fAction we need to fix it.; 1578 return copy;; 1579 }; 1580 };; 1581 ; 1582 INLINE_TEMPLATE_ARGS Int_t UseCache(TBuffer &b, void *addr, const TConfiguration *conf); 1583 {; 1584 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1585 ; 1586 Int_t bufpos = b.Length();; 1587 TVirtualArray *cached = b.PeekDataCache();; 1588 if (cached==0) {; 1589 TStreamerElement *aElement = conf->fCompInfo->fElem;; 1590 TStreamerInfo *info = (TStreamerInfo*)conf->fInfo;; 1591 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1592 char *ptr = (char*)addr;; 1593 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,1,0);; 1594 } else {; 1595 config->fAction(b, (*cached)[0]);; 1596 }; 1597 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1598 if (config->fNeedRepeat) {; 1599 b.SetBufferOffset(bufpos);; 1600 }; 1601 return 0;; 1602 }; 1603 ; 1604 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorPtrLoop(TBuffer &b, void *start, const void *end, const TConfiguration *conf); 1605 {; 1606 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1607 Int_t bufpos = b.Length();; 1608 ; 1609 TVirtualArray *cached = b.PeekDataCache();; 1610 if (cached==0) {; 1611 TStreamerElement *aElement = config->fCompInfo->fElem;; 1612 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1613 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1614 char *ptr = (char*)start;; 1615 UInt_t n = (((void**)end)-((void**)start));; 1616 info->ReadBufferSkip(b,&ptr,config->fCompInfo,conf->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1617 } else {; 161",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:65931,cache,cached,65931,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,"; 1582 // Architecture_t::PrintTensor(deepNet.GetLayerAt(1)->GetWeightsAt(0), "" cudnn weights"");; 1583 // ArchitectureImpl_t::PrintTensor(fNet->GetLayerAt(1)->GetWeightsAt(0), "" cpu weights"");; 1584 ; 1585 minValError = valError;; 1586 }; 1587 else if ( minValError <= 0. ); 1588 minValError = valError;; 1589 ; 1590 if (!computeLossInTraining) {; 1591 trainingError = 0.0;; 1592 // Compute training error.; 1593 for (auto batch : trainingData) {; 1594 auto inputTensor = batch.GetInput();; 1595 auto outputMatrix = batch.GetOutput();; 1596 auto weights = batch.GetWeights();; 1597 trainingError += deepNet.Loss(inputTensor, outputMatrix, weights, false, false);; 1598 }; 1599 }; 1600 // normalize loss to number of batches and add regularization term; 1601 trainingError /= (Double_t)(nTrainingSamples / settings.batchSize);; 1602 trainingError += regTerm;; 1603 ; 1604 //Log the loss value; 1605 fTrainHistory.AddValue(""trainingError"",nTrainEpochs,trainingError);; 1606 ; 1607 // stop measuring; 1608 tend = std::chrono::system_clock::now();; 1609 ; 1610 // Compute numerical throughput.; 1611 std::chrono::duration<double> elapsed_seconds = tend - tstart;; 1612 std::chrono::duration<double> elapsed1 = t1-tstart;; 1613 // std::chrono::duration<double> elapsed2 = t2-tstart;; 1614 // time to compute training and test errors; 1615 std::chrono::duration<double> elapsed_testing = tend-t1;; 1616 ; 1617 double seconds = elapsed_seconds.count();; 1618 // double nGFlops = (double)(settings.testInterval * batchesInEpoch * settings.batchSize)*1.E-9;; 1619 // nGFlops *= deepnet.GetNFlops() * 1e-9;; 1620 double eventTime = elapsed1.count()/( batchesInEpoch * settings.testInterval * settings.batchSize);; 1621 ; 1622 converged =; 1623 convergenceCount > settings.convergenceSteps || nTrainEpochs >= settings.maxEpochs;; 1624 ; 1625 ; 1626 Log() << std::setw(10) << nTrainEpochs << "" | ""; 1627 << std::setw(12) << trainingError; 1628 << std::setw(12) << valError; 1629 << std::setw(12) << seconds / sett",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:63929,throughput,throughput,63929,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['throughput'],['throughput']
Performance,"; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read); 1697{; 1698 if (read) {; 1699 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1700 if ( (fProperties & kIsAssociative) && read); 1701 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1702 }; 1703 ; 1704 if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;; 1705 ; 1706 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1707 ; 1708 // TODO can we do better than the default for RVec?; 1709 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:56608,load,load,56608,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"; 178 "" or cross entropy (binary classification)."");; 179 AddPreDefVal(TString(""CROSSENTROPY""));; 180 AddPreDefVal(TString(""SUMOFSQUARES""));; 181 AddPreDefVal(TString(""MUTUALEXCLUSIVE""));; 182 ; 183 DeclareOptionRef(fWeightInitializationString = ""XAVIER"", ""WeightInitialization"", ""Weight initialization strategy"");; 184 AddPreDefVal(TString(""XAVIER""));; 185 AddPreDefVal(TString(""XAVIERUNIFORM""));; 186 AddPreDefVal(TString(""GAUSS""));; 187 AddPreDefVal(TString(""UNIFORM""));; 188 AddPreDefVal(TString(""IDENTITY""));; 189 AddPreDefVal(TString(""ZERO""));; 190 ; 191 DeclareOptionRef(fRandomSeed = 0, ""RandomSeed"", ""Random seed used for weight initialization and batch shuffling"");; 192 ; 193 DeclareOptionRef(fNumValidationString = ""20%"", ""ValidationSize"", ""Part of the training data to use for validation. ""; 194 ""Specify as 0.2 or 20% to use a fifth of the data set as validation set. ""; 195 ""Specify as 100 to use exactly 100 events. (Default: 20%)"");; 196 ; 197 DeclareOptionRef(fArchitectureString = ""CPU"", ""Architecture"", ""Which architecture to perform the training on."");; 198 AddPreDefVal(TString(""STANDARD"")); // deprecated and not supported anymore; 199 AddPreDefVal(TString(""CPU""));; 200 AddPreDefVal(TString(""GPU""));; 201 AddPreDefVal(TString(""OPENCL"")); // not yet implemented; 202 AddPreDefVal(TString(""CUDNN"")); // not needed (by default GPU is now CUDNN if available); 203 ; 204 // define training strategy separated by a separator ""|""; 205 DeclareOptionRef(fTrainingStrategyString = ""LearningRate=1e-3,""; 206 ""Momentum=0.0,""; 207 ""ConvergenceSteps=100,""; 208 ""MaxEpochs=2000,""; 209 ""Optimizer=ADAM,""; 210 ""BatchSize=30,""; 211 ""TestRepetitions=1,""; 212 ""WeightDecay=0.0,""; 213 ""Regularization=None,""; 214 ""DropConfig=0.0"",; 215 ""TrainingStrategy"", ""Defines the training strategies."");; 216}; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219void MethodDL::ProcessOptions(); 220{; 221 ; 222 if (IgnoreEventsWithNegWeightsInTraining()) {; 223 Log(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:7104,perform,perform,7104,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['perform'],['perform']
Performance,"; 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module file are never unloaded (even if the library is; 1848 // unloaded) and, of course, never reloaded.; 1849 // Consequently, we must NOT remove the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:68808,Load,LoadPCM,68808,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['Load'],"['LoadPCM', 'Loading']"
Performance,"; 1817{; 1818 if (left == right) return kTRUE;; 1819 ; 1820 if (left==nullptr || right==nullptr) return kFALSE;; 1821 ; 1822 if ( (strcmp(right,left)==0) ) {; 1823 return kTRUE;; 1824 }; 1825 ; 1826#ifdef G__WIN32; 1827 ; 1828 char leftname[_MAX_PATH];; 1829 char rightname[_MAX_PATH];; 1830 _fullpath( leftname, left, _MAX_PATH );; 1831 _fullpath( rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The lib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:59498,Load,Load,59498,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['Load'],['Load']
Performance,"; 2. Sending Patches; You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the ROOT coding conventions in your code; Make sure you provide a set of tests for your feature/bug fix. Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix.; Picking up an Idea; We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" is a sketch of a development project, a functionality a missing feature we would like to see in our tool, in your ROOT! You can inspect the ideas in the following list. Ideas. ; 30-01-2019 ; Transform GNU-makefile tests to CMake; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake. ; 30-01-2019 ; Better argument parsing; Use a C++ command line argument library for defining and parsing ROOT's options. ; 30-01-2019 ; More tests, more benchmarks!; ROOT relies on testing, including performance testing - and we need to improve both. ; 05-01-2016 ; Wanted: A tool to 'warn' user of inefficient (for I/O) construct in data model; A tool to 'warn' user of inefficient (for I/O) construct in data model. ; 02-09-2015 ; Wanted: Storage of HEP data via key/value storage solutions; Interface the ROOT I/O to key/value stores. Completed ideas. ; 28-03-2015 ; Commandline tools for ROOT files inspection, modification and automated plotting; Create a unix-like set of Python command line tools to explore, modify and display the content of ROOT files. . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/collaborate-with-us.html:3711,perform,performance,3711,d/collaborate-with-us.html,https://root.cern,https://root.cern/d/collaborate-with-us.html,1,['perform'],['performance']
Performance,"; 2045#endif; 2046 TObject::SetObjectStat(gEnv->GetValue(""Root.ObjectStat"", 0));; 2047 }; 2048}; 2049 ; 2050////////////////////////////////////////////////////////////////////////////////; 2051/// Load and initialize thread library.; 2052 ; 2053void TROOT::InitThreads(); 2054{; 2055 if (gEnv->GetValue(""Root.UseThreads"", 0) || gEnv->GetValue(""Root.EnableThreadSafety"", 0)) {; 2056 ROOT::EnableThreadSafety();; 2057 }; 2058}; 2059 ; 2060////////////////////////////////////////////////////////////////////////////////; 2061/// Initialize the interpreter. Should be called only after main(),; 2062/// to make sure LLVM/Clang is fully initialized.; 2063 ; 2064void TROOT::InitInterpreter(); 2065{; 2066 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Sch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:79817,load,load,79817,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void MasterToLocalVect(const Double_t *master, Double_t *local) const { fCache->MasterToLocalVect(master, local); }; 240 void MasterToLocalBomb(const Double_t *master, Double_t *local) const { fCache->MasterToLocalBomb(master, local); }; 241 void MasterToTop(const Double_t *master, Double_t *top) const;; 242 void TopToMaster(const Double_t *top, Double_t *master) const;; 243 TGeoNodeCache *GetCache() const { return fCache; }; 244 // void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; 245 //--- stack manipulation; 246 Int_t PushPath(Int_t startlevel = 0) { return fCache->PushState(fCurrentOverlapping, startlevel, fNmany); }; 247 Bool_t PopPath(); 248 {; 249 fCurrentOverlapping = fCache->PopState(fNmany);; 250 fCurrentNode = fCache->GetNode();; 251 fLevel = fCache->GetLevel();; 252 fGlobalMatrix = fCache->GetCurrentMatrix();; 253 return fCurrentOverlapping;; 254 }; 255 Bool_t PopPath(Int_t index); 256 {; 257 fCurrentOverlapping = fCache->PopState(fNmany, index);; 258 fCurrentNode = fCache->GetNode();; 259 fLevel = fCache->GetLevel();; 260 fGlobalMatrix = fCache->GetCurrentMatrix();; 261 return fCurrentOverlapping;; 262 }; 263 Int_t PushPoint(Int_t startlevel = 0) { return fCache->PushState(fCurrentOverlapping, startlevel, fNmany, fPoint); }; 264 Bool_t PopPoint(); 265 {; 266 fCurrentOverlapping = fCache->PopState(fNmany, fPoint);; 267 fCurrentNode = fCache->GetNode();; 268 fLevel = fCache->GetLevel();; 269 fGlobalMatrix = fCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:12507,cache,cache,12507,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cache']
Performance,"; 25 2, # exp common parameter; 26 3, # Gaussian amplitude; 27 4, # Gaussian mean; 28 5, # Gaussian sigma; 29 ],; 30 dtype=np.int32,; 31); 32 ; 33# Create the GlobalCHi2 structure; 34 ; 35class GlobalChi2(object):; 36 def __init__(self, f1, f2):; 37 self._f1 = f1; 38 self._f2 = f2; 39 ; 40 def __call__(self, par):; 41 # parameter vector is first background (in common 1 and 2) and then is; 42 # signal (only in 2); 43 ; 44 # the zero-copy way to get a numpy array from a double *; 45 par_arr = np.frombuffer(par, dtype=np.float64, count=6); 46 ; 47 p1 = par_arr[iparB]; 48 p2 = par_arr[iparSB]; 49 ; 50 return self._f1(p1) + self._f2(p2); 51 ; 52 ; 53hB = ROOT.TH1D(""hB"", ""histo B"", 100, 0, 100); 54hSB = ROOT.TH1D(""hSB"", ""histo S+B"", 100, 0, 100); 55 ; 56fB = ROOT.TF1(""fB"", ""expo"", 0, 100); 57fB.SetParameters(1, -0.05); 58hB.FillRandom(""fB""); 59 ; 60fS = ROOT.TF1(""fS"", ""gaus"", 0, 100); 61fS.SetParameters(1, 30, 5); 62 ; 63hSB.FillRandom(""fB"", 2000); 64hSB.FillRandom(""fS"", 1000); 65 ; 66# perform now global fit; 67 ; 68fSB = ROOT.TF1(""fSB"", ""expo + gaus(2)"", 0, 100); 69 ; 70wfB = ROOT.Math.WrappedMultiTF1(fB, 1); 71wfSB = ROOT.Math.WrappedMultiTF1(fSB, 1); 72 ; 73opt = ROOT.Fit.DataOptions(); 74rangeB = ROOT.Fit.DataRange(); 75# set the data range; 76rangeB.SetRange(10, 90); 77dataB = ROOT.Fit.BinData(opt, rangeB); 78ROOT.Fit.FillData(dataB, hB); 79 ; 80rangeSB = ROOT.Fit.DataRange(); 81rangeSB.SetRange(10, 50); 82dataSB = ROOT.Fit.BinData(opt, rangeSB); 83ROOT.Fit.FillData(dataSB, hSB); 84 ; 85chi2_B = ROOT.Fit.Chi2Function(dataB, wfB); 86chi2_SB = ROOT.Fit.Chi2Function(dataSB, wfSB); 87 ; 88globalChi2 = GlobalChi2(chi2_B, chi2_SB); 89 ; 90fitter = ROOT.Fit.Fitter(); 91 ; 92Npar = 6; 93par0 = np.array([5, 5, -0.1, 100, 30, 10]); 94 ; 95# create before the parameter settings in order to fix or set range on them; 96fitter.Config().SetParamsSettings(6, par0); 97# fix 5-th parameter; 98fitter.Config().ParSettings(4).Fix(); 99# set limits on the third and 4-th parameter; 100fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py_source.html:1773,perform,perform,1773,doc/master/combinedFit_8py_source.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py_source.html,1,['perform'],['perform']
Performance,"; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2515 ; 2516 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 2517 R__TObjArray_InsertBefore( fElements, copy, element );; 2518 next(); // move the cursor passed the insert object.; 2519 copy->SetBit(TStreamerElement::kRepeat);; 2520 element = copy;; 2521 ; 2522 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 2523 } else {; 2524 // If the element is just cached and not repeat, we need to inject an element; 2525 // to insure the writing.; 2526 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 2527 R__TObjArray_InsertAfter( fElements, writecopy, element );; 2528 next(); // move the cursor passed the insert object.; 2529 writecopy->SetBit(TStreamerElement::kWrite);; 2530 writecopy->SetNewType( writecopy->GetType() );; 2531 writecopy->SetOffset(element->GetOffset());; 2532 }; 2533 element->SetBit(TStreamerElement::kCache);; 2534 element->SetNewType( element->GetType() );; 2535 element->SetOffset(infoalloc ? infoalloc->GetOffset(element->GetName()) : 0);; 2536 } else if (rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2537 // The data member exist in the onfile StreamerInfo and there is a rule; 2538 // that has the same member 'only' has a target ... so this means we are; 2539 // asked to ignore the input data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:100824,cache,cached,100824,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['cache'],['cached']
Performance,"; 2502#if defined(USE_WEBSOCKET); 2503 int in_websocket_handling; /* 1 if in read_websocket */; 2504#endif; 2505#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2506 && defined(MG_EXPERIMENTAL_INTERFACES); 2507 /* Parameters for websocket data compression according to rfc7692 */; 2508 int websocket_deflate_server_max_windows_bits;; 2509 int websocket_deflate_client_max_windows_bits;; 2510 int websocket_deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.g. 200 */; 2523 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2524 * throttle */; 2525 ; 2526 time_t last_throttle_time; /* Last time throttled data was sent */; 2527 int last_throttle_bytes; /* Bytes sent this second */; 2528 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2529 * atomic transmissions for websockets */; 2530#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2531 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2532#endif; 2533 ; 2534 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2535 * for quick access */; 2536};; 2537 ; 2538 ; 2539/* Directory entry */; 2540struct de {; 2541 struct mg_connection *conn;; 2542 char *file_name;; 2543 struct mg_file_stat file;; 2544};; 2545 ; 2546 ; 2547#define mg_cry_internal(conn, fmt, ...) \; 2548 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2549 ; 2550#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2551 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:79056,throttle,throttle,79056,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance,"; 2503#if defined(USE_WEBSOCKET); 2504 int in_websocket_handling; /* 1 if in read_websocket */; 2505#endif; 2506#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2507 && defined(MG_EXPERIMENTAL_INTERFACES); 2508 /* Parameters for websocket data compression according to rfc7692 */; 2509 int websocket_deflate_server_max_windows_bits;; 2510 int websocket_deflate_client_max_windows_bits;; 2511 int websocket_deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.g. 200 */; 2524 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2525 * throttle */; 2526 ; 2527 time_t last_throttle_time; /* Last time throttled data was sent */; 2528 int last_throttle_bytes; /* Bytes sent this second */; 2529 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2530 * atomic transmissions for websockets */; 2531#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2532 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2533#endif; 2534 ; 2535 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2536 * for quick access */; 2537};; 2538 ; 2539 ; 2540/* Directory entry */; 2541struct de {; 2542 struct mg_connection *conn;; 2543 char *file_name;; 2544 struct mg_file_stat file;; 2545};; 2546 ; 2547 ; 2548#define mg_cry_internal(conn, fmt, ...) \; 2549 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2550 ; 2551#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2552 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:79088,throttle,throttle,79088,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance,"; 2705 }; 2706 }; 2707 ; 2708 // It can happen that the objects cached by the client are also clients of; 2709 // the arg itself! In that case, the position of the client in the client; 2710 // list might have changed, and we need to find the new index.; 2711 if(clients.size() != oldClientsSize) {; 2712 auto clientIter = std::find(clients.begin(), clients.end(), client);; 2713 if(clientIter == clients.end()) {; 2714 throw std::runtime_error(""After a clients caches were cleared, the client was gone! This should not happen."");; 2715 }; 2716 iClient = std::distance(clients.begin(), clientIter);; 2717 }; 2718 }; 2719}; 2720 ; 2721} // namespace; 2722 ; 2723 ; 2724////////////////////////////////////////////////////////////////////////////////; 2725 ; 2726void RooAbsPdf::setNormRange(const char* rangeName); 2727{; 2728 if (rangeName) {; 2729 _normRange = rangeName ;; 2730 } else {; 2731 _normRange.Clear() ;; 2732 }; 2733 ; 2734 // the stuff that the clients have cached may depend on the normalization range; 2735 sterilizeClientCaches(*this);; 2736 ; 2737 if (_norm) {; 2738 _normMgr.sterilize() ;; 2739 _norm = nullptr ;; 2740 }; 2741}; 2742 ; 2743 ; 2744////////////////////////////////////////////////////////////////////////////////; 2745 ; 2746void RooAbsPdf::setNormRangeOverride(const char* rangeName); 2747{; 2748 if (rangeName) {; 2749 _normRangeOverride = rangeName ;; 2750 } else {; 2751 _normRangeOverride.Clear() ;; 2752 }; 2753 ; 2754 // the stuff that the clients have cached may depend on the normalization range; 2755 sterilizeClientCaches(*this);; 2756 ; 2757 if (_norm) {; 2758 _normMgr.sterilize() ;; 2759 _norm = nullptr ;; 2760 }; 2761}; 2762 ; 2763 ; 2764////////////////////////////////////////////////////////////////////////////////; 2765/// Hook function intercepting redirectServer calls. Discard current; 2766/// normalization object if any server is redirected; 2767 ; 2768bool RooAbsPdf::redirectServersHook(const RooAbsCollection & newServerList, bool mustRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:129661,cache,cached,129661,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"; 2770 SysError(""RedirectOutput"",; 2771 ""problems closing temporary 'out' descriptor %d (errno: %d)"",; 2772 TSystem::GetErrno(), xh->fStdOutDup);; 2773 rc = -1;; 2774 }; 2775 }; 2776 fflush(stderr);; 2777 if (!(xh->fStdErrTty.IsNull())) {; 2778 if (freopen(xh->fStdErrTty.Data(), ""a"", stderr) == nullptr) {; 2779 SysError(""RedirectOutput"", ""could not restore stderr (errno: %d)"", TSystem::GetErrno());; 2780 rc = -1;; 2781 }; 2782 xh->fStdErrTty = """";; 2783 } else {; 2784 if (close(STDERR_FILENO) != 0) {; 2785 SysError(""RedirectOutput"",; 2786 ""problems closing STDERR_FILENO (%d) before 'dup2' (errno: %d)"",; 2787 STDERR_FILENO, TSystem::GetErrno());; 2788 rc = -1;; 2789 }; 2790 if (dup2(xh->fStdErrDup, STDERR_FILENO) < 0) {; 2791 SysError(""RedirectOutput"", ""could not restore stderr (back to original redirected""; 2792 "" file) (errno: %d)"", TSystem::GetErrno());; 2793 rc = -1;; 2794 }; 2795 if (close(xh->fStdErrDup) != 0) {; 2796 SysError(""RedirectOutput"",; 2797 ""problems closing temporary 'err' descriptor %d (errno: %d)"",; 2798 TSystem::GetErrno(), xh->fStdErrDup);; 2799 rc = -1;; 2800 }; 2801 }; 2802 // Reset the static instance, if using that; 2803 if (xh == &loch); 2804 xh->Reset();; 2805 }; 2806 return rc;; 2807}; 2808 ; 2809//---- dynamic loading and linking ---------------------------------------------; 2810 ; 2811////////////////////////////////////////////////////////////////////////////////; 2812///dynamic linking of module; 2813 ; 2814Func_t TUnixSystem::DynFindSymbol(const char * /*module*/, const char *entry); 2815{; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:88642,load,loading,88642,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,"['Load', 'load']","['Load', 'loading']"
Performance,"; 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires the use of fClassInfo for %s to %s"",GetName(),toBase->GetName());; 2794 ; 2795 if (this == toBase) return 0;; 2796 ; 2797 if ((!address /* || !has_virtual_base */) &&; 2798 (!HasInterpreterInfoInMemory() || !toBase->HasInterpreterInfoInMemory())) {; 2799 // At least of the ClassInfo have not been loaded in memory yet and; 2800 // since there is no virtual base class (or we don't have enough so it; 2801 // would not make a difference) we can use the 'static' information; 2802 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2803 if (offset != -2) {; 2804 return offset;; 2805 }; 2806 return offset;; 2807 }; 2808 ; 2809 ClassInfo_t* derived = GetClassInfo();; 2810 ClassInfo_t* base = toBase->GetClassInfo();; 2811 if(derived && base) {; 2812 // TClingClassInfo::GetBaseOffset takes the lock.; 2813 return gCling->ClassInfo_GetBaseOffset(derived, base, address, isDerivedObject);; 2814 }; 2815 else {; 2816 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2817 if (offset != -2) {; 2818 return offset;; 2819 }; 2820 }; 2821 return -1;; 2822}; 2823 ; 2824////////////////////////////////////////////////////////////////////////////////; 2825/// Return pointer to (base) class that contains datamember.; 2826 ; 2827TClass *TClass::GetBaseDataMember(const char *datamember); 2828{; 2829 if (!HasDataMemberInfo())",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:104827,load,loaded,104827,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:92682,Load,Load,92682,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['Load'],['Load']
Performance,"; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(regexp);; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// Get list of shared libraries loaded at the start of the executable.; 2855/// Returns 0 in case list cannot be obtained or in case of error.; 2856 ; 2857const char *TUnixSystem::GetLinkedLibraries(); 2858{; 2859 static TString linkedLibs;; 2860 static Bool_t once = kFALSE;; 2861 ; 2862 R__LOCKGUARD2(gSystemMutex);; 2863 ; 2864 if (!linkedLibs.IsNull()); 2865 return linkedLibs;; 2866 ; 2867 if (once); 2868 return nullptr;; 2869 ; 2870#if !defined(R__MACOSX); 2871 const char *exe = GetExePath();; 2872 if (!exe || !*exe); 2873 return nullptr;; 2874#endif; 2875 ; 2876#if defined(R__MACOSX); 2877 DylibAdded(0, 0);; 2878 linkedLibs = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:90054,load,loaded,90054,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(regexp);; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// Get list of shared libraries loaded at the start of the executable.; 2855/// Returns 0 in case list cannot be obtained or in case of error.; 2856 ; 2857const char *TUnixSystem::GetLinkedLibraries(); 2858{; 2859 static TString linkedLibs;; 2860 static Bool_t once = kFALSE;; 2861 ; 2862 R__LOCKGUARD2(gSystemMutex);; 2863 ; 2864 if (!linkedLibs.IsNull()); 2865 return linkedLibs;; 2866 ; 2867 if (once); 2868 return nullptr;; 2869 ; 2870#if !defined(R__MACOSX); 2871 const char *exe = GetExePath();; 2872 if (!exe || !*exe); 2873 return nullptr;; 2874#endif; 2875 ; 2876#if defined(R__MACOSX); 2877 DylibAdded(0, 0);; 2878 linkedLibs = gLinkedDylibs;; 2879#if 0; 2880 FILE *p = OpenPipe(TString::Format(""otool -L %s"", exe), ""r"");; 2881 TString otool;; 2882 while (otool.Gets(p)) {; 2883 TString delim("" \t"");; 2884 TObjArray *tok = otool.Tokenize(delim);; 2885 TString dylib = ((TObjString*)tok->At(0))->String();; 2886 if (d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:90326,load,loaded,90326,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"; 2839 return -2;; 2840 return inh->GetDelta();; 2841 }; 2842 off = c->GetBaseClassOffsetRecurse(cl);; 2843 if (off == -2) return -2;; 2844 if (off != -1) {; 2845 return off + inh->GetDelta();; 2846 }; 2847 }; 2848 lnk = lnk->Next();; 2849 }; 2850 return -1;; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// - Return data member offset to the base class ""cl"".; 2855/// - Returns -1 in case ""cl"" is not a base class.; 2856/// Takes care of multiple inheritance.; 2857 ; 2858Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2859{; 2860 // Warning(""GetBaseClassOffset"",""Requires the use of fClassInfo for %s to %s"",GetName(),toBase->GetName());; 2861 ; 2862 if (this == toBase) return 0;; 2863 ; 2864 if ((!address /* || !has_virtual_base */) &&; 2865 (!HasInterpreterInfoInMemory() || !toBase->HasInterpreterInfoInMemory())) {; 2866 // At least of the ClassInfo have not been loaded in memory yet and; 2867 // since there is no virtual base class (or we don't have enough so it; 2868 // would not make a difference) we can use the 'static' information; 2869 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2870 if (offset != -2) {; 2871 return offset;; 2872 }; 2873 return offset;; 2874 }; 2875 ; 2876 ClassInfo_t* derived = GetClassInfo();; 2877 ClassInfo_t* base = toBase->GetClassInfo();; 2878 if(derived && base) {; 2879 // TClingClassInfo::GetBaseOffset takes the lock.; 2880 return gCling->ClassInfo_GetBaseOffset(derived, base, address, isDerivedObject);; 2881 }; 2882 else {; 2883 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2884 if (offset != -2) {; 2885 return offset;; 2886 }; 2887 }; 2888 return -1;; 2889}; 2890 ; 2891////////////////////////////////////////////////////////////////////////////////; 2892/// Return pointer to (base) class that contains datamember.; 2893 ; 2894TClass *TClass::GetBaseDataMember(const char *datamember); 2895{; 2896 if (!HasDataMemberInfo())",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:107578,load,loaded,107578,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:13132,perform,performed,13132,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['perform'],['performed']
Performance,"; 3121 ; 3122////////////////////////////////////////////////////////////////////////////////; 3123/// Set color index for text.; 3124 ; 3125void TGX11::SetTextColor(Color_t cindex); 3126{; 3127 if (cindex < 0) return;; 3128 ; 3129 TAttText::SetTextColor(cindex);; 3130 ; 3131 SetColor(gGCtext, Int_t(cindex));; 3132 ; 3133 XGCValues values;; 3134 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground | GCBackground, &values)) {; 3135 XSetForeground( (Display*)fDisplay, *gGCinvt, values.background );; 3136 XSetBackground( (Display*)fDisplay, *gGCinvt, values.foreground );; 3137 } else {; 3138 Error(""SetTextColor"", ""cannot get GC values"");; 3139 }; 3140 XSetBackground((Display*)fDisplay, *gGCtext, GetColor(0).fPixel);; 3141}; 3142 ; 3143////////////////////////////////////////////////////////////////////////////////; 3144/// Set text font to specified name.; 3145///; 3146/// \param [in] fontname font name; 3147/// \param [in] mode loading flag; 3148/// - mode=0 search if the font exist (kCheck); 3149/// - mode=1 search the font and load it if it exists (kLoad); 3150///; 3151/// Set text font to specified name. This function returns 0 if; 3152/// the specified font is found, 1 if not.; 3153 ; 3154Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode); 3155{; 3156 char **fontlist;; 3157 int fontcount;; 3158 int i;; 3159 ; 3160 if (mode == kLoad) {; 3161 for (i = 0; i < kMAXFONT; i++) {; 3162 if (strcmp(fontname, gFont[i].name) == 0) {; 3163 gTextFont = gFont[i].id;; 3164 XSetFont((Display*)fDisplay, *gGCtext, gTextFont->fid);; 3165 XSetFont((Display*)fDisplay, *gGCinvt, gTextFont->fid);; 3166 return 0;; 3167 }; 3168 }; 3169 }; 3170 ; 3171 fontlist = XListFonts((Display*)fDisplay, fontname, 1, &fontcount);; 3172 ; 3173 if (fontlist && fontcount != 0) {; 3174 if (mode == kLoad) {; 3175 if (gFont[gCurrentFontNumber].id); 3176 XFreeFont((Display*)fDisplay, gFont[gCurrentFontNumber].id);; 3177 gTextFont = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 3178 XSetFo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:104223,load,loading,104223,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,2,['load'],"['load', 'loading']"
Performance,"; 326 std::map<TString, MVector *>::iterator itrMap;; 327 ; 328 for (itrMap = fMethodsMap.begin(); itrMap != fMethodsMap.end(); ++itrMap) {; 329 MVector *methods = itrMap->second;; 330 // delete methods; 331 MVector::iterator itrMethod = methods->begin();; 332 for (; itrMethod != methods->end(); ++itrMethod) {; 333 Log() << kDEBUG << ""Delete method: "" << (*itrMethod)->GetName() << Endl;; 334 delete (*itrMethod);; 335 }; 336 methods->clear();; 337 delete methods;; 338 }; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342 ; 343void TMVA::Factory::SetVerbose(Bool_t v); 344{; 345 fVerbose = v;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Book a classifier or regression method.; 350 ; 351TMVA::MethodBase *; 352TMVA::Factory::BookMethod(TMVA::DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption); 353{; 354 if (fModelPersistence); 355 gSystem->MakeDirectory(loader->GetName()); // creating directory for DataLoader output; 356 ; 357 TString datasetname = loader->GetName();; 358 ; 359 if (fAnalysisType == Types::kNoAnalysisType) {; 360 if (loader->GetDataSetInfo().GetNClasses() == 2 && loader->GetDataSetInfo().GetClassInfo(""Signal"") != NULL &&; 361 loader->GetDataSetInfo().GetClassInfo(""Background"") != NULL) {; 362 fAnalysisType = Types::kClassification; // default is classification; 363 } else if (loader->GetDataSetInfo().GetNClasses() >= 2) {; 364 fAnalysisType = Types::kMulticlass; // if two classes, but not named ""Signal"" and ""Background""; 365 } else; 366 Log() << kFATAL << ""No analysis type for "" << loader->GetDataSetInfo().GetNClasses() << "" classes and ""; 367 << loader->GetDataSetInfo().GetNTargets() << "" regression targets."" << Endl;; 368 }; 369 ; 370 // booking via name; the names are translated into enums and the; 371 // corresponding overloaded BookMethod is called; 372 ; 373 if (fMethodsMap.find(datasetname) != fMethodsMap.end()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:13768,load,loader,13768,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,4,['load'],['loader']
Performance,"; 3470 fEntries++;; 3471 fTsumw = 0;; 3472 if (bin < 0) return;; 3473 if (bin >= fNcells) return;; 3474 UpdateBinContent(bin, content);; 3475}; 3476 ; 3477 ; 3478////////////////////////////////////////////////////////////////////////////////; 3479/// Stream an object of class TH3.; 3480 ; 3481void TH3::Streamer(TBuffer &R__b); 3482{; 3483 if (R__b.IsReading()) {; 3484 UInt_t R__s, R__c;; 3485 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3486 if (R__v > 2) {; 3487 R__b.ReadClassBuffer(TH3::Class(), this, R__v, R__s, R__c);; 3488 return;; 3489 }; 3490 //====process old versions before automatic schema evolution; 3491 TH1::Streamer(R__b);; 3492 TAtt3D::Streamer(R__b);; 3493 R__b.CheckByteCount(R__s, R__c, TH3::IsA());; 3494 //====end of old versions; 3495 ; 3496 } else {; 3497 R__b.WriteClassBuffer(TH3::Class(),this);; 3498 }; 3499}; 3500 ; 3501////////////////////////////////////////////////////////////////////////////////; 3502/// static methdod performing the projection to 1D histogram; 3503 ; 3504TH1D *TH3::DoProject1D(const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors,; 3505 bool originalRange, bool useUF, bool useOF); 3506{; 3507 return h.DoProject1D(name, title, projX, nullptr, nullptr, computeErrors, originalRange, useUF, useOF);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// static methdod performing the projection to 2D histogram; 3512 ; 3513TH2D *TH3::DoProject2D(const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY,; 3514 bool computeErrors, bool originalRange, bool useUF, bool useOF); 3515{; 3516 return h.DoProject2D(name, title, projX, projY, computeErrors, originalRange, useUF, useOF);; 3517}; 3518 ; 3519//______________________________________________________________________________; 3520// TH3C methods; 3521// TH3C a 3-D histogram with one byte per cell (char); 3522//______________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:136964,perform,performing,136964,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['perform'],['performing']
Performance,"; 349By default the number of divisions on axis is optimised to show a coherent; 350labelling of the main tick marks. The number of division (`ndiv`) is a; 351composite integer given by:; 352 ; 353` ndiv = N1 + 100*N2 + 10000*N3`; 354 ; 355 - `N1` = number of 1st divisions.; 356 - `N2` = number of 2nd divisions.; 357 - `N3` = number of 3rd divisions.; 358 ; 359by default the value of `N1`, `N2` and `N3` are maximum; 360values. After optimisation the real number of divisions will be smaller or; 361equal to these value. If one wants to bypass the optimisation, the option `""N""`; 362should be given when the `TGaxis` is created. The option `""I""`; 363also act on the number of division as it will force an integer labelling of; 364the axis.; 365 ; 366On an histogram pointer `h` the number of divisions can be set in different ways:.; 367 ; 368- Directly on the histogram. The following will set the number of division; 369 to 510 on the X axis of `h`. To avoid optimization the number of divisions; 370 should be negative (ie: -510);; 371~~~ {.cpp}; 372 h->SetNdivisions(510, ""X"");; 373~~~; 374- On the axis itself:; 375~~~ {.cpp}; 376 h->GetXaxis()->SetNdivisions(510, kTRUE);; 377~~~; 378 ; 379The first parameter is the number of division. If it is negative of if the; 380second parameter is kFALSE then the number of divisions is not optimised.; 381And other signature is also allowed:; 382~~~ {.cpp}; 383 h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:13818,optimiz,optimization,13818,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size() <= basketNumber); 415 brvec.resize(basketNumber + 1);; 416 ; 417 return brvec[basketNumber];; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Return the collection of baskets which have been read by the TTreeCache more; 422/// than once; 423 ; 424TTreePerfStats::BasketList_t TTreePerfStats::GetDuplicateBasketCache() const; 425{; 426 BasketList_t result;; 427 ; 428 TFile *file = fTree->GetCurrentFile();; 429 if (!file); 430 return result;; 431 ; 432 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 433 if (!cache); 434 return result;; 435 ; 436 auto branches = cache->GetCachedBranches();; 437 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 438 bool first = true;; 439 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 440 auto &info(fBasketsInfo[i][j]);; 441 if ((info.fLoaded + info.fLoadedMiss) > 1) {; 442 if (first) {; 443 result.emplace_back(BasketList_t::value_type((TBranch*)branches->At(i), std::vector<size_t>(1)));; 444 first = false;; 445 }; 446 auto &ref( result.back() );; 447 ref.second.push_back(j);; 448 }; 449 }; 450 }; 451 ; 452 return result;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Draw the TTree I/O perf graph.; 457 ; 458void TTreePerfStats::Paint(Option_t *option); 459{; 460 Int_t npoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:14746,cache,cache,14746,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,3,['cache'],['cache']
Performance,"; 4036/// If 'isflat' is true, then no subdirectory is created and the library; 4037/// is created directly in the directory 'build_dir'. Note that in this; 4038/// mode there is a risk than 2 script of the same in different source; 4039/// directory will over-write each other.; 4040/// \note This `build_dir` can also be controlled via `ACLiC.BuildDir` in; 4041/// your `.rootrc`.; 4042 ; 4043void TSystem::SetBuildDir(const char *build_dir, Bool_t isflat); 4044{; 4045 fBuildDir = build_dir;; 4046 if (isflat); 4047 fAclicProperties |= kFlatBuildDir;; 4048 else; 4049 fAclicProperties &= ~kFlatBuildDir;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085//",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:138309,optimiz,optimized,138309,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"; 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );; 4194 ; 4195 if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject; 4196 && fundType->GetType() > 0) {; 4197 // Fundamental type, no a class.; 4198 return kUnknown;; 4199 }; 4200 ; 4201 // Migrated from within TClass::GetClass; 4202 // If we want to know if a class or a namespace with this name exists in the; 4203 // interpreter and this is an enum in the type system, before or after loading; 4204 // according to the autoload function argument, return kUnknown.; 4205 if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone)); 4206 return kUnknown;; 4207 ; 4208 const char *classname = name;; 4209 ; 4210 // RAII to suspend and restore auto-loading and auto-parsing based on some external conditions.; 4211 class MaybeSuspendAutoLoadParse {; 4212 int fStoreAutoLoad = 0;; 4213 int fStoreAutoParse = 0;; 4214 bool fSuspendedAutoParse = false;; 4215 public:; 4216 MaybeSuspendAutoLoadParse(int autoload) {; 4217 fStoreAutoLoad = ((TCling*)gCling)->SetClassAutoLoading(autoload);; 4218 }; 4219 ; 4220 void SuspendAutoParsing() {; 4221 fSuspendedAutoParse = true;; 4222 fStoreAutoParse = ((TCling*)gCling)->SetSuspendAutoParsing(true);; 4223 }; 4224 ; 4225 ~MaybeSuspendAutoLoadParse() {; 4226 if (fSuspendedAutoParse); 4227 ((TCling*)gCling)->SetSuspendAutoParsing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:163041,load,loading,163041,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loading']
Performance,"; 4179 ; 4180void TClass::ResetClassInfo(); 4181{; 4182 R__LOCKGUARD(gInterpreterMutex);; 4183 ; 4184 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 4185 ; 4186 if (fClassInfo) {; 4187 TClass::RemoveClassDeclId(gInterpreter->GetDeclId(fClassInfo));; 4188 gInterpreter->ClassInfo_Delete(fClassInfo);; 4189 fClassInfo = nullptr;; 4190 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240/////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:159181,load,loaded,159181,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['cache', 'load']","['caches', 'loaded']"
Performance,"; 421 nf += AddFile(TString::Format(""%s%s"", path.c_str(), suffix.Data()), nentries);; 422 }; 423 }; 424 ; 425 if (fProofChain); 426 // This updates the proxy chain when we will really use PROOF; 427 ResetBit(kProofUptodate);; 428 ; 429 return nf;; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Add a new file to this chain.; 434///; 435/// Filename formats are similar to TChain::Add. Wildcards are not; 436/// applied. urls may also contain query and fragment identifiers; 437/// where the tree name can be specified in the url fragment.; 438///; 439/// eg.; 440/// ~~~ {.cpp}; 441/// root://machine/path/file_name[?query[#tree_name]]; 442/// root://machine/path/file_name.root[.oext]/tree_name[?query]; 443/// ~~~; 444/// If tree_name is given as a part of the file name it is used to; 445/// as the name of the tree to load from the file. Otherwise if tname; 446/// argument is specified the chain will load the tree named tname from; 447/// the file, otherwise the original treename specified in the TChain; 448/// constructor will be used.; 449/// Tagging the tree_name with a slash [/tree_name] is only supported for; 450/// backward compatibility; it requires the file name ot contain the string; 451/// '.root' and its use is deprecated.; 452///; 453/// A. If nentries <= 0, the file is opened and the tree header read; 454/// into memory to get the number of entries.; 455///; 456/// B. If nentries > 0, the file is not opened, and nentries is assumed; 457/// to be the number of entries in the file. In this case, no check; 458/// is made that the file exists nor that the tree exists in the file,; 459/// nor that the real TTree entries match with the input argument.; 460/// This second mode is interesting in case the number of entries in; 461/// the file is already stored in a run database for example.; 462/// \warning If you pass `nentries` > `tree_entries`, this may lead to silent; 463/// data corruption in your analysis or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:17520,load,load,17520,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['load']
Performance,"; 4246 ; 4247void TClass::ResetClassInfo(); 4248{; 4249 R__LOCKGUARD(gInterpreterMutex);; 4250 ; 4251 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 4252 ; 4253 if (fClassInfo) {; 4254 TClass::RemoveClassDeclId(gInterpreter->GetDeclId(fClassInfo));; 4255 gInterpreter->ClassInfo_Delete(fClassInfo);; 4256 fClassInfo = nullptr;; 4257 }; 4258 // We can not check at this point whether after the unload there will; 4259 // still be interpreter information about this class (as v5 was doing),; 4260 // instead this function must only be called if the definition is (about); 4261 // to be unloaded.; 4262 ; 4263 ResetCaches();; 4264 ; 4265 // We got here because the definition Decl is about to be unloaded.; 4266 if (fState != TClass::kHasTClassInit) {; 4267 if (fStreamerInfo->GetEntries() != 0) {; 4268 fState = TClass::kEmulated;; 4269 } else {; 4270 fState = TClass::kForwardDeclared;; 4271 }; 4272 } else {; 4273 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307/////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:161932,load,loaded,161932,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['cache', 'load']","['caches', 'loaded']"
Performance,"; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Compute the X and Y values corresponding to the maximum value of the function; 436///; 437/// Return the maximum value of the function; 438/// See TF2::GetMinimumXY; 439 ; 440Double_t TF2::GetMaximumXY(Double_t &x, Double_t &y) const; 441{; 442 double xx[2] = { 0,0 };; 443 xx[0] = TMath::QuietNaN(); // to force to do grid search in TF2::FindMinMax; 444 double fmax = FindMinMax(xx, true);; 445 x = xx[0]; y = xx[1];; 446 return fmax;; 447}; 448 ; 449 ; 450////////////////////////////////////////////////////////////////////////////////; 451/// Return minimum/maximum value of the function; 452///; 453/// To find the minimum on a range, first set this range via the SetRange function; 454/// If a vector x of coordinate is passed it will be used as starting point for the minimum.; 455/// In addition on exit x will contain the coordinate values at the minimuma; 456/// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; 457/// minimum location. The range of the function is divided into fNpx and fNpy; 458/// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; 459/// by SetNpx and SetNpy functions; 460/// Then, a minimization is used with starting values found by the grid search; 461/// The minimizer algorithm used (by default Minuit) can be changed by callinga; 462/// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); 463/// Other option for the minimizer can be set using the static method of the MinimizerOptions class; 464 ; 465Double_t TF2::GetMinimum(Double_t *x) const; 466{; 467 return FindMinMax(x, false);; 468}; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Return maximum value of the function; 472/// See TF2::GetMinimum; 473 ; 474Double_t TF2::GetMaximum(Double_t *x) const; 475{; 476 return FindMinMax(x, true);; 477}; 478 ; 479 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8cxx_source.html:15728,perform,performed,15728,doc/master/TF2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html,1,['perform'],['performed']
Performance,"; 44#define ROTL64(v, n) (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n)))); 45 ; 46#define ROTR32(v, n) ROTL32(v, 32 - (n)); 47#define ROTR64(v, n) ROTL64(v, 64 - (n)); 48 ; 49#endif; 50 ; 51#define ROTL8(v, n) (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n)))); 52 ; 53#define ROTL16(v, n) (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n)))); 54 ; 55#define ROTR8(v, n) ROTL8(v, 8 - (n)); 56#define ROTR16(v, n) ROTL16(v, 16 - (n)); 57 ; 58#define SHA256_DIGEST_SIZE 32; 59 ; 60typedef struct sha256_t {; 61 uint32_t stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSha256_8hxx_source.html:2357,optimiz,optimization,2357,doc/master/RSha256_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html,1,['optimiz'],['optimization']
Performance,"; 44#define ROTL64(v, n) (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n)))); 45 ; 46#define ROTR32(v, n) ROTL32(v, 32 - (n)); 47#define ROTR64(v, n) ROTL64(v, 64 - (n)); 48 ; 49#endif; 50 ; 51#define ROTL8(v, n) (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n)))); 52 ; 53#define ROTL16(v, n) (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n)))); 54 ; 55#define ROTR8(v, n) ROTL8(v, 8 - (n)); 56#define ROTR16(v, n) ROTL16(v, 16 - (n)); 57 ; 58#define SHA256_DIGEST_SIZE 32; 59 ; 60typedef struct sha256_t {; 61 uint32_t state",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RSha256_8hxx_source.html:2356,optimiz,optimization,2356,doc/v632/RSha256_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RSha256_8hxx_source.html,1,['optimiz'],['optimization']
Performance,; 46 char *fPackets; ///<! Packet descriptor string; 47 TBranch **fBranchPtr; //,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChainElement_8h_source.html:2053,load,loading,2053,doc/master/TChainElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TChainElement_8h_source.html,2,"['Load', 'load']","['LoadTree', 'loading']"
Performance,"; 476 fMethodsMap[datasetname]->push_back(method);; 477 return method;; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Books MVA method. The option configuration string is custom for each MVA; 482/// the TString field ""theNameAppendix"" serves to define (and distinguish); 483/// several instances of a given MVA, eg, when one wants to compare the; 484/// performance of various configurations; 485 ; 486TMVA::MethodBase *; 487TMVA::Factory::BookMethod(TMVA::DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption); 488{; 489 return BookMethod(loader, Types::Instance().GetMethodName(theMethod), methodTitle, theOption);; 490}; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Adds an already constructed method to be managed by this factory.; 494///; 495/// \note Private.; 496/// \note Know what you are doing when using this method. The method that you; 497/// are loading could be trained already.; 498///; 499 ; 500TMVA::MethodBase *; 501TMVA::Factory::BookMethodWeightfile(DataLoader *loader, TMVA::Types::EMVA methodType, const TString &weightfile); 502{; 503 TString datasetname = loader->GetName();; 504 std::string methodTypeName = std::string(Types::Instance().GetMethodName(methodType).Data());; 505 DataSetInfo &dsi = loader->GetDataSetInfo();; 506 ; 507 IMethod *im = ClassifierFactory::Instance().Create(methodTypeName, dsi, weightfile);; 508 MethodBase *method = (dynamic_cast<MethodBase *>(im));; 509 ; 510 if (method == nullptr); 511 return nullptr;; 512 ; 513 if (method->GetMethodType() == Types::kCategory) {; 514 Log() << kERROR << ""Cannot handle category methods for now."" << Endl;; 515 }; 516 ; 517 TString fileDir;; 518 if (fModelPersistence) {; 519 // find prefix in fWeightFileDir;; 520 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 521 fileDir = prefix;; 522 if (!prefix.IsNull()); 523 if (fileDir[fileDir.Length() - 1] != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:20553,load,loading,20553,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loading']
Performance,"; 50 The rectangular cut of a volume in the variable space is performed using; 51 a binary tree to sort the training events. This provides a significant; 52 reduction in computing time (up to several orders of magnitudes, depending; 53 on the complexity of the problem at hand).; 54 ; 55 Technically, optimisation is achieved in TMVA by two methods:; 56 ; 57 1. Monte Carlo generation using uniform priors for the lower cut value,; 58 and the cut width, thrown within the variable ranges.; 59 ; 60 2. A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; 61 The GA is configurable by many external settings through the option; 62 string. For difficult cases (such as many variables), some tuning; 63 may be necessary to achieve satisfying results; 64 ; 65 Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; 66 superior results, and often failed due to convergence at local minima.; 67 ; 68 The tests we have performed so far showed that in generic applications,; 69 the GA is superior to MC sampling, and hence GA is the default method.; 70 It is worthwhile trying both anyway.; 71 ; 72 **Decorrelated (or ""diagonalized"") Cuts**; 73 ; 74 See class description for Method Likelihood for a detailed explanation.; 75*/; 76 ; 77#include ""TMVA/MethodCuts.h""; 78 ; 79#include ""TMVA/BinarySearchTree.h""; 80#include ""TMVA/ClassifierFactory.h""; 81#include ""TMVA/Config.h""; 82#include ""TMVA/Configurable.h""; 83#include ""TMVA/DataSet.h""; 84#include ""TMVA/DataSetInfo.h""; 85#include ""TMVA/Event.h""; 86#include ""TMVA/IFitterTarget.h""; 87#include ""TMVA/IMethod.h""; 88#include ""TMVA/GeneticFitter.h""; 89#include ""TMVA/Interval.h""; 90#include ""TMVA/FitterBase.h""; 91#include ""TMVA/MCFitter.h""; 92#include ""TMVA/MethodBase.h""; 93#include ""TMVA/MethodFDA.h""; 94#include ""TMVA/MinuitFitter.h""; 95#include ""TMVA/MsgLogger.h""; 96#include ""TMVA/PDF.h""; 97#include ""TMVA/Results.h""; 98#include ""TMVA/SimulatedAnnealingFitter.h""; 99#include ""TMVA/Timer.h""; 100#include ""TMVA/Tools.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:3404,perform,performed,3404,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['perform'],['performed']
Performance,"; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUnixSystem::GetMemInfo(MemInfo_t *info) const; 5364{; 5365 if (!info) return -1;; 5366 ; 5367#if defined(R__MACOSX); 5368 GetDarwinMemInfo(info);; 5369#elif defined(R__LINUX); 5370 GetLinuxMemInfo(info);; 5371#endif; 5372 ; 5373 return 0;; 5374}; 5375 ; 5376////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173406,load,load,173406,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['load']
Performance,"; 546 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 547 if (cacheParamsStr && strlen(cacheParamsStr)) {; 548 ; 549 std::unique_ptr<RooArgSet> intParams{normInt->getVariables()} ;; 550 ; 551 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 552 ; 553 if (!cacheParams.empty()) {; 554 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 555 << ""-dim value cache for integral over "" << depList << "" as a function of "" << cacheParams << "" in range "" << (nr?nr:""<default>"") << endl ;; 556 string name = Form(""%s_CACHE_[%s]"",normInt->GetName(),cacheParams.contentsString().c_str()) ;; 557 RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,cacheParams) ;; 558 cachedIntegral->setInterpolationOrder(2) ;; 559 cachedIntegral->addOwnedComponents(*normInt) ;; 560 cachedIntegral->setCacheSource(true) ;; 561 if (normInt->operMode()==ADirty) {; 562 cachedIntegral->setOperMode(ADirty) ;; 563 }; 564 normInt= cachedIntegral ;; 565 }; 566 ; 567 }; 568 _norm = normInt ;; 569 }; 570 ; 571 // Register new normalization with manager (takes ownership); 572 cache = new CacheElem(*_norm) ;; 573 _normMgr.setObj(nset,cache) ;; 574 ; 575// cout << ""making new object "" << _norm->GetName() << endl ;; 576 ; 577 return true ;; 578}; 579 ; 580 ; 581 ; 582////////////////////////////////////////////////////////////////////////////////; 583/// Reset error counter to given value, limiting the number; 584/// of future error messages for this pdf to 'resetValue'; 585 ; 586void RooAbsPdf::resetErrorCounters(Int_t resetValue); 587{; 588 _errorCount = resetValue ;; 589 _negCount = resetValue ;; 590}; 591 ; 592 ; 593 ; 594////////////////////////////////////////////////////////////////////////////////; 595/// Reset trace counter to given value, limiting the; 596/// number of future trace messages for this pdf to 'value'; 597 ; 598void RooAbsPdf::setTraceCounter(Int_t val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:21817,cache,cacheParams,21817,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,8,"['Cache', 'cache']","['CacheElem', 'cache', 'cacheParams', 'cachedIntegral']"
Performance,; 56 CacheList_t fCacheStack; //Stack of pointers to the cache where to temporarily store the value of 'missing' data members;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:1932,cache,cache,1932,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,1,['cache'],['cache']
Performance,"; 628 template <class T> Int_t SetBranchAddress(const char *bname, T **add, TBranch **ptr = nullptr) {; 629 TClass *cl = TClass::GetClass<T>();; 630 EDataType type = kOther_t;; 631 if (!cl) type = TDataType::GetType(typeid(T));; 632 return SetBranchAddress(bname,add,ptr,cl,type,true);; 633 }; 634#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 635 // This can only be used when the template overload resolution can distinguish between; 636 // T* and T**; 637 template <class T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 638 TClass *cl = TClass::GetClass<T>();; 639 EDataType type = kOther_t;; 640 if (!cl) type = TDataType::GetType(typeid(T));; 641 return SetBranchAddress(bname,add,ptr,cl,type,false);; 642 }; 643#endif; 644 virtual void SetBranchStatus(const char* bname, bool status = true, UInt_t* found = nullptr);; 645 static void SetBranchStyle(Int_t style = 1); //style=0 for old branch, =1 for new branch style; 646 virtual Int_t SetCacheSize(Long64_t cachesize = -1);; 647 virtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last);; 648 virtual void SetCacheLearnEntries(Int_t n=10);; 649 virtual void SetChainOffset(Long64_t offset = 0) { fChainOffset=offset; }; 650 virtual void SetCircular(Long64_t maxEntries);; 651 virtual void SetClusterPrefetch(bool enabled) { fCacheDoClusterPrefetch = enabled; }; 652 virtual void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); // *MENU*; 653 virtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:36377,cache,cachesize,36377,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cachesize']
Performance,; 63*/; 64 ; 65 class TTGlyph {; 66 public:; 67 UInt_t fIndex{0}; ///< glyph index in face; 68 FT_Vector,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTF_8h_source.html:2533,load,loaded,2533,doc/master/TTF_8h_source.html,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html,1,['load'],['loaded']
Performance,"; 650 UInt_t h = 0;; 651 const char* c = (const char*)p;; 652 while (i--); 653 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 70",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:20091,optimiz,optimized,20091,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"; 650 if (!top) {; 651 SetVisLevel(vislevel);; 652 return 0;; 653 }; 654 fNVisNodes = -1;; 655 Bool_t again = kFALSE;; 656 for (Int_t level = 1; level < 20; level++) {; 657 vislevel = level;; 658 Int_t nnodes = CountNodes(top, level);; 659 if (top->IsVisOnly() || top->IsVisBranch()) {; 660 vislevel = fVisLevel;; 661 fNVisNodes = nnodes;; 662 break;; 663 }; 664 if (nnodes > maxnodes) {; 665 vislevel--;; 666 break;; 667 }; 668 if (nnodes == fNVisNodes) {; 669 if (again); 670 break;; 671 again = kTRUE;; 672 }; 673 fNVisNodes = nnodes;; 674 }; 675 SetVisLevel(vislevel);; 676 return fNVisNodes;; 677}; 678 ; 679////////////////////////////////////////////////////////////////////////////////; 680/// Check if Ged library is loaded and load geometry editor classe.; 681 ; 682void TGeoPainter::CheckEdit(); 683{; 684 if (fIsEditable); 685 return;; 686 if (!TClass::GetClass(""TGedEditor"")); 687 return;; 688 TPluginHandler *h;; 689 if ((h = gROOT->GetPluginManager()->FindHandler(""TGeoManagerEditor""))) {; 690 if (h->LoadPlugin() == -1); 691 return;; 692 h->ExecPlugin(0);; 693 }; 694 fIsEditable = kTRUE;; 695}; 696 ; 697////////////////////////////////////////////////////////////////////////////////; 698/// Start the geometry editor.; 699 ; 700void TGeoPainter::EditGeometry(Option_t *option); 701{; 702 if (!gPad); 703 return;; 704 if (!fIsEditable) {; 705 if (!option[0]); 706 gPad->GetCanvas()->GetCanvasImp()->ShowEditor();; 707 else; 708 TVirtualPadEditor::ShowEditor();; 709 CheckEdit();; 710 }; 711 gPad->SetSelected(fGeoManager);; 712 gPad->GetCanvas()->Selected(gPad, fGeoManager, kButton1Down);; 713}; 714 ; 715////////////////////////////////////////////////////////////////////////////////; 716/// Draw method.; 717 ; 718void TGeoPainter::Draw(Option_t *option); 719{; 720 DrawVolume(fGeoManager->GetTopVolume(), option);; 721}; 722 ; 723////////////////////////////////////////////////////////////////////////////////; 724/// Draw the time evolution of a radionuclide.; 725 ; 726void T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:22487,Load,LoadPlugin,22487,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofilename, const char* cutfilename, const char* option, Int_t maxUnrolling); 6770{; 6771 GetPlayer();; 6772 if (!fPlayer) return 0;; 6773 return fPlayer->MakeProxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:264024,load,loaded,264024,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loaded']
Performance,"; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494 return 0;; 7495}; 7496 ; 7497////////////////////////////////////////////////////////////////////////////////; 7498/// Load a source file or library called path into the interpreter.; 7499 ; 7500int TCling::LoadFile(const char* path) const; 7501{; 7502 // Modifying the interpreter state needs locking.; 7503 R__LOCKGUARD(gInterpreterMutex);; 7504 cling::Interpreter::CompilationResult compRes;; 7505 HandleInterpreterException(GetMetaProcessorImpl(), TString::Format("".L %s"", path), compRes, /*cling::Value*/nullptr);; 7506 return compRes == cling::Interpreter::kFailure;; 7507}; 7508 ; 7509////////////////////////////////////////////////////////////////////////////////; 7510/// Load the declarations from text into the interpreter.; 7511/// Note that this cannot be (top level) statements; text must contain; 7512/// top level declarations.; 7513/// Returns true on success, false on failure.; 7514 ; 7515Bool_t TCling::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:292600,Load,LoadFile,292600,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadFile']
Performance,"; 819 ; 820 // Close actual window on screen; 821 SafeDelete(fCanvasImp);; 822 }; 823 ; 824 if (cansave == this) {; 825 gPad = (TCanvas *) gROOT->GetListOfCanvases()->First();; 826 } else {; 827 gPad = padsave;; 828 }; 829 ; 830 Closed();; 831}; 832 ; 833////////////////////////////////////////////////////////////////////////////////; 834/// Copy the canvas pixmap of the pad to the canvas.; 835 ; 836void TCanvas::CopyPixmaps(); 837{; 838 if (!IsBatch()) {; 839 CopyPixmap();; 840 TPad::CopyPixmaps();; 841 }; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Draw a canvas.; 846/// If a canvas with the name is already on the screen, the canvas is repainted.; 847/// This function is useful when a canvas object has been saved in a Root file.; 848/// One can then do:; 849/// ~~~ {.cpp}; 850/// Root > TFile::Open(""file.root"");; 851/// Root > canvas->Draw();; 852/// ~~~; 853 ; 854void TCanvas::Draw(Option_t *); 855{; 856 // Load and initialize graphics libraries if; 857 // TApplication::NeedGraphicsLibs() has been called by a; 858 // library static initializer.; 859 if (gApplication); 860 gApplication->InitializeGraphics(gROOT->IsWebDisplay());; 861 ; 862 fDrawn = kTRUE;; 863 ; 864 TCanvas *old = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(GetName());; 865 if (old == this) {; 866 if (IsWeb()) {; 867 Modified();; 868 UpdateAsync();; 869 } else {; 870 Paint();; 871 }; 872 return;; 873 }; 874 if (old) { gROOT->GetListOfCanvases()->Remove(old); delete old;}; 875 ; 876 if (fWindowWidth == 0) {; 877 if (fCw !=0) fWindowWidth = fCw+4;; 878 else fWindowWidth = 800;; 879 }; 880 if (fWindowHeight == 0) {; 881 if (fCh !=0) fWindowHeight = fCh+28;; 882 else fWindowHeight = 600;; 883 }; 884 if (gROOT->IsBatch()) { //We are in Batch mode; 885 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, GetName(), fWindowWidth, fWindowHeight);; 886 if (!fCanvasImp) return;; 887 fBatch = kTRUE;; 888 ; 889 } else { //normal mode with a scree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:27228,Load,Load,27228,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Load'],['Load']
Performance,"; 886 ; 887\note The allowed operations to pass to LiveVisualize are:; 888 - Histo1D(), Histo2D(), Histo3D(); 889 - Graph(); 890 - Profile1D(), Profile2D(); 891 ; 892\warning The Live Visualization feature is only supported for the Dask backend.; 893 ; 894\anchor parallel-execution; 895## Performance tips and parallel execution; 896As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; 897the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; 898object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; 899subset of entries**, and their partial results are merged before returning the final values to the user.; 900There are no guarantees on the order in which threads will process the batches of entries.; 901In particular, note that this means that, for multi-thread event loops, there is no; 902guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:50688,multi-thread,multi-thread,50688,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"; 926 ; 927\note The allowed operations to pass to LiveVisualize are:; 928 - Histo1D(), Histo2D(), Histo3D(); 929 - Graph(); 930 - Profile1D(), Profile2D(); 931 ; 932\warning The Live Visualization feature is only supported for the Dask backend.; 933 ; 934\anchor parallel-execution; 935## Performance tips and parallel execution; 936As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; 937the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; 938object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; 939subset of entries**, and their partial results are merged before returning the final values to the user.; 940There are no guarantees on the order in which threads will process the batches of entries.; 941In particular, note that this means that, for multi-thread event loops, there is no; 942guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:52328,multi-thread,multi-thread,52328,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,; : -----------------------------------------------------------; : Preparing the Gaussian transformation...; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.013510 1.0000 [ -2.6520 6.2074 ]; : var2: 0.0096839 1.0000 [ -2.8402 6.3073 ]; : var3: 0.010397 1.0000 [ -3.0251 5.8860 ]; : var4: 0.0053980 1.0000 [ -3.0998 5.7078 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; Factory : Train method: BDTG for Multiclass classification; : ; : Training 1000 Decision Trees ... patience please; : Elapsed time for training with 4000 events: 5.42 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of BDTG on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 1.89 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAMulticlass_BDTG.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAMulticlass_BDTG.class.C␛[0m; : TMVAMulticlass.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; Factory : Train method: MLP for Multiclass classification; : ; : Training Network; : ; : Elapsed time for training with 4000 events: 23.9 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of MLP on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0125 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAMulticlass_MLP.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAMulticlass_MLP.class.C␛[0m; : Write special histos to file: TMVAMulticlass.root:/dataset/Method_MLP/MLP; Factory : Training finished; : ; F,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:10808,perform,performance,10808,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"; : 19 | 0.509836 0.557055 0.617073 0.042121 4348.19 0; : 20 | 0.510257 0.574511 0.617241 0.0402784 4333.04 1; : ; : Elapsed time for training with 3200 events: 12.3 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.22 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.7616; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.731202 0.712689 0.193045 0.0157486 14439.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.701214 0.698536 0.191577 0.0154545 14535.3 0; : 3 Minimum Test error f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:18685,Optimiz,Optimizer,18685,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,"; : 4 : var2 : 1.714e-01; : --------------------------------------; : No variable ranking supplied by classifier: DL_CPU; TH1.Print Name = TrainingHistory_DL_CPU_trainingError, Entries= 0, Total sum= 7.41943; TH1.Print Name = TrainingHistory_DL_CPU_valError, Entries= 0, Total sum= 7.13905; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_BDTG.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_MLP.weights.xml␛[0m; MLP : Building Network. ; : Initializing weights; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_PDEFoam.weights.xml␛[0m; : Read foams from file: ␛[0;36mdataset/weights/TMVAMulticlass_PDEFoam.weights_foams.root␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_DL_CPU.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDTG for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of BDTG on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 1.01 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: MLP for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of MLP on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0114 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: PDEFoam for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of PDEFoam on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.122 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:19398,perform,performance,19398,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_MLP : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: PDEFoam; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: DL_CPU; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_DL_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.077270 0.29534 [ -1.1155 1.0914 ]; : var2: 0.068045 0.27981 [ -1.0016 1.0000 ]; : var3: 0.027548 0.24565 [ -0.80459 0.85902 ]; : var4: -0.034157 0.25816 [ -1.0000 0.83435 ]; : -----------------------------------------------------------; TFHandler_DL_CPU :,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:22247,perform,performance,22247,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:42685,perform,performance,42685,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; #; # If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59511,load,loader,59511,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooObjCacheManager_normIntMgrThe integration cache manager; Int_t_numBins; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ParamHistFunc(). ParamHistFunc(const char* name, const char* title, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:36454,cache,cache,36454,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,6,['cache'],['cache']
Performance,"; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. void useHorizontalMorphing(bool val); { _useHorizMorph = val; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Tue Jun 30 14:34:05 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMomentMorph.html:46885,Cache,CacheElem,46885,root/html602/RooMomentMorph.html,https://root.cern,https://root.cern/root/html602/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. void useHorizontalMorphing(bool val); { _useHorizMorph = val; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Tue Mar 10 17:17:54 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMomentMorph.html:45090,Cache,CacheElem,45090,root/html534/RooMomentMorph.html,https://root.cern,https://root.cern/root/html534/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:34390,cache,cache,34390,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:34679,cache,cache,34679,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:21930,optimiz,optimizeCacheMode,21930,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,6,['optimiz'],['optimizeCacheMode']
Performance,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:43728,cache,cache,43728,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,8,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; vector<Int_t>_catRefReference valyes for categories; RooListProxy_catSetList of categories to check; TIterator*_catSetIter! do not persist; Bool_t_checkValCheck contents as well if true; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init!; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:35315,cache,cache,35315,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,8,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; XMLNodePointer_tfStreamerInfoNode! pointer of node with streamer info data; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Bool_tTXML",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:23078,cache,cache,23078,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,6,['cache'],['cache']
Performance,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:20027,cache,cache,20027,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,18,['cache'],['cache']
Performance,"; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLimitsFinder.html:4188,Optimiz,OptimizeLimits,4188,root/html530/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html530/TProofLimitsFinder.html,2,['Optimiz'],['OptimizeLimits']
Performance,"; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLimitsFinder.html:4188,Optimiz,OptimizeLimits,4188,root/html534/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html534/TProofLimitsFinder.html,1,['Optimiz'],['OptimizeLimits']
Performance,"; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdPdf(); Default constructor. RooProdPdf(const char* name, const char* title, Double_t cutOff = 0); Dummy constructor. RooProdPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Double_t cutOff = 0); Constructor with 2 PDFs (most frequent use case). The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgList& inPdfList, Double_t cutOff); Constructor from a list of PDFs. The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:42991,optimiz,optimization,42991,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['optimiz'],['optimization']
Performance,"; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdPdf(); Default constructor. RooProdPdf(const char* name, const char* title, Double_t cutOff = 0); Dummy constructor. RooProdPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Double_t cutOff = 0); Constructor with 2 PDFs (most frequent use case). The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgList& pdfList, Double_t cutOff = 0); Constructor from a list of PDFs. The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:44405,optimiz,optimization,44405,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,3,['optimiz'],['optimization']
Performance,"; Bool_t DumpWeights (Option_t *filename=""-"") const;  Dumps the weights to a text file. ;  ; Double_t Evaluate (Int_t index, Double_t *params) const;  Returns the Neural Net for a given set of input parameters #parameters must equal #input neurons. ;  ; void Export (Option_t *filename=""NNfunction"", Option_t *language=""C++"") const;  Exports the NN as a function for any non-ROOT-dependant code Supported languages are: only C++ , FORTRAN and Python (yet) This feature is also useful if you want to plot the NN as a function (TF1 or TF2). ;  ; Double_t GetDelta () const;  ; Double_t GetEpsilon () const;  ; Double_t GetError (Int_t event) const;  Error on the output for a given event. ;  ; Double_t GetError (TMultiLayerPerceptron::EDataSet set) const;  Error on the whole dataset. ;  ; Double_t GetEta () const;  ; Double_t GetEtaDecay () const;  ; TMultiLayerPerceptron::ELearningMethod GetLearningMethod () const;  ; Int_t GetReset () const;  ; TString GetStructure () const;  ; Double_t GetTau () const;  ; TNeuron::ENeuronType GetType () const;  ; TClass * IsA () const override;  ; Bool_t LoadWeights (Option_t *filename="""");  Loads the weights from a text file conforming to the format defined by DumpWeights. ;  ; void Randomize () const;  Randomize the weights. ;  ; Double_t Result (Int_t event, Int_t index=0) const;  Computes the output for a given event. ;  ; void SetData (TTree *);  Set the data source. ;  ; void SetDelta (Double_t delta);  Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEpsilon (Double_t eps);  Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEta (Double_t eta);  Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEtaDecay (Double_t ed);  Sets EtaDecay - Eta *= EtaD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:12956,Load,LoadWeights,12956,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,2,['Load'],"['LoadWeights', 'Loads']"
Performance,"; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes for StreamerInfo record. ;  ; Bool_t fNoAnchorInName {kFALSE};  !True if we don't want to force the anchor to be appended to the file name ;  ; Int_t fNProcessIDs {0};  Number of TProcessID written to this file. ;  ; Long64_t fOffset {0};  !Seek offset cache ;  ; TList * fOpenPhases {nullptr};  !Time info about open phases ;  ; TString fOption;  File options. ;  ; TObjArray * fProcessIDs {nullptr};  !Array of pointers to TProcessIDs ;  ; Int_t fReadCalls {0};  Number of read calls ( not counting the cache calls ) ;  ; TString fRealName;  Effective real file name (not original url) ;  ; Long64_t fSeekFree {0};  Location on disk of free segments structure. ;  ; Long64_t fSeekInfo {0};  Location on disk of StreamerInfo record. ;  ; Double_t fSum2Buffer {0};  Sum of squares of buffer sizes of objects written so far. ;  ; Double_t fSumBuffer {0};  Sum of buffer sizes of objects written so far. ;  ; Char_t fUnits {0};  Number of bytes for file pointers. ;  ; TUrl fUrl;  !URL of file ;  ; Int_t fVersion {0};  File format version. ;  ; std::mutex fWriteMutex;  !Lock for writing baskets / keys into the file. ;  ; Int_t fWritten {0};  Number of objects written so far. ;  ;  Protected Attributes inherited from TDirectoryFile; Int_t fBufferSize {0};  Default buffer size to create new TKeys. ;  ; TDatime fDatimeC;  Date and time when directory is created. ;  ; TDatime fDatimeM;  Date and time of last modification. ;  ; TFile * fFile {nullptr};  Pointer to current file in memory. ;  ; TList * fKeys {n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:39500,cache,cache,39500,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['cache'],['cache']
Performance,"; Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on conce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:35051,cache,cache,35051,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,9,['cache'],['cache']
Performance,"; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListBlock. class TEntryListBlock: public TObject. TEntryListBlock: Used by TEntryList to store the entry numbers; There are 2 ways to represent entry numbers in a TEntryListBlock:. as bits, where passing entry numbers are assigned 1, not passing - 0; as a simple array of entry numbers. storing the numbers of entries that pass; storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function. ; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is ; again changed to 1). . Picture; Source. {; //=========Macro generated from canvas: c/c; //========= (Fri Mar 16 18:59:21 2007) by ROOT version5.15/03; TCanvas *c = new TCanvas(""c"", ""c"",49,123,752,435);; c->Range(0,0,1,1);; c->SetBorderSize(2);; c->SetFrameFillColor(0);; ; TPaveText *pt = new TPaveText(0.00313972,0.650146,0.22135,0.772595,""br"");; pt->SetFillColor(19);; TText *text = pt->AddText(""TEntryListBlock"");; pt->Draw();; ; pt = new TPaveText(0.00313972,0.827988,0.675039,0.994169,""br"");; pt->SetFillColor(19);; pt->SetTextColor(4);; text = pt->AddText(""Indices representation in a TEntryListBlock"");; pt->Draw();; ; pt = new TPaveText(0.00410678,0.412955,0.221766,0.651822,""br"");; pt->SetFillColor(19);; pt->SetTextAlign(12);; pt->SetTextSize(0.048583);; text = pt->AddText(""UShort_t* fIndices"");; text = pt->AddText(""Int_t fType"");; pt->Draw();; ; pt = new TPaveText(0.324961,0.708455,0.959184,0.804665,""br"");; pt->SetFillColor(19);; text = pt->AddText(""Suppo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListBlock.html:1050,Optimiz,OptimizeStorage,1050,root/html528/TEntryListBlock.html,https://root.cern,https://root.cern/root/html528/TEntryListBlock.html,4,['Optimiz'],['OptimizeStorage']
Performance,"; Clone the browser. A new Browser will be created, with the same; plugins executed in the current one. void CloseTab(Int_t id); Remove tab element id from right tab. void CloseTabs(); Properly close the mainframes embedded in the different tabs. void CloseWindow(); Called when window is closed via the window manager. void DoTab(Int_t id); Handle Tab navigation. Long_t ExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); Execute a macro and embed the created frame in the tab ""pos""; and tab element ""subpos"". Option_t * GetDrawOption() const; Returns drawing option. TGTab* GetTab(Int_t pos) const; Returns the TGTab at position pos. Bool_t HandleKey(Event_t* event); Handle keyboard events. void HandleMenu(Int_t id); Handle menu entries events. void InitPlugins(Option_t* opt = """"); Initialize default plugins. Could be also of the form:; StartEmbedding(0);; TPluginHandler *ph;; ph = gROOT->GetPluginManager()->FindHandler(""TGClassBrowser"");; if (ph && ph->LoadPlugin() != -1) {; ph->ExecPlugin(3, gClient->GetRoot(), 200, 500);; }; StopEmbedding();. void ReallyDelete(); Really delete the browser and the this GUI. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void RecursiveReparent(TGPopupMenu* popup); Recursively reparent TGPopupMenu to gClient->GetDefaultRoot(). void Refresh(Bool_t force = kFALSE); Refresh the actual browser contents. void RemoveTab(Int_t pos, Int_t subpos); Remove tab element ""subpos"" from tab ""pos"". void SetTab(Int_t pos = kRight, Int_t subpos = -1); Switch to Tab ""subpos"" in TGTab ""pos"". void SetTabTitle(const char* title, Int_t pos = kRight, Int_t subpos = -1); Set text ""title"" of Tab ""subpos"" in TGTab ""pos"". void SetStatusText(const char* txt, Int_t col); Set text in culumn col in status bar. void ShowMenu(TGCompositeFrame* menu); Show the selected frame's menu and hide previous one. void StartEmbedding(Int_t pos = kRight, Int_t subpos = -1); Start embedding e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRootBrowser.html:27615,Load,LoadPlugin,27615,root/html530/TRootBrowser.html,https://root.cern,https://root.cern/root/html530/TRootBrowser.html,2,['Load'],['LoadPlugin']
Performance,"; Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix& operator=(const TGeoScale& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoMatrix.h 40116 2011-07-04 12:00:32Z agheata $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScale.html:15643,perform,perform,15643,root/html532/TGeoScale.html,https://root.cern,https://root.cern/root/html532/TGeoScale.html,1,['perform'],['perform']
Performance,"; Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. Bool_t IsLearning() const; {return kFALSE;}. void SetSkipZip(Bool_t = kTRUE); {}. » Author: Rene Brun 19/05/2006 » Copyright (C) 199",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:8394,cache,cache,8394,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,2,['cache'],['cache']
Performance,"; Definition at line 437 of file DisplacementVector3D.h. ◆ Dimension(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . unsigned int ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dimension ; (; ); const. inline . Dimension. ; Definition at line 273 of file DisplacementVector3D.h. ◆ Dot() [1/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const DisplacementVector3D< OtherCoords, OtherTag > & ; ); const. private . ◆ Dot() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const DisplacementVector3D< OtherCoords, Tag > & ; v); const. inline . Return the scalar (dot) product of two displacement vectors. ; It is possible to perform the product for any type of vector coordinates, but they must have the same coordinate system tag ; Definition at line 403 of file DisplacementVector3D.h. ◆ Dot() [3/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherVector > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const OtherVector & ; v); const. inline . Return the scalar (dot) product of two vectors. ; It is possible to perform the product for any classes implementing x(), y() and z() member functions ; Definition at line 412 of file DisplacementVector3D.h. ◆ Eta(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Eta ; (; ); const. inline . Polar eta, converting if necessary from internal coordinate system. ; Definition at line 311 of file DisplacementVector3D.h. ◆ eta(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::eta ; (; ); const. inline . Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html:16073,perform,perform,16073,doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,1,['perform'],['perform']
Performance,"; Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:14115,load,loaded,14115,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,6,['load'],['loaded']
Performance,"; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; // loader.SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; // It is possible also to specify the number of training and testing events,; // note we disable the computation of the correlation matrix of the input variables; ; int nTrainSig = 0.8 * nEventsSig;; int nTrainBkg = 0.8 * nEventsBkg;; ; // build the string options for DataLoader::PrepareTrainingAndTestTree; TString prepareOptions = TString::Format(; ""nTrain_Signal=%d:nTrain_Background=%d:SplitMode=Random:SplitSeed=100:NormMode=NumEvents:!V:!CalcCorrelations"",; nTrainSig, nTrainBkg);; ; loader.PrepareTrainingAndTestTree(mycuts, mycutb, prepareOptions);; ; /***; ; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree sig_tree of type Signal with 10000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree bkg_tree of type Background with 10000 events; ; ; ; **/; ; /****; # Booking Methods; ; Here we bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:52727,load,loader,52727,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t[3] p1, const Double_t[3] p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLAxis.html:4559,optimiz,optimized,4559,root/html602/TGLAxis.html,https://root.cern,https://root.cern/root/html602/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"; ErrorType ; = Poisson); const. inlinevirtual . Return the symmetric error on the current weight. ; See also weightError(double&,double&,ErrorType) const for asymmetric errors. ; Reimplemented in RooDataHist, and RooDataSet.; Definition at line 112 of file RooAbsData.h. ◆ weightSquared(). virtual double RooAbsData::weightSquared ; (; ); const. pure virtual . Implemented in RooDataHist, and RooDataSet. Friends And Related Symbol Documentation. ◆ RooAbsOptTestStatistic. friend class RooAbsOptTestStatistic. friend . Definition at line 332 of file RooAbsData.h. ◆ RooFit::TestStatistics::ConstantTermsOptimizer. friend struct RooFit::TestStatistics::ConstantTermsOptimizer. friend . Definition at line 333 of file RooAbsData.h. ◆ RooFit::TestStatistics::RooAbsL. friend class RooFit::TestStatistics::RooAbsL. friend . Definition at line 335 of file RooAbsData.h. Member Data Documentation. ◆ _cachedVars. RooArgSet RooAbsData::_cachedVars. protected . ! External variables cached with this data set ; Definition at line 349 of file RooAbsData.h. ◆ _dstore. std::unique_ptr<RooAbsDataStore> RooAbsData::_dstore. protected . Data storage implementation. ; Definition at line 351 of file RooAbsData.h. ◆ _globalObservables. std::unique_ptr<RooArgSet> RooAbsData::_globalObservables. protected . Snapshot of global observables. ; Definition at line 355 of file RooAbsData.h. ◆ _namePtr. const TNamed* RooAbsData::_namePtr = nullptr. mutableprotected . ! De-duplicated name pointer. This will be equal for all objects with the same name. ; Definition at line 357 of file RooAbsData.h. ◆ _ownedComponents. std::map<std::string,RooAbsData*> RooAbsData::_ownedComponents. protected . Owned external components. ; Definition at line 353 of file RooAbsData.h. ◆ _uniqueId. const RooFit::UniqueId<RooAbsData> RooAbsData::_uniqueId. private . ! ; Definition at line 364 of file RooAbsData.h. ◆ _vars. RooArgSet RooAbsData::_vars. protected . Dimensions of this data set. ; Definition at line 348 of file RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:78247,cache,cached,78247,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance,"; For most applications, it is better to use the derived class TUnfoldDensity instead of TUnfold. TUnfoldDensity adds various features to TUnfold, such as: background subtraction, propagation of systematic uncertainties, complex multidimensional arrangements of the bins. For innocent users, the most notable improvement of TUnfoldDensity over TUnfold are the getter functions. For TUnfold, histograms have to be booked by the user and the getter functions fill the histogram bins. TUnfoldDensity simply returns a new, already filled histogram.; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfold: . a matrix (truth,reconstructed) is given as a two-dimensional histogram as argument to the constructor of TUnfold . a vector of measurements is given as one-dimensional histogram using the SetInput() method . The unfolding is performed . either once with a fixed parameter tau, method DoUnfold(tau) . or multiple times in a scan to determine the best chouce of tau, method ScanLCurve() . Unfolding results are retrieved using various GetXXX() methods . Basic formulae:; χ2A=(Ax-y)TVyy-1(Ax-y); χ2L=(x-f*x0)TLTL(x-f*x0); χ2unf=χ2A+τ2χ2L+λΣi(Ax-y)i; x:result, A:probabilities, y:data, Vyy:data covariance, f:bias scale, x0:bias, L:regularisation conditions, τ:regularisation strength, λ:Lagrangian multiplier; Without area constraint, λ is set to zero, and χ2unf is minimized to determine x. With area constraint, both x and λ are determined. ; Definition at line 107 of file TUnfold.h. Public Types; enum  EConstraint { kEConstraintNone =0; , kEConstraintArea =1; };  type of extra constraint More...;  ; enum  EHistMap { kHistMapOutputHoriz = 0; , kHistMapOutputVert = 1; };  arrangement of axes for the response matrix (TH2 histogram) More...;  ; enum  ERegMode { ;   kRegModeNone = 0; , kRegModeSize = 1; , kRegModeDeriva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:1912,perform,performed,1912,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['perform'],['performed']
Performance,"; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:27200,load,loading,27200,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['loading']
Performance,"; If cache object does not exist, create and fill and register it on the fly. If recalculate=false recalculation of cache contents of existing caches that are marked dirty due to dependent parameter changes is suppressed. ; Definition at line 113 of file RooAbsCachedPdf.cxx. ◆ getCacheHist() [1/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet & ; nset); const. inline . Definition at line 43 of file RooAbsCachedPdf.h. ◆ getCacheHist() [2/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooDataHist cache histogram for given choice of observables. ; Definition at line 100 of file RooAbsCachedPdf.cxx. ◆ getCachePdf() [1/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet & ; nset); const. inline . Definition at line 39 of file RooAbsCachedPdf.h. ◆ getCachePdf() [2/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooHistPdf cache pdf for given choice of observables. ; Definition at line 90 of file RooAbsCachedPdf.cxx. ◆ getInterpolationOrder(). Int_t RooAbsCachedPdf::getInterpolationOrder ; (; ); const. inline . Definition at line 51 of file RooAbsCachedPdf.h. ◆ getValV(). double RooAbsCachedPdf::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Implementation of getVal() overriding default implementation of RooAbsPdf. ; Return normalized value stored in cache p.d.f rather than return value of evaluate() which is undefined for RooAbsCachedPdf ; Reimplemented from RooAbsReal.; Definition at line 72 of file RooAbsCachedPdf.cxx. ◆ histNameSuffix(). virtual TString RooAbsCachedPdf::histNameSuffix ; (; ); const. inlineprotectedvirtual . Reimplemented in RooFFTConvPdf.; Definition at line 115 of file RooAbsCachedPdf.h. ◆ inputBaseName(). virtual const char * RooAbsCachedPdf::inputBaseName ; (; ); const. protectedpure virtual . Implemented in RooIntegralMorph, RooCachedPdf, and RooFFTConvPdf. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:82586,cache,cache,82586,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"; If name contains a '.' it is assumed to be the name of a file, and; the macro is automatically filled by reading all the lines in the file,; if the title is empty, it will be set to the name of the file,; the name will be set to the filename without path or extension. . Definition at line 75 of file TMacro.cxx. ◆ ~TMacro(). TMacro::~TMacro ; (; ). virtual . Delete this macro. ; Definition at line 111 of file TMacro.cxx. Member Function Documentation. ◆ AddLine(). TObjString * TMacro::AddLine ; (; const char * ; text). virtual . Add line with text in the list of lines of this macro. ; Definition at line 138 of file TMacro.cxx. ◆ Browse(). void TMacro::Browse ; (; TBrowser * ; b). overridevirtual . When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ; TMacro.Browse can be set in the system.rootrc or .rootrc file like: TMacro.Browse : Action; TMacro::Browsevoid Browse(TBrowser *b) overrideWhen clicking in the browser, the following action is performed on this macro, depending the content ...Definition TMacro.cxx:171; or set via gEnv->SetValue, eg gEnv->SetValue(""TMacro.Browse"",""Print"");; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; By default TMacro.Browse="""" -if TMacro.Browse ="""" the macro is executed -if TMacro.Browse =""Print"" the macro is printed in stdout -if TMacro.Browse is of the form ""mymacro.C"" the macro void mymacro.C(TMacro *m) is called where m=this macro An example of macro.C saving the macro into a file and viewing it with emacs is shown below: void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:15656,perform,performed,15656,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['perform'],['performed']
Performance,"; In particular we looking for possible alternative name (default template parameter, typedefs template arguments, typedefed name). ; Definition at line 1484 of file TROOT.cxx. ◆ ForceStyle(). void TROOT::ForceStyle ; (; Bool_t ; force = kTRUE). inline . Definition at line 206 of file TROOT.h. ◆ FromPopUp(). Bool_t TROOT::FromPopUp ; (; ); const. inline . Definition at line 207 of file TROOT.h. ◆ GetApplication(). TApplication * TROOT::GetApplication ; (; ); const. inline . Definition at line 209 of file TROOT.h. ◆ GetBinDir(). const TString & TROOT::GetBinDir ; (; ). static . Get the binary directory in the installation. Static utility function. ; Definition at line 2989 of file TROOT.cxx. ◆ GetBuiltDate(). Int_t TROOT::GetBuiltDate ; (; ); const. inline . Definition at line 221 of file TROOT.h. ◆ GetBuiltTime(). Int_t TROOT::GetBuiltTime ; (; ); const. inline . Definition at line 222 of file TROOT.h. ◆ GetClass() [1/2]. TClass * TROOT::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class with name. Obsolete, use TClass::GetClass directly. ; Definition at line 1518 of file TROOT.cxx. ◆ GetClass() [2/2]. TClass * TROOT::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class from its name. ; Obsolete, use TClass::GetClass directly See TClass::GetClass ; Definition at line 1528 of file TROOT.cxx. ◆ GetClipboard(). TSeqCollection * TROOT::GetClipboard ; (; ); const. inline . Definition at line 254 of file TROOT.h. ◆ GetColor(). TColor * TROOT::GetColor ; (; Int_t ; color); const. Return address of color with index color. ; Definition at line 1536 of file TROOT.cxx. ◆ GetConfigFeatures(). const char * TROOT::GetConfigFeatures ; (; ); const. inline . Definition at line 215 of file TROOT.h. ◆ GetConfigOptions(). const char * TROOT::GetConfigOptions ; (; ); const. inline . Definition at line 214 of file TROOT.h. ◆ GetCutClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:48623,load,load,48623,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['load'],['load']
Performance,"; In particular we looking for possible alternative name (default template parameter, typedefs template arguments, typedefed name). ; Definition at line 1484 of file TROOT.cxx. ◆ ForceStyle(). void TROOT::ForceStyle ; (; Bool_t ; force = kTRUE). inline . Definition at line 206 of file TROOT.h. ◆ FromPopUp(). Bool_t TROOT::FromPopUp ; (; ); const. inline . Definition at line 207 of file TROOT.h. ◆ GetApplication(). TApplication * TROOT::GetApplication ; (; ); const. inline . Definition at line 209 of file TROOT.h. ◆ GetBinDir(). const TString & TROOT::GetBinDir ; (; ). static . Get the binary directory in the installation. Static utility function. ; Definition at line 2993 of file TROOT.cxx. ◆ GetBuiltDate(). Int_t TROOT::GetBuiltDate ; (; ); const. inline . Definition at line 221 of file TROOT.h. ◆ GetBuiltTime(). Int_t TROOT::GetBuiltTime ; (; ); const. inline . Definition at line 222 of file TROOT.h. ◆ GetClass() [1/2]. TClass * TROOT::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class with name. Obsolete, use TClass::GetClass directly. ; Definition at line 1518 of file TROOT.cxx. ◆ GetClass() [2/2]. TClass * TROOT::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class from its name. ; Obsolete, use TClass::GetClass directly See TClass::GetClass ; Definition at line 1528 of file TROOT.cxx. ◆ GetClipboard(). TSeqCollection * TROOT::GetClipboard ; (; ); const. inline . Definition at line 254 of file TROOT.h. ◆ GetColor(). TColor * TROOT::GetColor ; (; Int_t ; color); const. Return address of color with index color. ; Definition at line 1536 of file TROOT.cxx. ◆ GetConfigFeatures(). const char * TROOT::GetConfigFeatures ; (; ); const. inline . Definition at line 215 of file TROOT.h. ◆ GetConfigOptions(). const char * TROOT::GetConfigOptions ; (; ); const. inline . Definition at line 214 of file TROOT.h. ◆ GetCutClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:48592,load,load,48592,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['load'],['load']
Performance,"; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:36311,optimiz,optimizations,36311,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,3,['optimiz'],['optimizations']
Performance,; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:12451,cache,cache,12451,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:5813,load,load,5813,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,2,['load'],['load']
Performance,"; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:5802,load,load,5802,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:7677,cache,cache,7677,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['cache'],['cache']
Performance,"; Int_t GetEvent (Long64_t entry, Int_t getall=0);  ; TEventList * GetEventList () const;  ; virtual Int_t GetFileNumber () const;  ; virtual TTree * GetFriend (const char *) const;  Return a pointer to the TTree friend whose name or alias is friendname. ;  ; virtual const char * GetFriendAlias (TTree *) const;  If the 'tree' is a friend, this method returns its alias name. ;  ; TH1 * GetHistogram ();  ; virtual bool GetImplicitMT ();  ; virtual Int_t * GetIndex ();  ; virtual Double_t * GetIndexValues ();  ; ROOT::TIOFeatures GetIOFeatures () const;  Returns the current set of IO settings. ;  ; virtual TIterator * GetIteratorOnAllLeaves (bool dir=kIterForward);  Creates a new iterator that will go through all the leaves on the tree itself and its friend. ;  ; virtual TList * GetListOfAliases () const;  ; virtual TList * GetListOfClones ();  ; virtual TList * GetListOfFriends () const;  ; Int_t GetMakeClass () const;  ; virtual Long64_t GetMaxEntryLoop () const;  ; virtual Long64_t GetMaxVirtualSize () const;  ; TObject * GetNotify () const;  ; virtual Int_t GetPacketSize () const;  ; virtual TVirtualPerfStats * GetPerfStats () const;  ; TVirtualTreePlayer * GetPlayer ();  Load the TTreePlayer (if not already done). ;  ; TTreeCache * GetReadCache (TFile *file) const;  Find and return the TTreeCache registered with the file and which may contain branches for us. ;  ; TTreeCache * GetReadCache (TFile *file, bool create);  Find and return the TTreeCache registered with the file and which may contain branches for us. ;  ; virtual Long64_t GetReadEvent () const;  ; virtual Int_t GetScanField () const;  ; TTreeFormula * GetSelect ();  ; virtual Long64_t GetSelectedRows ();  ; Float_t GetTargetMemoryRatio () const;  ; virtual Int_t GetTimerInterval () const;  ; virtual Long64_t GetTotBytes () const;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TTree for reading/writing baskets. ;  ; virtual TVirtualIndex * GetTreeIndex ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:20325,Load,Load,20325,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['Load'],['Load']
Performance,"; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:4162,cache,cache,4162,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:33388,cache,cache,33388,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,3,['cache'],['cache']
Performance,"; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter, bool useTitle, bool useLatex); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter, bool useTitle, bool useLatex); Write the GraphViz representation of the expr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:33135,cache,cache,33135,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['cache'],['cache']
Performance,"; Long64_tTEventIter::fElemNumnumber of entries to process for this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterTree.html:7043,cache,cache,7043,root/html530/TEventIterTree.html,https://root.cern,https://root.cern/root/html530/TEventIterTree.html,6,['cache'],['cache']
Performance,"; Long64_t fCanvVersion {1};  ! actual canvas version, changed with every new Modified() call ;  ; UInt_t fClientBits {0};  ! latest status bits from client like editor visible or not ;  ; UInt_t fColorsHash {0};  ! last hash of colors/palette ;  ; Long64_t fColorsVersion {0};  ! current colors/palette version, checked every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique_ptr< ROOT::RWebDisplayHandle > > fHelpHandles;  ! array of handles for help widgets ;  ; Int_t fJsonComp {0};  ! compression factor for messages send to the client ;  ; Bool_t fLongerPolling {kFALSE};  ! when true, make longer polling in blocking operations ;  ; ObjectSelectSignal_t fObjSelectSignal;  ! signal emitted when new object selected in the pad ;  ; PadClickedSignal_t fPadClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; PadClickedSignal_t fPadDblClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; std::map< TPad *, PadStatus > fPadsStatus;  ! map of pads in canvas and their status flags ;  ; Int_t fPaletteDelivery {1};  ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ;  ; Int_t fPrimitivesMerge {100};  ! number of PS primitives, which will be merged together ;  ; Bool_t fProcessingData {kFALSE};  ! flag used to prevent blocking methods when process data is invoked ;  ; Bool_t fReadOnly {kFALSE};  !< configured display ;  ; Int_t fStyleDelivery {0};  ! gStyle delivery to clients: 0:never, 1:once, 2:always ;  ; UInt_t fStyleHash {0};  ! last hash of gStyle ;  ; Long64_t fStyleVersion {0};  ! current gStyle object version, checked every time when new snapshot created ;  ; Int_t fTF1UseSave {1};  ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ;  ; TWebCanvasTimer * fTimer {nullptr};  ! timer to submit control messages ;  ; UpdatedSignal_t fUpdatedSignal;  ! signal emitted when canvas updated or state is changed ;  ; std::map< TObject *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:14982,perform,performed,14982,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['perform'],['performed']
Performance,"; MatchLegacyCheckSum(UInt_t checksum) constTStreamerInfo; MayNotUse(const char *method) constTObject; New(void *obj=nullptr) overrideTStreamerInfovirtual; NewArray(Long_t nElements, void *ary=nullptr) overrideTStreamerInfovirtual; NewInfo(TClass *cl) overrideTStreamerInfoinlinevirtual; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TStreamerInfo &)=deleteTStreamerInfoprivate; TVirtualStreamerInfo::operator=(const TVirtualStreamerInfo &)TVirtualStreamerInfoprotected; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; Optimize(Bool_t opt=kTRUE)TVirtualStreamerInfostatic; Paint(Option_t *option="""")TObjectvirtual; Pop()TObjectvirtual; Print(Option_t *option="""") const overrideTNamedvirtual; PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) constTStreamerInfo; PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count)TStreamerInfoprivatestatic; PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) constTStreamerInfo; PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) constTStreamerInfo; Read(const char *name)TObjectvirtual; ReadBuffer(TBuffer &b, const T &arrptr, TCompInfo *const *const compinfo, Int_t first, Int_t last, Int_t narr=1, Int_t eoffset=0, Int_t mode=0)TStreamerInfo; ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset)TStreamerInfo; ReadBufferClones(TBuffer &b, TClonesArray *clon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo-members.html:14251,Optimiz,Optimize,14251,doc/master/classTStreamerInfo-members.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo-members.html,1,['Optimiz'],['Optimize']
Performance,"; Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); function to read class from buffer, used in old-style streamers. void WriteClass(const TClass* cl); function to write class into buffer, used in old-style streamers. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferXML.html:34166,Perform,PerformPostProcessing,34166,root/html534/TBufferXML.html,https://root.cern,https://root.cern/root/html534/TBufferXML.html,2,['Perform'],['PerformPostProcessing']
Performance,"; Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferXML.html:34923,Perform,PerformPostProcessing,34923,root/html602/TBufferXML.html,https://root.cern,https://root.cern/root/html602/TBufferXML.html,1,['Perform'],['PerformPostProcessing']
Performance,"; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsAnaConvPdf;  ; class RooAddModel;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:73720,Cache,CacheMode,73720,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['Cache'],['CacheMode']
Performance,"; Private Member Functions |; Friends |; List of all members ; RooMCStudy Class ReferenceRooFit » RooFit Core. ; Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. ; These may be generated from either same PDF or from a different PDF with similar parameters.; Given a fit and a generator PDF (they might be identical), RooMCStudy can produce toyMC samples and/or fit these. It accumulates the post-fit parameters of each iteration in a dataset. These can be retrieved using fitParams() or fitParDataSet(). This dataset additionally contains the variables; NLL: The value of the negative log-likelihood for each run.; ngen: The number of events generated for each run. Additional plotting routines simplify the task of plotting the distribution of the minimized likelihood, the fitted parameter values, fitted error and pull distribution.; RooMCStudy provides the option to insert add-in modules that modify the generate-and-fit cycle and allow to perform extra steps in the cycle. Output of these modules can be stored alongside the fit results in the aggregate results dataset. These study modules should derive from the class RooAbsMCStudyModule.; Check the RooFit tutorials; rf801_mcstudy.C; rf802_mcstudy_addons.C; rf803_mcstudy_addons2.C; rf804_mcstudy_constr.C for usage examples. PyROOT; Some member functions of RooMCStudy that take a RooCmdArg as argument also support keyword arguments. So far, this applies to constructor RooMCStudy(), RooMCStudy::plotParamOn, RooMCStudy::plotParam, RooMCStudy::plotNLL, RooMCStudy::plotError and RooMCStudy::plotPull. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; frame3 = mcstudy.plotPull(mean, ROOT.RooFit.Bins(40), ROOT.RooFit.FitGauss(True)); ; # With keyword arguments:; frame3 = mcstudy.plotPull(mean, Bins=40, FitGauss=True). Definition at line 32 of file RooMCStudy.h. Public Member Functions;  RooMCStudy (cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:1292,perform,perform,1292,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['perform'],['perform']
Performance,"; Reimplemented from TGMainFrame.; Definition at line 310 of file TProofProgressLog.cxx. ◆ DeclFileName(). static const char * TProofProgressLog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TProofProgressLog.h. ◆ DoLog(). void TProofProgressLog::DoLog ; (; Bool_t ; grep = kFALSE). Display logs. ; 'grep' is set to kTRUE if it is invoked by pressing the 'Filter' button. ; Definition at line 388 of file TProofProgressLog.cxx. ◆ Init(). void TProofProgressLog::Init ; (; Int_t ; w = 700, . Int_t ; h = 600 . ). private . Init window frame for log messages. ; Definition at line 70 of file TProofProgressLog.cxx. ◆ IsA(). TClass * TProofProgressLog::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 93 of file TProofProgressLog.h. ◆ LoadBuffer(). void TProofProgressLog::LoadBuffer ; (; const char * ; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. ◆ LoadFile(). void TProofProgressLog::LoadFile ; (; const char * ; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. ◆ LogMessage(). void TProofProgressLog::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame, if open. ; Definition at line 519 of file TProofProgressLog.cxx. ◆ NoLineEntry(). void TProofProgressLog::NoLineEntry ; (; ). Enable/disable the line number entry. ; Definition at line 599 of file TProofProgressLog.cxx. ◆ Popup(). void TProofProgressLog::Popup ; (; ). Show log window. ; Definition at line 263 of file TProofProgressLog.cxx. ◆ Rebuild(). void TProofProgressLog::Rebuild ; (; ). Rebuild the log info for a new entered session. ; Definition at line 635 of file TProofProgressLog.cxx. ◆ SaveToFile(). void TProofProgressLog::SaveToFile ; (; ). Save the logs to a file Only the name of the file is taken, no expansion. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:41116,Load,Load,41116,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['Load'],['Load']
Performance,"; Reimplemented from TTree.; Definition at line 2571 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2613 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2441 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2640 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """" (default): both the file names of the chain elements and the file names of the TEntryList sublists are expanded to full path name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:96881,cache,cachesize,96881,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['cache'],['cachesize']
Performance,"; Reimplemented from TTree.; Definition at line 2597 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2639 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2666 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """" (default): both the file names of the chain elements and the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:97435,cache,cachesize,97435,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['cache'],['cachesize']
Performance,"; Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ==================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:53177,Perform,Performs,53177,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['Perform'],['Performs']
Performance,"; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = kAscii, const char* rfile = 0); Send a file to the server. Return 0 on success, -1 in case of error.; If defined, the full path of the remote path will be rfile.; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run). void Terminate(Int_t status = 0); Terminate this session. void SetPortParam(Int_t lower = -1, Int_t upper = -1, Int_t attempts = -1); Set port parameters for tunnelling. A value of -1 means unchanged. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* error = 0); Parse a single command line and forward the request to the remote server; where it will be processed. The line is either a C++ statement or an; interpreter command starting with a ""."".; Return the return value of the command casted to a long. void Print(Option_t* option = """") const; Print some info about this instance. void Interrupt(Int_t type = kRRI_Hard); Send interrupt OOB byte to server.; Returns 0 if ok, -1 in case of error. void Browse(TBrowser* b); Browse remote application (working directory and ROOT files). Int_t Broadcast(const TMessage& mess). Bool_t IsFolder() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:16062,cache,cache,16062,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,5,['cache'],['cache']
Performance,"; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = kAscii, const char* rfile = 0); Send a file to the server. Return 0 on success, -1 in case of error.; If defined, the full path of the remote path will be rfile.; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run). void Terminate(Int_t status = 0); Terminate this session. void SetPortParam(Int_t lower = -1, Int_t upper = -1, Int_t attempts = -1); Set port parameters for tunnelling. A value of -1 means unchanged. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* error = 0); Parse a single command line and forward the request to the remote server; where it will be processed. The line is either a C++ statement or an; interpreter command starting with a ""."".; Return the return value of the command casted to a long. void Print(Option_t* option = """") const; Print some info about this instance. void Interrupt(Int_t type = kRRI_Hard); Send interrupt OOB byte to server.; Returns 0 if ok, -1 in case of error. void Browse(TBrowser* b); Browse remote application (working directory and ROOT files). Int_t Broadcast(const TMessage& mess). TApplicationRemote(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationRemote.html:17265,cache,cache,17265,root/html602/TApplicationRemote.html,https://root.cern,https://root.cern/root/html602/TApplicationRemote.html,2,['cache'],['cache']
Performance,"; Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the proxy describinb the collection (if any). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char *name, Bool_t load, Bool_t silent); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class namesmassaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t /* silent */); Return pointer to class with name. VoidFuncPtr_t GetDict(const char *cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:23363,load,load,23363,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,2,['load'],"['load', 'loading']"
Performance,"; Returns -1 if window initialization fails. Int_t AddWindow(ULong_t qwid, UInt_t w, UInt_t h); Registers a window created by Qt as a ROOT window. w, h - the width and height, which define the window size. Int_t AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); Registers a pixmap created by TGLManager as a ROOT pixmap. w, h - the width and height, which define the pixmap size. void RemoveWindow(ULong_t qwid); Removes the created by Qt window ""qwid"". void MoveWindow(Int_t wid, Int_t x, Int_t y); Moves the window ""wid"" to the specified x and y coordinates.; It does not change the window's size, raise the window, or change; the mapping state of the window. x, y - coordinates, which define the new position of the window; relative to its parent. Int_t OpenPixmap(UInt_t w, UInt_t h); Creates a pixmap of the width ""w"" and height ""h"" you specified. void QueryPointer(Int_t& ix, Int_t& iy); Returns the pointer position. Pixmap_t ReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); If id is NULL - loads the specified gif file at position [x0,y0] in the; current window. Otherwise creates pixmap from gif file. Int_t RequestLocator(Int_t mode, Int_t ctyp, Int_t& x, Int_t& y); Requests Locator position.; x,y - cursor position at moment of button press (output); ctyp - cursor type (input); ctyp = 1 tracking cross; ctyp = 2 cross-hair; ctyp = 3 rubber circle; ctyp = 4 rubber band; ctyp = 5 rubber rectangle. mode - input mode; mode = 0 request; mode = 1 sample. The returned value is:; in request mode:; 1 = left is pressed; 2 = middle is pressed; 3 = right is pressed; in sample mode:; 11 = left is released; 12 = middle is released; 13 = right is released; -1 = nothing is pressed or released; -2 = leave the window; else = keycode (keyboard is pressed). Int_t RequestString(Int_t x, Int_t y, char* text); Requests string: text is displayed and can be edited with Emacs-like; keybinding. Returns termination code (0 for ESC, 1 for RETURN). x,y - position where text is displayed; text ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:27973,load,loads,27973,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,6,['load'],['loads']
Performance,"; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:15212,cache,cacheArgs,15212,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,2,"['Cache', 'cache']","['Cache', 'cacheArgs']"
Performance,"; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooResolutionModel&operator=(const RooResolutionModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:25213,optimiz,optimizeCacheMode,25213,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,4,['optimiz'],['optimizeCacheMode']
Performance,"; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__BayesianCalculator.html:11317,cache,cached,11317,root/html534/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__BayesianCalculator.html,3,['cache'],['cached']
Performance,"; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFracRemainder(); Default constructor. RooFracRemainder(const char* name, const char* title, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFracRemainder.html:36171,cache,cache,36171,root/html602/RooFracRemainder.html,https://root.cern,https://root.cern/root/html602/RooFracRemainder.html,4,['cache'],['cache']
Performance,"; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Definition RooGlobalFunc.cxx:134; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf501_simultaneouspdfDefinition rf501_simultaneouspdf.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html:9345,optimiz,optimization,9345,doc/master/rf501__simultaneouspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html,2,['optimiz'],['optimization']
Performance,"; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:33836,cache,cache,33836,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,1,['cache'],['cache']
Performance,; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:37281,cache,cache,37281,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,3,['cache'],['cache']
Performance,; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:44777,cache,cache,44777,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2571 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2613 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2441 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2640 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:96746,cache,cacheSize,96746,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['cache'],['cacheSize']
Performance,"; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2597 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2639 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2666 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:97300,cache,cacheSize,97300,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['cache'],['cacheSize']
Performance,"; Set global passwd hash flag to be used for authentication to rootd or proofd. void SetGlobalSRPPwd(Bool_t srppwd); Set global SRP passwd flag to be used for authentication to rootd or proofd. void SetReadHomeAuthrc(Bool_t readhomeauthrc); Set flag controlling the reading of $HOME/.rootauthrc.; In PROOF the administrator may want to switch off private settings.; Always true, may only be set false via option to proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTimeOut(Int_t to); Set timeout (active if > 0). void SetAuthReUse(Bool_t authreuse); Set global AuthReUse flag. void SetPromptUser(Bool_t promptuser); Set global PromptUser flag. void SetSecureAuthHook(SecureAuth_t func); Set secure authorization function. Automatically called when libSRPAuth; is loaded. void SetKrb5AuthHook(Krb5Auth_t func); Set kerberos5 authorization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:16510,load,loaded,16510,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['load'],['loaded']
Performance,"; Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The axis x may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1. void Multiply(const TH1* h1); Multiply this profile by h1*-*-; *-* =============================. this = this*h1. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH1D * ProjectionX(const char* name = ""_px"", Option_t* option = ""e"") const; Project this profile into a 1-D histogram along X*-*-; *-* =================================================. The projection is always of the type TH1D. if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:37924,Perform,Performs,37924,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,3,['Perform'],['Performs']
Performance,"; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TSPlot Class Reference. ; Legacy Code TSPlot is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TSPlot might still be a valid solution. ; A common method used in High Energy Physics to perform measurements is the maximum Likelihood method, exploiting discriminating variables to disentangle signal from background. The crucial point for such an analysis to be reliable is to use an exhaustive list of sources of events combined with an accurate description of all the Probability Density Functions (PDF).; To assess the validity of the fit, a convincing quality check is to explore further the data sample by examining the distributions of control variables. A control variable can be obtained for instance by removing one of the discriminating variables before performing again the maximum Likelihood fit: this removed variable is a control variable. The expected distribution of this control variable, for signal, is to be compared to the one extracted, for signal, from the data sample. In order to be able to do so, one must be able to unfold from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for the control variable, independently for each of the various sources of events, without making use of any a priori knowledge on this variable. The aim is thus to use the knowledge available for the discriminating variables to infer the behaviour of the individual sources of events with respect to the control variable.; TSPlot is optimal if the control variable is uncorrelated with the discriminating variables.; A detail description of the formalism itself, called \(\hbox{$_s$}{\cal P}lot\), is given in [1]. The method; The \(\hbox{$_s$}{\cal P}lot\) technique is developed in the above contex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:1169,perform,performing,1169,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,1,['perform'],['performing']
Performance,"; T->Print();; T->Write();; }; ; void read() {; //read the JetEvent file; TFile f(""JetEvent.root"");; TTree *T = (TTree*)f.Get(""T"");; JetEvent *event = 0;; T->SetBranchAddress(""event"", &event);; Long64_t nentries = T->GetEntries();; ; for (Long64_t ev=0;ev<nentries;ev++) {; T->GetEntry(ev);; if (ev) continue; //dump first event only; cout << "" Event: ""<< ev; << "" Jets: "" << event->GetNjet(); << "" Tracks: "" << event->GetNtrack(); << "" Hits A: "" << event->GetNhitA(); << "" Hits B: "" << event->GetNhitB() << endl;; }; }; ; void pileup(Int_t nev=200) {; //make nev pileup events, each build with LOOPMAX events selected; //randomly among the nentries; TFile f(""JetEvent.root"");; TTree *T = (TTree*)f.Get(""T"");; // Long64_t nentries = T->GetEntries();; ; const Int_t LOOPMAX=10;; JetEvent *events[LOOPMAX];; Int_t loop;; for (loop=0;loop<LOOPMAX;loop++) events[loop] = 0;; for (Long64_t ev=0;ev<nev;ev++) {; if (ev%10 == 0) printf(""building pileup: %lld\n"",ev);; for (loop=0;loop<LOOPMAX;loop++) {; Int_t rev = gRandom->Uniform(LOOPMAX);; T->SetBranchAddress(""event"", &events[loop]);; T->GetEntry(rev);; }; }; }; ; void jets(Int_t nev=100, Int_t npileup=200, Bool_t secondrun = true) {; // Embedding these loads inside the first run of the script is not yet; // supported in v6; // gROOT->ProcessLine("".L $ROOTSYS/tutorials/tree/JetEvent.cxx+"");; write(nev);; read();; pileup(npileup);; }; ; #else; ; //void jets(Int_t nev=100, Int_t npileup=200, Bool_t secondrun);; void jets(Int_t nev=100, Int_t npileup=200) {; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".L "" + tutdir + ""/tree/JetEvent.cxx+"");; gROOT->ProcessLine(""#define JETS_SECOND_RUN yes"");; gROOT->ProcessLine(""#include \"""" __FILE__ ""\"""");; gROOT->ProcessLine(""jets(100,200,true)"");; }; ; #endif; JetEvent.h; f#define f(i)Definition RSha256.hxx:104; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TFile.h; nentriesin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree_2jets_8C.html:2191,load,loads,2191,doc/master/tree_2jets_8C.html,https://root.cern,https://root.cern/doc/master/tree_2jets_8C.html,1,['load'],['loads']
Performance,"; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TBRIKA box with faces perpendicular to the axes.Definition TBRIK.h:26; TCONEA conical tube.Definition TCONE.h:28; TCONSA segment of a conical tube.Definition TCONS.h:27; TCanvasThe Canvas class.Definition TCanvas.h:23; TGTRAA general twisted trapezoid.Definition TGTRA.h:27; TGeoManager::GetListOfNodesTObjArray * GetListOfNodes()Definition TGeoManager.h:467; TGeoManager::GetListOfShapesTObjArray * GetListOfShapes() constDefinition TGeoManager.h:475; TNodeTNode description.Definition TNode.h:33; TNode::Drawvoid Draw(Option_t *option="""") overrideDraw Referenced node with current parameters.Definition TNode.cxx:322; TNode::cdvirtual void cd(const char *path=nullptr)Change Current Reference node to this.Definition TNode.cxx:249; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TPARAA parallelepiped.Definition TPARA.h:30; TPCONA polycone.Definition TPCON.h:33; TPCON::DefineSectionvirtual void DefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax)Defines section secNum of the polycone.Definition TPCON.cxx:174; TPGONA polygon.Definition TPGON.h:30; TSPHEA Sphere.Definition TSPHE.h:28; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TTRAPA general trapezoid.Definition TTRAP.h:33; TTRD1A trapezoid with the x dimension varying along z.Definition TTRD1.h:28; TTRD2A trapezoid with both x and y dimensions varying along z.Definition TTRD2.h:29; TTUBEA tube.Definition TTUBE.h:32; TTUBSA segment of a tube.Definition TTUBS.h:29; c1return c1Definition legend1.C:41; shapesDefinition shapes.py:1; AuthorRene Brun ; Definition in file shapes.C. tutorialsgeomshapes.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/shapes_8C.html:5299,Load,Loadvirtual,5299,doc/master/shapes_8C.html,https://root.cern,https://root.cern/doc/master/shapes_8C.html,3,['Load'],"['Load', 'Loadvirtual']"
Performance,; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 162 of file RooMomentMorphFuncND.h. ◆ sumFunc(). RooMomentMorphFuncND::Base_t * RooMomentMorphFuncND::sumFunc ; (; const RooArgSet * ; nset). protected . Definition at line 522 of file RooMomentMorphFuncND.cxx. ◆ useHorizontalMorphing(). void RooMomentMorphFuncND::useHorizontalMorphing ; (; bool ; val). inline . Definition at line 127 of file RooMomentMorphFuncND.h. Friends And Related Symbol Documentation. ◆ CacheElem. friend class CacheElem. friend . Definition at line 140 of file RooMomentMorphFuncND.h. ◆ Grid2. friend class Grid2. friend . Definition at line 141 of file RooMomentMorphFuncND.h. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooMomentMorphFuncND::_cacheMgr. mutableprotected . ! Transient cache manager ; Definition at line 143 of file RooMomentMorphFuncND.h. ◆ _curNormSet. RooArgSet* RooMomentMorphFuncND::_curNormSet = nullptr. mutableprotected . ! Transient cache manager ; Definition at line 144 of file RooMomentMorphFuncND.h. ◆ _isPdfMode. bool RooMomentMorphFuncND::_isPdfMode = false. protected . Definition at line 158 of file RooMomentMorphFuncND.h. ◆ _M. std::unique_ptr<TMatrixD> RooMomentMorphFuncND::_M. mutableprotected . Definition at line 151 of file RooMomentMorphFuncND.h. ◆ _MSqr. std::unique_ptr<TMatrixD> RooMomentMorphFuncND::_MSqr. mutableprotected . Definition at line 152 of file RooMomentMorphFuncND.h. ◆ _obsList. RooSetProxy RooMomentMorphFuncND::_obsList. protected . Definition at line 147 of file RooMomentMorphFuncND.h. ◆ _parList. RooListProxy RooMomentMorphFuncND::_parList. protected . Definition at line 146 of file RooMomentMorphFuncND.h. ◆ _pdfList. RooListProxy RooMomentMorphFuncND::_pdfList. protected . Definition at line 149 of file RooMomentMorphFuncND.h. ◆ _referenceGrid. Grid2 RooMomentMorphFuncND::_referenceGrid. mutableprotected . Definition at line 148 of file RooMomentMorphFuncND.h. ◆ _setting. Setting RooMomentMorphFuncND::_setting. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:68148,cache,cache,68148,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['cache'],['cache']
Performance,; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:52238,cache,cache,52238,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2211 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:52308,cache,cache,52308,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::W...Definition TClonesArray.cxx:321; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::GetObjectRefvirtual TObject ** GetObjectRef(const TObject *obj) const =0; TCollection::MakeIteratorvirtual TIterator * MakeIterator(Bool_t dir=kIterForward) const =0; TCollection::Classstatic TClass * C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:404101,load,load,404101,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['load']
Performance,"; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual std::list< double > * binBoundaries (RooAbsRealLValue &obs, double xlo, double xhi) const;  Retrieve bin boundaries if this distribution is binned in obs. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooLinkedList &cmdList);  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:18214,Perform,Perform,18214,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,108,['Perform'],['Perform']
Performance,"; TFile::SetCompressionAlgorithmvirtual void SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)See comments for function SetCompressionSettings.Definition TFile.cxx:2305; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::fNbytesFreeInt_t fNbytesFreeNumber of bytes for free segments structure.Definition TFile.h:85; TFile::fDInt_t fDFile descriptor.Definition TFile.h:82; TFile::ResetErrnovirtual void ResetErrno() constMethod resetting the errno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::SetOptionvirtual void SetOption(Option_t *option="">"")Definition TFile.h:289; TFile::EFileTypeEFileTypeFile type.Definition TFile.h:202; TFile::kWeb@ kWebDefinition TFile.h:202; TFile::kDefault@ kDefaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:40613,cache,cache,40613,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"; TFile::SetReadCallsvirtual void SetReadCalls(Int_t readcalls=0)Definition TFile.h:290; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::GetNfreevirtual Int_t GetNfree() constDefinition TFile.h:238; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TFile.h:64; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::GetBytesWrittenvirtual Long64_t GetBytesWritten() constReturn the total number of bytes written so far to the file.Definition TFile.cxx:4566; TFile::ERelativeToERelativeToDefinition TFile.h:199; TFile::kCur@ kCurDefinition TFile.h:199; TFile::kBeg@ kBegDefinition TFile.h:199; TFile::kEnd@ kEndDefinition TFile.h:199; TFile::GetSeekInfovirtual Long64_t GetSeekInfo() constDefinition TFile.h:253; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:38221,cache,cache,38221,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:12910,cache,cache,12910,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,3,['cache'],['cache']
Performance,"; TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ""invisible"" (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:31438,optimiz,optimizes,31438,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimizes', 'performance']"
Performance,"; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::kVolumeImportNodes@ kVolumeImportNodesDefinition TGeoVolume.h:76; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::GetNodeTGeoNode * GetNode(const char *name) constget the pointer to a daughter nodeDefinition TGeoVolume.cxx:2193; TGeoVolume::GetIndexInt_t GetIndex(const TGeoNode *node) constget index number for a given daughterDefinition TGeoVolume.cxx:1743; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::SetShapevoid SetShape(const TGeoShape *shape)set the shape associated with this volumeDefinition TGeoVolume.cxx:2067; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::IsAssemblyvirtual Bool_t IsAssembly() constReturns true if the volume is an assembly or a scaled assembly.Definition TGeoVolume.cxx:1822; TGeoVoxelFinderFinder class handling voxels.Definition TGeoVoxelFinder.h:20; TGeoVoxelFinder::SetNeedRebuildvoid SetNeedRebuild(Bool_t flag=kTRUE)Definition TGeoVoxelFinder.h:107; TGeoVoxelFinder::Voxelizevirtual void Voxelize(Option_t *option="""")Voxelize attached volume according to option If the volume is an assembly, make sure the bbox is comp...Definition TGeoVoxelFinder.cxx:2419; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:32565,optimiz,optimization,32565,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"; TH3::IntegralDouble_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH3.cxx:1390; TH3::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w)Accumulate arguments in buffer.Definition TH3.cxx:339; TH3::IsATClass * IsA() const overrideDefinition TH3.h:152; TH3::SetShowProjectionvirtual void SetShowProjection(const char *option=""xy"", Int_t nbins=1)When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a proj...Definition TH3.cxx:3676; TH3::RebinXTH3 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin3D.Definition TH3.cxx:2906; TH3::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH3.cxx:1191; TH3::DoProject1Dvirtual TH1D * DoProject1D(const char *name, const char *title, int imin1, int imax1, int imin2, int imax2, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, Option_t *option) constinternal method performing the projection to 1D histogram called from TH3::Project3DDefinition TH3.cxx:1829; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TH3.h:101; TH3::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH3.cxx:3468; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::TH3TH3()Default constructor.Definition TH3.cxx:74; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::FitSlicesZvirtual void FitSlicesZ(TF1 *f1=nullptr, Int_t binminx=1, Int_t binmaxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, Option_t *option=""QNR"")Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-...Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:210813,perform,performing,210813,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['perform'],['performing']
Performance,"; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes for StreamerInfo record. ;  ; Bool_t fNoAnchorInName {kFALSE};  !True if we don't want to force the anchor to be appended to the file name ;  ; Int_t fNProcessIDs {0};  Number of TProcessID written to this file. ;  ; Long64_t fOffset {0};  !Seek offset cache ;  ; TList * fOpenPhases {nullptr};  !Time info about open phases ;  ; TString fOption;  File options. ;  ; TObjArray * fProcessIDs {nullptr};  !Array of pointers to TProcessIDs ;  ; Int_t fReadCalls {0};  Number of read calls ( not counting the cache calls ) ;  ; TString fRealName;  Effective real file name (not original url) ;  ; Long64_t fSeekFree {0};  Location on disk of free segments structure. ;  ; Long64_t fSeekInfo {0};  Location on disk of StreamerInfo record. ;  ; Double_t fSum2Buffer {0};  Sum of squares of buffer sizes of objects written so far. ;  ; Double_t fSumBuffer {0};  Sum of buffer sizes of objects written so far. ;  ; Char_t fUnits {0};  Number of bytes for file pointers. ;  ; TUrl fUrl;  !URL of file ;  ; Int_t fVersion {0};  File format version. ;  ; std::mutex fWriteMutex;  !Lock for writing baskets / keys into the file. ;  ; Int_t fWritten {0};  Number of objects written so far. ;  ;  Protected Attributes inherited from TDirectoryFile; Int_t fBufferSize {0};  Default buffer size to crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:39248,cache,cache,39248,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['cache'],['cache']
Performance,"; TMinuit::fApsiDouble_t fApsiDefinition TMinuit.h:54; TMinuit::fBigedmDouble_t fBigedmDefinition TMinuit.h:61; TMinuit::~TMinuit~TMinuit() overrideMinuit default destructor.Definition TMinuit.cxx:497; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::GetPlotvirtual TObject * GetPlot() constDefinition TMinuit.h:200; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::SetGraphicsModevirtual void SetGraphicsMode(Bool_t mode=kTRUE)Definition TMinuit.h:263; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::GetObjectFitTObject * GetObjectFit() constDefinition TMinuit.h:194; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8h_source.html:20923,Perform,Performs,20923,doc/master/TMinuit_8h_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html,1,['Perform'],['Performs']
Performance,"; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::GetPlotvirtual TObject * GetPlot() constDefinition TMinuit.h:200; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::SetGraphicsModevirtual void SetGraphicsMode(Bool_t mode=kTRUE)Definition TMinuit.h:263; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::GetObjectFitTObject * GetObjectFit() constDefinition TMinuit.h:194; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinuit.h:108; TMinuit::fNfcnlcInt_t fNfcnlcDefinition TMinuit.h:147; TMinuit::fISWInt_t fISW[7]Definition TMinuit.h:141; TMinuit::fHESSyyDouble_t * fHESSyyDefinition TMinuit.h:104; TMinuit::fGraphicsMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8h_source.html:21157,Perform,Perform,21157,doc/master/TMinuit_8h_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html,1,['Perform'],['Perform']
Performance,"; TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGridJobStatusList.h 32840 2010-03-30 16:36:09Z rdm $ » Last generated: 2010-09-23 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJobStatusList.html:9414,cache,cache,9414,root/html528/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html528/TGridJobStatusList.html,1,['cache'],['cache']
Performance,"; TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGridJobStatusList.h 32840 2010-03-30 16:36:09Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGridJobStatusList.html:9535,cache,cache,9535,root/html530/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html530/TGridJobStatusList.html,1,['cache'],['cache']
Performance,"; TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGridJobStatusList.h 32840 2010-03-30 16:36:09Z rdm $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGridJobStatusList.html:9535,cache,cache,9535,root/html532/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html532/TGridJobStatusList.html,1,['cache'],['cache']
Performance,"; TPBReadType*fReadTypeType of read (partial, full); TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:""); Draw the CPU speedup plot.; opt = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node. Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs""); Draw the CPU speedup plot.; opt = 'std:' Standard scaling plot; 'norm:' Normalized scaling plot; 'stdx:' Standard scali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBench.html:8500,Perform,Perform,8500,root/html532/TProofBench.html,https://root.cern,https://root.cern/root/html532/TProofBench.html,1,['Perform'],['Perform']
Performance,"; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormulaVar.html:33067,cache,cache,33067,root/html530/RooFormulaVar.html,https://root.cern,https://root.cern/root/html530/RooFormulaVar.html,2,['cache'],['cache']
Performance,"; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::BaseNamevirtual const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:481313,Load,Loadvirtual,481313,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,3,['Load'],"['Load', 'Loadvirtual']"
Performance,; TTextEditor text editor; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Specialization of TFileCacheRead for a TTree; TTreeCacheUnzip Specialization of TTreeCache for parallel unzipping; TTreeCloner helper used for the fast cloning of TTrees.; TTreeDrawArgsParser Helper class to parse the argument to TTree::Draw; TTreeFormula The Tree formula; TTreeFormulaManager A class coordinating several TTreeFormula objects.; TTreeFriendLeafIter Linked list iterator; TTreeIndex A Tree Index with majorname and minorname.; TTreeInput Simple input dialog; TTreePerfStats TTree I/O performance measurement; TTreePlayer Manager class to play with TTrees; TTreeReader A simple interface to read trees; TTreeResult TTree query result; TTreeRow One row of an TTree query result; TTreeSQL TTree Implementation read and write to a SQL database.; TTreeTableInterface Interface to data in a TTree; TTreeViewer A GUI oriented tree viewer; TUDPSocket This class implements UDP client sockets; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldBinning Complex binning schemes for TUnfoldDensity; TUnfoldDensity Unfolding with densisty regularisation; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUpload,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:130809,perform,performance,130809,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['perform'],['performance']
Performance,"; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:34766,cache,cache,34766,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['cache'],['cache']
Performance,"; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35252,cache,cache,35252,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['cache'],['cache']
Performance,"; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (curren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36498,cache,cache,36498,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:8676,perform,perform,8676,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['perform'],['perform']
Performance,"; The percentage of the bar drawn with either the light or dark color is:. 0% for option ""(h)bar"" or ""(h)bar0""; 10% for option ""(h)bar1""; 20% for option ""(h)bar2""; 30% for option ""(h)bar3""; 40% for option ""(h)bar4"". To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:24309,scalab,scalable,24309,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,1,['scalab'],['scalable']
Performance,"; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extended; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:33077,cache,cache,33077,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,3,['cache'],['cache']
Performance,"; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:42137,cache,cache,42137,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 9.46654 L(-10 - 10) ""x""; 2) y = 0.0174204 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; 1) RooRealVar:: y = 0.0106407; 2) RooRealVar:: x = -0.79919; 1) RooRealVar:: x = 0.0106407; 2) RooRealVar:: y = -0.79919; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[y,x] = 64 entries; ; -----------------------; Reading data from ASCII; ; Original data, line 20:; ; Read-back data, line 20:; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf102_dataimport.py. tutorialsroofitrf102_dataimport.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:7146,load,loadValues,7146,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['load'],['loadValues']
Performance,"; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2) 514 ; ; =================================================================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; Factory : Booking method: ␛[1mPyKeras␛[0m; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Loading Keras Model ; : Loaded model from file: model_cnn.h5; Factory : Booking method: ␛[1mPyTorch␛[0m; : ; : Using PyTorch - setting special configuration options ; : Using PyTorch version 2; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; running Torch code defining the model....; The PyTorch CNN model is created and saved as PyTorchModelCNN.pt; : Loaded pytorch train function: ; : Loaded pytorch optimizer: ; : Loaded pytorch loss function: ; : Loaded pytorch predict function: ; : Loaded model from file: PyTorchModelCNN.pt; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: BDT for Classification; : ; BDT : #events: (reweighted) sig: 800 bkg: 800; : #events: (unweighted) sig: 800 bkg: 800; : Training 200 Decision Trees ... patience please; : Elapsed time for training with 1600 events: 0.877 sec ; BDT : [dataset] : Evaluation of BDT on tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:8638,Load,Loading,8638,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,2,['Load'],"['Loaded', 'Loading']"
Performance,"; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid caus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2966,perform,performance,2966,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['perform'],['performance']
Performance,"; and if that does not succeed, it will try the second one, and so on; until it finds a server that will respond. See the TNetFile documentation for the description of the other arguments. The creation consists of internal variable settings (most important is; the client's domain), creation of a TXUrl array containing all specified; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getting a valid access to the remote; server the client is connected to using GetAccessToSrv() method,; recognizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options field of the URL can be used for the following purposes:; a. open a non-ROOT generic file; ""root://server1:port1[,server2:port2,...]/pathfile?filetype=raw""; b. re-check the environment variables; ""root://server1:port1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:25488,cache,cachesz,25488,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,6,['cache'],['cachesz']
Performance,"; as either state names or 'name=id' assignments. Otherwise a RooRealvar is created and the; arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant. string processCreateArg(string& func, vector<string>& args); Glue function between high-level syntax and low-level factory call to createArg:; Process a parsed call to create a p.d.f named func. The func arg is interpreted as ClassName::ObjectName and the arglist is passed; verbatim to createArg. The received arglist is expected to be fully reduced (i.e.; all inline object creations must have been compiled). std::string processMetaArg(string& func, vector<string>& args); Concatenate list of args into comma separated string. vector<string> splitFunctionArgs(const char* funcExpr); Allocate and fill work buffer. Bool_t checkSyntax(const char* arg); Perform basic syntax on given factory expression. If function returns; true syntax errors are found. void checkIndex(UInt_t index). RooAbsArg& asARG(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsArg reference found in workspace. RooAbsReal& asFUNC(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsReal reference found in workspace. RooAbsRealLValue& asVARLV(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsRealLValue reference found in workspace. RooRealVar& asVAR(const char* ); CINT constructor interface, return constructor string argument #idx as RooRealVar reference found in workspace. RooAbsPdf& asPDF(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsPdf reference found in workspace. RooResolutionModel& asRMODEL(const char* ); CINT constructor interface, return constructor string argument #idx as RooResolutionModel refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFactoryWSTool.html:20538,Perform,Perform,20538,root/html602/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html602/RooFactoryWSTool.html,2,['Perform'],['Perform']
Performance,"; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClass::EStatefState!Current 'state' of the class (Emulated,Interpreted,Loaded); TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:23498,cache,cached,23498,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['cache'],['cached']
Performance,"; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still av",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:47429,cache,cache,47429,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Long64_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Buffersize might be clamped, see TFileCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:47433,cache,cache,47433,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemented.. ; Definition at line 87 of file OptimizeConfigParameters.h. ◆ fFOMvsIter. std::vector<Float_t> TMVA::OptimizeConfigParameters::fFOMvsIter. private . graph showing the development of the Figure Of Merit values during the fit ; Definition at line 83 of file OptimizeConfigParameters.h. ◆ fLogger. MsgLogger* TMVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D* TMVA::OptimizeConfigParameters::fMvaBkg. private . MVA distribution for bakgr. events, used for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:10625,Optimiz,OptimizeConfigParameters,10625,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html:1219,perform,performed,1219,root/html604/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN.html,1,['perform'],['performed']
Performance,"; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; 14.8 Speed Comparisons; Speed of four matrix operations have been compared between four matrix libraries, GSL CLHEP, ROOT v3.10 and ROOT v4.0. Next figure shows the CPU time for these four operations as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:802178,optimiz,optimized,802178,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"; const char * ; new_name = """"); const. overridevirtual . Create a Clone of this TClass object using a different name but using the same 'dictionary'. ; This effectively creates a hard alias for the class name. ; Reimplemented from TObject.; Definition at line 2406 of file TClass.cxx. ◆ ConvStreamerInstrumented(). void TClass::ConvStreamerInstrumented ; (; const TClass * ; pThis, . void * ; object, . TBuffer & ; b, . const TClass * ; onfile_class . ). staticprivate . Case of instrumented class with a library. ; Definition at line 6845 of file TClass.cxx. ◆ CopyCollectionProxy(). void TClass::CopyCollectionProxy ; (; const TVirtualCollectionProxy & ; orig). Replaces the collection proxy for this class. ; The provided object is cloned and the copy is then owned by TClass. ; Definition at line 2470 of file TClass.cxx. ◆ CreateListOfDataMembers(). TList * TClass::CreateListOfDataMembers ; (; std::atomic< TListOfDataMembers * > & ; data, . TDictionary::EMemberSelection ; selection, . bool ; load . ). private . Create the list containing the TDataMembers (of actual data members or members pulled in through using declarations) of a class. ; Definition at line 3741 of file TClass.cxx. ◆ DeclFileName(). static const char * TClass::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 618 of file TClass.h. ◆ DeleteArray() [1/2]. void TClass::DeleteArray ; (; TClass::ObjectPtr ; obj, . Bool_t ; dtorOnly = kFALSE . ). Explicitly call operator delete[] for an array. ; Definition at line 5639 of file TClass.cxx. ◆ DeleteArray() [2/2]. void TClass::DeleteArray ; (; void * ; ary, . Bool_t ; dtorOnly = kFALSE . ). Explicitly call operator delete[] for an array. ; Definition at line 5529 of file TClass.cxx. ◆ Destructor() [1/2]. void TClass::Destructor ; (; TClass::ObjectPtr ; obj, . Bool_t ; dtorOnly = kFALSE . ). Explicitly call destructor for object. ; Definition at line 5513 of file TClass.cxx. ◆ Destructor() [2/2]. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:61459,load,load,61459,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"; const char * ; new_name = """"); const. overridevirtual . Create a Clone of this TClass object using a different name but using the same 'dictionary'. ; This effectively creates a hard alias for the class name. ; Reimplemented from TObject.; Definition at line 2473 of file TClass.cxx. ◆ ConvStreamerInstrumented(). void TClass::ConvStreamerInstrumented ; (; const TClass * ; pThis, . void * ; object, . TBuffer & ; b, . const TClass * ; onfile_class . ). staticprivate . Case of instrumented class with a library. ; Definition at line 6912 of file TClass.cxx. ◆ CopyCollectionProxy(). void TClass::CopyCollectionProxy ; (; const TVirtualCollectionProxy & ; orig). Replaces the collection proxy for this class. ; The provided object is cloned and the copy is then owned by TClass. ; Definition at line 2537 of file TClass.cxx. ◆ CreateListOfDataMembers(). TList * TClass::CreateListOfDataMembers ; (; std::atomic< TListOfDataMembers * > & ; data, . TDictionary::EMemberSelection ; selection, . bool ; load . ). private . Create the list containing the TDataMembers (of actual data members or members pulled in through using declarations) of a class. ; Definition at line 3808 of file TClass.cxx. ◆ DeclFileName(). static const char * TClass::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 618 of file TClass.h. ◆ DeleteArray() [1/2]. void TClass::DeleteArray ; (; TClass::ObjectPtr ; obj, . Bool_t ; dtorOnly = kFALSE . ). Explicitly call operator delete[] for an array. ; Definition at line 5706 of file TClass.cxx. ◆ DeleteArray() [2/2]. void TClass::DeleteArray ; (; void * ; ary, . Bool_t ; dtorOnly = kFALSE . ). Explicitly call operator delete[] for an array. ; Definition at line 5596 of file TClass.cxx. ◆ Destructor() [1/2]. void TClass::Destructor ; (; TClass::ObjectPtr ; obj, . Bool_t ; dtorOnly = kFALSE . ). Explicitly call destructor for object. ; Definition at line 5580 of file TClass.cxx. ◆ Destructor() [2/2]. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:61460,load,load,61460,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"; const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNLLVar.html:3151,cache,cacheUniqueSuffix,3151,root/html528/RooNLLVar.html,https://root.cern,https://root.cern/root/html528/RooNLLVar.html,2,['cache'],['cacheUniqueSuffix']
Performance,"; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 555 of file TInterpreter.h. ◆ IsUnsignedIntegerType(). virtual Bool_t TInterpreter::IsUnsignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 556 of file TInterpreter.h. ◆ IsVoidPointerType(). virtual Bool_t TInterpreter::IsVoidPointerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 559 of file TInterpreter.h. ◆ Load(). virtual Int_t TInterpreter::Load ; (; const char * ; filenam, . Bool_t ; system = kFALSE . ). pure virtual . Implemented in TCling. ◆ LoadEnums(). virtual void TInterpreter::LoadEnums ; (; TListOfEnums & ; cl); const. pure virtual . Implemented in TCling. ◆ LoadFile(). virtual int TInterpreter::LoadFile ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 259 of file TInterpreter.h. ◆ LoadFunctionTemplates(). virtual void TInterpreter::LoadFunctionTemplates ; (; TClass * ; cl); const. pure virtual . Implemented in TCling. ◆ LoadLibraryMap(). virtual Int_t TInterpreter::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). pure virtual . Implemented in TCling. ◆ LoadMacro(). virtual void TInterpreter::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). pure virtual . Implemented in TCling. ◆ LoadText(). virtual Bool_t TInterpreter::LoadText ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 260 of file TInterpreter.h. ◆ MakeInterpreterValue(). virtual std::unique_ptr< TInterpreterValue > TInterpreter::MakeInterpreterValue ; (; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 278 of file TInterpreter.h. ◆ MapCppName(). virtual const char * TInterpreter::MapCppName ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 261 of file TInterpreter.h. ◆ MethodArgInfo_DefaultValue(). virtual const char * TInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:78797,Load,LoadFunctionTemplates,78797,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadFunctionTemplates']
Performance,"; const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:43945,cache,cache,43945,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"; const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2251 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:43949,cache,cache,43949,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,; const. protected . Return absolute index to last object in array. ; Returns -1 in case array is empty. ; Definition at line 539 of file TObjArray.cxx. ◆ GetEntries(). Int_t TObjArray::GetEntries ; (; ); const. overridevirtual . Return the number of objects in array (i.e. ; number of non-empty slots). Attention: use this method ONLY if you want to know the number of non-empty slots. This function loops over the complete array and is therefore very slow when applied in a loop. Most of the time you better use GetEntriesFast() (only in case when there are no empty slots). ; Reimplemented from TCollection.; Definition at line 523 of file TObjArray.cxx. ◆ GetEntriesFast(). Int_t TObjArray::GetEntriesFast ; (; ); const. inline . Definition at line 58 of file TObjArray.h. ◆ GetEntriesUnsafe(). Int_t TObjArray::GetEntriesUnsafe ; (; ); const. Return the number of objects in array (i.e. ; number of non-empty slots). This is a thread-unsafe version of GetEntriesFast. Use it only if sure it will not be invoked concurrently. ; Definition at line 565 of file TObjArray.cxx. ◆ GetLast(). Int_t TObjArray::GetLast ; (; ); const. overridevirtual . Return index of last object in array. ; Returns lowerBound-1 in case array is empty. ; Reimplemented from TSeqCollection.; Definition at line 577 of file TObjArray.cxx. ◆ GetObjectRef() [1/2]. TObject ** TObjArray::GetObjectRef ; (; ); const. inline . Definition at line 63 of file TObjArray.h. ◆ GetObjectRef() [2/2]. TObject ** TObjArray::GetObjectRef ; (; const TObject * ; obj); const. overridevirtual . Return address of pointer obj. If obj is 0 returns address of container. ; Implements TCollection.; Definition at line 587 of file TObjArray.cxx. ◆ IndexOf(). Int_t TObjArray::IndexOf ; (; const TObject * ; obj); const. overridevirtual . obj != 0 Return index of object in array. Returns lowerBound-1 in case array doesn't contain the obj.; obj == 0 Return the index of the first empty slot. Returns lowerBound-1 in case array doesn't contain a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjArray.html:28256,concurren,concurrently,28256,doc/master/classTObjArray.html,https://root.cern,https://root.cern/doc/master/classTObjArray.html,1,['concurren'],['concurrently']
Performance,"; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:57976,perform,performed,57976,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['perform'],['performed']
Performance,"; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:133313,cache,cachesize,133313,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['cache'],"['cache', 'cachesize']"
Performance,"; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }. Function Members (Methods); public:. virtual~TGTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComposi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTable.html:2771,Load,Load,2771,root/html602/TGTable.html,https://root.cern,https://root.cern/root/html602/TGTable.html,2,['Load'],['Load']
Performance,"; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }. Function Members (Methods); public:. virtual~TTableRange(); static TClass*Class(); virtual TClass*IsA() const; TTableRange&operator=(const TTableRange&); Bool_toperator==(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableRange.html:2765,Load,Load,2765,root/html602/TTableRange.html,https://root.cern,https://root.cern/root/html602/TTableRange.html,2,['Load'],['Load']
Performance,"; effect. When this tree is deleted, all the addresses of; the cloned tree are reset to their default values. If 'option' contains the word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:62074,optimiz,optimize,62074,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['optimiz'],['optimize']
Performance,"; elist . ). private . Create a TProofQueryResult instance for this query. ; Definition at line 3530 of file TProofServ.cxx. ◆ NextQuery(). TProofQueryResult * TProofServ::NextQuery ; (; ). private . Get the next query from the waiting list. ; The query is removed from the list. ; Definition at line 6867 of file TProofServ.cxx. ◆ OldAuthSetup(). Int_t TProofServ::OldAuthSetup ; (; TString & ; conf). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 3492 of file TProofServ.cxx. ◆ Print(). void TProofServ::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print status of slave server. ; Reimplemented from TObject.; Definition at line 2506 of file TProofServ.cxx. ◆ ProcessNext(). void TProofServ::ProcessNext ; (; TString * ; slb = 0). protectedvirtual . process the next query from the queue of submitted jobs. ; to be called on the top master only. ; Definition at line 4416 of file TProofServ.cxx. ◆ QueueQuery(). Int_t TProofServ::QueueQuery ; (; TProofQueryResult * ; pq). private . Add a query to the waiting list Returns the number of queries in the list. ; Definition at line 6856 of file TProofServ.cxx. ◆ ReceiveFile(). Int_t TProofServ::ReceiveFile ; (; const char * ; file, . Bool_t ; bin, . Long64_t ; size . ). Receive a file, either sent by a client or a master server. ; If bin is true it is a binary file, other wise it is an ASCII file and we need to check for Windows \r tokens. Returns -1 in case of error, 0 otherwise. ; Definition at line 2578 of file TProofServ.cxx. ◆ RedirectOutput(). void TProofServ::RedirectOutput ; (; const char * ; dir = 0, . const char * ; mode = ""w"" . ). private . Redirect stdout to a log file. ; This log file will be flushed to the client or master after each command. ; Definition at line 2518 of file TProofServ.cxx. ◆ RegisterDataSets(). Int_t TProofServ::RegisterDataSets ; (; TList * ; in, . TList * ; out, . TDataSetManager * ; dsm, . TString & ; e .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:50475,Queue,QueueQuery,50475,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['Queue'],['QueueQuery']
Performance,"; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::GetEntryNumberLong64_t GetEntryNumber(Long64_t entry) const overrideReturn entry number corresponding to entry.Definition TChain.cxx:1021; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t *opt="""") overrideSet the input entry list (processing the entries of the chain will then be limited to the entries in ...Definition TChain.cxx:2703; TChain::Addvirtual Int_t Add(TChain *chain)Add all files referenced by the passed chain to this chain.Definition TChain.cxx:219; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; TChain::GetEntriesLong64_t GetEntries() const overrideReturn the total number of entries in the chain.Definition TChain.cxx:978; TChain::GetEntryInt_t GetEntry(Long64_t entry=0, Int_t getall=0) overrideGet entry from the file to memory.Definition TChain.cxx:1002; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TEntryList::GetNvirtual Long64_t GetN() constDefinition TEntryList.h:78; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; int; When using the TEntryList interface directly, you can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:3098,Load,LoadTree,3098,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['Load'],['LoadTree']
Performance,"; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if succesfull. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if succesfull. Bool_t Rollback(); submit ""ROL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLServer.html:8128,load,loaded,8128,root/html528/TSQLServer.html,https://root.cern,https://root.cern/root/html528/TSQLServer.html,3,['load'],['loaded']
Performance,"; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLServer.html:8504,load,loaded,8504,root/html534/TSQLServer.html,https://root.cern,https://root.cern/root/html534/TSQLServer.html,1,['load'],['loaded']
Performance,; enum TTree::ESetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum TTree::[unnamed] { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event select,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THbookTree.html:23010,cache,cache,23010,root/html534/THbookTree.html,https://root.cern,https://root.cern/root/html534/THbookTree.html,2,['cache'],['cache']
Performance,"; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:20142,cache,cache,20142,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],['cache']
Performance,"; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) {; 1771 if (TClass::AddRule(rule)) {; 1772 ++count;; 1773 }; 1774 rule.Clear();; 1775 }; 1776 }; 1777 contin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:66414,load,load,66414,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1795 fIsOffsetStreamerSet=kFALSE;; 1796 ; 1797 if ( fIsA ) delete fIsA;; 1798 ; 1799 if ( fRefProxy ) fRefProxy->Release();; 1800 fRefProxy = nullptr;; 1801 ; 1802 delete fStreamer;; 1803 delete fCollectionProxy;; 1804 delete fIsAMethod.load();; 1805 delete fSchemaRules;; 1806 if (fConversionStreamerInfo.load()) {; 1807 std::map<std::string, TObjArray*>::iterator it;; 1808 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1809 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1810 delete it->second;; 1811 }; 1812 delete fConversionStreamerInfo.load();; 1813 }; 1814}; 1815 ; 1816////////////////////////////////////////////////////////////////////////////////; 1817 ; 1818namespace {; 1819 Int_t ReadRulesContent(FILE *f); 1820 {; 1821 // Read a class.rules file which contains one rule per line with comment; 1822 // starting with a #; 1823 // Returns the number of rules loaded.; 1824 // Returns -1 in case of error.; 1825 ; 1826 R__ASSERT(f!=nullptr);; 1827 TString rule(1024);; 1828 int c, state = 0;; 1829 Int_t count = 0;; 1830 ; 1831 while ((c = fgetc(f)) != EOF) {; 1832 if (c == 13) // ignore CR; 1833 continue;; 1834 if (c == '\n') {; 1835 if (state != 3) {; 1836 state = 0;; 1837 if (rule.Length() > 0) {; 1838 if (TClass::AddRule(rule)) {; 1839 ++count;; 1840 }; 1841 rule.Clear();; 1842 }; 1843 }; 1844 contin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:69165,load,load,69165,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"; fSharedLibsTClassprivate; fShowMembersTClassprivate; fSizeofTClassprivate; fStateTClassprivate; fStreamerTClassprivate; fStreamerFuncTClassprivate; fStreamerImplTClassmutableprivate; fStreamerInfoTClassmutableprivate; fStreamerTypeTClassprivate; fTitleTNamedprotected; fTypeInfoTClassprivate; fUniqueIDTObjectprivate; fUpdatingTransactionCountTDictionaryprivate; fUsingDataTClassprivate; fVersionUsedTClassmutableprivate; GetActualClass(const void *object) constTClass; GetAttributeMap() constTDictionaryinline; GetBaseClass(const char *classname)TClass; GetBaseClass(const TClass *base)TClass; GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)TClass; GetBaseClassOffsetRecurse(const TClass *toBase)TClassprivate; GetBaseDataMember(const char *datamember)TClass; GetCheckSum(ECheckSum code=kCurrentCheckSum) constTClass; GetCheckSum(Bool_t &isvalid) constTClass; GetCheckSum(ECheckSum code, Bool_t &isvalid) constTClass; GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size)TClassstatic; GetClass(const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0)TClassstatic; GetClass(ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(DeclId_t id, std::vector< TClass * > &classes)TClassstatic; GetClassInfo() constTClassinline; GetClassMethod(Longptr_t faddr)TClassprivate; GetClassMethod(const char *name, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetClassSize() constTClassinline; GetClassVersion() constTClassinline; GetCollectionProxy() constTClass; GetCollectionType() constTClass; GetContextMenuTit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:7079,load,load,7079,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL and COLZ options. There is one major difference and that concerns the treatment of bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector graphics file format like PostScript or PDF (an empty image will be generated). It can be saved only in bitmap files like PNG format for instance. The CANDLE and VIOLIN options; The mechanism behind Candle plots and Violin plots is very similar. Because of this they are implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for vertical projections, or Y or H for horizontal projections) and/or predefined definitions (1-6 for candles, 1-2 for violins). The orde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:48708,optimiz,optimized,48708,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['optimiz'],['optimized']
Performance,"; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooBrentRootFinder. class RooBrentRootFinder: public RooAbsRootFinder. Implement the abstract 1-dimensional root finding interface using; the Brent-Decker method. This implementation is based on the one; in the GNU scientific library (v0.99).; . Function Members (Methods); public:. RooBrentRootFinder(const RooAbsFunc& function); RooBrentRootFinder(const RooBrentRootFinder&); virtual~RooBrentRootFinder(); static TClass*Class(); virtual Bool_tfindRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; virtual TClass*IsA() const; voidsetTol(Double_t tol); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { MaxIterations; };. protected:. const RooAbsFunc*RooAbsRootFinder::_functionPointer to input function; Double_t_tol; Bool_tRooAbsRootFinder::_validTrue if current state is valid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBrentRootFinder(const RooAbsFunc& function); Constructor taking function binding as input. Bool_t findRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; Do the root finding using the Brent-Decker method. Returns a boolean status and; loads 'result' with our best guess at the root if true.; Prints a warning if the initial interval does not bracket a single; root or if the root is not found after a fixed number of iterations. RooBrentRootFinder(const RooAbsFunc& function). virtual ~RooBrentRootFinder(); { }. void setTol(Double_t tol); Set convergence tolerance parameter. » Last changed: Thu Sep 23 19:58:35 2010 » Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBrentRootFinder.html:1522,load,loads,1522,root/html528/RooBrentRootFinder.html,https://root.cern,https://root.cern/root/html528/RooBrentRootFinder.html,1,['load'],['loads']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5619 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 597 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:19458,multi-thread,multi-threading,19458,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5648 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 596 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:19366,multi-thread,multi-threading,19366,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5832 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 543 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:20056,multi-thread,multi-threading,20056,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5846 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 542 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:20095,multi-thread,multi-threading,20095,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5855 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:23114,multi-thread,multi-threading,23114,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:24876,multi-thread,multi-threading,24876,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:31873,multi-thread,multi-threading,31873,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5936 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:31661,multi-thread,multi-threading,31661,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"; if 'update' flag is true (default), the new model's parameters; are assigned to all clients.; false - The old model is kept, false is returned. If insert is successful, the ownership of the model-element is; transferred to the manager. Bool_t InsertVizDBEntry(const TString& tag, TEveElement* model); Insert a new visualization-parameter database entry with the default; parameters for replace and update, as specified by members; fVizDBReplace(default=kTRUE) and fVizDBUpdate(default=kTRUE).; See docs of the above function. TEveElement* FindVizDBEntry(const TString& tag); Find a visualization-parameter database entry corresponding to tag.; If the entry is not found 0 is returned. void LoadVizDB(const TString& filename, Bool_t replace, Bool_t update); Load visualization-parameter database from file filename. The; replace, update arguments replace the values of fVizDBReplace; and fVizDBUpdate members for the duration of the macro; execution. void LoadVizDB(const TString& filename); Load visualization-parameter database from file filename.; State of data-members fVizDBReplace and fVizDBUpdate determine; how the registered entries are handled. void SaveVizDB(const TString& filename); Save visualization-parameter database to file filename. TGeoManager* GetGeometry(const TString& filename); Get geometry with given filename.; This is cached internally so the second time this function is; called with the same argument the same geo-manager is returned.; gGeoManager is set to the return value. TGeoManager* GetGeometryByAlias(const TString& alias); Get geometry with given alias.; The alias must be registered via RegisterGeometryAlias(). TGeoManager* GetDefaultGeometry(); Get the default geometry.; It should be registered via RegisterGeometryName(""Default"", <URL>). void RegisterGeometryAlias(const TString& alias, const TString& filename); Register 'name' as an alias for geometry file 'filename'.; The old aliases are silently overwritten.; After that the geometry can be retrieved a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveManager.html:9323,Load,LoadVizDB,9323,root/html528/TEveManager.html,https://root.cern,https://root.cern/root/html528/TEveManager.html,12,['Load'],"['Load', 'LoadVizDB']"
Performance,"; it != Use.end(); it++) std::cout << it->first << "" "";; 162 std::cout << std::endl;; 163 return 1;; 164 }; 165 Use[regMethod] = 1;; 166 }; 167 }; 168 ; 169 // --------------------------------------------------------------------------------------------------; 170 ; 171 // Here the preparation phase begins; 172 ; 173 // Read training and test data; 174 // (it is also possible to use ASCII format as input -> see TMVA Users Guide); 175 // Set the cache directory for the TFile to the current directory. The input; 176 // data file will be downloaded here if not present yet, then it will be read; 177 // from the cache path directly.; 178 TFile::SetCacheFileDir(""."");; 179 std::unique_ptr<TFile> input{TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"")};; 180 if (!input || input->IsZombie()) {; 181 throw std::runtime_error(""ERROR: could not open data file"");; 182 }; 183 std::cout << ""--- TMVAClassification : Using input file: "" << input->GetName() << std::endl;; 184 ; 185 // Register the training and test trees; 186 ; 187 TTree *signalTree = (TTree*)input->Get(""TreeS"");; 188 TTree *background = (TTree*)input->Get(""TreeB"");; 189 ; 190 // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; 191 TString outfileName(""TMVAC.root"");; 192 std::unique_ptr<TFile> outputFile{TFile::Open(outfileName, ""RECREATE"")};; 193 if (!outputFile || outputFile->IsZombie()) {; 194 throw std::runtime_error(""ERROR: could not open output file"");; 195 }; 196 ; 197 // Create the factory object. Later you can choose the methods; 198 // whose performance you'd like to investigate. The factory is; 199 // the only TMVA object you have to interact with; 200 //; 201 // The first argument is the base of the name of all the; 202 // weightfiles in the directory weight/; 203 //; 204 // The second argument is the output file for the training results; 205 // All TMVA output can be suppressed by removing the ""!"" (not) in; 206 // front of the ""Silent"" argument in the optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:6783,CACHE,CACHEREAD,6783,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,1,['CACHE'],['CACHEREAD']
Performance,"; jbase += nx;; 3474 for (jimg = jbase, icol = *jimg++, x = x1+1; x <= x2; jimg++, x++) {; 3475 if (icol != *jimg) {; 3476 if (icol != itran) {; 3477 n = nlines[icol]++;; 3478 lines[icol][n].x1 = xcur; lines[icol][n].y1 = y;; 3479 lines[icol][n].x2 = x-1; lines[icol][n].y2 = y;; 3480 if (nlines[icol] == maxSegment) {; 3481 SetColor(gGCline,(int)icol+offset);; 3482 XDrawSegments((Display*)fDisplay,id,*gGCline,&lines[icol][0],; 3483 maxSegment);; 3484 nlines[icol] = 0;; 3485 }; 3486 }; 3487 icol = *jimg; xcur = x;; 3488 }; 3489 }; 3490 if (icol != itran) {; 3491 n = nlines[icol]++;; 3492 lines[icol][n].x1 = xcur; lines[icol][n].y1 = y;; 3493 lines[icol][n].x2 = x-1; lines[icol][n].y2 = y;; 3494 if (nlines[icol] == maxSegment) {; 3495 SetColor(gGCline,(int)icol+offset);; 3496 XDrawSegments((Display*)fDisplay,id,*gGCline,&lines[icol][0],; 3497 maxSegment);; 3498 nlines[icol] = 0;; 3499 }; 3500 }; 3501 }; 3502 ; 3503 for (i = 0; i < 256; i++) {; 3504 if (nlines[i] != 0) {; 3505 SetColor(gGCline,i+offset);; 3506 XDrawSegments((Display*)fDisplay,id,*gGCline,&lines[i][0],nlines[i]);; 3507 }; 3508 }; 3509}; 3510 ; 3511////////////////////////////////////////////////////////////////////////////////; 3512/// If id is NULL - loads the specified gif file at position [x0,y0] in the; 3513/// current window. Otherwise creates pixmap from gif file; 3514 ; 3515Pixmap_t TGX11::ReadGIF(int x0, int y0, const char *file, Window_t id); 3516{; 3517 FILE *fd;; 3518 Seek_t filesize = 0;; 3519 unsigned char *gifArr, *pixArr, red[256], green[256], blue[256], *j1, *j2, icol;; 3520 int i, j, k, width, height, ncolor, irep, offset;; 3521 float rr, gg, bb;; 3522 Pixmap_t pic = 0;; 3523 ; 3524 fd = fopen(file, ""r"");; 3525 if (!fd) {; 3526 Error(""ReadGIF"", ""unable to open GIF file"");; 3527 return pic;; 3528 }; 3529 ; 3530 fseek(fd, 0L, 2);; 3531 long ft = ftell(fd);; 3532 if (ft <=0) {; 3533 Error(""ReadGIF"", ""unable to open GIF file"");; 3534 fclose(fd);; 3535 return pic;; 3536 } else {; 3537 filesize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:116022,load,loads,116022,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['load'],['loads']
Performance,"; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData! ; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value ; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names ; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key ; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:20279,cache,cache,20279,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,3,['cache'],['cache']
Performance,"; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; Bool_tfIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; TList*fMethodlinked list for methods; void*fNewpoint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:14457,cache,cached,14457,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['cache'],['cached']
Performance,"; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; void*fInterStreamer!saved info to call Streamer; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; TList*fMethodlinked list for methods; void*fNewpointer to a function newing one ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:13624,cache,cached,13624,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['cache'],['cached']
Performance,"; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TXMLSetup::EXMLLayout { kSpecialized; kGeneralized; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferXML.html:22818,cache,cache,22818,root/html530/TBufferXML.html,https://root.cern,https://root.cern/root/html530/TBufferXML.html,2,['cache'],['cache']
Performance,"; kNoBaseCheckSum enum valueTClass; kNoContextMenu enum valueTObject; kNoEnum enum valueTClass; kNoInfo enum valueTClass; kNone enum valueTDictionary; kNoRange enum valueTClass; kNoRangeCheck enum valueTClass; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kRealNew enum valueTClass; kReflex enum valueTClass; kReflexNoComment enum valueTClass; kReservedLoading enum valueTClass; kSet enum valueTDictionary; kSingleKey enum valueTObject; kStartWithTObject enum valueTClass; kTObject enum valueTClassprivate; kUnloaded enum valueTClass; kUnloading enum valueTClassprivate; kUnorderedMap enum valueTDictionary; kUnorderedMultimap enum valueTDictionary; kUnorderedMultiset enum valueTDictionary; kUnorderedSet enum valueTDictionary; kVector enum valueTDictionary; kWarned enum valueTClass; kWithTypeDef enum valueTClass; kWriteDelete enum valueTObject; kZombie enum valueTObject; Load(TBuffer &b)TClassstatic; LoadClass(const char *requestedname, Bool_t silent)TClassstatic; LoadClassCustom(const char *requestedname, Bool_t silent)TClassprivatestatic; LoadClassDefault(const char *requestedname, Bool_t silent)TClassprivatestatic; LoadClassInfo() constTClassprivate; ls(Option_t *opt="""") const overrideTClassvirtual; MakeCustomMenuList()TClass; MakeZombie()TObjectinlineprotected; MatchLegacyCheckSum(UInt_t checksum) constTClass; MayNotUse(const char *method) constTObject; Move(void *arenaFrom, void *arenaTo) constTClass; MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constTClassprivate; New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constTClass; New(void *arena, ENewType defConstructor=kClassNew) constTClass; NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constTClass; NewArray(Long_t nElements, void *arena, ENewType defConstructor=kClassNew) constTClass; NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constTClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:15616,Load,LoadClass,15616,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['Load'],['LoadClass']
Performance,; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfAccessIdUser id ; TStringfAccessKeySecret key; TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; TStringfAuthPrefixAuthentication prefix for Amazon S3; Long64_tTFile::fBEGINFirst used byte in file; TStringTWebFile::fBasicUrlbasic url without authentication and options; TStringTWebFile::fBasicUrlOrgsave original url in case of temp redirection; TStringfBucketBucket name; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tTWebFile::fHTTP11true if server support HTTP/1.1; Bool_tTWebFile::fHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitD,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:19793,cache,cache,19793,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,2,['cache'],['cache']
Performance,"; kNoEnum enum valueTClass; kNoInfo enum valueTClass; kNone enum valueTDictionary; kNoRange enum valueTClass; kNoRangeCheck enum valueTClass; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kRealNew enum valueTClass; kReflex enum valueTClass; kReflexNoComment enum valueTClass; kReservedLoading enum valueTClass; kSet enum valueTDictionary; kSingleKey enum valueTObject; kStartWithTObject enum valueTClass; kTObject enum valueTClassprivate; kUnloaded enum valueTClass; kUnloading enum valueTClassprivate; kUnorderedMap enum valueTDictionary; kUnorderedMultimap enum valueTDictionary; kUnorderedMultiset enum valueTDictionary; kUnorderedSet enum valueTDictionary; kVector enum valueTDictionary; kWarned enum valueTClass; kWithTypeDef enum valueTClass; kWriteDelete enum valueTObject; kZombie enum valueTObject; Load(TBuffer &b)TClassstatic; LoadClass(const char *requestedname, Bool_t silent)TClassstatic; LoadClassCustom(const char *requestedname, Bool_t silent)TClassprivatestatic; LoadClassDefault(const char *requestedname, Bool_t silent)TClassprivatestatic; LoadClassInfo() constTClassprivate; ls(Option_t *opt="""") const overrideTClassvirtual; MakeCustomMenuList()TClass; MakeZombie()TObjectinlineprotected; MatchLegacyCheckSum(UInt_t checksum) constTClass; MayNotUse(const char *method) constTObject; Move(void *arenaFrom, void *arenaTo) constTClass; MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constTClassprivate; New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constTClass; New(void *arena, ENewType defConstructor=kClassNew) constTClass; NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constTClass; NewArray(Long_t nElements, void *arena, ENewType defConstructor=kClassNew) constTClass; NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constTClass; NewObject(void *arena, ENewType defConstructor=kClassNew) constTCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:15681,Load,LoadClassCustom,15681,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['Load'],['LoadClassCustom']
Performance,"; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix& operator=(const TGeoScale& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: And",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScale.html:15153,perform,perform,15153,root/html528/TGeoScale.html,https://root.cern,https://root.cern/root/html528/TGeoScale.html,3,['perform'],['perform']
Performance,; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringfBasicUrlbasic url without authentication and options; TStringfBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfHTTP11true if server support HTTP/1.1; Bool_tfHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TWebFile.html:19288,cache,cache,19288,root/html534/TWebFile.html,https://root.cern,https://root.cern/root/html534/TWebFile.html,3,['cache'],['cache']
Performance,"; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TString_convVarNameName of convolution variable; RooRealVar*_cvModelConvolution variable in resModel event; RooRealVar*_cvOutConvolution variable in output event; RooRealVar*_cvPdfConvolution variable in PDFxTruth event; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooArgSet*_modelCloneSetOwner of resModel clone; RooAbsGenContext*_modelGenResolution model generator context; RooArgSet*_modelVarsHolder of resModel event; RooArgSet*_modelVarsOwnedOwning version of modelVars ;; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; RooArgSet*_pdfCloneSetOwner of PDF clone; RooAbsGenContext*_pdfGenPhysics model generator context; RooArgSet*_pdfVarsHolder of PDF x truth event; RooArgSet*_pdfVarsOwnedOwning version of pdfVars ;; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvGenContext(const RooAbsAnaConvPdf &model, const RooArgSet &vars, 	 			 const RooDataSet *prototype, const RooArgSet* auxProto, Bool_t verbose); Constructor for specialized generator context for analytical convolutions. Builds a generator for the physics PDF convoluted with the truth model; and a generator for the resolution model as PDF. Events are generated; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvGenContext.html:8718,load,load,8718,root/html526/RooConvGenContext.html,https://root.cern,https://root.cern/root/html526/RooConvGenContext.html,1,['load'],['load']
Performance,"; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiCategory.html:20767,cache,cache,20767,root/html534/RooMultiCategory.html,https://root.cern,https://root.cern/root/html534/RooMultiCategory.html,4,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tfDimensionDimension of the current expression; TStringfInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManager; Int_tfMultiplicityIndicator of the variability of the size of entries; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDraw.html:7434,load,loaded,7434,root/html528/TProofDraw.html,https://root.cern,https://root.cern/root/html528/TProofDraw.html,1,['load'],['loaded']
Performance,"; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheWrite.html:6958,cache,cache,6958,root/html534/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; \]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874467,load,load,874467,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Load', 'load']","['Load', 'load']"
Performance,"; loader, . TString ; options = """" . ). Iterates over all MVA input variables and evaluates them. ; Definition at line 1360 of file Factory.cxx. ◆ EvaluateImportance(). TH1F * TMVA::Factory::EvaluateImportance ; (; DataLoader * ; loader, . VIType ; vitype, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). Evaluate Variable Importance. ; Definition at line 2217 of file Factory.cxx. ◆ EvaluateImportanceAll(). TH1F * TMVA::Factory::EvaluateImportanceAll ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2246 of file Factory.cxx. ◆ EvaluateImportanceRandom(). TH1F * TMVA::Factory::EvaluateImportanceRandom ; (; DataLoader * ; loader, . UInt_t ; nseeds, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2473 of file Factory.cxx. ◆ EvaluateImportanceShort(). TH1F * TMVA::Factory::EvaluateImportanceShort ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2358 of file Factory.cxx. ◆ GetImportance(). TH1F * TMVA::Factory::GetImportance ; (; const int ; nbits, . std::vector< Double_t > ; importances, . std::vector< TString > ; varNames . ). private . Definition at line 2591 of file Factory.cxx. ◆ GetMethod(). TMVA::IMethod * TMVA::Factory::GetMethod ; (; const TString & ; datasetname, . const TString & ; title . ); const. Returns pointer to MVA that corresponds to given method title. ; Definition at line 566 of file Factory.cxx. ◆ GetROC() [1/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). private . Private method to generate a ROCCurve instance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:24889,load,loader,24889,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"; max, . Int_t & ; count . ). virtual . Returns list of font names matching fontname regexp, like ""-*-times-*"". ; The pattern string can contain any characters, but each asterisk (*) is a wildcard for any number of characters, and each question mark (?) is a wildcard for a single character. If the pattern string is not in the Host Portable Character Encoding, the result is implementation dependent. Use of uppercase or lowercase does not matter. Each returned string is null-terminated.; Parameters. [in]fontnamespecifies the null-terminated pattern string that can contain wildcard characters ; [in]maxspecifies the maximum number of names to be returned ; [in]countreturns the actual number of font names . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2260 of file TVirtualX.cxx. ◆ LoadQueryFont(). FontStruct_t TVirtualX::LoadQueryFont ; (; const char * ; font_name). virtual . Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ; If the font does not exist, it returns NULL. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1299 of file TVirtualX.cxx. ◆ LookupString(). void TVirtualX::LookupString ; (; Event_t * ; event, . char * ; buf, . Int_t ; buflen, . UInt_t & ; keysym . ). virtual . Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ; In ""buf"" a null terminated ASCII string is returned representing the string that is currently mapped to the key code.; Parameters. [in]eventspecifies the event structure to be used ; [in]bufreturns the translated characters ; [in]buflenthe length of the buffer ; [in]keysymreturns the ""keysym"" computed from the event if this argument is not NULL . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2009 of file TVirtualX.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:100302,load,loads,100302,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['load'],['loads']
Performance,"; obj); const. overridevirtual . Find an object in this collection using the object's IsEqual() member function. ; Requires a sequential scan till the object has been found. Returns 0 if object is not found. Typically this function is overridden by a more efficient version in concrete collection classes (e.g. THashTable). ; Reimplemented from TObject.; Reimplemented in TMap, TListOfTypes, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 337 of file TCollection.cxx. ◆ GarbageCollect(). void TCollection::GarbageCollect ; (; TObject * ; obj). static . Add to the list of things to be cleaned up. ; Definition at line 725 of file TCollection.cxx. ◆ GetCollectionEntryName(). const char * TCollection::GetCollectionEntryName ; (; TObject * ; entry); const. protectedvirtual . For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ; Definition at line 437 of file TCollection.cxx. ◆ GetCurrentCollection(). TCollection * TCollection::GetCurrentCollection ; (; ). static . Return the globally accessible collection. ; Definition at line 680 of file TCollection.cxx. ◆ GetEntries(). virtual Int_t TCollection::GetEntries ; (; ); const. inlinevirtual . Reimplemented in TObjArray, and TRefArray.; Definition at line 179 of file TCollection.h. ◆ GetName(). const char * TCollection::GetName ; (; ); const. overridevirtual . Return name of this collection. ; if no name, return the collection class name. ; Reimplemented from TObject.; Reimplemented in TQCommand, and TQConnection.; Definition at line 351 of file TCollection.cxx. ◆ GetObjectRef(). virtual TObject ** TCollection::GetObjectRef ; (; const TObject * ; obj); const. pure virtual . Implemented in TBtree, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TListOfEnumsWithLock, TListOfFunctio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:21599,perform,perform,21599,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['perform'],['perform']
Performance,"; objlen is the length of the de-compressed buffer . Implements TVirtualPerfStats.; Definition at line 312 of file TTreePerfStats.cxx. ◆ UpdateBranchIndices(). void TTreePerfStats::UpdateBranchIndices ; (; TObjArray * ; branchNames). overridevirtual . Update the fBranchIndexCache collection to match the current TTree given the ordered list of branch names. ; Implements TVirtualPerfStats.; Definition at line 360 of file TTreePerfStats.cxx. Member Data Documentation. ◆ fBasketsInfo. std::vector<std::vector<BasketInfo> > TTreePerfStats::fBasketsInfo. protected . Definition at line 77 of file TTreePerfStats.h. ◆ fBranchIndexCache. std::unordered_map<TBranch*, size_t> TTreePerfStats::fBranchIndexCache. protected . Definition at line 76 of file TTreePerfStats.h. ◆ fBytesRead. Long64_t TTreePerfStats::fBytesRead. protected . Number of bytes read. ; Definition at line 55 of file TTreePerfStats.h. ◆ fBytesReadExtra. Long64_t TTreePerfStats::fBytesReadExtra. protected . Number of bytes (overhead) of the read-ahead cache. ; Definition at line 56 of file TTreePerfStats.h. ◆ fCompress. Double_t TTreePerfStats::fCompress. protected . Tree compression factor. ; Definition at line 64 of file TTreePerfStats.h. ◆ fCpuTime. Double_t TTreePerfStats::fCpuTime. protected . Cpu time. ; Definition at line 59 of file TTreePerfStats.h. ◆ fDiskTime. Double_t TTreePerfStats::fDiskTime. protected . Time spent in pure raw disk IO. ; Definition at line 60 of file TTreePerfStats.h. ◆ fFile. TFile* TTreePerfStats::fFile. protected . ! Pointer to the file containing the Tree ; Definition at line 67 of file TTreePerfStats.h. ◆ fGraphIO. TGraphErrors* TTreePerfStats::fGraphIO. protected . Pointer to the graph with IO data. ; Definition at line 69 of file TTreePerfStats.h. ◆ fGraphTime. TGraphErrors* TTreePerfStats::fGraphTime. protected . Pointer to the graph with timestamp info. ; Definition at line 70 of file TTreePerfStats.h. ◆ fHostInfo. TString TTreePerfStats::fHostInfo. protected . Name of the h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats.html:34304,cache,cache,34304,doc/master/classTTreePerfStats.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats.html,1,['cache'],['cache']
Performance,"; parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF = const ROOT::RVecF &;; using cRVecI = const ROOT::RVecI &;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:2681,load,load,2681,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['load'],['load']
Performance,"; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLMinimizer.html:7930,perform,perform,7930,root/html602/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLMinimizer.html,1,['perform'],['perform']
Performance,"; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__GSLMinimizer.html:7930,perform,perform,7930,root/html604/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__GSLMinimizer.html,1,['perform'],['perform']
Performance,"; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfGridtype of GRID (AliEn, Globus, ...); TStringfGridUrlthe GRID url used to create the grid connection; TStringfHostGRID portal to which we are connected; TStringfOptionsoptions specified; Int_tfPortport to which we are connected; TStringfPwuser passwd; TStringfUseruser name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGrid * Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); The grid should be of the form: <grid>://<host>[:<port>],; e.g.: alien://alice.cern.ch, globus://glsrv1.cern.ch, ...; The uid is the username and pw the password that should be used for; the connection. Depending on the <grid> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. For AliEn the supported options are:; -domain=<domain name>; -debug=<debug level from 1 to 10>; Example: ""-domain=cern.ch -debug=5"". TGrid(); { }. virtual ~TGrid(); { }. const char * GridUrl() const; { return fGridUrl; }. const char * GetGrid() const; { return fGrid; }. const char * GetHost() const; { return fHost; }. const char * GetUser() const; { return fUser; }. const char * GetPw() const; { return fPw; }. const char * GetOptions() const; { return fOptions; }. Int_t GetPort() const; { return fPort; }. Bool_t IsConnected() const; { return fPort == -1 ? kFALSE : kTRUE; }. void Shell(); { MayNotUse(""Shell""); }. void Stdout(); { MayNotUse(""Stdout""); }. void Stderr(); { MayNotUse(""Stderr""); }. TGridResult * Command(const char* , Bool_t = kFALSE, UInt_t = 2); { MayNotUse(""Command""); return 0; }. TGridResult * Query(const char* , const char* , const char* = """", const char* = """"); { MayNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGrid.html:7692,load,loaded,7692,root/html528/TGrid.html,https://root.cern,https://root.cern/root/html528/TGrid.html,4,['load'],['loaded']
Performance,"; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); assignment operator must be the default because the 'copy' constructor is actually a move constructor and must be used. {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move constructor ... TConfiguredAction & operator=(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move assignment!. TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:6912,optimiz,optimized,6912,root/html534/TStreamerInfoActions__TConfiguredAction.html,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html,2,['optimiz'],['optimized']
Performance,"; soft = kFALSE . ). Remove everything about query qr. ; If soft = TRUE leave a track in memory with the relevant info ; Definition at line 512 of file TQueryResultManager.cxx. ◆ ResetTime(). void TQueryResultManager::ResetTime ; (; ). inline . Definition at line 76 of file TQueryResultManager.h. ◆ SaveQuery() [1/2]. void TQueryResultManager::SaveQuery ; (; TProofQueryResult * ; qr, . const char * ; fout = 0 . ). Save current status of query 'qr' to file name fout. ; If fout == 0 (default) use the default name. ; Definition at line 450 of file TQueryResultManager.cxx. ◆ SaveQuery() [2/2]. void TQueryResultManager::SaveQuery ; (; TProofQueryResult * ; qr, . Int_t ; mxq . ). Save current query honouring the max number of queries allowed. ; Definition at line 683 of file TQueryResultManager.cxx. ◆ ScanPreviousQueries(). void TQueryResultManager::ScanPreviousQueries ; (; const char * ; dir). Scan the queries directory for the results of previous queries. ; The headers of the query results found are loaded in fPreviousQueries. The full query result can be retrieved via TProof::Retrieve. ; Definition at line 157 of file TQueryResultManager.cxx. ◆ SeqNum(). Int_t TQueryResultManager::SeqNum ; (; ); const. inline . Definition at line 58 of file TQueryResultManager.h. ◆ Streamer(). void TQueryResultManager::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TQueryResultManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 84 of file TQueryResultManager.h. Member Data Documentation. ◆ fCompute. TStopwatch TQueryResultManager::fCompute. private . Definition at line 48 of file TQueryResultManager.h. ◆ fDrawQueries. Int_t TQueryResultManager::fDrawQueries. private . Definition at line 42 of file TQueryResultManager.h. ◆ fKeptQueries. Int_t TQueryResultManager::fKeptQueries. private . Definition at line 43 of file TQueryResultManager.h. ◆ fLock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQueryResultManager.html:18270,load,loaded,18270,doc/master/classTQueryResultManager.html,https://root.cern,https://root.cern/doc/master/classTQueryResultManager.html,1,['load'],['loaded']
Performance,"; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooBrentRootFinder. class RooBrentRootFinder: public RooAbsRootFinder. Implement the abstract 1-dimensional root finding interface using; the Brent-Decker method. This implementation is based on the one; in the GNU scientific library (v0.99).; . Function Members (Methods); public:. RooBrentRootFinder(const RooAbsFunc& function); RooBrentRootFinder(const RooBrentRootFinder&); virtual~RooBrentRootFinder(); static TClass*Class(); virtual Bool_tfindRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; virtual TClass*IsA() const; voidsetTol(Double_t tol); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum { MaxIterations; };. protected:. const RooAbsFunc*RooAbsRootFinder::_functionPointer to input function; Double_t_tol; Bool_tRooAbsRootFinder::_validTrue if current state is valid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBrentRootFinder(const RooAbsFunc& function); Constructor taking function binding as input. Bool_t findRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; Do the root finding using the Brent-Decker method. Returns a boolean status and; loads 'result' with our best guess at the root if true.; Prints a warning if the initial interval does not bracket a single; root or if the root is not found after a fixed number of iterations. RooBrentRootFinder(const RooAbsFunc& function). virtual ~RooBrentRootFinder(); { }. void setTol(Double_t tol); Set convergence tolerance parameter. » Last changed: Tue Dec 8 17:03:14 2009 » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBrentRootFinder.html:1536,load,loads,1536,root/html526/RooBrentRootFinder.html,https://root.cern,https://root.cern/root/html526/RooBrentRootFinder.html,1,['load'],['loads']
Performance,"; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSet_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:38373,cache,cache,38373,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TWebFile; static Long64_t fgMaxFullCacheSize = 500000000;  ; static TUrl fgProxy;  size of the cached content ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TS3WebFile.h>. Inheritance diagram for TS3WebFile:. This browser is n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:46273,CACHE,CACHEREAD,46273,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['CACHE'],['CACHEREAD']
Performance,"; static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormulaVar.html:19112,optimiz,optimizeCacheMode,19112,root/html530/RooFormulaVar.html,https://root.cern,https://root.cern/root/html530/RooFormulaVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f; double_maxEffMaximum of efficiency in vars; RooArgSet*_varsVars to generate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. Generate an event from the p.d.f and; then perform an accept/reject sampling based on the efficiency; function. RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Tue Jun 2 15:30:29 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooEffGenContext.html:10762,perform,perform,10762,root/html604/RooEffGenContext.html,https://root.cern,https://root.cern/root/html604/RooEffGenContext.html,1,['perform'],['perform']
Performance,"; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooCatType*_defCatDefault (unmapped) output type; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooCategoryProxy_inputCatInput category; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; map<string,RooMappedCategory::Entry>_mapArrayList of mapping rules; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:21825,cache,cache,21825,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,8,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  THttpWSHandler (const char *name, const char *title, Bool_t syncmode=kTRUE);  normal constructor ;  ; virtual void CompleteWSSend (UInt_t);  Method called when multi-threaded send operation is completed. ;  ; virtual std::string GetCodeVersion ();  Method generate extra suffix for all kinds of loaded code. ;  ; virtual Bool_t ProcessBatchHolder (std::shared_ptr< THttpCallArg > &);  Method used to accept or reject root_batch_holder.js request. ;  ; virtual void VerifyDefaultPageContent (std::shared_ptr< THttpCallArg > &arg);  Method called when default page content is prepared for use By default no-cache header is provided. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; Int_t CompleteSend (std::shared_ptr< THttpWSEngine > &engine);  Complete current send operation. ;  ; std::shared_ptr< THttpWSEngine > FindEngine (UInt_t id, Bool_t book_send=kFALSE);  Find websocket connection han",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:13703,multi-thread,multi-threaded,13703,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['multi-thread'],['multi-threaded']
Performance,"; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; TEveCaloData::vCellId_tfCellList; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tTEveCaloViz::fEndCapPosBbackward end cap z coordinate in cm (should be < 0); Float_tTEveCaloViz::fEndCapPosFforward end cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Color_tfFrameColor; Char_tfFrameTransparency; Float_tfFrameWidth; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveEleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCalo3D.html:21567,cache,cache,21567,root/html602/TEveCalo3D.html,https://root.cern,https://root.cern/root/html602/TEveCalo3D.html,2,['cache'],['cache']
Performance,"; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html:44887,cache,cache,44887,root/html602/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html,2,['cache'],['cache']
Performance,"; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooIntegralMorph.h>. Inheritance diagram for RooIntegralMorph:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooIntegralMorph() [1/3]. RooIntegralMorph::RooIntegralMorph ; (; ). default . ◆ RooIntegralMorph() [2/3]. RooIntegralMorph::RooIntegralMorph ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _pdf1, . RooAbsReal & ; _pdf2, . RooAbsReal & ; _x, . RooAbsReal & ; _alpha, . bool ; cacheAlpha = false . ). Constructor with observables x, pdf shapes pdf1 and pdf2 which represent the shapes at the end points of the interpolation parameter alpha If doCacheAlpha is true, a two-dimensional cache is constructed in both alpha and x. ; Definition at line 101 of file RooIntegralMorph.cxx. ◆ RooIntegralMorph() [3/3]. RooIntegralMorph::RooIntegralMorph ; (; const RooIntegralMorph & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 119 of file RooIntegralMorph.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Observable to be cached for given choice of normalization. ; Returns the 'x' observable unless doCacheAlpha is set in which case a set with both x and alpha ; Implements RooAbsCachedPdf.; Definition at line 134 of file RooIntegralMorph.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Parameters of the cache. ; Returns par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:81462,cache,cache,81462,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; bool CreateMinimizer ();  internal function to create the minimizer for finding the contours ;  ; void ResetLimits ();  reset the cached limit values ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; RooArgSet * fBestFitParams;  snapshot of the model parameters with best fit value (managed internally) ;  ; double fConfidenceLevel;  Requested confidence level (eg. 0.95 for 95% CL) ;  ; std::shared_ptr< RooFunctor > fFunctor;  ! transient pointer to functor class used by the minimizer ;  ; RooAbsReal * fLikelihoodRatio;  likelihood ratio function used to make contours (managed internally) ;  ; std::map< std::string, double > fLowerLimits;  map with cached lower bound values ;  ; std::shared_ptr< ROOT::Math::IMultiGenFunction > fMinFunc;  ! transient pointer to the minimization function ;  ; std::shared_ptr< ROOT::Math::Minimizer > fMinimizer;  ! transient pointer to minimizer class used to find limits and contour ;  ; RooArgSet fParameters;  parameters of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html:14195,cache,cached,14195,doc/master/classRooStats_1_1LikelihoodInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html,1,['cache'],['cached']
Performance,"; static function returning true if optimization can be on. const char * GetElementCounterStart(const char* dmTitle); Given a comment/title declaring an array counter, for example:; //[fArraySize] array of size fArraySize; return the start of the array dimension declaration start in the string; (so the location of the 'f'. TStreamerBasicType * GetElementCounter(const char* countName, TClass* cl); Get pointer to a TStreamerBasicType in TClass *cl; static function. Bool_t GetStreamMemberWise(); Return whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing. A collection can be saved member wise when it contain is guaranteed to be; homogeneous. For example std::vector<THit> can be stored member wise,; while std::vector<THit*> can not (possible use of polymorphism). void Optimize(Bool_t opt = kTRUE); This is a static function.; Set optimization option.; When this option is activated (default), consecutive data members; of the same type are merged into an array (faster).; Optimization must be off in TTree split mode. TVirtualStreamerInfo * Factory(); Static function returning a pointer to a new TVirtualStreamerInfo object.; If the Info factory does not exist, it is created via the plugin manager.; In reality the factory is an empty TStreamerInfo object. void SetCanDelete(Bool_t opt = kTRUE); This is a static function.; Set object delete option.; When this option is activated (default), ReadBuffer automatically; delete objects when a data member is a pointer to an object.; If your constructor is not presetting pointers to 0, you must; call this static function TStreamerInfo::SetCanDelete(kFALSE);. void SetFactory(TVirtualStreamerInfo* factory); static function: Set the StreamerInfo factory. Bool_t SetStreamMemberWise(Bool_t enable = kTRUE); Set whether the TStreamerInfos will save the collections in; ""member-wise"" order w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualStreamerInfo.html:13727,optimiz,optimization,13727,root/html602/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TVirtualStreamerInfo.html,2,['optimiz'],['optimization']
Performance,"; std::size_t ; first, . std::size_t ; len . ); const. overridevirtual . Get the weights of the events in the range [first, first+len). ; This implementation will fill a vector with every event retrieved one by one (even if the weight is constant). Then, it returns a span. ; Implements RooAbsDataStore.; Definition at line 1197 of file RooTreeDataStore.cxx. ◆ initialize(). void RooTreeDataStore::initialize ; (; ). private . One-time initialization common to all constructor forms. ; Attach variables of internal ArgSet to the corresponding TTree branches ; Definition at line 307 of file RooTreeDataStore.cxx. ◆ IsA(). TClass * RooTreeDataStore::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsDataStore.; Definition at line 181 of file RooTreeDataStore.h. ◆ isWeighted(). bool RooTreeDataStore::isWeighted ; (; ); const. inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 74 of file RooTreeDataStore.h. ◆ loadValues() [1/2]. void RooTreeDataStore::loadValues ; (; const RooAbsDataStore * ; tds, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Load values from dataset 't' into this data collection, optionally selecting events using 'select' RooFormulaVar. ; Implements RooAbsDataStore.; Definition at line 470 of file RooTreeDataStore.cxx. ◆ loadValues() [2/2]. void RooTreeDataStore::loadValues ; (; const TTree * ; t, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . Int_t ; nStart = 0, . Int_t ; nStop = 2000000000 . ). Load values from tree 't' into this data collection, optionally selecting events using the RooFormulaVar 'select'. ; The source tree 't' is cloned to not disturb its branch structure when retrieving information from it. ; Definition at line 367 of file RooTreeDataStore.cxx. ◆ makeTreeName(). std::string ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:33409,load,loadValues,33409,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['load'],['loadValues']
Performance,"; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TMemFile; static constexpr Long64_t fgDefaultBlockSize = 2 * 1024 * 1024;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <ROOT/TBufferMerger.hxx>. Inheritance diagram for ROOT::TBufferMergerF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:43769,CACHE,CACHEREAD,43769,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,2,['CACHE'],['CACHEREAD']
Performance,"; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TMemFile; static constexpr Long64_t fgDefaultBlockSize = 2 * 1024 * 1024;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TParallelMergingFile.h>. Inheritance diagram for TParallelMergingFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelMergingFile.html:43174,CACHE,CACHEREAD,43174,doc/master/classTParallelMergingFile.html,https://root.cern,https://root.cern/doc/master/classTParallelMergingFile.html,1,['CACHE'],['CACHEREAD']
Performance,; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorageSize::maxInlineByteSizestatic constexpr unsigned maxInlineByteSizeDefinition RVec.hxx:521; ROOT::Internal::VecOps::RVecInlineStorageSize::elementsPerCacheLinestatic constexpr unsigned elementsPerCacheLineDefinition RVec.hxx:520. Definition at line 524 of file RVec.hxx. Collaboration diagram for ROOT::Internal::VecOps::RVecInlineStorageSize< T >:. This browser is not,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:1391,cache,cacheLineSize,1391,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,1,['cache'],['cacheLineSize']
Performance,"; template<typename AFloat > ; __global__ void SymmetricRelu (AFloat *A, int m, int n);  ; template<typename AFloat > ; __global__ void SymmetricReluDerivative (AFloat *B, const AFloat *A, int m, int n);  ; template<typename AFloat > ; __global__ void Tanh (AFloat *A, int m, int n);  ; template<typename AFloat > ; __global__ void TanhDerivative (AFloat *B, const AFloat *A, int m, int n);  ; template<typename AFloat > ; __global__ void UpdateWeights (AFloat *A, const AFloat **B, int batchSize, int nRows, int nCols);  . Function Documentation. ◆ AbsoluteSum(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::AbsoluteSum ; (; AFloat * ; result, . const AFloat * ; A, . int ; m, . int ; n . ). Definition at line 729 of file Kernels.cuh. ◆ AdamUpdate(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::AdamUpdate ; (; AFloat * ; A, . const AFloat * ; M, . const AFloat * ; V, . int ; m, . int ; n, . AFloat ; alpha, . AFloat ; eps . ). optimizer kernel functions ; Definition at line 408 of file Kernels.cuh. ◆ AdamUpdateFirstMom(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::AdamUpdateFirstMom ; (; AFloat * ; A, . const AFloat * ; B, . int ; m, . int ; n, . AFloat ; beta . ). Definition at line 422 of file Kernels.cuh. ◆ AdamUpdateSecondMom(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::AdamUpdateSecondMom ; (; AFloat * ; A, . const AFloat * ; B, . int ; m, . int ; n, . AFloat ; beta . ). Definition at line 436 of file Kernels.cuh. ◆ AddBiases(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::AddBiases ; (; AFloat * ; A, . const AFloat * ; B, . int ; nRows, . int ; nCols . ). Definition at line 1118 of file Kernels.cuh. ◆ AddL1RegularizationGradients(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::AddL1RegularizationGradients ; (; AFloat * ; A, . const AFloat * ; B, . AFloat ; weightDecay, . int ; m, . int ; n . ). Definition at line 767 of file Kernels.cuh. ◆ AddL2RegularizationGradi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html:7923,optimiz,optimizer,7923,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,1,['optimiz'],['optimizer']
Performance,"; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCacheUnzip.html:18332,cache,cache,18332,root/html604/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getting a valid access to the remote; server the client is connected to using GetAccessToSrv() method,; recognizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options field of the URL can be used for the following purposes:; a. open a non-ROOT generic file; ""root://server1:port1[,server2:port2,...]/pathfile?filetype=raw""; b. re-check the environment variables; ""root://server1:port1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:25845,concurren,concurrently,25845,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,6,['concurren'],['concurrently']
Performance,"; useTMVADNN = False; ; if not ""tmva-pymva"" in ROOT.gROOT.GetConfigFeatures():; useKerasCNN = False; usePyTorchCNN = False; else:; TMVA.PyMethodBase.PyInitialize(); ; if not useTMVACNN:; ROOT.Warning(; ""TMVA_CNN_Classificaton"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"",; ); ; writeOutputFile = True; ; num_threads = 4 # use max 4 threads; max_epochs = 10 # maximum number of epochs used for training; ; ; # do enable MT running; if ""imt"" in ROOT.gROOT.GetConfigFeatures():; ROOT.EnableImplicitMT(num_threads); ROOT.gSystem.Setenv(""OMP_NUM_THREADS"", ""1"") # switch OFF MT in OpenBLAS; print(""Running with nthreads = {}"".format(ROOT.GetThreadPoolSize())); else:; print(""Running in serial mode since ROOT does not support MT""); ; ; ; ; outputFile = None; if writeOutputFile:; outputFile = TFile.Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE""); ; ; ## Create TMVA Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; # - The first argument is the base of the name of all the output; # weight files in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; ; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; # option string; ; # - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; # input variables; ; ; factory = TMVA.Factory(; ""TMVA_CNN_Classification"",; outputFile,; V=False,; ROC=True,; Silent=False,; Color=True,; AnalysisType=""Classification"",; Transformations=None,; Correlations=False,; ); ; ; ## Declare DataLoader(s); ; # The n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:5184,perform,performance,5184,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['perform'],['performance']
Performance,"; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase*constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; Bool_tfNotDoneYetflat to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html:2882,Optimiz,OptimizeConfigParameters,2882,root/html602/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html,6,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'optimizationType', 'tuneParameters']"
Performance,"; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearMinimizer.html:5711,perform,performing,5711,root/html528/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html528/TLinearMinimizer.html,4,['perform'],['performing']
Performance,"; virtual Bool_tIsCursorEnabledithoutFocus() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTGTextView::IsMarked() const; virtual Bool_tIsMenuEnabled() const; Bool_tTObject::IsOnHeap() const; Bool_tTGTextView::IsReadOnly() const; virtual Bool_tTGTextView::IsSaved(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGTextView::Layout(); virtual voidLineDown(); virtual voidLineUp(); virtual Bool_tTGTextView::LoadBuffer(const char* txtbuf); virtual Bool_tTGTextView::LoadFile(const char* fname, long startpos = 0, long length = -1); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTGTextView::Marked(Bool_t mark)SIGNAL ; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual voidNextChar(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidOpened()SIGNAL ; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEdit.html:11921,Load,LoadFile,11921,root/html528/TGTextEdit.html,https://root.cern,https://root.cern/root/html528/TGTextEdit.html,1,['Load'],['LoadFile']
Performance,"; virtual Bool_tIsCursorEnabledithoutFocus() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTGTextView::IsMarked() const; virtual Bool_tIsMenuEnabled() const; Bool_tTObject::IsOnHeap() const; Bool_tTGTextView::IsReadOnly() const; virtual Bool_tTGTextView::IsSaved(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGTextView::Layout(); virtual voidLineDown(); virtual voidLineUp(); virtual Bool_tTGTextView::LoadBuffer(const char* txtbuf); virtual Bool_tTGTextView::LoadFile(const char* fname, long startpos = 0, long length = -1); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTGTextView::Marked(Bool_t mark)SIGNAL ; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual voidNextChar(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOpened",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGTextEdit.html:11921,Load,LoadFile,11921,root/html530/TGTextEdit.html,https://root.cern,https://root.cern/root/html530/TGTextEdit.html,3,['Load'],['LoadFile']
Performance,"; virtual Bool_tIsCursorEnabledithoutFocus() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTGTextView::IsMarked() const; virtual Bool_tIsMenuEnabled() const; Bool_tTObject::IsOnHeap() const; Bool_tTGTextView::IsReadOnly() const; virtual Bool_tTGTextView::IsSaved(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGTextView::Layout(); virtual voidLineDown(); virtual voidLineUp(); virtual Bool_tTGTextView::LoadBuffer(const char* txtbuf); virtual Bool_tTGTextView::LoadFile(const char* fname, long startpos = 0, long length = -1); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTGTextView::Marked(Bool_t mark)SIGNAL ; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual voidNextChar(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOpened()SIGNAL ; voidTObject::operator delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEdit.html:11501,Load,LoadFile,11501,root/html602/TGTextEdit.html,https://root.cern,https://root.cern/root/html602/TGTextEdit.html,2,['Load'],['LoadFile']
Performance,"; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:3887,cache,cacheUniqueSuffix,3887,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,2,['cache'],['cacheUniqueSuffix']
Performance,"; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; void Draw (Option_t *option="""") override;  Draw this histogram with options. ;  ; virtual TH1 * DrawCopy (Option_t *option="""", const char *name_postfix=""_copy"") const;  Copy this histogram and Draw in the current pad. ;  ; virtual TH1 * DrawNormalized (Option_t *option="""", Double_t norm=1) const;  Draw a normalized copy of this histogram. ;  ; virtual void DrawPanel ();  Display a panel with all histogram drawing options. ;  ; virtual void Eval (TF1 *f1, Option_t *option="""");  Evaluate function f1 at the center of bins of this histogram. ;  ; void ExecuteEvent (Int_t e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:21168,Perform,Perform,21168,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['Perform'],['Perform']
Performance,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsDataStore.html:8063,cache,cached,8063,root/html526/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html526/RooAbsDataStore.html,10,"['cache', 'load']","['cached', 'loading']"
Performance,"; virtual bool addOwned (const RooAbsCollection &list, bool silent=false);  for each element in the source collection. ;  ; virtual bool addOwned (RooAbsArg &var, bool silent=false);  Add an argument and transfer the ownership to the collection. ;  ; bool addOwned (RooAbsCollection &&list, bool silent=false);  Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ;  ; bool addOwned (std::unique_ptr< RooAbsArg > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; TIterator begin ();  ; RooLinkedListIter begin ();  ; RooFIter begin ();  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; virtual TObject * clone (const char *newname) const =0;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:4664,cache,cache,4664,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['cache'],['cache']
Performance,"; virtual bool addOwned (const RooAbsCollection &list, bool silent=false);  for each element in the source collection. ;  ; virtual bool addOwned (RooAbsArg &var, bool silent=false);  Add an argument and transfer the ownership to the collection. ;  ; bool addOwned (RooAbsCollection &&list, bool silent=false);  Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ;  ; bool addOwned (std::unique_ptr< RooAbsArg > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:8254,cache,cache,8254,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['cache'],['cache']
Performance,"; virtual bool addOwned (const RooAbsCollection &list, bool silent=false);  for each element in the source collection. ;  ; virtual bool addOwned (RooAbsArg &var, bool silent=false);  Add an argument and transfer the ownership to the collection. ;  ; bool addOwned (RooAbsCollection &&list, bool silent=false);  Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ;  ; bool addOwned (std::unique_ptr< RooAbsArg > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::string contentsString () const;  Return comma separated list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgList.html:5670,cache,cache,5670,doc/master/classRooArgList.html,https://root.cern,https://root.cern/doc/master/classRooArgList.html,1,['cache'],['cache']
Performance,"; virtual bool addOwned (const RooAbsCollection &list, bool silent=false);  for each element in the source collection. ;  ; virtual bool addOwned (RooAbsArg &var, bool silent=false);  Add an argument and transfer the ownership to the collection. ;  ; bool addOwned (RooAbsCollection &&list, bool silent=false);  Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ;  ; bool addOwned (std::unique_ptr< RooAbsArg > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; virtual TObject * clone (const char *newname) const =0;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:4665,cache,cache,4665,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['cache'],['cache']
Performance,"; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(double x, const double* p) const; evaluate function passing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html:3050,cache,cachen,3050,root/html528/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html,4,['cache'],['cachen']
Performance,"; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:15515,cache,cache,15515,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['cache'],['cache']
Performance,"; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidSho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinearVar.html:27645,cache,cache,27645,root/html532/RooLinearVar.html,https://root.cern,https://root.cern/root/html532/RooLinearVar.html,1,['cache'],['cache']
Performance,"; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinearVar.html:27502,cache,cache,27502,root/html530/RooLinearVar.html,https://root.cern,https://root.cern/root/html530/RooLinearVar.html,1,['cache'],['cache']
Performance,"; virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:3773,cache,cache,3773,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,1,['cache'],['cache']
Performance,"; virtual voidTChain::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTChain::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTChain::SetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTChain::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* enlist, const Option_t*); virtual voidTChain::SetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofChain.html:16809,cache,cacheSize,16809,root/html604/TProofChain.html,https://root.cern,https://root.cern/root/html604/TProofChain.html,1,['cache'],['cacheSize']
Performance,"; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenCategory.html:16002,cache,cache,16002,root/html532/RooGenCategory.html,https://root.cern,https://root.cern/root/html532/RooGenCategory.html,4,['cache'],['cache']
Performance,"; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(bool constant); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetParamConst(Int_t, Bool_t = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetShape(TH1* shape); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUnique",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:24697,cache,cache,24697,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['cache'],['cache']
Performance,"; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:23726,cache,cache,23726,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to disk all the basket that have not yet been individually written and create an event cluster boundary (by default). ;  ; UInt_t GetAllocationCount () const;  ; virtual Long64_t GetAutoFlush () const;  ; virtual Long64_t GetAutoSave () const;  ; virtual TBranchRef * GetBranchRef () const;  ; virtual Long64_t GetChainOffset () const;  ; virtual bool GetClusterPrefetch () const;  ; TFile * GetCur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:18323,cache,cache,18323,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,3,['cache'],['cache']
Performance,"; virtual ~Interpolator ();  ; double Deriv (double x) const;  Return the derivative of the interpolated function at point x. ;  ; double Deriv2 (double x) const;  Return the second derivative of the interpolated function at point x. ;  ; double Eval (double x) const;  Return the interpolated value at point x. ;  ; double Integ (double a, double b) const;  Return the Integral of the interpolated function over the range [a,b]. ;  ; Interpolator & operator= (const Interpolator &)=delete;  ; Interpolator & operator= (Interpolator &&)=delete;  ; bool SetData (const std::vector< double > &x, const std::vector< double > &y);  Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used in the constructor (ndata) If this is not the case a new re-initialization is performed with the new data size. ;  ; bool SetData (unsigned int ndata, const double *x, const double *y);  Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used when constructing the class (ndata) If this is not the case a new re-initialization is performed with the new data size. ;  ; std::string Type () const;  Return the type of interpolation method. ;  ; std::string TypeGet () const;  . Private Attributes; GSLInterpolator * fInterp;  . #include <Math/Interpolator.h>; Constructor & Destructor Documentation. ◆ Interpolator() [1/4]. ROOT::Math::Interpolator::Interpolator ; (; unsigned int ; ndata = 0, . Interpolation::Type ; type = Interpolation::kCSPLINE . ). Constructs an interpolator class from number of data points and with Interpolation::Type type. ; The data can be set later on with the SetData method. In case the data size is not known, better using the default of zero or the next constructor later on. The default interpolation type is Cubic spline ; Definition at line 40 of file Interpolator.cxx. ◆ Interpolator() [2/4]. ROOT::Math::Interpolator::Interpolator ; (; const std::vector< double > & ; x, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html:2595,perform,performed,2595,doc/master/classROOT_1_1Math_1_1Interpolator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html,1,['perform'],['performed']
Performance,"; voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:14893,cache,cache,14893,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"; voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSuperCategory.html:15294,cache,cache,15294,root/html530/RooSuperCategory.html,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html,1,['cache'],['cache']
Performance,"; voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCategory.html:14979,cache,cache,14979,root/html530/RooCategory.html,https://root.cern,https://root.cern/root/html530/RooCategory.html,1,['cache'],['cache']
Performance,"; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsRealLValue::volume(const char* rangeName) const; virtual Double_tRooAbsRealLValue::volume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:28634,cache,cache,28634,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,3,['cache'],['cache']
Performance,"; voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of dependents defining dimensions of histogram; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:29695,cache,cache,29695,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,2,['cache'],"['cache', 'caches']"
Performance,"; voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveDigitSetGL.html:1989,cache,cached,1989,root/html534/TEveDigitSetGL.html,https://root.cern,https://root.cern/root/html534/TEveDigitSetGL.html,1,['cache'],['cached']
Performance,"; voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:1638,cache,cacheUniqueSuffix,1638,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance,"; voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:1638,cache,cacheUniqueSuffix,1638,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance,"; voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:1638,cache,cacheUniqueSuffix,1638,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance,"; voidTObject::MakeZombie(); virtual TObjLink*NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. TList(const TList&); TList&operator=(const TList&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*fFirst! pointer to first entry in linked list; TObjLink*fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TList(); Delete the list. Objects are not deleted unless the TList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TList.html:10625,cache,cache,10625,root/html528/TList.html,https://root.cern,https://root.cern/root/html528/TList.html,4,['cache'],['cache']
Performance,"; voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:12147,optimiz,optimizeCacheMode,12147,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,"; voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:5896,load,loadopts,5896,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['load'],['loadopts']
Performance,"; voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:6125,load,loadopts,6125,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,2,['load'],['loadopts']
Performance,"; void AddInputData (TObject *obj, Bool_t push=kFALSE);  Add data objects that might be needed during the processing of the selector (see Process()). ;  ; Int_t Archive (const char *queryref, const char *url=0);  Send archive request for the query specified by ref. ;  ; Int_t Archive (Int_t query, const char *url);  Send archive request for the qry-th query in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; virtual Bool_t CancelStagingDataSet (const char *dataset);  Cancels a dataset staging request. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send cleanup request for the session specified by tag. ;  ; virtual void ClearCache (const char *file=0);  Remove file from all file caches. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; virtual void ClearDataSetCache (const char *dataset=0);  Clear the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:4500,cache,cache,4500,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['cache'],['cache']
Performance,"; void Class_ShowMembers (TClass *cl, const void *obj, TMemberInspector &);  Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. ;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:7515,multi-thread,multi-threading,7515,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"; void CountLevels ();  Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices. ;  ; Int_t CountNodes (const TGeoVolume *vol=nullptr, Int_t nlevels=10000, Int_t option=0);  Count the total number of nodes starting from a volume, nlevels down. ;  ; TGeoParallelWorld * CreateParallelWorld (const char *name);  Create a parallel world for prioritised navigation. ;  ; void CreateThreadData () const;  Create thread private data for all geometry objects. ;  ; TGeoNode * CrossBoundaryAndLocate (Bool_t downwards, TGeoNode *skipnode);  Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode. ;  ; void DefaultAngles ();  Set default angles for a given view. ;  ; void DefaultColors ();  Set default volume colors according to A of material. ;  ; void DisableInactiveVolumes ();  ; TGeoVolume * Division (const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""");  Create a new volume by dividing an existing one (GEANT3 like) ;  ; void DoBackupState ();  Backup the current state without affecting the cache stack. ;  ; void DoRestoreState ();  Restore a backed-up state without affecting the cache stack. ;  ; void DrawCurrentPoint (Int_t color=2);  Draw current point in the same view. ;  ; void DrawPath (const char *path, Option_t *option="""");  Draw current path. ;  ; void DrawTracks (Option_t *option="""");  Draw tracks over the geometry, according to option. ;  ; virtual void Edit (Option_t *option="""");  Append a pad for this geometry. ;  ; void EnableInactiveVolumes ();  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this manager. ;  ; virtual Int_t Export (const char *filename, const char *name="""", Option_t *option=""vg"");  Export this geometry to a file. ;  ; TGeoMaterial * FindDuplicateMaterial (const TGeoMaterial *mat) const;  Find if a given material duplicates an existing one. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:25766,cache,cache,25766,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['cache'],['cache']
Performance,"; void SetBufferDisplacement (Int_t skipped) override;  ; void SetPidOffset (UShort_t offset) override;  This offset is used when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; virtual Int_t ApplySequence (const TStreamerInfoActions::TActionSequence &sequence, void *object)=0;  ; virtual Int_t ApplySequence (const TStreamerInfoActions::TActionSequence &sequence, void *start_collection, void *end_collection)=0;  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:4765,cache,cacheReuse,4765,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,3,['cache'],['cacheReuse']
Performance,"; void SetBufferDisplacement (Int_t skipped) override;  ; void SetPidOffset (UShort_t offset) override;  This offset is used when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:22389,cache,cacheReuse,22389,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,3,['cache'],['cacheReuse']
Performance,"; void SetClassVersion (Version_t version);  Private function. ;  ; void SetRuntimeProperties ();  Internal routine to set calculate the class properties that can only be known at run-time, for example whether the Hash member function and the destructor are consistent. ;  ; void SetStreamerImpl ();  Internal routine to set fStreamerImpl based on the value of fStreamerType. ;  ; void UnregisterAddressInRepository (const char *where, void *location, const TClass *what) const;  . Static Private Member Functions; static void ConvStreamerInstrumented (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of instrumented class with a library. ;  ; static DeclIdMap_t * GetDeclIdMap ();  ; static IdMap_t * GetIdMap ();  ; static Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl (const char *);  ; static TClass * LoadClassCustom (const char *requestedname, Bool_t silent);  Helper function used by TClass::GetClass(). ;  ; static TClass * LoadClassDefault (const char *requestedname, Bool_t silent);  Helper function used by TClass::GetClass(). ;  ; static void StreamerDefault (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Default streaming in cases where either we have no way to know what to do or if Property() has not yet been called. ;  ; static void StreamerExternal (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  There is special streamer for the class. ;  ; static void StreamerInstrumented (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of instrumented class with a library. ;  ; static void StreamerStreamerInfo (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of where we should directly use the StreamerInfo. ;  ; static void StreamerTObject (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of TObjects. ;  ; static void StreamerTObjectEmulated (const TClass *pThis, void *object, TBuffer &b, const TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:41894,Load,LoadClassDefault,41894,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['Load'],['LoadClassDefault']
Performance,"; w->factory(""CEXPR::GC('x*x+a',{x,a[1]})"");; ; // Compiled and interpreted functions (rather than pdfs) can be made with the lower case; // 'expr' and 'cexpr' types; ; // Print workspace contents; w->Print();; ; // Make workspace visible on command line; gDirectory->Add(w);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; gROOT#define gROOTDefinition TROOT.h:406; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf512_wsfactory_operDefinition rf512_wsfactory_oper.py:1; ; [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html:4252,cache,cache,4252,doc/master/rf512__wsfactory__oper_8C.html,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html,1,['cache'],['cache']
Performance,";  . Protected Member Functions; void boxInfoInit (BoxInfo *bi, const char *rangeName, Int_t code) const;  ; void calculateBandWidth ();  ; void calculatePreNorm (BoxInfo *bi) const;  bi->nEventsBMSW=0.; bi->nEventsBW=0.; ;  ; void calculateShell (BoxInfo *bi) const;  determine points in +/- nSigma shell around the box determined by the variable ranges. ;  ; void checkInitWeights () const;  ; RooDataSet * createDatasetFromHist (const RooArgList &varList, const TH1 &hist) const;  ; void createPdf (bool firstCall, RooDataSet const &data);  evaluation order of constructor. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; double gauss (std::vector< double > &x, std::vector< std::vector< double > > &weights) const;  loop over all closest point to x, as determined by loopRange() ;  ; void initialize (RooDataSet const &data);  initialization ;  ; void loadDataSet (bool firstCall, RooDataSet const &data);  copy the dataset and calculate some useful variables ;  ; void loadWeightSet (RooDataSet const &data);  ; void loopRange (std::vector< double > &x, std::vector< Int_t > &indices) const;  determine closest points to x, to loop over in evaluate() ;  ; void mirrorDataSet ();  determine mirror dataset. ;  ; void setOptions ();  set the configuration ;  ; void sortDataIndices (BoxInfo *bi=nullptr);  sort entries, as needed for loopRange() ;  ; void updateRho () const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:64275,load,loadDataSet,64275,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,2,['load'],"['loadDataSet', 'loadWeightSet']"
Performance,";  ; Bool_t Add (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1) override;  Replace contents of this profile2D by the addition of h1 and h2. ;  ; Bool_t Add (const TH1 *h1, Double_t c1=1) override;  Performs the operation: this = this + c1*h1 . ;  ; Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""") override;  Performs the operation: this = this + c1*f1 . ;  ; Int_t BufferEmpty (Int_t action=0) override;  Fill histogram with all entries in the buffer. ;  ; void BuildOptions (Double_t zmin, Double_t zmax, Option_t *option);  Set Profile2D histogram structure and options. ;  ; void Copy (TObject &hnew) const override;  Copy a Profile2D histogram to a new profile2D histogram. ;  ; Bool_t Divide (const TH1 *h1) override;  Divide this profile2D by h1. ;  ; Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""") override;  Replace contents of this profile2D by the division of h1 by h2. ;  ; Bool_t Divide (TF1 *h1, Double_t c1=1) override;  Performs the operation: this = this/(c1*f1) . ;  ; void ExtendAxis (Double_t x, TAxis *axis) override;  Profile histogram is resized along axis such that x is in the axis range. ;  ; Int_t Fill (const char *namex, const char *namey, Double_t z) override;  Increment cell defined by namex,namey by a weight w. ;  ; virtual Int_t Fill (const char *namex, const char *namey, Double_t z, Double_t w);  Fill a Profile2D histogram (no weights). ;  ; Int_t Fill (const char *namex, Double_t y, Double_t z) override;  Increment cell defined by namex,y by a weight w. ;  ; virtual Int_t Fill (const char *namex, Double_t y, Double_t z, Double_t w);  Fill a Profile2D histogram (no weights). ;  ; Int_t Fill (Double_t x, const char *namey, Double_t z) override;  Increment cell defined by x,namey by a weight w. ;  ; virtual Int_t Fill (Double_t x, const char *namey, Double_t z, Double_t w);  Fill a Profile2D histogram (no weights). ;  ; Int_t Fill (Double_t x, Double_t y, Double_t z) override;  Fill a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:5701,Perform,Performs,5701,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['Perform'],['Performs']
Performance,";  ; Bool_t Add (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1) override;  Replace contents of this profile3D by the addition of h1 and h2. ;  ; Bool_t Add (const TH1 *h1, Double_t c1=1) override;  Performs the operation: this = this + c1*h1 . ;  ; Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""") override;  Performs the operation: this = this + c1*f1 . ;  ; Int_t BufferEmpty (Int_t action=0) override;  Fill histogram with all entries in the buffer. ;  ; void BuildOptions (Double_t tmin, Double_t tmax, Option_t *option);  Set Profile3D histogram structure and options. ;  ; void Copy (TObject &hnew) const override;  Copy a Profile3D histogram to a new profile2D histogram. ;  ; Bool_t Divide (const TH1 *h1) override;  Divide this profile2D by h1. ;  ; Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""") override;  Replace contents of this profile2D by the division of h1 by h2. ;  ; Bool_t Divide (TF1 *h1, Double_t c1=1) override;  Performs the operation: this = this/(c1*f1) . ;  ; void ExtendAxis (Double_t x, TAxis *axis) override;  Profile histogram is resized along axis such that x is in the axis range. ;  ; Int_t Fill (Double_t x, Double_t y, Double_t z, Double_t t) override;  Fill a Profile3D histogram (no weights). ;  ; virtual Int_t Fill (Double_t x, Double_t y, Double_t z, Double_t t, Double_t w);  Fill a Profile3D histogram with weights. ;  ; Double_t GetBinContent (Int_t bin) const override;  Return bin content of a Profile3D histogram. ;  ; Double_t GetBinContent (Int_t binx, Int_t biny, Int_t binz) const override;  ; Double_t GetBinContent (Int_t, Int_t) const override;  ; virtual Double_t GetBinEffectiveEntries (Int_t bin);  Return bin effective entries for a weighted filled Profile histogram. ;  ; virtual Double_t GetBinEntries (Int_t bin) const;  Return bin entries of a Profile3D histogram. ;  ; Double_t GetBinError (Int_t bin) const override;  Return bin error of a Profile3D histogram. ;  ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:4517,Perform,Performs,4517,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['Perform'],['Performs']
Performance,";  ; Bool_t BuildingScene () const override;  ; Bool_t CanLoopOnPrimitives () const override;  ; void ClearCurrentOvlElm ();  Reset current overlay-element to zero, eventually notifying the old one that the mouse has left. ;  ; virtual void Clicked (TObject *obj);  Emit Clicked signal. ;  ; virtual void Clicked (TObject *obj, UInt_t button, UInt_t state);  Emit Clicked signal with button id and modifier state. ;  ; void CloseComposite () override;  ; TGLColorSet & ColorSet ();  ; TGLCamera & CurrentCamera () const;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Calculate and return pixel distance to nearest viewer object from window location px, py This is provided for use when embedding GL viewer into pad. ;  ; void DoDraw (Bool_t swap_buffers=kTRUE);  Draw out the viewer. ;  ; void DoDrawMono (Bool_t swap_buffers);  Draw out in monoscopic mode. ;  ; void DoDrawStereo (Bool_t swap_buffers);  Draw out in stereoscopic mode. ;  ; Bool_t DoOverlaySelect (Int_t x, Int_t y);  Perform GL selection, picking overlay objects only. ;  ; Bool_t DoSecondarySelect (Int_t x, Int_t y);  Secondary selection. ;  ; Bool_t DoSelect (Int_t x, Int_t y);  Perform GL selection, picking objects overlapping WINDOW area described by 'rect'. ;  ; virtual void DoubleClicked ();  ; void DrawDebugInfo ();  If in debug mode draw camera aids and overall bounding box. ;  ; void DrawGuides ();  Draw reference marker and coordinate axes. ;  ; void EndScene () override;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Process event of type 'event' - one of EEventType types, occurring at window location px, py This is provided for use when embedding GL viewer into pad. ;  ; TGLAutoRotator * GetAutoRotator ();  Get the auto-rotator for this viewer. ;  ; TGLCameraOverlay * GetCameraOverlay () const;  ; Bool_t GetClipAutoUpdate () const;  ; TGLClipSet * GetClipSet () const;  ; TGLOverlayElement * GetCurrentOvlElm () const;  ; Int_t GetDev () const;  ; EDragAction GetDragActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:3231,Perform,Perform,3231,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,2,['Perform'],['Perform']
Performance,";  ; Bool_t HandleDNDLeave () override;  Handle Drag Leave event. ;  ; Atom_t HandleDNDPosition (Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot) override;  Handle Drag position event. ;  ; Bool_t HandleDoubleClick (Event_t *event) override;  handle double click ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion event in the text editor widget. ;  ; Bool_t HandleSelectionClear (Event_t *event) override;  Handle selection clear event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle request to send current clipboard contents to requestor window. ;  ; Bool_t HandleTimer (TTimer *t) override;  Handle scroll timer. ;  ; Bool_t IsMarked () const;  ; Bool_t IsReadOnly () const;  ; virtual Bool_t IsSaved ();  ; void Layout () override;  Layout the components of view. ;  ; virtual Bool_t LoadBuffer (const char *txtbuf);  Load text from a text buffer. Return false in case of failure. ;  ; virtual Bool_t LoadFile (const char *fname, long startpos=0, long length=-1);  Load a file in the text view widget. ;  ; virtual void Marked (Bool_t mark);  ; virtual Long_t ReturnHeighestColHeight ();  ; virtual Long_t ReturnLineCount ();  ; virtual Long_t ReturnLineLength (Long_t line);  ; virtual Long_t ReturnLongestLine ();  ; virtual Long_t ReturnLongestLineWidth ();  Return width of longest line. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save a text edit widget as a C++ statement(s) on output stream out. ;  ; virtual Bool_t Search (const char *string, Bool_t direction, Bool_t caseSensitive);  Search for string in text. ;  ; virtual Bool_t SelectAll ();  Select all text in the viewer. ;  ; virtual void SetBackground (Pixel_t p);  set background color ;  ; virtual void SetFont (FontStruct_t font);  Changes text entry font. ;  ; void SetForegroundColor (Pixel_t) override;  Set text color. ;  ; virtual void SetHsbPosition (Long_t newPos);  Set position of horizontal scrollbar. ;  ; virtual void SetReadOnly (Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextViewostream.html:3657,Load,LoadFile,3657,doc/master/classTGTextViewostream.html,https://root.cern,https://root.cern/doc/master/classTGTextViewostream.html,2,['Load'],"['Load', 'LoadFile']"
Performance,";  ; Bool_t IsValid () const;  ; Bool_t IsVisContainers () const;  ; virtual Bool_t IsVisible () const;  ; Bool_t IsVisibleDaughters () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; virtual Bool_t IsVolumeMulti () const;  ; Bool_t IsXYZVoxels () const;  ; TH2F * LegoPlot (Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""");  Generate a lego plot fot the top volume, according to option. ;  ; void MakeCopyNodes (const TGeoVolume *other);  make a new list of nodes and copy all nodes of other volume inside ;  ; virtual TGeoVolume * MakeCopyVolume (TGeoShape *newshape);  make a copy of this volume build a volume with same name, shape and medium ;  ; TGeoVolume * MakeReflectedVolume (const char *newname="""") const;  Make a copy of this volume which is reflected with respect to XY plane. ;  ; Bool_t OptimizeVoxels ();  Perform an extensive sampling to find which type of voxelization is most efficient. ;  ; void Paint (Option_t *option="""") override;  paint volume ;  ; void Print (Option_t *option="""") const override;  Print volume info. ;  ; void PrintNodes () const;  print nodes ;  ; void PrintVoxels () const;  Print the voxels for this volume. ;  ; void RandomPoints (Int_t npoints=1000000, Option_t *option="""");  Draw random points in the bounding box of this volume. ;  ; void RandomRays (Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Random raytracing method. ;  ; void Raytrace (Bool_t flag=kTRUE);  Draw this volume with current settings and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:20391,Optimiz,OptimizeVoxels,20391,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,2,"['Optimiz', 'Perform']","['OptimizeVoxels', 'Perform']"
Performance,";  ; Bool_t fDoQuota;  Full tracing in workers. ;  ; Bool_t fDoSlaveTrace;  Trace processing rate in master. ;  ; Bool_t fDoTrace;  Fill histos. ;  ; Bool_t fDoTraceRate;  Trace details in master. ;  ; TDSet * fDSet;  ; TH1D * fEventsHist;  histogram of packets being processed per slave ;  ; TH2D * fLatencyHist;  histogram of slaves per file serving node ;  ; Bool_t fMonitorPerPacket;  Save stats on SQL server for quota management. ;  ; TObjArray fMonSenders;  Whether to send the full entry per each packet. ;  ; TH1D * fNodeHist;  histogram of events processed per slave ;  ; Long64_t fNumEvents;  total number of events processed ;  ; TList * fOutput;  Saved pointer to the TDSet object. ;  ; TH1D * fPacketsHist;  TPerfEvent used to fill tree. ;  ; TPerfEvent * fPerfEvent;  start time of this run ;  ; TH1I * fProcPcktHist;  histogram of packets processed per slave ;  ; TH2D * fProcTimeHist;  histogram of latency due to packet requests ;  ; Int_t fSlaves;  total number of events to be processed ;  ; Long64_t fTotBytesRead;  total cpu time of all slaves ;  ; Double_t fTotCpuTime;  track bytes read of main file ;  ; Long64_t fTotEvents;  total bytes read on all slaves ;  ; TTree * fTrace;  ; TTimeStamp fTzero;  TTree with trace events. ;  . Static Private Attributes; static Long_t fgResMemMax = -1;  Max virtual memory used by this process. ;  ; static Long_t fgVirtMemMax = -1;  Saved pointer to the output list. ;  . Friends; class TProofMonSender;  . Additional Inherited Members;  Public Types inherited from TVirtualPerfStats; enum  EEventType { ;   kUnDefined; , kPacket; , kStart; , kStop; , ;   kFile; , kFileOpen; , kFileRead; , kRate; , ;   kNumEventType. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDepre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPerfStats.html:13240,latency,latency,13240,doc/master/classTPerfStats.html,https://root.cern,https://root.cern/doc/master/classTPerfStats.html,1,['latency'],['latency']
Performance,";  ; Int_t GetSplitLevel () const;  ; TBranch * GetSubBranch (const TBranch *br) const;  Find the parent branch of child. ;  ; Long64_t GetTotalSize (Option_t *option="""") const;  Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchSTL.html:7084,Load,LoadBaskets,7084,doc/master/classTBranchSTL.html,https://root.cern,https://root.cern/doc/master/classTBranchSTL.html,1,['Load'],['LoadBaskets']
Performance,";  ; Int_t GetSplitLevel () const;  ; TBranch * GetSubBranch (const TBranch *br) const;  Find the parent branch of child. ;  ; Long64_t GetTotalSize (Option_t *option="""") const;  Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:7380,Load,LoadBaskets,7380,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,1,['Load'],['LoadBaskets']
Performance,";  ; Int_t GetSplitLevel () const;  ; TBranch * GetSubBranch (const TBranch *br) const;  Find the parent branch of child. ;  ; Long64_t GetTotalSize (Option_t *option="""") const;  Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSetting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:7865,Load,LoadBaskets,7865,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,1,['Load'],['LoadBaskets']
Performance,";  ; Int_t GetSplitLevel () const;  ; TBranch * GetSubBranch (const TBranch *br) const;  Find the parent branch of child. ;  ; Long64_t GetTotalSize (Option_t *option="""") const;  Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:12636,Load,LoadBaskets,12636,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['Load'],['LoadBaskets']
Performance,";  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelectorDraw; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html:13564,load,loaded,13564,doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,4,['load'],['loaded']
Performance,";  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Private Member Functions;  TFileCacheRead (const TFileCacheRead &)=delete;  ; TFileCacheRead & operator= (const TFileCacheRead &)=delete;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 ));",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:13938,cache,cache,13938,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cache']
Performance,";  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMiss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:31566,cache,cache,31566,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCac,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:24261,cache,cache,24261,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,";  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static const char * GetDirDelimiter ();  ; static Bool_t IsNamespace (const TClass *cl);  Check whether cl is a namespace. ;  ; static void LoadAllLibs ();  Load all libraries known to ROOT via the rootmap system. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual void CreateJavascript () const;  Write the default ROOT style sheet. ;  ; void CreateListOfClasses (const char *filter);  Create the list of all known classes. ;  ; void CreateListOfTypes ();  Create index of all data types and a page for each typedef-to-class. ;  ; virtual void CreateStyleSheet () const;  Write the default ROOT style sheet. ;  ; virtual bool GetDeclImplFileName (TClass *cl, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml.html:33799,Load,LoadAllLibs,33799,doc/master/classTHtml.html,https://root.cern,https://root.cern/doc/master/classTHtml.html,4,['Load'],"['Load', 'LoadAllLibs']"
Performance,";  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEvePointSelectorConsumer;  TEvePointSelectorConsumer (ETreeVarType_e cs=kTVT_XYZ);  ; virtual ~TEvePointSelectorConsumer ();  ; ETreeVarType_e GetSourceCS () const;  ; void SetSourceCS (ETreeVarType_e cs);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveProjectable;  TEveProjectable ();  Constructor. ;  ; virtual ~TEveProjectable ();  Destructor. ;  ; virtual void AddProjected (TEveProjected *p);  ; virtual void AddProjectedsToSet (std::set< TEveElement * > &set);  Add the projected elements to the set, dyn-casting them to TEveElement. ;  ; virtual void AnnihilateProjecteds ();  Optimized destroy of projected elements with condition there is only one parent for projected element. ;  ; ProjList_i BeginProjecteds ();  ; virtual void ClearProjectedList ();  ; ProjList_i EndProjecteds ();  ; virtual Bool_t HasProjecteds () const;  ; virtual void PropagateMainColor (Color_t color, Color_t old_color);  Set main color of projecteds if their color is the same as old_color. ;  ; virtual void PropagateMainTransparency (Char_t t, Char_t old_t);  Set main transparency of projecteds if their transparency is the same as the old one. ;  ; virtual void PropagateRenderState (Bool_t rnr_self, Bool_t rnr_children);  Set render state of projecteds. ;  ; virtual void PropagateVizParams (TEveElement *el=nullptr);  Set visualization parameters of projecteds. ;  ; virtual void RemoveProjected (TEveProjected *p);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TQObject;  TQObject ();  TQObject Constructor. ;  ; virtual ~TQObject ();  TQObject Destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveLine.html:33658,Optimiz,Optimized,33658,doc/master/classTEveLine.html,https://root.cern,https://root.cern/doc/master/classTEveLine.html,6,['Optimiz'],['Optimized']
Performance,";  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; Short_t GetImplFileLine () const;  ; const char * GetImplFileName () const;  ; UInt_t GetInstanceCount () const;  ; TVirtualIsAProxy * GetIsAProxy () const;  Return the proxy implementing the IsA functionality. ;  ; TVirtualStreamerInfo * GetLastReadInfo () const;  ; TList * GetListOfAllPublicDataMembers (Bool_t load=kTRUE);  Returns a list of all public data members of this class and its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ;  ; TList * GetListOfBases ();  Return list containing the TBaseClass(es) of a class. ;  ; TList * GetListOfDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of a class. ;  ; TList * GetListOfEnums (Bool_t load=kTRUE);  Return a list containing the TEnums of a class. ;  ; TList * GetListOfFunctionTemplates (Bool_t load=kTRUE);  Return TListOfFunctionTemplates for a class. ;  ; TCollection * GetListOfMethodOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TList * GetListOfMethods (Bool_t load=kTRUE);  Return list containing the TMethods of a class. ;  ; TList * GetListOfRealData () const;  ; TList * GetListOfUsingDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of using declarations of a class. ;  ; void GetMenuItems (TList *listitems);  Returns list of methods accessible by context menu. ;  ; TList * GetMenuList () const;  Return the list of menu items associated with the class. ;  ; ROOT::MergeFunc_t GetMerge () const;  Return the wrapper around Merge. ;  ; TMethod * GetMethod (const char *method, const char *params, Bool_t objectIsConst=kFALSE);  Find the best method (if there is one) matching the parameters. ;  ; TMethod * GetMethodAllAny (const char *method);  Return pointer to method without looking at parameters. ;  ; TMethod * G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:11755,load,load,11755,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['load'],['load']
Performance,";  ; bool LookupObject (const clang::DeclContext *DC, clang::DeclarationName Name) override;  ; void PrintStackTrace () override;  ; void ReturnedFromUserCode (void *stateInfo) override;  ; void SetAutoLoadingEnabled (bool val=true);  ; void SetAutoParsingSuspended (bool val=true);  ; void TransactionCodeGenFinished (const cling::Transaction &T) override;  ; void TransactionCodeGenStarted (const cling::Transaction &T) override;  ; void TransactionCommitted (const cling::Transaction &T) override;  ; void TransactionRollback (const cling::Transaction &T) override;  ; void TransactionUnloaded (const cling::Transaction &T) override;  ; void UnlockCompilationDuringUserCodeExecution (void *StateInfo) override;  . Private Member Functions; bool findInGlobalModuleIndex (clang::DeclarationName Name, bool loadFirstMatchOnly=true);  ; bool shouldResolveAtRuntime (clang::LookupResult &R, clang::Scope *S);  ; bool tryAutoParseInternal (llvm::StringRef Name, clang::LookupResult &R, clang::Scope *S, clang::OptionalFileEntryRef FE=std::nullopt);  ; bool tryFindROOTSpecialInternal (clang::LookupResult &R, clang::Scope *S);  ; bool tryInjectImplicitAutoKeyword (clang::LookupResult &R, clang::Scope *S);  ; bool tryResolveAtRuntimeInternal (clang::LookupResult &R, clang::Scope *S);  . Private Attributes; bool fFirstRun = true;  ; bool fIsAutoLoading = false;  ; bool fIsAutoLoadingRecursively = false;  ; bool fIsAutoParsingSuspended = false;  ; bool fIsCodeGening = false;  ; bool fIsLoadingModule = false;  ; void * fLastLookupCtx = nullptr;  ; clang::NamespaceDecl * fROOTSpecialNamespace = nullptr;  ; llvm::DenseMap< llvm::StringRef, clang::DeclarationName > m_LoadedModuleFiles;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/core/metacling/src/TClingCallbacks.h>. Inheritance diagram for TClingCallbacks:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TClingC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClingCallbacks.html:2333,load,loadFirstMatchOnly,2333,doc/master/classTClingCallbacks.html,https://root.cern,https://root.cern/doc/master/classTClingCallbacks.html,1,['load'],['loadFirstMatchOnly']
Performance,";  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:44819,cache,cacheUniqueSuffix,44819,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cacheUniqueSuffix']
Performance,";  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:19147,cache,cache,19147,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['cache'],['cache']
Performance,";  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TProofServ; virtual void DeletePlayer ();  Delete player instance. ;  ; virtual Int_t Fork ();  Fork a child. ;  ; Int_t GetSessionStatus ();  Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ;  ; virtual void HandleArchive (TMessage *mess, TString *slb=0);  Handle archive request. ;  ; virtual Int_t HandleCache (TMessage *mess, TString *slb=0);  Handle here all cache and package requests. ;  ; virtual void HandleCheckFile (TMessage *mess, TString *slb=0);  Handle file checking request. ;  ; virtual Int_t HandleDataSets (TMessage *mess, TString *slb=0);  Handle here requests about datasets. ;  ; virtual Int_t HandleLibIncPath (TMessage *mess);  Handle lib, inc search paths modification request. ;  ; virtual void HandleProcess (TMessage *mess, TString *slb=0);  Handle processing request. ;  ; virtual void HandleQueryList (TMessage *mess);  Handle request for list of queries. ;  ; virtual void HandleRemove (TMessage *mess, TString *slb=0);  Handle remove request. ;  ; virtual void HandleRetrieve (TMessage *mess, TString *slb=0);  Handle retrieve request. ;  ; virtual void HandleSubmerger (TMessage *mess);  Handle a message of type kPROOF_SUBMERGER. ;  ; virtual Int_t HandleWorkerLists (TMessage *mess);  Handle here all requests to modify worker lists. ;  ; Bool_t IsIdle ();  Return the idle status. ;  ; virtual void M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLite.html:24305,cache,cache,24305,doc/master/classTProofServLite.html,https://root.cern,https://root.cern/doc/master/classTProofServLite.html,1,['cache'],['cache']
Performance,";  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void DoAddParameter (const TString &name, Double_t value, bool processFormula);  Adds parameter to known parameters. ;  ; Double_t DoEval (const Double_t *x, const Double_t *p=nullptr) const;  Evaluate formula. ;  ; void DoSetParameters (const Double_t *p, Int_t size);  ; void ExtractFunctors (TString &formula);  Extracts functors from formula, and put them in fFuncs. ;  ; Bool_t PrepareFormula (TString &formula);  prepare the formula to be executed normally is called with fFormula ;  ; void PreProcessFormula (TString &formula);  Preprocessing of formula Replace all ** by ^, and removes spaces. ;  ; void ProcessFormula (TString &formula);  Iterates through functors in fFuncs and performs the appropriate action. ;  ; void ReplaceParamName (TString &formula, const TString &oldname, const TString &name);  Replace in Formula expression the parameter name. ;  ; void SetPredefinedParamNames ();  Set parameter names only in case of pre-defined functions. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Bool_t IsAParameterName (const TString &formula, int ipos);  ; static Bool_t IsBracket (const char c);  ; static Bool_t IsFunctionNameChar (const char c);  ; static Bool_t IsHexadecimal (const TString &formula, int ipos);  ; static Bool_t IsOperator (const char c);  ; static Bool_t IsScientificNotation (const TString &formula, int ipos);  . Protected Attributes; std::map< TString, Double_t > fConsts;  ! ;  ; TString fFormula;  String rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:23638,perform,performs,23638,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,1,['perform'],['performs']
