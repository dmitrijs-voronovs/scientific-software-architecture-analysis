quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. fin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:3885,variab,variable,3885,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:3892,variab,variable,3892,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['variab'],['variable']
Modifiability,"_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, …); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_opdm(self); docstring. form_tpdm(self); docstring. frequencies(). from_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:2693,variab,variable,2693,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:3417,inherit,inherited,3417,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF refere",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98077,variab,variable,98077,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html:5106,variab,variable,5106,psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,4,['variab'],['variable']
Modifiability,"_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = core.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]def xml2dict(filename=None):; """"""Read XML *filename* into nested OrderedDict-s. *filename* defaults to; active CSX file. """"""; import xmltodict as xd; if filename is None:; csx = os.path.splitext(core.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.items():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:17110,variab,variables,17110,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['variab'],['variables']
Modifiability,"_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]def xml2dict(filename=None):; """"""Read XML *filename* into nested OrderedDict-s. *filename* defaults to; active CSX file. """"""; import xmltodict as xd; if filename is None:; csx = os.path.splitext(psi4.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); exc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:13085,variab,variables,13085,psi4manual/1.0.0/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html,1,['variab'],['variables']
Modifiability,"_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:43410,variab,variables,43410,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:4443,variab,variable,4443,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,4,['variab'],['variable']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:16263,variab,variables,16263,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,3,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html:16259,variab,variables,16259,psi4manual/1.4.0/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html,4,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html:16334,variab,variables,16334,psi4manual/1.4.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html,4,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.uhf.html:16259,variab,variables,16259,psi4manual/1.4.0/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.uhf.html,4,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html:16276,variab,variables,16276,psi4manual/1.4.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html,3,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:13065,variab,variables,13065,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,3,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:11698,variab,variables,11698,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:11676,variab,variables,11676,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,7,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:16810,variab,variables,16810,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. cle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.RHF.html:16806,variab,variables,16806,psi4manual/1.6.x/api/psi4.core.RHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.RHF.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html:17177,variab,variables,17177,psi4manual/1.6.x/api/psi4.core.ROHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. cle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.UHF.html:16806,variab,variables,16806,psi4manual/1.6.x/api/psi4.core.UHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.UHF.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:16825,variab,variables,16825,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:13223,variab,variables,13223,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:11819,variab,variables,11819,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,2,['variab'],['variables']
Modifiability,"_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:11900,variab,variables,11900,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,4,['variab'],['variables']
Modifiability,"_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient=G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:67464,variab,variables,67464,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Same for FREEZE_CORE. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:10462,variab,variable,10462,psi4manual/4.0b4/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html,2,['variab'],['variable']
Modifiability,"_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components in v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:124897,variab,variable,124897,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:31946,variab,variable,31946,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CUHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | CUHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from HF:; | ; | occupation_a(...); | occupation_a( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_a(N3psi3scf2HFE {lvalu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:404227,inherit,inherited,404227,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE matrix(N3psi10CdSalcListE {lvalue}); | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi10CdSalcListE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:415856,inherit,inherited,415856,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void close(N3psi4PSIOE {lvalue},j,i); | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void open(N3psi4PSIOE {lvalue},j,i); | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | C++ signature :; | i open_check(N3psi4PSIOE {lvalue},j)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:488948,inherit,inherited,488948,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ROHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | ROHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | moFa(...); | moFa( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFa(N3psi3scf4ROHFE {lvalue}); | ; | moFb(...); | moFb( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFb(N3psi3scf4ROHFE {lvalue}); | ; | moFeff(...); | moFeff( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFeff(N3psi3scf4ROHFE {lvalue}); | ; | ---------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:605228,inherit,inherited,605228,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10PetiteListEEE petite_list(N3psi10SOBasisSetE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data desc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:617331,inherit,inherited,617331,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have bee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:42718,variab,variables,42718,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:37211,variab,variables,37211,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:46019,variab,variables,46019,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89475,variab,variable,89475,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variable']
Modifiability,"_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. optstash.restore(); core.tstop(); return dfmp2_wfn. def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:83074,config,configuration,83074,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['config'],['configuration']
Modifiability,"_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python eco",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:11008,variab,variable,11008,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['variab'],['variable']
Modifiability,"_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:11008,variab,variable,11008,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,5,['variab'],['variable']
Modifiability,"_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within Psi4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:11576,variab,variable,11576,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['variab'],['variable']
Modifiability,"_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}\end{split}\]; The transformation ( \(U\) ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( \(h^{FW}_{\rm ++}\) ); is given by the sum; of a transformed kinetic (\(T_{\rm X2C}\)) and potential energy ( \(V_{\rm X2C}\) ) contribution.; Relativistic kinetic energy ( \(T_{\rm X2C}\) ) and nuclear-electron interaction potential ( \(V_{\rm X2C}\) ) is given in terms of non-relativisitc kinetic (\(T=\hat{p}^2/2\)) energy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. K",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:4158,coupling,coupling,4158,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,15,['coupling'],['coupling']
Modifiability,"` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only).""). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.arrays"", ""psi4.core.Wavefunction.variables"", 1.9, f"" Replace `psi4.core.Wavefunction.arrays` with `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only).""). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). core.Wavefunction.frequencies = _core_wavefunction_frequencies. def _core_doublet(A, B, transA, transB):; """"""Multiply two matrices together. .. deprecated:: 1.4; Use :py:func:`psi4.core.doublet` ins",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:48388,variab,variables,48388,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:6064,flexible,flexible,6064,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['flexible'],['flexible']
Modifiability,"`conda install cmake`); # - C++ and C compilers (C++17 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - networkx >=2.4 (runtime only; e.g., `conda install networkx`); # - pint >=0.10 (runtime only; e.g., `conda install pint -c conda-forge`); # - pydantic >=1.0 (runtime only; e.g., `conda install pydantic -c conda-forge`); # - msgpack-python (runtime only; e.g., `conda install msgpack-python`); # - Eigen (for Libint2; e.g., `conda install eigen`); # - Boost (header-only libs for Libint2; e.g., `conda install boost-cpp`); # - SciPy (runtime only; avoidable through keyword setting; e.g., `conda install scipy`); # - py-cpuinfo (runtime only; e.g., `conda install py-cpuinfo`); # - psutil (runtime only; e.g., `conda install psutil`). # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - Python_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python3.7)""; # - Python_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python3.7.so)""; # - Python_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python3.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, ecpint, libefp, Einsums, erd, gau2grid, gdma, Libint2, PCMSolver, pybind11, pylibefp,; # qcelemental, qcengine, optking, simint, Libxc; # - CMAKE_PREFIX_PATH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:16746,variab,variables,16746,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"`conda install cmake`); # - C++ and C compilers (C++17 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - networkx >=2.4 (runtime only; e.g., `conda install networkx`); # - pint >=0.10 (runtime only; e.g., `conda install pint -c conda-forge`); # - pydantic >=1.0 (runtime only; e.g., `conda install pydantic -c conda-forge`); # - msgpack-python (runtime only; e.g., `conda install msgpack-python`); # - Eigen (for Libint2; e.g., `conda install eigen`); # - Boost (header-only libs for Libint2; e.g., `conda install boost-cpp`); # - SciPy (runtime only; avoidable through keyword setting; e.g., `conda install scipy`); # - py-cpuinfo (runtime only; e.g., `conda install py-cpuinfo`); # - psutil (runtime only; e.g., `conda install psutil`). # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - Python_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python3.7)""; # - Python_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python3.7.so)""; # - Python_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python3.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, ecpint, libefp, erd, gau2grid, gdma, Libint2, PCMSolver, pybind11, pylibefp,; # qcelemental, qcengine, optking, simint, Libxc; # - CMAKE_PREFIX_PATH ""Set to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:16431,variab,variables,16431,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"`conda install cmake`); # - C++ and C compilers (C++20 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - networkx >=2.4 (runtime only; e.g., `conda install networkx`); # - pint >=0.10 (runtime only; e.g., `conda install pint -c conda-forge`); # - pydantic >=1.0 (runtime only; e.g., `conda install pydantic -c conda-forge`); # - msgpack-python (runtime only; e.g., `conda install msgpack-python`); # - Eigen (for Libint2; e.g., `conda install eigen`); # - Boost (header-only libs for Libint2; e.g., `conda install boost-cpp`); # - SciPy (runtime only; avoidable through keyword setting; e.g., `conda install scipy`); # - py-cpuinfo (runtime only; e.g., `conda install py-cpuinfo`); # - psutil (runtime only; e.g., `conda install psutil`). # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - Python_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python3.7)""; # - Python_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python3.7.so)""; # - Python_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python3.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, ecpint, libefp, Einsums, gau2grid, gdma, Libint2, PCMSolver, pybind11, pylibefp,; # qcelemental, qcengine, optking, simint, Libxc, IntegratorXX, gauxc; # - C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:16975,variab,variables,16975,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:35876,variab,variable,35876,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:34007,variab,variable,34007,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"a `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_depre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:41232,variab,variable,41232,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"a `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_dep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:39161,variab,variable,39161,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmake (psi4 cmake version info); share/doc/psi4/html/ (sphinx html documentation); share/psi4/ (text files needed by psi4); share/psi4/basis (basis sets); share/psi4/plugins (plugin template files); share/psi4/fsapt (fsapt scripts); share/psi4/samples/ (sample input files); lib/ (shared libraries and py modules for psi4 + any external proj); # ordinary; lib/psi4/ (object files); lib/psi4/driver/ (py-side, uncompiled); lib/psi4/header.py (prints file header); lib/psi4/metadata.py (psi4 version info); lib/psi4/__init__.py (module marker/loader for psi4.core); lib/psi4/core.cpython-*.so (c-side, compiled and bound by pybind11); # conda; lib/pythonX.X/site-packages/psi4/. The following environment variables point to certain places in the above; directory structure. None to few need to be set; see for details:; running compiled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in you",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:21694,plugin,plugins,21694,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,22,['plugin'],"['plugin', 'plugins']"
Modifiability,"a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmake (psi4 cmake version info); share/doc/psi4/html/ (sphinx html documentation); share/psi4/ (text files needed by psi4); share/psi4/basis (basis sets); share/psi4/plugins (plugin template files); share/psi4/fsapt (fsapt scripts); share/psi4/samples/ (sample input files); lib/ (shared libraries and py modules for psi4 + any external proj); # ordinary; lib/psi4/ (object files); lib/psi4/driver/ (py-side, uncompiled); lib/psi4/header.py (prints file header); lib/psi4/metadata.py (psi4 version info); lib/psi4/__init__.py (module marker/loader for psi4.core); lib/psi4/core.so (c-side, compiled and bound by pybind11); # conda; lib/pythonX.X/site-packages/psi4/. The following environment variables point to certain places in the above; directory structure. None to few need to be set; see for details:; running compiled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; termina",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:20750,plugin,plugins,20750,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"a installation, conda remove libint. Source. Note that PSI4 uses v1. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint/libint.h; Libint_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing share/cmake/Libint/LibintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint — CMake variable to force detecting pre-built Libint and not falling back on internal build; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint=ON. Build bundled shared library with AM=6. >>> cmake -DMAX_AM_ERI=6 -DBUILD_SHARED_LIBS=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/libint-1.html:2042,variab,variable,2042,psi4manual/1.3.2/libint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/libint-1.html,10,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:2108,plugin,plugins,2108,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,16,"['config', 'plugin']","['configure', 'plugins']"
Modifiability,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:2093,plugin,plugins,2093,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,16,"['config', 'plugin']","['configure', 'plugins']"
Modifiability,"a.u.)""] = data; adc_wfn.set_variable(f""{name} transition dipoles"", core.Matrix.from_array(data)). if ""OSCILLATOR_STRENGTH"" in properties:; if gauge == ""velocity"":; data = state.oscillator_strength_velocity.reshape(-1, 1); else:; data = state.oscillator_strength.reshape(-1, 1); computed[f""Oscillator strength ({gauge} gauge)""] = data; adc_wfn.set_variable(f""{name} oscillator strengths ({gauge_short})"",; core.Matrix.from_array(data)). if ""ROTATIONAL_STRENGTH"" in properties:; data = state.rotatory_strength.reshape(-1, 1); computed[""Rotational strength (velocity gauge)""] = data; adc_wfn.set_variable(f""{name} rotational strengths (VEL)"",; core.Matrix.from_array(data)). if ""DIPOLE"" in properties:; data = state.state_dipole_moment; computed[""State dipole moment (in a.u.)""] = data; adc_wfn.set_variable(f""{name} state dipoles"", core.Matrix.from_array(data)). core.print_out(""\nExcited state properties:\n""); n_states = adc_wfn.variable(""number of excited states""); for i in range(int(n_states)):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(computed.items()):; lines += [ind + ind + format_vector(prop, data[i])]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:120801,variab,variable,120801,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"a1', 3.99051E0); C.set_parameter('B97_os_a2', -1.70066E1); C.set_parameter('B97_os_a3', 1.07292E0); C.set_parameter('B97_os_a4', 8.88211E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -2.55352E0); C.set_parameter('B97_ss_a2', 1.18926E1); C.set_parameter('B97_ss_a3', -2.69452E1); C.set_parameter('B97_ss_a4', 1.70927E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.157706)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:46000,Parameteriz,Parameterized,46000,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,3,['Parameteriz'],['Parameterized']
Modifiability,"a2_basis'] = 'cc-pV[56]Z'; if not ('delta2_scheme' in kwargs):; kwargs['delta2_scheme'] = corl_xtpl_helgaker_2. # delta CCSDT - CCSD(T); if not ('delta3_wfn' in kwargs):; kwargs['delta3_wfn'] = 'mrccsdt'; if not ('delta3_wfn_lesser' in kwargs):; kwargs['delta3_wfn_lesser'] = 'mrccsd(t)'; if not ('delta3_basis' in kwargs):; kwargs['delta3_basis'] = 'cc-pVTZ'; if not ('delta3_scheme' in kwargs):; kwargs['delta3_scheme'] = highest_1. # delta CCSDT(Q) - CCSDT; if not ('delta4_wfn' in kwargs):; kwargs['delta4_wfn'] = 'mrccsdt(q)'; if not ('delta4_wfn_lesser' in kwargs):; kwargs['delta4_wfn_lesser'] = 'mrccsdt'; if not ('delta4_basis' in kwargs):; kwargs['delta4_basis'] = 'cc-pVDZ'; if not ('delta4_scheme' in kwargs):; kwargs['delta4_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables:; #; # .. hlist::; # :columns: 1; #; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>`; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>`; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:6586,variab,variables,6586,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,2,['variab'],['variables']
Modifiability,"a3] » ; Appendices »; Keywords by Module ». PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. General¶. ACTIVE¶. The number of active orbitals per irrep. Type: array; Default: No Default. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CORR_ANSATZ¶. The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP¶. The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN¶. The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: intege",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html:1097,coupling,coupling,1097,psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html,4,['coupling'],['coupling']
Modifiability,"a4] » ; Appendices »; Keywords by Module ». PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. General¶. ACTIVE¶. The number of active orbitals per irrep. Type: array; Default: No Default. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CORR_ANSATZ¶. The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP¶. The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN¶. The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: intege",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html:1097,coupling,coupling,1097,psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html,4,['coupling'],['coupling']
Modifiability,"a5] » ; Appendices »; Keywords by Module ». PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. General¶. ACTIVE¶. The number of active orbitals per irrep. Type: array; Default: No Default. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CORR_ANSATZ¶. The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP¶. The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN¶. The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: intege",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html:1097,coupling,coupling,1097,psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html,4,['coupling'],['coupling']
Modifiability,"aISC_EEEEEE __iter__(N5boost6python14back_referenceIRSt6vectorINS_10shared_ptrIN3psi6MatrixEEESaIS6_EEEE); | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int :; | ; | C++ signature :; | m __len__(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue}); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None :; | ; | C++ signature :; | void __setitem__(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},P7_object,P7_object); | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None :; | ; | C++ signature :; | void append(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE); | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None :; | ; | C++ signature :; | void extend(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class vector_of_doubles(Boost.Python.instance); | docstring; | ; | Method resolution order:; | vector_of_doubles; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (vector_of_doubles)arg1, (object)arg2) -> bool :; | ; | C++ signature :; | b __contains__(St6vectorIdSaIdEE {lvalue},P7_object); | ; | __delitem__(...); | __delitem__( (vector_of_doubles)arg1, (object)arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:661148,extend,extend,661148,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,"['extend', 'inherit']","['extend', 'inherited']"
Modifiability,"able = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:23506,variab,variables,23506,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"able names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic nu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:3713,Variab,VariableType,3713,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['Variab'],['VariableType']
Modifiability,"able values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | MultipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:94279,inherit,inherited,94279,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"able values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:62312,inherit,inherited,62312,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['inherit'],['inherited']
Modifiability,"able(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:33570,variab,variable,33570,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"able(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31347,variab,variable,31347,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"able; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_arra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:34662,variab,variables,34662,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"ables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:42368,variab,variable,42368,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:44437,variab,variable,44437,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; warnings.warn(; ""Using ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:21663,variab,variables,21663,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"ables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_vector(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:24940,variab,variables,24940,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variables']
Modifiability,"about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:111383,inherit,inherited,111383,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ac_traverse() call is substituted; for something like:; # Argument is the molecule object.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:21928,extend,extending,21928,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,2,['extend'],['extending']
Modifiability,"ace to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to ddx by A. Mikhalev, A. Jha, M. Nottoli and M. F. Herbst; Installation; Using dd-based continum solvation models; Solvent model and solvent cavity definition; Numerical integration and discretisation parameters; Iterative solver parameters; Further keywords for ddx; How to configure ddx for building Psi4. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/interfacing.html:2008,config,configure,2008,psi4manual/1.7.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/interfacing.html,3,['config'],['configure']
Modifiability,"ace to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to ddx by A. Mikhalev, A. Jha, M. Nottoli and M. F. Herbst; Installation; Using dd-based continum solvation models; Solvent model and solvent cavity definition; Numerical integration and discretisation parameters; Iterative solver parameters; Further keywords for ddx; How to configure ddx for building Psi4. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for bu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/interfacing.html:2017,config,configure,2017,psi4manual/master/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/master/interfacing.html,1,['config'],['configure']
Modifiability,"ace.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:24180,variab,variable,24180,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['variab'],['variable']
Modifiability,"ace.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:24087,variab,variable,24087,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,2,['variab'],['variable']
Modifiability,"ace.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:47185,variab,variable,47185,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['variab'],['variable']
Modifiability,"ace.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:24054,variab,variable,24054,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['variab'],['variable']
Modifiability,"acetylene), test case 16 from the S22 database. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Poin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:21188,plugin,plugins,21188,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['plugin'],['plugins']
Modifiability,"ach should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; -D1 [2]; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 [3]; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3ZERO2B, -D3ZERO, -D32B, -D3; -D3 [4] w/ original zero-damping w/o 3-body ATM; s-dftd3 or dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\), \(s_{r,8}\)]. -D3ZEROATM; -D3 [4] w/ original zero-damping w/ 3-body ATM; s-dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\), \(s_{r,8}\), \(s_9\)]. -D3BJ2B, -D3BJ, -D3(BJ); -D3 [5] w/ newer Becke-Johnson rational damping w/o 3-body ATM; s-dftd3 or dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3BJATM; -D3 [5] w/ newer Becke-Johnson rational damping w/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:7567,variab,variable,7567,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['variab'],['variable']
Modifiability,"activate gcc52. # (B) tell CMake to tell the compiler which GCC to use; >>> vi do-configure; GCC5=/path/to/miniconda/envs/gcc52; cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gcc-name=${GCC5}/bin/gcc"" \; -DCMAKE_CXX_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=icpc \; -DCMAKE_Fortran_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gcc or gcc-5 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:28886,config,configure,28886,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['config'],['configure']
Modifiability,"active EFP object.; C++ signature :. N5boost10shared_ptrIN3psi3efp3EFPEEE get_active_efp(). psi4.get_active_molecule()¶; Python Library Documentation: built-in function get_active_molecule in module psi4; get_active_molecule(...). get_active_molecule() -> Molecule :. Returns the currently active molecule object.; C++ signature :. N5boost10shared_ptrIN3psi8MoleculeEEE get_active_molecule(). psi4.get_array_variable()¶; Python Library Documentation: built-in function get_array_variable in module psi4; get_array_variable(...). get_array_variable( (str)arg1) -> Matrix :. Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE get_array_variable(Ss). psi4.get_array_variables()¶; Python Library Documentation: built-in function get_array_variables in module psi4; get_array_variables(...). get_array_variables() -> dict :. Returns dictionary of the PSI variables set internally by the modules or python driver.; C++ signature :. N5boost6python4dictE get_array_variables(). psi4.get_atomic_point_charges()¶; Python Library Documentation: built-in function get_atomic_point_charges in module psi4; get_atomic_point_charges(...). get_atomic_point_charges() -> Vector :. Returns the most recently computed atomic point charges, as a double * object.; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE get_atomic_point_charges(). psi4.get_efp_torque()¶; Python Library Documentation: built-in function get_efp_torque in module psi4; get_efp_torque(...). get_efp_torque() -> Matrix :. Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE get_efp_torque(). psi4.get_frequencies()¶; Python Library Documentation: built-in function get_frequencies in module psi4; get_frequencies(...). get_frequencies() -> Vector :. Returns the most recently computed frequencies, as a 3N-6 V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:25471,variab,variables,25471,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variables']
Modifiability,"active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out(""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:4945,variab,variables,4945,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,4,['variab'],['variables']
Modifiability,"active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html:4945,variab,variables,4945,psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,10,['variab'],['variables']
Modifiability,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_eri_shell(...); | ao_eri_shell( (MintsHelper)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> Matrix :; | docstring; | ; |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:76702,inherit,inherited,76702,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_f12(...); | ao_f12( (MintsHelper)arg1, (CorrelationFactor)arg2) -> Matrix :; | docstring; | ; | ao_f12_double_commutator(...);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:45502,inherit,inherited,45502,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['inherit'],['inherited']
Modifiability,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_kinetic(...); | ao_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_nabla(...); | ao_nabla( (MintsHelper)arg1) -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:41657,inherit,inherited,41657,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,ad; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:792423,variab,variable,792423,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['variab'],['variable']
Modifiability,ad; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicate,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:822772,variab,variable,822772,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['variab'],['variable']
Modifiability,"adient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28340,variab,variable,28340,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"adient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Tur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3299,variab,variables,3299,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['variab'],['variables']
Modifiability,"ads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.ins",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:9993,variab,variable,9993,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['variab'],['variable']
Modifiability,"after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:63843,config,configure,63843,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,4,['config'],['configure']
Modifiability,"agers:; Ubuntu gfortran; conda gfortran_linux-64 or gfortran_osx-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gfortran_osx-64 conda package. This provides; gfortran compilers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpenMP. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:38046,variab,variable,38046,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"agments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:52258,adapt,adapted,52258,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['adapt'],['adapted']
Modifiability,"agments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [molparse.from_arrays(geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = Molecule.contiguize_from_fragment_pattern(frag_pattern,; geom=cgeom,; elez=celez,; elem=celem,; mass=cmass); molrec = molparse.from_arrays(geom=dcont",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:55399,adapt,adapted,55399,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['adapt'],['adapted']
Modifiability,"ailable to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4169,plugin,plugin,4169,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"ails.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [""auto_fragments""]. from typing import List, Optional. from psi4 import core. [docs]def auto_fragments(; molecule: Optional[core.Molecule] = None,; seed_atoms: Optional[List[List[int]]] = None,; ) -> core.Molecule:; r""""""Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters; ----------; molecule : :ref:`molecule <op_py_molecule>`, optional; The target molecule, if not the last molecule defined.; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`. Returns; -------; :py:class:`~psi4.core.Molecule` |w--w| fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; --------; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; if molecule is None:; molecule = core.get_active_molecule(); molecule.update_geometry(); molname = molecule.name(). frag, bmol = molecule.BFS(seed_atoms=seed_atoms, return_molecule=True). bmol.set_name(molname); bmol.print_cluster(); core.print_out("""""" Exiting auto_fragments\n""""""). return bmol. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.wrapper_autofrag. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_autofrag.html:1912,variab,variable,1912,psi4manual/1.7.x/_modules/psi4/driver/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_autofrag.html,2,['variab'],['variable']
Modifiability,"ained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf3; File retention, docc, socc, and bond distances specified explicitly. mbis-2; MBIS calculation on OH- (Expanded Arrays). opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. mbis-3; MBIS calculation on OH radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fnocc4; Test FNO-DF-CCSD(T) energy. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:7507,variab,variables,7507,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"aise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93011,variab,variable,93011,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"ake it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math library (better than MKL for AMD processors); ../configure --prefix=/usr/local/psi4 --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with-opt=-O2 --with-blas=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"" --with-lapack=""-L/opt/acml5.2.0/gfortran6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:6494,config,configure,6494,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,['config'],['configure']
Modifiability,"ake it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:7474,config,configure,7474,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dkh.html:2787,variab,variable,2787,psi4manual/master/dkh.html,https://psicode.org,https://psicode.org/psi4manual/master/dkh.html,2,['variab'],['variable']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dkh-1.html:2778,variab,variable,2778,psi4manual/1.4.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dkh-1.html,4,['variab'],['variable']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dkh-1.html:2778,variab,variable,2778,psi4manual/1.5.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dkh-1.html,4,['variab'],['variable']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/dkh.html:2778,variab,variable,2778,psi4manual/1.6.x/dkh.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/dkh.html,2,['variab'],['variable']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 Dece",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dkh.html:2778,variab,variable,2778,psi4manual/1.7.x/dkh.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dkh.html,2,['variab'],['variable']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/dkh.html:2780,variab,variable,2780,psi4manual/1.8.x/dkh.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/dkh.html,2,['variab'],['variable']
Modifiability,"ake reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dkh.html:2780,variab,variable,2780,psi4manual/1.9.x/dkh.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dkh.html,2,['variab'],['variable']
Modifiability,"ake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI“¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuilt. How to configure code to use high angular momentum basis sets. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage/prefix. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:16255,config,configuration,16255,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['config'],"['configuration', 'configure']"
Modifiability,"akes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html:1488,variab,variable,1488,psi4manual/1.4.0/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html,9,['variab'],['variable']
Modifiability,"al 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]; The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7]; (1,2,3); For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless converge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:48489,flexible,flexible,48489,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['flexible'],['flexible']
Modifiability,"al and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_vector(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_ci_H0block(self: psi4.core.CIWavefunction) → None¶; docstring. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:26032,variab,variable,26032,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"al core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:246309,variab,variable,246309,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"al mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in Psi4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = energy('ccsd(t)', bsse_type = 'cp'). psi4.print_out(""\n""); psi4.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); psi4.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi_hartree2kcalmol; psi4.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the scan across the potential energy surface.; Below the molecule block, you can see the Rvals array; specified. This is a Python array holding the interatomic distances we; want to consider. In Python, arrays are surrounded by square brackets, and; elements are separated by commas.; The next lines, set basis aug-cc-pVDZ and set freeze_core True,; are familiar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:18105,variab,variable,18105,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['variab'],['variable']
Modifiability,"al or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4.; >>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. How to solve ModuleNotFoundError: No module named 'psi4'¶; You’re using PSI4 in PsiAPI mode (python input.py where; input.py contains import psi4) but the Python interpreter; can’t find the PSI4 Python module. Follow the directions at; How to configure paths for PsiAPI. How to configure paths for PsiAPI¶; If you know the location of the PSI4 executable (bin/psi4); for Psithon mode and want to know the corresponding location to add to; PYTHONPATH for PsiAPI mode, execute psi4 --psiapi. It; will return bash commands to set PATH (for correct python; interpreter) and PYTHONPATH (to find psi4 module) correctly,; after which import psi4 will work.; >>> psi4 --psiapi-path; export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". >>> python -c ""import psi4;print(psi4.__file__, psi4.__version__)"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:26780,config,configure,26780,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['config'],['configure']
Modifiability,"al to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC (CFOUR); CFOUR — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY (CFOUR); CFOUR — Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR); CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL (CFOUR); CFOUR — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:56771,coupling,coupling,56771,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,16,['coupling'],['coupling']
Modifiability,"al(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:83482,variab,variables,83482,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"al), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:4397,variab,variables,4397,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['variab'],['variables']
Modifiability,"al), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:4435,variab,variables,4435,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['variab'],['variables']
Modifiability,"al-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:34562,config,configuration,34562,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['config'],['configuration']
Modifiability,"al_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:147722,variab,variable,147722,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:53988,variab,variable,53988,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,4,['variab'],['variable']
Modifiability,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53421,variab,variable,53421,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:46888,variab,variable,46888,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:53413,variab,variable,53413,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"al_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(mono",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:134698,variab,variables,134698,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"al_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:132334,variab,variables,132334,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"al_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:250085,variab,variable,250085,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is made, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, Psi4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; Psi4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, Psi4 will complain.; >>> psi4 --new-plugin myplugin. Psi4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; Psi4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:2043,plugin,plugins,2043,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:2036,plugin,plugins,2036,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugins']
Modifiability,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:2021,plugin,plugins,2021,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugins']
Modifiability,"alization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:3387,variab,variable,3387,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,6,['variab'],['variable']
Modifiability,"alization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print('\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables)). [docs]class CoordEntry(object):; """"""Class to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:4398,variab,variable,4398,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['variab'],['variable']
Modifiability,"alization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12139,adapt,adapted,12139,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['adapt'],['adapted']
Modifiability,"alize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __array_interface__(...); | __array_interface__( (Matrix)arg1) -> dict :; | docstring; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:69925,inherit,inherited,69925,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"alize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CIVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CIVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | axpy(...); | axpy( (CIVector)arg1, (float)arg2, (CIVector)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | C++ signature :; | void axpy(N3psi5detci6CIvectE {lvalue},d,N5boost10shared_ptrIN3psi5detci6CIvectEEE,i,i); | ; | close_io_files(...); | close_io_files( (CIVector)arg1, (int)arg2) -> None :; | docstring; | ; | C++ signature :; | void close_io_files(N3psi5detci6CIvectE {lvalue},i); | ; | copy(...); | copy( (CIVector)arg1, (CIVector)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | C++ signature :",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:384494,inherit,inherited,384494,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"alize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE aotoso(N3psi10PetiteListE {lvalue}); | ; | print(...); | print( (PetiteList)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void print(N3psi10PetiteListE {lvalue},Ss); | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE sotoao(N3psi10PetiteListE {lvalue}); | ; | ---------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:577242,inherit,inherited,577242,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"alizer attribute, [1]. UHF class in psi4.core, [1]. UHF_NOONS (SCF). UNCP-CORRECTED2-BODYINTERACTIONENERGY. unit() psi4.core.SymmetryOperation method, [1], [2]. units. ; molecule. UNITS (GLOBALS). units psi4.core.Molecule attribute, [1], [2]. Unnormalized psi4.core.PrimitiveType attribute, [1], [2]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. update_geometry() psi4.core.Molecule method, [1], [2]. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. V() psi4.core.VBase method, [1], [2]. V_potential() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. Va() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VAL_EX_LEVEL (DETCI). ValidationError. value() psi4.core.SuperFunctional method, [1], [2]. variables() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Vb() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VBase class in psi4.core, [1]. vdot() psi4.core.CIVector method, [1], [2]. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core, [1]. Vector3 class in psi4.core, [1]. vector_dot() psi4.core.Matrix method, [1], [2]. vector_multiply() psi4.core.CIVector method, [1], [2]. VectorMatrix class in psi4.core, [1]. version() in module psi4.core, [1]. vibrational analysis. ; function call. output. View class in psi4.core, [1]. visualization, [1]. VMDPATH. vmfc. ; setting keywords. Vvals() psi4.core.OEProp method, [1], [2]. W. WABEI_LOWDISK (CCHBAR). Wavefunction class in psi4.core, [1]. WebMO. WFN (CCDENSITY). (CCENERGY). (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:101115,variab,variables,101115,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['variab'],['variables']
Modifiability,"alled and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:15137,config,configure,15137,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configure']
Modifiability,"alled and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.53.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.53.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:14903,config,configure,14903,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configure']
Modifiability,"allow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool :; | ; | C++ signature :; | b __contains__(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},P7_object); | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None :; | ; | C++ signature :; | void __delitem__(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},P7_object); | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object :; | ; | C++ signature :; | N5boost6python3api6objectE __getitem__(N5boost6python14back_refere",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:658979,inherit,inherited,658979,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"alpha; Extrapolated water energies. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. mints-benchmark; run some BLAS benchmarks. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. ao-dfcasscf-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:15412,variab,variables,15412,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"als are necessary for the post-scf, compute them if; only the df integrals were run previously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below:; # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, CURRENT ENERGY will be set by; energy(), etc. In future, this will be extracted from the wavefunction.; # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods¶; There are several conditions when a method and derivative combination should be managed:. when functionality overlaps between modules, a pattern is needed to; access each route through the code;; when functionality doesn’t overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; FREEZE_CORE state (AE/FC).; for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn’t; exactly match energy functional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/proc_py.html:3739,variab,variables,3739,psi4manual/1.7.x/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/proc_py.html,4,['variab'],['variables']
Modifiability,"als. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:20893,variab,variable,20893,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variable']
Modifiability,"alue for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_SCS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. IP_POLES¶. Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html:2607,extend,extended,2607,psi4manual/1.4.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html,10,['extend'],['extended']
Modifiability,"alue for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_SCS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. IP_POLES¶. Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html:2427,extend,extended,2427,psi4manual/1.7.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html,8,['extend'],['extended']
Modifiability,"ambit ""Enables the ambit tensor library"" OFF); option(ENABLE_CheMPS2 ""Enables CheMPS2 for DMRG (requires HDF5)"" OFF); option(ENABLE_cppe ""Enables CPPE for Polarizable Embedding"" OFF); option(ENABLE_adcc ""Enables adcc for algebraic-diagrammatic construction methods (requires libtensorlight; can also be added at runtime)"" OFF); option(ENABLE_ddx ""Enables ddx for domain-decomposition contiuum solvation models (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_dkh ""Enables DKH integrals (requires Fortran)"" OFF); option(ENABLE_ecpint ""Enables libecpint for effective core potentials (ECP)"" OFF); option(ENABLE_libefp ""Enables LIBEFP and PylibEFP for fragments"" OFF); option(ENABLE_erd ""Enables use of ERD instead of Libint (requires Fortran)"" OFF); option(ENABLE_simint ""Enables use of SIMINT two-electron integral library"" OFF); option(ENABLE_gdma ""Enables Stone's GDMA multipole code (requires Fortran)"" OFF); option(ENABLE_PCMSolver ""Enables PCMSolver library (requires Fortran)"" OFF); option(ENABLE_snsmp2 ""Enables SNSMP2 plugin (can also be added at runtime)"" OFF); option(ENABLE_v2rdm_casscf ""Enables V2RDM_CASSCF plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_psi4fockci ""Enables Psi4FockCI plugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:20043,plugin,plugin,20043,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,7,['plugin'],['plugin']
Modifiability,"ame + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:5078,variab,variable,5078,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,6,['variab'],['variable']
Modifiability,"ame == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:125717,variab,variable,125717,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"ame == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:125506,variab,variable,125506,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"ame ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)¶. TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)¶; The velocity-gauge oscillator strength of the transition from root m to root n,; which are in irreps h and i, respectively..; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶. CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶; The velocity-gauge oscillator strength of the transition from root m to root n,; and the transition is of irrep h.; DFT functional labeled if canonical. ADC ROOT n TOTAL ENERGY - h TRANSITION¶; The total ADC energy of root n within irrep h. This variable is only defined for Psi’s; built-in ADC and will be removed for 1.7. ADC ROOT 0 -> ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy contribution to the excitation energy from the ground state to; root n within irrep h. This variable is only defined for Psi’s built-in ADC and will be removed for 1.7. AQCC DIPOLE¶; Dipole array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,). AQCC QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:7495,variab,variable,7495,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['variab'],['variable']
Modifiability,"ame(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. ndet(self); docstring. new_civector(self, arg0, arg1, arg2, arg3); docstring. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. opdm(self, arg0, arg1, arg2, arg3); docstring. options(self); Returns the Wavefunction's options object. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. reset_ci_H0block(self); docstring. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:6787,variab,variables,6787,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variables']
Modifiability,"ame). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:86493,variab,variables,86493,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"ame,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; geom_unsettled=geom_unsettled,; variables=variables,; # processing details; speclabel=speclabel,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:3661,variab,variables,3661,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,6,['variab'],['variables']
Modifiability,"ame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer"" OFF; ""-fsanitize=thread"" ""-fno-omit-frame-pointer -pie""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer"" OFF; ""-fsanitize=undefined"" ""-fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2); option_with_default(BUILD_FPIC ""Compile static libraries with position independent code"" ON). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI“¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuilt. How to configure co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:14889,variab,variable,14889,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ame=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:3410,variab,variables,3410,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html,14,['variab'],['variables']
Modifiability,"amping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP)¶EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP)¶EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP)¶EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP)¶EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP)¶EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC)¶OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC)¶DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC)¶OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCT)¶DCT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING)¶OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM)¶CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:120695,extend,extended,120695,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['extend'],['extended']
Modifiability,"ample with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). scf-upcast-custom-basis; test scf castup with custom basis sets. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-custom; DFT custom functional test. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. soscf-large; Second-order SCF convergnece: Benzene. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:22768,variab,variables,22768,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"an be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/plugins.html:7905,plugin,plugin,7905,psi4manual/1.8.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/plugins.html,5,['plugin'],['plugin']
Modifiability,"an be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/plugins.html:7905,plugin,plugin,7905,psi4manual/1.9.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/plugins.html,5,['plugin'],['plugin']
Modifiability,"an compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to use a local Add-On repository in the Psi4 build; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_faq.html:3518,config,configure,3518,psi4manual/master/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/build_faq.html,1,['config'],['configure']
Modifiability,"an for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:297587,plugin,plugin,297587,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:3298,plugin,plugin,3298,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,12,['plugin'],"['plugin', 'plugin-name']"
Modifiability,"an; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). table of contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; E_CONVERGENCE; MAXITER; DIIS_MAX_VECS; NAT_ORBS; OCC_TOLERANCE; TRIPLES_LOW_MEMORY; CC_TIMINGS; DF_BASIS_CC; CHOLESKY_TOLERANCE; CEPA_NO_SINGLES; DIPMOM. Advanced FNOCC Keywords; SCS_MP2; MP2_SCALE_OS; MP2_SCALE_SS; SCS_CCSD; CC_SCALE_OS; CC_SCALE_SS; RUN_MP2; RUN_MP3; RUN_MP4; RUN_CCSD; RUN_CEPA; COMPUTE_TRIPLES; COMPUTE_MP4_TRIPLES; DFCC; CEPA_LEVEL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fnocc.html:19717,config,configuration,19717,psi4manual/master/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/master/fnocc.html,1,['config'],['configuration']
Modifiability,"anShell.nfunction()¶; Python Library Documentation: property. docstring. psi4.GaussianShell.nprimitive()¶; Python Library Documentation: property. docstring. psi4.GaussianShell.original_coef()¶; Python Library Documentation: method original_coef; original_coef(...) unbound psi4.GaussianShell method. original_coef( (GaussianShell)arg1, (int)arg2) -> float :. docstring; C++ signature :. d original_coef(N3psi13GaussianShellE {lvalue},i). GeometryUnits¶. psi4.GeometryUnits.Angstrom()¶; Python Library Documentation: GeometryUnits in module psi4 object; class GeometryUnits(Boost.Python.enum). docstring. Method resolution order:. GeometryUnits. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Angstrom = psi4.GeometryUnits.Angstrom. Bohr = psi4.GeometryUnits.Bohr. names = {‘Angstrom’: psi4.GeometryUnits.Angstrom, ‘Bohr’: psi4.Geometr... values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}. ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:152507,inherit,inherited,152507,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __init__( (object)arg1, (str)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,Ss); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | Returns Schoenflies symbol for point group; | ; | C++ signature :; | Ss symbol(N3psi10PointGroupE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PotentialInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | PotentialInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class canno",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:579703,inherit,inherited,579703,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"and Andrew C. Simmonett; Section author: Andrew C. Simmonett. oeprop(wfn, *args[, title])[source]¶; Evaluate one-electron properties. Returns:None. Parameters:wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters:title (string) – label prepended to all psivars computed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). Psi4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of Psi4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/oeprop-1.html:1294,variab,variables,1294,psi4manual/1.0.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/oeprop-1.html,2,['variab'],['variables']
Modifiability,"and CMake configuration files; required to build PSI4 with BrianQC. Create a build directory to keep the source tree clean. cd <brianqc_install_path>; mkdir build; cd build. Configure project and generate makefiles with CMake.; You will require Eigen (tested with version 3.1.2); and boost (tested with version 1.62). cmake .. Build the examples and samples. make. Test the installation by starting a small calculation.; Make sure to set the BRIANQC_INSTALL_PATH environment variable to <brianqc_install_path>!. export BRIANQC_INSTALL_PATH=<brianqc_install_path>; bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz. Building PSI4 with BrianQC¶; When CMake-ing PSI4, set the ENABLE_BrianQC CMake variable to 1; and set the BrianQC_DIR CMake variable to the path where BrianQC’s; components have been built (usually <brianqc_install_path>/build), then build PSI4 normally. Using BrianQC from PSI4¶; To use BrianQC, the BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; internal computation is either performed by PSI4 (if unsupported by BrianQC),; or taken over by BrianQC, yielding the same result to within the required; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computations, including Fock and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:2147,variab,variable,2147,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,9,['variab'],['variable']
Modifiability,and Thermochemical Analysis; Psithon Tutorial: Using PSI4 as an Executable; Psithon Tutorial: Using PSI4 as an Executable. /1.6.x; . /_downloads; . /bb210d30fde032b2d23ae4dcb2ad36e2; ; gdma-2.2.06.pdf. /_modules; . /psi4; . /driver; . /p4util; ; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.text; psi4.driver.p4util.util. /procrouting; ; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc; psi4.driver.procrouting.proc_util. /qcdb; ; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib. /util; ; psi4.driver.util.filesystem. psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_nbody; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.pluginutil; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.wrapper_database. /qcdb; ; qcdb.vib. /qcelemental; . /models; ; qcelemental.models.types. /molparse; ; qcelemental.molparse.from_arrays. /molutil; ; qcelemental.molutil.align. qcelemental.datum; qcelemental.exceptions; qcelemental.testing. Overview: module code. /_static; ; basic.css; cloud.base.js; cloud.css; cloud.js; doctools.js; documentation_options.js; favicon-psi4.ico; graphviz.css; jquery.cookie.js; jquery.js; language_data.js; psi4.css; pygments.css; searchtools.js; underscore.js. ADC: Ab Initio Polarization Propagator; Interface to adcc by M. F. Herbst and M. Scheurer; Test Suite. /api; ; adc; AngularMomentumInt; AOShellCombinationsIterator; array_variable; array_variables; BasisExtents; BasisFunctions; BasisSet; be_quiet; benchmark_blas1; benchmark_blas2; benchmark_blas3; benchmark_disk; benchmark_integrals; benchmark_math; BlockOPoints; BoysLocalizer; BSVec; ccdensity; ccenergy; cceom; cchbar; cclambda; ccresponse; cct,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:759118,plugin,pluginutil,759118,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['pluginutil']
Modifiability,"and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved.; CD; A threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4’s internal routines. Expert",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:22658,config,configurations,22658,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,4,['config'],['configurations']
Modifiability,"and obtain a license.; Note that there are several prerequisites for using BrianQC, including; having a supported GPU available in the computing node and having the; proper GPU drivers installed. Please refer to the BrianQC manual; for a full list of prerequisites.; When installing BrianQC, choose the SDK installation by setting the; BRIANQC_SDK_INSTALL envoronment variable to 1. Building BrianQC’s user-built components¶; After the installation, build BrianQC’s example and sample programs,; which also creates the wrapper library and CMake configuration files; required to build PSI4 with BrianQC. Create a build directory to keep the source tree clean. cd <brianqc_install_path>; mkdir build; cd build. Configure project and generate makefiles with CMake.; You will require Eigen (tested with version 3.1.2); and boost (tested with version 1.62). cmake .. Build the examples and samples. make. Test the installation by starting a small calculation.; Make sure to set the BRIANQC_INSTALL_PATH environment variable to <brianqc_install_path>!. export BRIANQC_INSTALL_PATH=<brianqc_install_path>; bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz. Building PSI4 with BrianQC¶; When CMake-ing PSI4, set the ENABLE_BrianQC CMake variable to 1; and set the BrianQC_DIR CMake variable to the path where BrianQC’s; components have been built (usually <brianqc_install_path>/build), then build PSI4 normally. Using BrianQC from PSI4¶; To use BrianQC, the BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:1616,variab,variable,1616,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,9,['variab'],['variable']
Modifiability,"and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Localizer(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __array_interface__(...); | __array_interface__( (Matrix)arg1) -> dict :; | docstring; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:69745,inherit,inherited,69745,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:64494,variab,variables,64494,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['variab'],['variables']
Modifiability,"and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:66051,variab,variables,66051,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['variab'],['variables']
Modifiability,"and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:30517,variab,variables,30517,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from conf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:3306,config,configure,3306,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,['config'],['configure']
Modifiability,"andard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below:; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:12349,variab,variable,12349,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,9,['variab'],['variable']
Modifiability,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:5670,plugin,plugin,5670,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,8,['plugin'],['plugin']
Modifiability,"andwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR); CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR); CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with CFOUR_COORDINATES =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS (CFOUR); CFOUR — Where the initial SCF eigenvectors are read from. MOREAD means to read from the disk (the JOBARC f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:49331,variab,variables,49331,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['variab'],['variables']
Modifiability,"anged! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:65505,variab,variable,65505,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"ansforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from exter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:3089,plugin,plugin,3089,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,18,['plugin'],['plugin']
Modifiability,"anslated correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Updating the PSI4 Users’ and Programmers’ Manual. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/documentation-1.html:7606,variab,variable,7606,psi4manual/1.4.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/documentation-1.html,2,['variab'],['variable']
Modifiability,"anslated correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Updating the PSI4 Users’ and Programmers’ Manual. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/documentation-1.html:7606,variab,variable,7606,psi4manual/1.5.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/documentation-1.html,2,['variab'],['variable']
Modifiability,"api(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. occupation_a(self); Returns the Alpha occupation numbers. occupation_b(self); Returns the Beta occupation numbers. onel_Hx(self, arg0); One-electron Hessian-vector products. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_energies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reference_wavefunction(self); Returns the reference wavefunction. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self); docstring. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:8855,variab,variables,8855,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['variab'],['variables']
Modifiability,"apolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Possible Values: A, AG, AU, AP, APP, A1, A2, B, BG, BU, B1, B2, B3, B1G, B2G, B3G, B1U, B2U, B3U, 0, 1, 2, 3, 4, 5, 6, 7, 8; Default: 1. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. Expert¶. PERTURB_CBS¶. Do compute the perturbative corrections for basis set incompleteness?. Type: boolean; Default: false. PERTURB_CBS_COUPLING¶. Do include the terms that couple different reference determinants in perturbative CBS correction computations?. Type: boolean; Default: true. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. table of contents. PSIMRCC; General; CC_NUM_THREADS; CORR_ANSATZ; CORR_CCSD_T; CORR_CHARGE; CORR_MULTP; CORR_WFN; COUPLING; COUPLING_TERMS; DAMPING_PERCENTAGE; DIAGONALIZE_HEFF; DIAGONAL_CCSD_T; DIIS_MAX_VECS; DIIS_START; E_CONVERGENCE; FAVG_CCSD_T; FOLLOW_ROOT; HEFF4; HEFF_PRINT; LOCK_SINGLET; MAXITER; MP2_CCSD_METHOD; MP2_GUESS; NO_SINGLES; OFFDIAGONAL_CCSD_T; PT_ENERGY; R_CONVERGENCE; SMALL_CUTOFF; TIKHONOW_MAX; TIKHONOW_OMEGA; TRIPLES_ALGORITHM; TRIPLES_DIIS; USE_SPIN_SYM; WFN_SYM; ZERO_INTERNAL_AMPS. Expert; PERTURB_CBS; PERTURB_CBS_COUPLING; TIKHONOW_TRIPLES; USE_SPIN_SYMMETRY. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__psimrcc-1.html:5124,config,configurations,5124,psi4manual/1.1.0/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__psimrcc-1.html,2,['config'],['configurations']
Modifiability,"apt_wfn. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); psi4.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:92482,variab,variables,92482,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['variab'],['variables']
Modifiability,"ar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:37218,variab,variable,37218,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"ar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:38689,variab,variable,38689,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"ar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:7819,plugin,plugin,7819,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['plugin'],['plugin']
Modifiability,"ar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:7732,plugin,plugin,7732,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"ar; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.53.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.53.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (defaul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:14347,config,config,14347,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['config']
Modifiability,"arameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. soFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; Returns the effective Fock matrix in the orthogonalized SO basis. See libscf_solver/rohf.cc::form_Cfor technical definition. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html:35273,inherit,inherited,35273,psi4manual/1.6.x/api/psi4.core.ROHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html,2,['inherit'],['inherited']
Modifiability,"arameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. soFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; Returns the effective Fock matrix in the orthogonalized SO basis. See libscf_solver/rohf.cc::form_Cfor technical definition. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:35020,inherit,inherited,35020,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,2,['inherit'],['inherited']
Modifiability,"architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever direc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:6577,config,configure,6577,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,6,['config'],"['configuration', 'configure']"
Modifiability,"are package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; """"""Module with utility classes and functions related; to data tables and text. """"""; import psi4; import sys; import re; import p4const; from psiexceptions import *. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(),; row_label_width=10,; row_label_precision=4,; cols=(),; width=16, precision=10):; self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols,); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x); return "" "".join(map(str, values)). def __getitem__(self, value):; self.labels.append(value); return self. def __setitem__(self, name, va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html:1219,flexible,flexible,1219,psi4manual/4.0b5/_modules/p4util/text.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html,2,['flexible'],['flexible']
Modifiability,"are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additional custom compiler flags for C++ source.; CMAKE_C_FLAGS — CMake variable to specify any additional custom compiler flags for C source. Examples. Build with detected compilers from PATH. >>> cmake. Build with specific (Intel) compilers from PATH. >>> cmake -DCMAKE_CXX_COMPILER=icpc -DCMAKE_C_COMPILER=icc. Build with specific (GNU) compilers not in PATH. >>> cmake -DCMAKE_CXX_COMPILER=/path/to/gcc6.2/bin/g++ -DCMAKE_C_COMPILER=/path/to/gcc6.2/bin/gcc. Build with specific (Intel) compilers from PATH based on GCC not in PATH. >>> cmake -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gcc-name=${GCC5}/bin/gcc"" \; -DCMAKE_CXX_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"". Build with specific (Intel) compilers from PATH based on GCC not in PATH and also building Fortran Add-Ons. >>> cmake -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_C_FLAGS=""-gcc-name=${GCC5}/bin/gcc"" \; -DCMAKE_CXX_FLAGS=""-gcc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:28392,variab,variable,28392,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,15,['variab'],['variable']
Modifiability,"arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None¶; docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. scf_type(self: psi4.core.HF) → str¶; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:30669,variab,variable,30669,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['variab'],['variable']
Modifiability,"arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:13444,variab,variable,13444,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,4,['variab'],['variable']
Modifiability,"arg1) -> Wavefunction :. Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE fnocc(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.get_active_efp()¶; Python Library Documentation: built-in function get_active_efp in module psi4; get_active_efp(...). get_active_efp() -> EFP :. Returns the currently active EFP object.; C++ signature :. N5boost10shared_ptrIN3psi3efp3EFPEEE get_active_efp(). psi4.get_active_molecule()¶; Python Library Documentation: built-in function get_active_molecule in module psi4; get_active_molecule(...). get_active_molecule() -> Molecule :. Returns the currently active molecule object.; C++ signature :. N5boost10shared_ptrIN3psi8MoleculeEEE get_active_molecule(). psi4.get_array_variable()¶; Python Library Documentation: built-in function get_array_variable in module psi4; get_array_variable(...). get_array_variable( (str)arg1) -> Matrix :. Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE get_array_variable(Ss). psi4.get_array_variables()¶; Python Library Documentation: built-in function get_array_variables in module psi4; get_array_variables(...). get_array_variables() -> dict :. Returns dictionary of the PSI variables set internally by the modules or python driver.; C++ signature :. N5boost6python4dictE get_array_variables(). psi4.get_atomic_point_charges()¶; Python Library Documentation: built-in function get_atomic_point_charges in module psi4; get_atomic_point_charges(...). get_atomic_point_charges() -> Vector :. Returns the most recently computed atomic point charges, as a double * object.; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE get_atomic_point_charges(). psi4.get_efp_torque()¶; Python Library Documentation: built-in function get_efp_torque in module psi4; get_efp_torque(...). get_efp_torque() -> Matrix :. Returns the most recent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:25080,variab,variables,25080,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['variab'],['variables']
Modifiability,"arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242288,config,configuration,242288,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['config'],['configuration']
Modifiability,"arg1, (int)arg2) -> int :; | docstring; | ; | shell_to_basis_function(...); | shell_to_basis_function( (BasisSet)arg1, (int)arg2) -> int :; | docstring; | ; | shell_to_center(...); | shell_to_center( (BasisSet)arg1, (int)arg2) -> int :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:8308,inherit,inherited,8308,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:2398,variab,variables,2398,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,4,['variab'],['variables']
Modifiability,"arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247168,plugin,plugin,247168,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:62132,inherit,inherited,62132,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"arg5 are required. An optional argument to force the puream setting is arg4 for orbital basis sets and arg6 for auxiliary basis sets.; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8BasisSetEEE pyconstruct_orbital(N5boost10shared_ptrIN3psi8MoleculeEEE,Ss,Ss [,i]); | ; | zero_ao_basis_set(...); | zero_ao_basis_set() -> BasisSet :; | Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0.; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8BasisSetEEE zero_ao_basis_set(); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:381710,inherit,inherited,381710,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"args)[source]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.properties-1.html:1264,config,configurational,1264,psi4manual/1.2.1/api/psi4.driver.properties-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.properties-1.html,2,['config'],['configurational']
Modifiability,"ariable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144711,variab,variables,144711,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"ariable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:131799,variab,variables,131799,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"ariable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variable(key)¶. variables()¶. class psi4.core.CUHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:34334,inherit,inherited,34334,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,ariable; psi4.core.get_variables; psi4.core.get_writer_file_prefix; psi4.core.git_version; psi4.core.has_global_option_changed; psi4.core.has_local_option_changed; psi4.core.has_option_changed; psi4.core.has_variable; psi4.core.HF; psi4.core.IDAMAX; psi4.core.initialize; psi4.core.IntegralFactory; psi4.core.IntVector; psi4.core.IO; psi4.core.IOManager; psi4.core.JK; psi4.core.KineticInt; psi4.core.LaplaceDenominator; psi4.core.legacy_wavefunction; psi4.core.libfock; psi4.core.Localizer; psi4.core.Matrix; psi4.core.MatrixFactory; psi4.core.mcscf; psi4.core.MintsHelper; psi4.core.MoldenWriter; psi4.core.Molecule; psi4.core.MOWriter; psi4.core.mrcc_generate_input; psi4.core.mrcc_load_densities; psi4.core.MultipoleInt; psi4.core.MultipoleSymmetry; psi4.core.NablaInt; psi4.core.NBOWriter; psi4.core.occ; psi4.core.OEProp; psi4.core.OneBodyAOInt; psi4.core.opt_clean; psi4.core.optking; psi4.core.OrbitalSpace; psi4.core.outfile_name; psi4.core.OverlapInt; psi4.core.PetiteList; psi4.core.plugin; psi4.core.plugin_close; psi4.core.plugin_close_all; psi4.core.plugin_load; psi4.core.PMLocalizer; psi4.core.PointGroup; psi4.core.PotentialInt; psi4.core.prepare_options_for_module; psi4.core.PrimitiveType; psi4.core.print_global_options; psi4.core.print_options; psi4.core.print_out; psi4.core.print_variables; psi4.core.Prop; psi4.core.PseudospectralInt; psi4.core.PseudoTrial; psi4.core.psi_top_srcdir; psi4.core.psimrcc; psi4.core.PsiReturnType; psi4.core.QuadrupoleInt; psi4.core.reopen_outfile; psi4.core.revoke_global_option_changed; psi4.core.revoke_local_option_changed; psi4.core.RHF; psi4.core.ROHF; psi4.core.run_gdma; psi4.core.sapt; psi4.core.scatter; psi4.core.scfgrad; psi4.core.scfhess; psi4.core.set_active_molecule; psi4.core.set_array_variable; psi4.core.set_efp_torque; psi4.core.set_environment; psi4.core.set_frequencies; psi4.core.set_global_option; psi4.core.set_global_option_python; psi4.core.set_gradient; psi4.core.set_legacy_molecule; psi4.core.set_legacy_wavefunction;,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:295095,plugin,plugin,295095,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['plugin'],['plugin']
Modifiability,"ariable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:35047,variab,variables,35047,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ariables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:35275,variab,variables,35275,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"ariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (str) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25339,variab,variable,25339,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict[str, Dict[str, Any]]:; """"""Serialize a Wavefunction object. Opposite of; :meth:`~psi4.core.Wavefunction.from_file`. Parameters; ----------; wfn; Wavefunction or inherited class instance.; filename; An optional filename to which to write the data. Returns; -------; ~typing.Dict[str, ~typing.Dict[str, ~typing.Any]]; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if wfn.lagrangian() else None,; 'aotoso': wfn.aotoso().to_array() if wfn.aotoso() else None,; 'gradient': wfn.gradient().to_array() if wfn.gradient() else None,; 'hessian': wfn.hessian().to_array() if wfn.hessian() else None; },; 'vector': {; 'epsilon_a': wfn.epsilon_a().to_array() if wfn.epsilon_a() else N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:11009,variab,variables,11009,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variables']
Modifiability,"art of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.PsiReturnType.EndLoop()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:279669,inherit,inherited,279669,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"art of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.PsiReturnType.Failure()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:283196,inherit,inherited,283196,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"art of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.PsiReturnType.Success()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:286723,inherit,inherited,286723,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"art of the; dictionary for each participating reaction, along with *dbse* and *rxn* keys; in argument *data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1); posnS = []; for weft in range(Nweft):; posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); posnT = []; for weft in range(Nweft - 1):; posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); posnM = []. # initialize plot; fht = Nweft * 0.8; #fig, ax = plt.subplots(figsize=(12, fht)); fig, ax = plt.subplots(figsize=(11, fht)); plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:17587,extend,extend,17587,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"arties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ]. import math; import os; import re; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np; import qcelemental as qcel. from psi4 import core, extras. from .. import qcdb; from . import optproc; from .exceptions import TestComparisonError, UpgradeHelper, ValidationError. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional[Union[str, Callable]] = None,; puream: int = -1,; return_atomlist: bool = False,; *,; quiet: bool",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/python_helpers.html:1259,variab,variable-related,1259,psi4manual/master/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable-related']
Modifiability,"ary to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:5038,plugin,plugin,5038,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=Future",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:34511,variab,variables,34511,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"ary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, doubles are required for; RHF-MP2, and doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. Conventional MP2¶; Module: Keywords, PSI Variables, MP2; PSI4 also has a non-density-fitted MP2 algorithm for RHF, UHF, and; ROHF energies and RHF gradients. This code is not highly optimized, so the; density-fitted module DFMP2 is always the default. To access the; conventional MP2 code, set MP2_TYPE to conv and call; energy('mp2')/optimize('mp2'). MP2_TYPE¶. What algorithm to use for the MP2 computation. Type: strin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dfmp2-1.html:7026,variab,variable,7026,psi4manual/4.0b3/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dfmp2-1.html,2,['variab'],['variable']
Modifiability,"ary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, doubles are required for; RHF-MP2, and doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. Table Of Contents. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Previous topic; DCFT: Density Cumulant Functional Theory; Next topic; CC: Coupled Cluster Methods. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:7141,variab,variable,7141,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,2,['variab'],['variable']
Modifiability,"ary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, doubles are required for; RHF-MP2, and doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. Table Of Contents. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Previous topic; DCFT: Density Cumulant Functional Theory; Next topic; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . ne",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dfmp2-1.html:7026,variab,variable,7026,psi4manual/4.0b4/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dfmp2-1.html,4,['variab'],['variable']
Modifiability,"ary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, doubles are required for; RHF-MP2, and doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. Table Of Contents. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Previous topic; Density Functional Theory; Next topic; Ab Initio Polarization Propagator; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyrigh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html:6985,variab,variable,6985,psi4manual/4.0b2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html,2,['variab'],['variable']
Modifiability,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:4764,variab,variable,4764,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,16,['variab'],"['variable', 'variables']"
Modifiability,"as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; erd can be obtained through conda install erd.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code.; To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Navigation. Index. modules    .    .    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/erd-1.html:1986,variab,variable,1986,psi4manual/1.1.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/erd-1.html,4,['variab'],['variable']
Modifiability,"as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). The conda package is compiled to least-common-denominator, namely SSE instruction set. If using the PSI4 binary, simint has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; simint can be obtained through conda install simint -c psi4.; Then enable it as a feature with ENABLE_simint,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect simint and activate dependent code. Previous bullet had details. To build PSI4 from source and use; simint from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/simint-1.html:1799,config,configure,1799,psi4manual/1.2.1/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/simint-1.html,4,['config'],['configure']
Modifiability,as an Executable. /_downloads; . /bb210d30fde032b2d23ae4dcb2ad36e2; ; gdma-2.2.06.pdf. /_modules; . /psi4; . /driver; . /p4util; ; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util. /procrouting; ; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc. /qcdb; ; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib. psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.pluginutil; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database. psi4.extras. /qcdb; ; qcdb.vib. /qcelemental; ; qcelemental.testing. Overview: module code. /_static; . autodoc_pydantic-1.css. autodoc_pydantic-1.css; autodoc_pydantic.css. autodoc_pydantic.css; basic.css; cloud.base.js; cloud.css; cloud.js; doctools.js; documentation_options.js; documentation_options-1.js; favicon-psi4.ico; graphviz.css; jquery.cookie.js; language_data.js; nbsphinx-code-cells.css; psi4.css; pygments.css; searchtools.js; sphinx_highlight.js. ADC: Ab Initio Polarization Propagator; Interface to adcc by M. F. Herbst and M. Scheurer; Test Suite. /api; ; AngularMomentumInt; AOShellCombinationsIterator; array_variable; array_variables; BasisExtents; BasisFunctions; BasisSet; be_quiet; benchmark_blas1; benchmark_blas2; benchmark_blas3; benchmark_disk; benchmark_integrals; benchmark_math; BlockOPoints; BoysLocalizer; BSVec; ccdensity; ccenergy; cc,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:849211,plugin,pluginutil,849211,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['pluginutil']
Modifiability,"as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html:2602,variab,variables,2602,psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,11,['variab'],['variables']
Modifiability,"as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2656,variab,variables,2656,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,6,['variab'],['variables']
Modifiability,"as_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:7782,plugin,plugins,7782,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['plugin'],['plugins']
Modifiability,"as_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:7695,plugin,plugins,7695,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['plugin'],['plugins']
Modifiability,"ase class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:26300,variab,variable,26300,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:4499,plugin,plugin,4499,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['plugin'],['plugin']
Modifiability,"asis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for props and freqs; if ptype in [""properties"", ""frequency""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:66904,variab,variables,66904,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['variab'],['variables']
Modifiability,"ass CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE matrix(N3psi10CdSalcListE {lvalue}); | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi10CdSalcListE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,j); | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_params(N3psi17CorrelationFactorE {lvalue},N5boos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:417102,inherit,inherited,417102,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_dipole=False, use_c1=True, **kwargs) # C1 certified. psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). dfmp2_wfn = psi4.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('SCS-MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = psi4.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return dfmp2_wfn. [docs]def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). psi4.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; psi4.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = psi4.get_global_option('avg_states'); nroots = psi4.get_global_option('num_roots'); if len(states) != nroots:; states = range(1, nroots + 1). # Run OEProp; oe = psi4.OEProp(ciwfn); oe.set_title(name.upper()); for prop",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:64435,config,configuration,64435,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['config'],['configuration']
Modifiability,"ass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2539,variab,variables,2539,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['variab'],['variables']
Modifiability,"at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. Previous bullet had details. To build PSI4 from source and use; Libxc from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libxc-1.html:1731,variab,variable,1731,psi4manual/1.2.1/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libxc-1.html,4,['variab'],['variable']
Modifiability,"at files in psi4/samples; PSI Variables: variables and associated modules extracted from code and comments in the Python and C++ source; * Modules scraped are the sections of psi4/psi4/src/read_options.cc; * Variables should be all-caps, except where representing substitutions, e.g., ROOT n -> ROOT m and double-quote "" delimited, even in Python; * Scraper looks for Process::environment.globals, set_array_variable, variables_, etc. lines and comments in the C++ code; * C-side, the module for the variable is determined by the directory where it’s found.; * Scraper looks for set_variable together with # P::e MODULE lines and comments in the Python code; * Py-side, the module for the variable is specified by MODULE in the comment; * When a variable is set by code in either language, e.g., variables_[varname.str()] rather than plain string, variables_[""FCI TOTAL ENERGY""], add a plain string line as a single-line comment, so the scraper can find it.; * Add new places to scrape for variables to psi4/doc/sphinxman/document_psivariables.pl; * For now, we’re scraping both global and Wfn variables; * All of these show up in referenceable appendices like apdx:detci_psivar; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/psi4/include/psi4/psifiles.h. Some documentation is even extracted from PSI4 objects at runtime. psi4: docstrings for the C++ submodule psi4.core and the Python submodule psi4.driver that comprise PSI4. C++ docstrings from “core” and “export” files in psi4/psi4/src/, and Py docstrings from psi4/psi4/driver/.; DFT: functional availability and characteristics as encoded in psi4/psi4/driver/procrouting/dft; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/psi4/driver/qcdb/basislistdunning.py and psi4/psi4/driver/qcdb/basislistother.py. Building all the documentation takes ~10 minutes. There is now good; dependency struc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/documentation-1.html:3510,variab,variables,3510,psi4manual/1.4.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/documentation-1.html,9,['variab'],['variables']
Modifiability,"at indicated; in the input file (see memory setting).; Then, we move to the working directory using PBS variable $PBS_O_WORKDIR and; we create scratch directories on every node, using the $PBS_NODEFILE which; points to a file containing a list of the nodes attributed to the job.; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. The next section is very important as it sets the environment variables needed; by PSI4:; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}. PSIDATADIR does not need to be set.; In the present example we unset it to make sure it does not interfere with the internal location-finding.; PSIPATH is needed only if you are using external modules or; plugins in PSI4 and should point to the directories where they can be found. In the; present example, we make sure the variable is set with if ! ( $?PSIPATH ) setenv PSIPATH """"; before adding more paths to it. Finally, PSI_SCRATCH should point to a fast, existing; local disk for temporary file storage. To use 4 threads for OpenMP parallelization; and threaded BLAS (see section Threading), we set -n4 below.; The next step is then to actually run the computation:; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:16760,plugin,plugins,16760,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['plugin'],['plugins']
Modifiability,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:7182,plugin,plugin,7182,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,8,['plugin'],['plugin']
Modifiability,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/plugins-1.html:7121,plugin,plugin,7121,psi4manual/1.3.2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/plugins-1.html,22,['plugin'],['plugin']
Modifiability,"at)arg2) -> Vector :; | Prints the rotational constants of the molecule; | ; | C++ signature :; | N3psi6VectorE rotational_constants(N3psi8MoleculeE {lvalue},d); | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in; | :envvar:`PATH` or :envvar:`PSIPATH`.; | *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; | (works b/c psi4.Molecule has been extended by this method py-side and; | only public interface fns used) or a string that can be instantiated; | into a qcdb.Molecule.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | C++ signature :; | Ss save_string_xyz(N3psi8MoleculeE {lvalue}); | ; | save_string_xyz_file(...); | save_string_xyz_file( (Molecule)arg1) -> str :; | Saves an XYZ file to arg2; | ; | C++ signature :; | Ss save_string_xyz_file(N3psi8MoleculeE {lvalue}); | ; | save_xyz_file(...); | save_xyz_file( (Molecule)arg1, (str)arg2, (bool)arg3) -> None :; | Saves an XYZ file to arg2; | ; | C++ signature :; | void save_xyz_file(N3psi8MoleculeE {lvalue},Ss,b); | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | C++ signature :; | Ss schoenflies_symbol(N3psi8MoleculeE {lvalue}); | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | C++ signature",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:553324,extend,extended,553324,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['extend'],['extended']
Modifiability,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:6920,inherit,inherited,6920,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:6778,inherit,inherited,6778,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"atch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:8596,variab,variable,8596,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"ated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:14622,variab,variable,14622,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,6,"['config', 'variab']","['configure', 'variable']"
Modifiability,"ated using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:3191,plugin,plugin-name,3191,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,9,['plugin'],['plugin-name']
Modifiability,"ated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(). © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gdma-1.html:6348,config,configdir,6348,psi4manual/1.4.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gdma-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"ated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(). © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/gdma-1.html:6348,config,configdir,6348,psi4manual/1.5.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/gdma-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"ation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4636,plugin,plugin,4636,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"ation within CMAKE_INSTALL_PREFIX to which executables are installed (default: bin)""; # - CMAKE_INSTALL_LIBDIR ""Location within CMAKE_INSTALL_PREFIX to which libraries are installed (default: lib)""; # - CMAKE_INSTALL_DATADIR ""Location within CMAKE_INSTALL_PREFIX to which resources are installed (default: share)""; # - CMAKE_INSTALL_INCLUDEDIR ""Location within CMAKE_INSTALL_PREFIX to which headers are installed (default: include)""; # - PYMOD_INSTALL_LIBDIR ""Location within CMAKE_INSTALL_LIBDIR to which python modules are installed (default: /); # Must start with /"". ############################ Options: Build What? ############################; option(ENABLE_ambit ""Enables the ambit tensor library"" OFF); option(ENABLE_CheMPS2 ""Enables CheMPS2 for DMRG (requires HDF5)"" OFF); option(ENABLE_dkh ""Enables DKH integrals (requires Fortran)"" OFF); option(ENABLE_libefp ""Enables LIBEFP for fragments"" OFF); option(ENABLE_erd ""Enables use of ERD instead of Libint (requires Fortran)"" OFF); option(ENABLE_simint ""Enables use of SIMINT two-electron integral library"" OFF); option(ENABLE_gdma ""Enables Stone's GDMA multipole code (requires Fortran)"" OFF); option(ENABLE_PCMSolver ""Enables PCMSolver library (requires Fortran)"" OFF); # These options are relevant to pasture; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(). if(ENABLE_erd); message(WARNING ""ERD will build, link, and run in Psi4 just fine. However, it has not been hooked into Psi4 in all roles, notably gradients, LRC DFT energies, and ESP. So upon activati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:11964,plugin,plugin,11964,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['plugin'],['plugin']
Modifiability,"ation within CMAKE_INSTALL_PREFIX to which resources are installed (default: share)""; # - CMAKE_INSTALL_INCLUDEDIR ""Location within CMAKE_INSTALL_PREFIX to which headers are installed (default: include)""; # - PYMOD_INSTALL_LIBDIR ""Location within CMAKE_INSTALL_LIBDIR to which python modules are installed (default: /); # Must start with: / . Used to imitate python install: /python3.6/site-packages ."". ############################ Options: Build What? ############################; option(ENABLE_ambit ""Enables the ambit tensor library"" OFF); option(ENABLE_CheMPS2 ""Enables CheMPS2 for DMRG (requires HDF5)"" OFF); option(ENABLE_dkh ""Enables DKH integrals (requires Fortran)"" OFF); option(ENABLE_libefp ""Enables LIBEFP for fragments"" OFF); option(ENABLE_erd ""Enables use of ERD instead of Libint (requires Fortran)"" OFF); option(ENABLE_simint ""Enables use of SIMINT two-electron integral library"" OFF); option(ENABLE_gdma ""Enables Stone's GDMA multipole code (requires Fortran)"" OFF); option(ENABLE_PCMSolver ""Enables PCMSolver library (requires Fortran)"" OFF); option(ENABLE_snsmp2 ""Enables SNSMP2 plugin (can also be added at runtime)"" OFF); option(ENABLE_v2rdm_casscf ""Enables V2RDM_CASSCF plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(). if(ENABLE_erd); message(FATAL_ERR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:13404,plugin,plugin,13404,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,10,['plugin'],['plugin']
Modifiability,"ation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Installation and Runtime Configuration. Conda Binary Distribution¶; PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) architectures; through Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page; (pre-release downloads page).; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of . How to install a Psi4 binary with the Psi4conda installer, download site¶; Download one of the nine installers (Linux/Mac/Windows; Py27/35/36).; bash it. Follow the prompts and do make the adjustments to; PATH and PSI_SCRATCH that it suggests at the end. Test; with psi4 --test. Done. Explicit commands at How to install a Psi4 binary with the Psi4conda installer, command-line. How to install a Psi4 binary ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:1009,plugin,plugins,1009,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,2,['plugin'],['plugins']
Modifiability,"ation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Installation and Runtime Configuration ». Binary Distribution¶; Psi4 is available as a pre-compiled binary for Linux and Mac architectures; through Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight python; distribution with same package manger conda). Some nice features for us:. cross-platform (Linux only at present); no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o Psi4; ~1 GB including Psi4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop Psi4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The Psi4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to Psi4conda Installer; or the psicode downloads page.; Users proficient with conda may prefer to consult Conda Proficients.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of Psi4. Psi4conda Installer¶; Sequence of commands to get you to a working Psi4 on Linux; or Mac. Installs Miniconda+Psi4 into $HOME/psi4conda and; the Psi4 executable into the main conda environment at; $HOME/psi4conda/bin/psi4.; # Linux; >>> curl -o ""http://www.psicode.org/downloads/Psi4conda2-latest-Linux.sh"" --keepalive-time 2; >>> bash; >>> bash Psi4conda-latest-Linux.sh -b -p $HOME/psi4conda # agrees to license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bashrc; # log out, log back in so conda and psi4 in path; >>> psi4 ""$(d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/conda-1.html:1031,plugin,plugins,1031,psi4manual/1.0.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/conda-1.html,2,['plugin'],['plugins']
Modifiability,"ation; Initial Guess/Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/methods-1.html:1666,config,configuration,1666,psi4manual/1.0.0/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/methods-1.html,2,['config'],['configuration']
Modifiability,"ationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components by v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:167220,variab,variables,167220,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"ations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive ; cumulant updates. As a result, for small closed-shell systems the two-step; algorithm is usually preferred, while for larger systems and molecules with; open-shell character it is recommended to use the simultaneous algorithm.; Efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; and computing the terms that involve these integrals in the AO; basis. In or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:9792,coupling,coupling,9792,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['coupling'],['coupling']
Modifiability,"ations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below \(10^{-7}\). The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive \({\cal O}(N^5)\) integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive \({\cal O}(N^6)\); cumulant updates. As a result, for small closed-shell systems the two-step; algorithm is usually preferred, while for larger systems and molecules with; open-shell character it is recommended to use the simultaneous algorithm.; Efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; \((vv|vv)\) and computing the t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:10687,coupling,coupling,10687,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,15,['coupling'],['coupling']
Modifiability,"ations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints-helper; A general test of the MintsHelper function. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. cbs-parser; mtd/basis syntax examples. dft-reference; MP2 with a PBE0 reference computation. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:20998,variab,variables,20998,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"ations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:35042,variab,variables,35042,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str; Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True); Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json'); Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12); Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None; Translates molecule by arg2. units(self: psi4.core.Molecule) → str; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float; x position of atom. y(self: psi4.core.Molecule, arg0: int) → float; y position of atom. z(self: psi4.core.Molecule, arg0: int) → float; z position of atom. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:56365,variab,variable,56365,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['variab'],['variable']
Modifiability,"atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. Hirshfeld volume ratios; MBIS_VOLUME_RATIOS; Generate the AIM to free atom volume ratios. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in properties() function, e.g.:; properties('ccsd', properties=['dipole']). The properties() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of properties() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/oeprop.html:2703,variab,variables,2703,psi4manual/1.9.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/oeprop.html,2,['variab'],['variables']
Modifiability,"atrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:9798,variab,variable,9798,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,6,['variab'],['variable']
Modifiability,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_deta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:1723,inherit,inherited,1723,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:1658,inherit,inherited,1658,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:1723,inherit,inherited,1723,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"atural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. set_array(self, arg0, arg1); Returns the requested internal array. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(self, arg0); Sets the frequencies of the Hessian. set_gradient(self, arg0); Sets the Wavefunctions gradient. set_hessian(self, arg0); Sets the Wavefunctions Hessian. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_variable(self, arg0, arg1); Sets the requested internal variable. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. variables(self); Returns the map of all internal variables. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:4658,variab,variable,4658,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serial",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:145790,variab,variable,145790,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,6,['variab'],"['variable', 'variables']"
Modifiability,"au2grid and activate dependent code. Previous bullet had details. To build PSI4 from source and use; gau2grid from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gau2grid-1.html:1974,variab,variable,1974,psi4manual/1.2.1/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gau2grid-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ault: REMOVE. BORDER_N_REDIST¶. number of neighbor sites to redistribute to. The default (-1) redistributes to all sites which are not in the border region. Type: integer; Default: -1. BORDER_REDIST_ORDER¶. order from which moments are removed, e.g., if set to 1 (default), only charges are redistributed and all higher order moments are removed. Type: integer; Default: 1. BORDER_RMIN¶. minimum radius from QM atoms to MM sites to be taken into account for removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT¶. unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_REDIST_POL¶. redistribute polarizabilities? If false, polarizabilities are removed (default). Type: boolean; Default: false. How to configure CPPE for building Psi4¶; Role and Dependencies. Role — In PSI4, CPPE is a library that provides additional; quantum chemical capabilities (explicit solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) CPPE; Upstream Dependencies — CPPE. CMake Variables. ENABLE_cppe — CMake variable toggling whether Psi4 builds with CPPE; cppe_DIR — CMake variable to specify where pre-built CPPE can be found. Set to installation directory containing share/cmake/cppe/cppeConfig.cmake. Examples. Build bundled. >>> cmake -DENABLE_cppe=ON. Build without CPPE. >>> cmake. table of contents. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; PE; POTFILE; ISOTROPIC_POL; INDUCED_CONVERGENCE; MAXITER; BORDER; BORDER_TYPE; BORDER_N_REDIST; BORDER_REDIST_ORDER; BORDER_RMIN; BORDER_RMIN_UNIT; BORDER_REDIST_POL. How to configure CPPE for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to CPPE by M. Scheurer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cppe.html:4716,variab,variable,4716,psi4manual/1.8.x/cppe.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cppe.html,3,"['config', 'variab']","['configure', 'variable']"
Modifiability,"ault: REMOVE. BORDER_N_REDIST¶. number of neighbor sites to redistribute to. The default (-1) redistributes to all sites which are not in the border region. Type: integer; Default: -1. BORDER_REDIST_ORDER¶. order from which moments are removed, e.g., if set to 1 (default), only charges are redistributed and all higher order moments are removed. Type: integer; Default: 1. BORDER_RMIN¶. minimum radius from QM atoms to MM sites to be taken into account for removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT¶. unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_REDIST_POL¶. redistribute polarizabilities? If false, polarizabilities are removed (default). Type: boolean; Default: false. How to configure CPPE for building Psi4¶; Role and Dependencies. Role — In PSI4, CPPE is a library that provides additional; quantum chemical capabilities (explicit solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) CPPE; Upstream Dependencies — CPPE. CMake Variables. ENABLE_cppe — CMake variable toggling whether Psi4 builds with CPPE; cppe_DIR — CMake variable to specify where pre-built CPPE can be found. Set to installation directory containing share/cmake/cppe/cppeConfig.cmake. Examples. Build bundled. >>> cmake -DENABLE_cppe=ON. Build without CPPE. >>> cmake. table of contents. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; PE; POTFILE; ISOTROPIC_POL; INDUCED_CONVERGENCE; MAXITER; BORDER; BORDER_TYPE; BORDER_N_REDIST; BORDER_REDIST_ORDER; BORDER_RMIN; BORDER_RMIN_UNIT; BORDER_REDIST_POL. How to configure CPPE for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to CPPE by M. Scheurer. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/cppe.html:4716,variab,variable,4716,psi4manual/1.9.x/cppe.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/cppe.html,3,"['config', 'variab']","['configure', 'variable']"
Modifiability,"ault: input.dat. -l <name>, --psidatadir <name>¶; Mainly for use by developers, this overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (psi4/share). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename (subtracting; any ”.in” or ”.dat” suffix) plus ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to Psi4 for available templates. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; >>> psi4 --version; 0.4.262. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence Psi4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:14960,plugin,plugin,14960,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['plugin'],['plugin']
Modifiability,"ause the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:3944,config,configure,3944,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configure']
Modifiability,"aussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (defaul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:14581,config,config,14581,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['config']
Modifiability,"author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples. Installation¶; Binary. gCP is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, gCP has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp. To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:1228,variab,variables,1228,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,2,['variab'],['variables']
Modifiability,"avefunction object. Return type:Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key). gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool; Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool; Is the double QC variable (case-insensitive) set?. has_variable(key). hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunction’s Hessian. legacy_frequencies(). mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule; Returns the Wavefunction’s molecule. nalpha(self: psi4.core.Wavefunction) → int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:23251,variab,variable,23251,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"avefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:84370,inherit,inherited,84370,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"avefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Fock Matrix. Fb(self:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:12127,variab,variables,12127,psi4manual/1.1.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html,1,['variab'],['variables']
Modifiability,"avefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:144538,variab,variables,144538,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"avefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233505,plugin,plugins,233505,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['plugin'],['plugins']
Modifiability,"avefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from HF:; | ; | occupation_a(...); | occupation_a( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_a(N3psi3scf2HFE {lvalue}); | ; | occupation_b(...); | occupation_b( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_b(N3psi3scf2HFE {lvalue}); | ; | semicanonicalize(...); | semicanonicalize( (HF)arg1) -> None :; | docstring; | ; | C++ signature :; | void semicanonicalize(N3psi3scf2HFE {lvalue}); | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca(N3psi12WavefunctionE {lvalue}); | ; | Ca_subset(...); | Ca_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca_subset(N3psi12WavefunctionE {lvalue},Ss,Ss); | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Cb(N3psi12WavefunctionE {lvalue}); | ; | Cb_subset(...); | Cb_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Cb_subset(N3psi12WavefunctionE {lvalue},Ss,Ss); | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Da(N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:405586,inherit,inherited,405586,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"avelength, (x) rounded to nearest integer. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:8298,config,configuration,8298,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"avigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__dfocc.html:1867,Variab,Variables,1867,psi4manual/1.6.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__dfocc.html,1,['Variab'],['Variables']
Modifiability,"ay(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_array` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only).""). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.arrays"", ""psi4.core.Wavefunction.variables"", 1.9, f"" Replace `psi4.core.Wavefunction.arrays` with `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only).""). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:48068,variab,variables,48068,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ay, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict[str, Dict[str, Any]]:; """"""Serialize a Wavefunction object. Opposite of; :meth:`~psi4.core.Wavefunction.from_file`. Parameters; ----------; wfn; Wavefunction or inherited class instance.; filename; An optional filename to which to write the data. Returns; -------; ~typing.Dict[str, ~typing.Dict[str, ~typing.Any]]; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:10761,inherit,inherited,10761,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['inherit'],['inherited']
Modifiability,"b = dimer_wfn.basisset().n_ecp_core(); share_df_ints = ((sapt_basis == 'dimer') and (ri == 'DF') and not (necp_ab and (os.name == 'nt'))); if (sapt_basis == 'dimer') and (ri == 'DF') and not share_df_ints:; core.print_out(f""\n Turning off SAPT DF integrals sharing because of ECP: {necp_ab}\n\n""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if share_df_ints:; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); # core.set_local_option('SAPT', 'CPHF_R_CONVERGENCE', 10e-10); if name in ['sapt0',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html:149309,variab,variable,149309,psi4manual/master/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"b = dimer_wfn.basisset().n_ecp_core(); share_df_ints = ((sapt_basis == 'dimer') and (ri == 'DF') and not (necp_ab and (os.name == 'nt'))); if (sapt_basis == 'dimer') and (ri == 'DF') and not share_df_ints:; core.print_out(f""\n Turning off SAPT DF integrals sharing because of ECP: {necp_ab}\n\n""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if share_df_ints:; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:149302,variab,variable,149302,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"b. Some of these libraries may not be found correctly. How to set up the scratch directory¶; The scratch directory is where Psi4 stores potentially large files during; computation. It should thus be on a local, fast disk to minimize any; computational inefficiencies caused by I/O. The scratch directory is; commonly set up through the PSI_SCRATCH environment variable:; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. See also the more general scratch documentation. How do I retain specific Psi4 scratch files¶; You can set up a specific path for PSI4 scratch file and keep them; for later use through the psi4_io handler. How to use Psi4 within a PBS queue¶; You will usually need to set up a PBS job script that is setting all; necessary environment variables, making sure the scratch directories are; set up, and invokes the executable. An example PBS script; is provided in the manual, but make sure to also consult your own PBS; documentation for appropriate setup. How to update and rebuild Psi4¶; Obtain code updates as appropriate from Binary Installer,; Clone from GitHub Repository, or Fork from GitHub Repository. Move into; objdir and reissue make, whereupon CMake may reconfigure but; will only rebuild objects and libraries depending on changed files. It is; scarcely ever necessary for the user to reinvoke cmake to update; objdir. How to run a minute’s worth of tests¶; When you want to do a very minimal test of the build and have; CTest installed, the following command can be useful.; 1>>> ctest -L smoke -j`getconf _NPROCESSORS_ONLN`. If you have pytest installed, very similar coverage is obtained through:; 1>>> make pytest. How to run a subset of tests¶; CTest allows flexibly partitioned running of the test",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:44819,variab,variables,44819,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,6,['variab'],['variables']
Modifiability,"b.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.interface_dftd3.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. table of contents. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:8599,extend,extended,8599,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,2,['extend'],['extended']
Modifiability,"bal_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components by v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:167048,variab,variable,167048,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"bals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optionshandling-1.html:988,plugin,plugins,988,psi4manual/1.2.1/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optionshandling-1.html,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"base.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise Validat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:10768,Config,Configuration,10768,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Config'],['Configuration']
Modifiability,"basis sets, returns strings from which auxiliary; basis sets and heavy-aug can be constructed. Note that; valence/core-valence/etc. is conserved and X-zeta/(X+d)zeta is; not, since this is the usual aux basis pattern.; augbasis is round up to the nearest aug-cc-pVXZ; rootbasis is round down to the nearest cc-pVXZ; auxbasis is round up to the nearest cc-pVXZ or aug-cc-pVXZ. Module with non-generic exceptions classes. exception BasisSetFileNotFound(msg)[source]¶. exception BasisSetNotDefined(msg)[source]¶. exception BasisSetNotFound(msg, silent=False)[source]¶. exception Dftd3Error(msg)[source]¶. exception FeatureNotImplemented(msg)[source]¶; Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. exception FragmentCountError(msg)[source]¶; Error called molecule has wrong number of fragments for method.; Prints error message msg to standard output stream. exception IncompleteAtomError(msg)[source]¶; Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception ParsingValidationError(msg)[source]¶; Error called for problems with syntax from a QC output file. Prints; error message msg to standard output stream. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Infile(mem, mol, mtd, der, opt)[source]¶. format_infile_string()[source]¶. harvest_output(outtext)[source]¶; Function to separate portions of a Psi4 output file outtext. muster_basis(bas)[source]¶; Transform input mem in MB into psi4-type options. muster_cdsgroup_options()[source]¶. muster_memory(mem)[source]¶; Transform input mem in MB into psi4-type options. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:56522,variab,variables,56522,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"basisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:69989,inherit,inherited,69989,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; # all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC bi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:1779,variab,variables,1779,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['variab'],['variables']
Modifiability,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PotentialInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | PotentialInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:108845,inherit,inherited,108845,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:59658,inherit,inherited,59658,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"be obtained through conda install dftd3 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the dftd3 executable can be obtained through conda install dftd3 -c psi4. To remove a conda installation, conda remove dftd3. Source. If using PSI4 built from source and you want to build DFTD3 from; from source also,; follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:1568,variab,variables,1568,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,4,['variab'],['variables']
Modifiability,"be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:19477,variab,variable,19477,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['variab'],['variable']
Modifiability,"bedding_charges'] = driver_nbody_helper.compute_charges(kwargs['charge_method'],; kwargs.get('charge_type', 'MULLIKEN_CHARGES').upper(), molecule); for count, n in enumerate(compute_list.keys()):; core.print_out(""\n ==> N-Body: Now computing %d-body complexes <==\n\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; core.print_out(; ""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); current_mol.set_name(""%s_%i_%i"" % (current_mol.name(), count, num)); if metadata['embedding_charges']: driver_nbody_helper.electrostatic_embedding(metadata, pair=pair); # Save energies info; ptype_dict[pair], wfn = func(method_string, molecule=current_mol, return_wfn=True, **kwargs); core.set_global_option_python('EXTERN', None); energies_dict[pair] = core.variable(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure whic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:16910,variab,variable,16910,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,5,['variab'],['variable']
Modifiability,"bel); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; St",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:11669,adapt,adapted,11669,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"ber of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:6334,variab,variable,6334,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,12,['variab'],['variable']
Modifiability,"ber of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:6163,variab,variable,6163,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"ber of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:6082,variab,variable,6082,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/adcc.html:2430,config,configure,2430,psi4manual/master/adcc.html,https://psicode.org,https://psicode.org/psi4manual/master/adcc.html,1,['config'],['configure']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adcc-1.html:2421,config,configure,2421,psi4manual/1.4.0/adcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adcc-1.html,2,['config'],['configure']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/adcc-1.html:2421,config,configure,2421,psi4manual/1.5.0/adcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/adcc-1.html,2,['config'],['configure']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/adcc.html:2421,config,configure,2421,psi4manual/1.6.x/adcc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/adcc.html,1,['config'],['configure']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/adcc.html:2421,config,configure,2421,psi4manual/1.7.x/adcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/adcc.html,1,['config'],['configure']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/adcc.html:2423,config,configure,2423,psi4manual/1.8.x/adcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/adcc.html,1,['config'],['configure']
Modifiability,"ber of subspace vectors. A negative value uses * the adcc default (roughly between 20 and 5 * N_GUESSES). This option is only available for the adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/adcc.html:2423,config,configure,2423,psi4manual/1.9.x/adcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/adcc.html,1,['config'],['configure']
Modifiability,"beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:25679,variab,variable,25679,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:9928,variab,variable,9928,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,6,['variab'],['variable']
Modifiability,"betapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential Q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:6334,variab,variables,6334,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variables']
Modifiability,"bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:3872,plugin,plugin-compile,3872,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,9,['plugin'],['plugin-compile']
Modifiability,"bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gfortran_linux-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:34188,variab,variable,34188,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['variab'],['variable']
Modifiability,"bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gfortran_linux-64 or gfortran_osx-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gfortran_osx-64 conda package. This provides; gfortran compilers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular syst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:36665,variab,variable,36665,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"bital; basis. This affects SAPT0 and sSAPT0 computed with the SAPT; module (the default code for energy(""sapt0"") that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; energy(""sapt0"") or energy(""ssapt0"") change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the SAPT module breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see fitting changes ) and the; default SAPT0 results from the SAPT module are now; consistent with those from the FISAPT module and; the sapt(dft) module. See sapt-compare for an example.; To reproduce former behavior, set DF_BASIS_ELST to the; orbital basis set’s RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/sapt.html:3011,adapt,adapted,3011,psi4manual/1.6.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/sapt.html,5,['adapt'],['adapted']
Modifiability,"bitals per irrep. options(self: psi4.core.Wavefunction) → psi::Options¶; Returns the Wavefunction’s options object. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21797,variab,variable,21797,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"bitals per irrep. options(self: psi4.core.Wavefunction) → psi::Options¶; Returns the Wavefunction’s options object. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:21525,variab,variable,21525,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"bitals per irrep. options(self: psi4.core.Wavefunction) → psi::Options¶; Returns the Wavefunction’s options object. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:21997,variab,variable,21997,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,12,['variab'],['variable']
Modifiability,"bitals per irrep. options(self: psi4.core.Wavefunction) → psi::Options¶; Returns the Wavefunction’s options object. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:21617,variab,variable,21617,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:63273,inherit,inherited,63273,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"bject with type S, a subtype of T; ; class TwoElectronInt(TwoBodyAOInt); | docstring; | ; | Method resolution order:; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:136025,inherit,inherited,136025,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,4,['inherit'],['inherited']
Modifiability,"bjects14iterator_rangeINS0_19return_value_policyINS0_15return_by_valueENS0_21default_call_policiesEEEN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEEE __iter__(N5boost6python14back_referenceIRSt6vectorIdSaIdEEEE); | ; | __len__(...); | __len__( (vector_of_doubles)arg1) -> int :; | ; | C++ signature :; | m __len__(St6vectorIdSaIdEE {lvalue}); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (vector_of_doubles)arg1, (object)arg2, (object)arg3) -> None :; | ; | C++ signature :; | void __setitem__(St6vectorIdSaIdEE {lvalue},P7_object,P7_object); | ; | append(...); | append( (vector_of_doubles)arg1, (object)arg2) -> None :; | ; | C++ signature :; | void append(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE); | ; | extend(...); | extend( (vector_of_doubles)arg1, (object)arg2) -> None :; | ; | C++ signature :; | void extend(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; C++ signature :; d DASUM(i,m,N5boost10shared_ptrIN3psi6VectorEEE,i); ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; C++ signature :; void DAXPY(i,m,d,N5boost10shared_ptrIN3psi6VectorEEE,i,N5boost10shared_ptrIN3psi6VectorEEE,i); ; DCOPY(...); DCOPY( (int)arg1, (int)arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:663678,extend,extend,663678,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,"['extend', 'inherit']","['extend', 'inherited']"
Modifiability,"ble = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45612,variab,variables,45612,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ble QC variables. set_array(key, val). set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on self. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[, assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename, do_virtual, use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters:. ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:7189,variab,variable,7189,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ble from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libefp-1.html:8466,config,configdir,8466,psi4manual/1.4.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libefp-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"ble from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/libefp-1.html:8466,config,configdir,8466,psi4manual/1.5.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/libefp-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"ble"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_array` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:46867,variab,variable,46867,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ble(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:23087,variab,variable,23087,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variable']
Modifiability,"ble(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.array_variable(arg0: str) → psi::Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. psi4.core.array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of all Matrix QC variables. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:277032,variab,variable,277032,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ble; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:21915,variab,variable,21915,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variable']
Modifiability,"ble_pybuffer(...) unbound psi4.PotentialInt method. set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b). Process¶. psi4.Process.environment()¶; Python Library Documentation: Environment in module psi4 object; class Environment(Boost.Python.instance). Method resolution order:. Environment. Boost.Python.instance. __builtin__.object. Methods defined here:. __getitem__(...). __getitem__( (Environment)arg1, (str)arg2) -> str :. docstring. C++ signature :. Ss __getitem__(N3psi7Process11EnvironmentE {lvalue},Ss). __init__(...). __init__( (object)arg1) -> None :. C++ signature :. void __init__(P7_object). __reduce__ = <unnamed Boost.Python function>(...). ———————————————————————-. Data and other attributes defined here:. __instance_size__ = 464. ———————————————————————-. Data descriptors inherited from Boost.Python.instance:. __dict__. __weakref__. ———————————————————————-. Data and other attributes inherited from Boost.Python.instance:. __new__ = <built-in method __new__ of Boost.Python.class object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. PseudoTrial¶. psi4.PseudoTrial.getA()¶; Python Library Documentation: method getA; getA(...) unbound psi4.PseudoTrial method. getA( (PseudoTrial)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE getA(N3psi11PseudoTrialE {lvalue}). psi4.PseudoTrial.getI()¶; Python Library Documentation: method getI; getI(...) unbound psi4.PseudoTrial method. getI( (PseudoTrial)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE getI(N3psi11PseudoTrialE {lvalue}). psi4.PseudoTrial.getIPS()¶; Python Library Documentation: method getIPS; getIPS(...) unbound psi4.PseudoTrial method. getIPS( (PseudoTrial)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE getIPS(N3psi11PseudoTrialE {lvalue}). psi4.PseudoTrial.getQ()¶; Python Library Documentation:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:272645,inherit,inherited,272645,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ble` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:23782,variab,variables,23782,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,bles; get_atomic_point_charges; get_datadir; get_global_option; get_global_option_list; get_gradient; get_legacy_gradient; get_legacy_molecule; get_local_option; get_memory; get_num_threads; get_option; get_options; get_output_file; get_variable; get_variables; get_writer_file_prefix; git_version; has_array_variable; has_global_option_changed; has_local_option_changed; has_option_changed; has_scalar_variable; has_variable; HF; IDAMAX; initialize; IntegralFactory; IntegralTransform; IntVector; IO; IOManager; IrreducibleRepresentation; JK; KineticInt; LaplaceDenominator; legacy_wavefunction; LibXCFunctional; Localizer; Matrix; MatrixFactory; mcscf; MemDFJK; MintsHelper; MoldenWriter; MolecularGrid; Molecule; MOSpace; MOWriter; mrcc_generate_input; mrcc_load_densities; MultipoleInt; MultipoleSymmetry; NablaInt; NBOWriter; occ; OEProp; OneBodyAOInt; OneBodySOInt; opt_clean; option_exists_in_module; Options; options_to_python; optking; OrbitalSpace; outfile_name; OverlapInt; PetiteList; plugin; plugin_close; plugin_close_all; plugin_load; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_gradient; set_legacy_gradient; set_legacy_molecule; set_legacy_wavefunction; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; ThreeCenterOverlapInt; timer_off; timer_on; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoB,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:762221,plugin,plugin,762221,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugin']
Modifiability,"block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 1000. H_BOND_CONNECT (OPTKING); OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. H_GUESS_EVERY (OPTKING); OPTKING — Re-estimate the Hessian at every step, i.e., ignore the currently stored Hessian. Type: boolean; Default: false. H_UPDATE_DEN_TOL (OPTKING); OPTKING — Denominator check for hessian update. Type: conv double; Default: 1e-7. HD_AVG (DETCI); DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI); DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC); PSIMRCC — Do include the fourth-order contributions to the e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:136585,coupling,coupling,136585,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['coupling'],['coupling']
Modifiability,"bosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html:1718,variab,variables,1718,psi4manual/1.4.0/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html,9,['variab'],['variables']
Modifiability,"brational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT¶. Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE¶. Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP¶. In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ¶. This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE¶. This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are split, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION¶. Specifies the field strength for a perturbation (defined within a %perturbation section). The value must be given",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:25244,adapt,adapted,25244,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['adapt'],['adapted']
Modifiability,"bring a test to CMake’s attention. If a test needs additional files, register them in psi4/psi4/CMakeLists.txt. A few notes on test contents:. Import testing functions from utils and use Python assert: assert compare_values(expected, computed, ...).; Don’t worry about cleaning up files or resetting options. A function in psi4/tests/pytests/conftest.py does this automatically between every test.; Especially if using data or functions from outside a test, run a variety of tests at different pytest -n <N> levels to mix up test ordering. If tests fail that pass when run alone, you’ve got a function of the same name changing state or some similar correctable phenomenon. A few notes on test labels:. For every new test file, add pytestmark = [pytest.mark.psi, pytest.mark.api] at the top.; This ensures that every test has the psi mark and every PsiAPI test has the api mark to contrast with PSIthon tests with cli mark.; There are individual “marks” that can be added to whole tests or parts; of parameterized tests so that they can be run by category (pytest -m <mark>; vs. ctest -L <mark>) rather than just by name (pytest -k <name_fragment>; vs. ctest -R <name_fragment>). Far more complicated logic is allowed than for; CTest: pytest -m ""dftd3 and not api and not long"".; The most important marks are “quick” and “long” that opt tests into the quick CI suite or out of; the normal full suite. Mark with a decorator for the full test or the; marks argument in a parameterized test. Search “mark” in the test suite; for examples. Use “quick” freely for tests that cover functionality and; are under 15s. Use “long” sparingly to winnow out the longest examples,; particularly those over a minute. Running for Debugging¶; There are many ways to run pytest, How to test a Psi4 installation, and three different copies of the test file; (i.e., psi4/tests/pytests/test_mp2.py, <objdir>/stage/lib/PYMOD_INSTALL_LIBDIR/psi4/tests/test_mp2.py,; CMAKE_INSTALL_PREFIX/lib/PYMOD_INSTALL_LIBDIR/psi4/tests/t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:12368,parameteriz,parameterized,12368,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,5,['parameteriz'],['parameterized']
Modifiability,"bsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:22305,config,configuration,22305,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['config'],['configuration']
Modifiability,"buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:582606,inherit,inherited,582606,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/ecpint.html:1841,variab,variable,1841,psi4manual/master/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/master/ecpint.html,2,['variab'],['variable']
Modifiability,"built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/ecpint.html:1832,variab,variable,1832,psi4manual/1.7.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/ecpint.html,2,['variab'],['variable']
Modifiability,"built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/ecpint.html:1834,variab,variable,1834,psi4manual/1.8.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/ecpint.html,2,['variab'],['variable']
Modifiability,"built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/ecpint.html:1834,variab,variable,1834,psi4manual/1.9.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/ecpint.html,2,['variab'],['variable']
Modifiability,"built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class AngularMomentumInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | AngularMomentumInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:3368,inherit,inherited,3368,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class AngularMomentumInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | AngularMomentumInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:373932,inherit,inherited,373932,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"buntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:3294,plugin,plugin,3294,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,9,['plugin'],['plugin']
Modifiability,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:53500,inherit,inherited,53500,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:3458,config,configure,3458,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,18,"['config', 'plugin']","['configure', 'plugin-compile']"
Modifiability,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:22976,flexible,flexible,22976,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['flexible'],['flexible']
Modifiability,"c(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scalar_variable(arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(); Returns dictionary of all double QC variables. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian progr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:298129,variab,variables,298129,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"c(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247710,variab,variables,247710,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"c); otherwise, it’ll just remove libint and every package; depending on libint.; 1conda remove --features am8 -c psi4. The default package is AM6 because of its manageable file size (on Linux,; 10MB for libint and 40MB for libderiv). The AM7 are 20/100, respectively,; and the AM8 is 50/210. How to see what build configuration options are available¶; CMake doesn’t provide a summary for this (unless you want to try the CMake; GUI, which the developers have never looked at). However, the top half of; the main CMakeLists.txt is a passable summary:. ################ Options: Overview and Not Otherwise Mentioned ###############. # <<< CMake build overview >>>; #; # >>> ls; # external/ LICENSE psi4/ tests/ ...; # >>> cmake -H. -Bobjdir -DCMAKE_INSTALL_PREFIX=/path/to/install-psi4 ...; # ...; # -- Generating done; # -- Build files have been written to: /current/dir/objdir; # >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; # >>> make install. # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - PYTHON_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python2.7)""; # - PYTHON_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python2.7.so)""; # - PYTHON_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python2.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, libefp, erd, gdma, Libint, PCMSolver, pybind11, simint; # - CMAKE_PREFIX_PATH ""Set to list of root directories to look for externally built add-ons and depen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:8464,variab,variables,8464,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"c, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; cbs_kwargs['scf_scheme'] = kwargs['scf_scheme']; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; cbs_kwargs['corl_scheme'] = kwargs['corl_scheme']. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_basis'] = basis_list[1]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:58643,variab,variables,58643,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['variab'],['variables']
Modifiability,"c, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_basis'] = basis_list[1]. ptype_value, wfn = cbs(func, label, **cbs_kwargs). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. Quick search. Enter search terms o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:58200,variab,variables,58200,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['variab'],['variables']
Modifiability,"c-pVDZ energy for the H2O molecule. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc54; CCSD dipole with user-specified basis set. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. fnocc7; Test fnocc with linear dependencies. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. scf7; Tests SCF gradient in the presence of a dipole field. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. mints-helper; A general test of the MintsHelper function. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). scf-upcast-custom-basis; test scf castup with custom basis sets. dct10; The multiple guesses for DC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:20530,variab,variables,20530,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gcp-1.html:3535,extend,extended,3535,psi4manual/1.2.1/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gcp-1.html,2,['extend'],['extended']
Modifiability,"c:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:40797,variab,variables,40797,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"c_{c\sigma\sigma,1}; C.set_parameter('B97_ss_a2', 3.13343E1) # Table 1: c_{c\sigma\sigma,2}; C.set_parameter('B97_ss_a3', -5.10533E1) # Table 1: c_{c\sigma\sigma,3}; C.set_parameter('B97_ss_a4', 2.64423E1) # Table 1: c_{c\sigma\sigma,4}. sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(omega) # Table 1: omega; sup.set_c_omega(0.0); sup.set_x_alpha(alpha) # Table 1: c_x; sup.set_c_alpha(0.0). # => -D2 (CHG Damping Function) <= #; sup.set_dispersion(psi4.Dispersion.build('-CHG', 1.0, 0.0, 0.0, 0.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', 0.08151); X.set_parameter('Meta_a2', -0.43956); X.set_parameter('Meta_a3', -3.22422); X.set_parameter('Meta_a4', 2.01819); X.set_parameter('Meta_a5', 8.79431); X.set_parameter('Meta_a6', -0.00295); X.set_parameter('Meta_a7', 9.8202",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:61891,Parameteriz,Parameterized,61891,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,1,['Parameteriz'],['Parameterized']
Modifiability,"called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:2642,config,configure,2642,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"caps; according to psi4/media/README.md.; html: <span style=""font-family: Optima, sans-serif; color: #273896;"">P<span style=""font-size: 82%;"">SI</span>4</span>. as Psi4 with “si” in generated small caps; html: <span style=""font-variant: small-caps;"">Psi4</span>. as Psi4 with “si” in lowercase; as psi4 in code; NOT PSI4 or PSI. table of contents. Compiling and Installing from Source; Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies; How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda; How to see what build configuration options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to fix error “RuntimeError: value for ERI“; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set PSIDATADIR and why; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:41795,config,configure,41795,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,10,['config'],"['configuration', 'configure']"
Modifiability,"cary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:33985,variab,variables,33985,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"cary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31762,variab,variables,31762,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ccess, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:22730,config,configure,22730,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configure']
Modifiability,"ccessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugins.html:7912,plugin,plugin,7912,psi4manual/master/plugins.html,https://psicode.org,https://psicode.org/psi4manual/master/plugins.html,5,['plugin'],['plugin']
Modifiability,"cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:2349,config,configuration,2349,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['config'],['configuration']
Modifiability,"cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run Psi4 after installation, you need to configur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:2347,config,configuration,2347,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['config'],['configuration']
Modifiability,"cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:2756,config,configuration,2756,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,4,['config'],['configuration']
Modifiability,"ce, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; # all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by direc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:1896,variab,variables,1896,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,9,['variab'],['variables']
Modifiability,"ce.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:84462,variab,variable,84462,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"ce:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TracelessQuadrupoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | TracelessQuadrupoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoBodyAOInt(Boost.Python.instance); | docstring; | ; | Method resolution order:; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:133000,inherit,inherited,133000,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32182,variab,variables,32182,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:170425,variab,variables,170425,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, arg3: int) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:183195,variab,variables,183195,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:206499,variab,variables,206499,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:80316,variab,variables,80316,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"ces are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/extras.html:7520,extend,extend,7520,psi4manual/1.9.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/extras.html,4,['extend'],['extend']
Modifiability,"cessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/psi4/share/psi4/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:3786,variab,variables,3786,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['variab'],['variables']
Modifiability,"cf; optimization HF/svp on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. «; h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:3944,variab,variables,3944,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['variab'],['variables']
Modifiability,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html:3362,config,configuration,3362,psi4manual/1.1.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html,38,['config'],['configuration']
Modifiability,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:13777,variab,variables,13777,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,15,['variab'],['variables']
Modifiability,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_sub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13891,variab,variables,13891,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,3,['variab'],['variables']
Modifiability,"changed:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:46378,variab,variables,46378,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. Added in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:26845,variab,variables,26845,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26693,variab,variables,26693,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variables']
Modifiability,"checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Move a file out of scratch following the naming convention. copy_file_to_scratch(filename, prefix, ...); Move a file into scratch following the naming convention. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. davidson_solver(engine, guess, *, nroot[, ...]); Solves for the lowest few eigenvalues and eigenvectors of a large problem emulated through an engine. docs_table_link(name, mode); Compose a link to mode documentation table. drop_duplicates(seq); Return a copy of collection seq without any duplicate entries. energies_from_fcidump(intdump); From integrals dictionary generated from fcidump_from_file(), compute energies. expand_psivars(pvdefs[, verbose]); From rules on building QCVariables from others, set new variables to P::e if all the contributors are available. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. format_molecule_for_input(mol[, name, forcexyz]); Function to return a string of the output of process_input() applied to the XYZ format of molecule, passed as either fragmented geometry string mol or molecule instance mol. format_options_for_input([molecule]); Function to return a string of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:24506,variab,variables,24506,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,2,['variab'],['variables']
Modifiability,"checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Move a file out of scratch following the naming convention. copy_file_to_scratch(filename, prefix, ...); Move a file into scratch following the naming convention. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. davidson_solver(engine, guess, *, nroot[, ...]); Solves for the lowest few eigenvalues and eigenvectors of a large problem emulated through an engine. docs_table_link(name, mode); Compose a link to mode documentation table. drop_duplicates(seq); Return a copy of collection seq without any duplicate entries. energies_from_fcidump(intdump); From integrals dictionary generated from fcidump_from_file(), compute energies. expand_psivars(pvdefs[, verbose]); From rules on building QCVariables from others, set new variables to P::e if all the contributors are available. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. format_molecule_for_input(mol[, name, forcexyz]); Old function for input string from molecule. format_options_for_input([molecule]); Function to return a string of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:24372,variab,variables,24372,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['variab'],['variables']
Modifiability,"cific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_specific_retention(N3psi11PSIOManagerE {lvalue},i,b); | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | C++ signature :; | void write_scratch_file(N3psi11PSIOManagerE {lvalue},Ss,Ss); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi11PSIOManagerEEE shared_object(); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __init__( (object)arg1, (int)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,i); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | C++ signature :; | i dim(N3psi9IntVectorE {lvalue},i); | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | C++ signature :; | i get(N3psi9IntVectorE {lvalue},i,i); | ; | nirrep(...); | nirrep( ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:494850,inherit,inherited,494850,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ck Installation),; erd can be obtained through conda install erd.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code.; To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/erd-1.html:2223,variab,variable,2223,psi4manual/1.1.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/erd-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ckend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. Herbst and M. Scheurer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/adcc.html:2846,variab,variable,2846,psi4manual/1.8.x/adcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/adcc.html,2,"['config', 'variab']","['configure', 'variable']"
Modifiability,"ckend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. Herbst and M. Scheurer. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/adcc.html:2846,variab,variable,2846,psi4manual/1.9.x/adcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/adcc.html,2,"['config', 'variab']","['configure', 'variable']"
Modifiability,"cklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:35377,variab,variables,35377,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; This class extends qcdb.LibmintsMolecule and occasionally; psi4.core.Molecule itself. class psi4.driver.ipi_broker.IPIBroker(LOT, options=None, serverdata=False, molecule=None)[source]¶; Interface implementation between i-PI (https://ipi-code.org/) and PSI4. psi4.driver.wrapper_autofrag.auto_fragments(molecule=None, seed_atoms=None)[source]¶; Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters:. molecule (molecule, optional) – The target molecule, if not the last molecule defined.; seed_atoms (Optional[List[List[int]]]) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]. Return type:; Molecule. Returns:. Molecule – fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python.; :rtype: str; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/external_apis.html:1946,variab,variable,1946,psi4manual/1.9.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/external_apis.html,1,['variab'],['variable']
Modifiability,"class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; This class extends qcdb.LibmintsMolecule and occasionally; psi4.core.Molecule itself. class psi4.driver.ipi_broker.IPIBroker(LOT, options=None, serverdata=False, molecule=None)[source]¶; Interface implementation between i-PI (https://ipi-code.org/) and PSI4. psi4.driver.wrapper_autofrag.auto_fragments(molecule=None, seed_atoms=None)[source]¶; Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters:. molecule (molecule, optional) – The target molecule, if not the last molecule defined.; seed_atoms (Optional[List[List[int]]]) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]. Return type:; Molecule. Returns:. Molecule – fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python.; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:1953,variab,variable,1953,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,1,['variab'],['variable']
Modifiability,"class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; This class extends qcdb.LibmintsMolecule and occasionally; psi4.core.Molecule itself. class psi4.driver.ipi_broker.IPIBroker(LOT, options=None, serverdata=False, molecule=None)[source]¶; Interface implementation between i-PI (https://ipi-code.org/) and PSI4. psi4.driver.wrapper_autofrag.auto_fragments(molecule=None, seed_atoms=None)[source]¶; Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters:. molecule (molecule, optional) – The target molecule, if not the last molecule defined.; seed_atoms (Optional[List[List[int]]]) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]. Return type:; Molecule. Returns:. Molecule – fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/external_apis.html:1944,variab,variable,1944,psi4manual/1.7.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/external_apis.html,2,['variab'],['variable']
Modifiability,"class:`~psi4.core.Matrix`; storage maps. """"""; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:33571,variab,variables,33571,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"cluded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); - ERISieve (constructor); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ""temp_circular_import_blocker"", # retire ASAP; ]. import os; import re; import sys; import math; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4 import extras; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:1252,variab,variable-related,1252,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable-related']
Modifiability,"cluded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); - ERISieve (constructor); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ]. import math; import os; import re; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np; import qcelemental as qcel. from psi4 import core, extras. from .. import qcdb; from . import optproc; from .exceptions import TestComparisonError, UpgradeHelper, ValidationError. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional[Union[str, Callable]] = None,; puream: int = -1,; return_atomlist: bool = False,; *,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:1252,variab,variable-related,1252,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable-related']
Modifiability,"cludes dummies) in Bohr; >>> print H2OH2O.fz(4); 0.0. geometry()[source]¶; Returns the geometry in Bohr as a N X 3 array.; >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. get_anchor_atom(vstr, line)[source]¶; Attempts to interpret a string vstr as an atom specifier in; a zmatrix. Takes the current line for error message printing.; Returns the atom number (adjusted to zero-based counting). get_coord_value(vstr)[source]¶; Attempts to interpret a string as a double, if not it assumes it’s a variable. get_full_point_group()[source]¶; Return point group name such as C3v or S8.; (method name in libmints is full_point_group). get_variable(vstr)[source]¶; Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. has_inversion(origin, tol=1e-08)[source]¶; Does the molecule have an inversion center at origin. has_symmetry_element(op, tol=1e-08)[source]¶; NYI Whether molecule satisfies the vector symmetry; operation op. Not used by libmints. has_zmatrix()[source]¶; Gets the presence of any zmatrix entry; >>> print H2OH2O.has_zmatrix(); False. inertia_tensor()[source]¶; Compute inertia tensor.; >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. init_with_checkpoint(chkpt)[source]¶; NYI Pull information from the chkpt object passed; (method name in libmints is init_with_chkpt). init_with_io(psio)[source]¶; NYI Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). classmethod init_with_xyz(xyzfilename)[source]¶; Pull information from an XYZ file. No fragment or chg/mult in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:82190,variab,variable,82190,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variable']
Modifiability,"code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to ERD by N. Flocke and V. Lotrich. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/erd.html:2555,variab,variable,2555,psi4manual/1.8.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/erd.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to ERD by N. Flocke and V. Lotrich. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/erd.html:2555,variab,variable,2555,psi4manual/1.9.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/erd.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"code. has_option_changed((arg0: str, ...); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Runs a CPHF calculation, using libfock. mcscf(...); Runs the MCSCF code, (N.B. mrcc_generate_input(...); Generates an input for Kallay’s MRCC code. mrcc_load_densities(...); Reads in the density matrices from Kallay’s MRCC code. occ(...); Runs the orbital optimized CC codes. opt_clean(() -> None); Cleans up the optimizer’s scratch files. optking(() -> int); Runs the geometry optimization / frequency analysis code. outfile_name(() -> str); Returns the name of the output file. plugin((arg0: str, ...); Call the plugin of name arg0. plugin_close((arg0: str) -> None); Close the plugin of name arg0. plugin_close_all(() -> None); Close all open plugins. plugin_load((arg0: str) -> int); Load the plugin of name arg0. prepare_options_for_module((arg0: str) -> None); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(() -> None); Prints the currently set global (all modules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multireference coupled cluster code. reopen_outfile(() -> None); Reopens the output file. revoke_global_option_changed((arg0: str) -> None); Given a string of a keyword name arg1, sets the has_chang",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:168595,plugin,plugin,168595,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gcc or gcc-5 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be semicolon-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present). >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:30451,variab,variable,30451,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; df_basis_cc cholesky; basis aug-cc-pvdz; freeze_core true; }; energy('df-ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. ). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to the DETCI implementations of these methods. name; calls method. qcisd; quadratic configuration interaction singles doubles. qcisd(t); qcisd with perturbative triples. mp2.5; average of second- and third-order perturbation theories. mp3; third-order perturbation theory. mp4(sdq); fourth-order perturbation theory, minus triples contribution. mp4; full fourth-order perturbation theory. cepa(0); coupled electron pair approximation, variant 0. cepa(1); coupled electron pair approximation, variant 1. cepa(3); coupled electron pair approximation, variant 3. acpf; averaged coupled-pair functional. aqcc; averaged quadratic coupled-cluster. sdci; configuration interaction with single and double excitations. dci; configuration interaction with double excitations. fno-qcisd; qcisd with frozen natural orbitals. fno-qcisd(t); qcisd(t) with frozen natural orbitals. fno-ccsd; coupled cluster singles doubles with frozen natural orbitals. fno-ccsd(t); ccsd with perturbative triples and frozen natural orbitals. fno-mp3; mp3 with frozen natural orbitals. fno-mp4(sdq); mp4(sdq) with frozen natural",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:10380,config,configuration,10380,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['config'],['configuration']
Modifiability,"computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:11039,variab,variable,11039,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['variab'],['variable']
Modifiability,"conda_cos6-linux-gnu-g++; >>> echo ${HOST}; x86_64-conda_cos6-linux-gnu. # build with GNU; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=${CC} \; -DCMAKE_CXX_COMPILER=${CXX} \. # build with Intel; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:33346,config,configure,33346,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"conda_cos6-linux-gnu-g++; >>> echo ${HOST}; x86_64-conda_cos6-linux-gnu. # build with GNU; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=${CC} \; -DCMAKE_CXX_COMPILER=${CXX} \. # build with Intel; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:35823,config,configure,35823,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"conda_cos6-linux-gnu-g++; >>> echo ${HOST}; x86_64-conda_cos6-linux-gnu. # build with GNU; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=${CC} \; -DCMAKE_CXX_COMPILER=${CXX} \. # build with Intel; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables before running cmake.; CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... CRAYPE_LINK_TYPE¶; Set to allow PSI4 to build as shared library on Cray supercomputers. CRAY_ADD_RPATH¶; Set to true to allow PSI4 to build on Cray supercomputers. How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies. PSI4 (\(\Leftarrow\) optional) Fortran Compiler; dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:40285,config,configure,40285,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['config'],['configure']
Modifiability,"conda_cos6-linux-gnu-g++; >>> echo ${HOST}; x86_64-conda_cos6-linux-gnu. # build with GNU; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=${CC} \; -DCMAKE_CXX_COMPILER=${CXX} \. # build with Intel; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables before running cmake.; CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... CRAYPE_LINK_TYPE¶; Set to allow PSI4 to build as shared library on Cray supercomputers. CRAY_ADD_RPATH¶; Set to true to allow PSI4 to build on Cray supercomputers. How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies. PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:38850,config,configure,38850,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,8,['config'],['configure']
Modifiability,"conf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:2445,config,configuration,2445,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['config'],"['configuration', 'configure']"
Modifiability,"conf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run Psi4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:2443,config,configuration,2443,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['config'],"['configuration', 'configure']"
Modifiability,"conf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:2852,config,configuration,2852,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,4,['config'],"['configuration', 'configure']"
Modifiability,"control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpenMP. MKL_ROOT¶; Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location. MATH_ROOT¶; Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so). Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present); If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE. Build with Intel MKL. >>> source /path/to/intel/vers/linux/mkl/bin/mklvars.sh intel64 # adjust sh/csh and arch as needed; >>> cmake. >>> MATH_ROOT=/path/to/intel/vers/linux/mkl/ cmake. Build with Intel MKL from conda (install mkl-devel package from defaults channel). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:41700,variab,variable,41700,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['variab'],['variable']
Modifiability,"conv double; Default: 1e-3. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. GUESS_R_CONVERGENCE¶. Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. MAXITER¶. Maximum number of macro- or micro-iterations for both energy and response equations. Type: integer; Default: 40. ODC_GUESS¶. Whether to perform a guess DC-06 or DC-12 computation for ODC-06 or ODC-12 methods, respectively. Currently only available for ALGORITHM = SIMULTANEOUS. Type: boolean; Default: false. OPDM¶. Compute a (relaxed) one-particle density matrix? Can be set manually. Set internally for property and gradient computations. Type: boolean; Default: false. QC_COUPLING¶. Controls whether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_TYPE¶. Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: UHF, RHF, ROHF; Default: RHF. RESPONSE_ALGORITHM¶. Algorithm to use for the solution of DC-06 response equations in computation of analytic gradients and * properties. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. R_CONVERGENCE¶. Convergence criterion for the RMS of the residual vector in density cumulant updates, as well as the solution of the density cumulant and orbital respo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html:2744,coupling,coupling,2744,psi4manual/1.4.0/autodir_options_c/module__dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html,18,['coupling'],['coupling']
Modifiability,"copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:2463,variab,variable,2463,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variable']
Modifiability,"copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:2463,variab,variable,2463,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,3,['variab'],['variable']
Modifiability,"core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:13373,variab,variable,13373,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,3,['variab'],['variable']
Modifiability,"core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:13447,variab,variable,13447,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,8,['variab'],['variable']
Modifiability,"core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:3728,variab,variable,3728,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,6,['variab'],['variable']
Modifiability,"core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/ipi_broker.html:3724,variab,variable,3724,psi4manual/1.7.x/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/ipi_broker.html,2,['variab'],['variable']
Modifiability,"core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:3550,variab,variable,3550,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,6,['variab'],['variable']
Modifiability,"core.PrimitiveType attribute, [1], [2]. Unrestricted psi4.core.IntegralTransform.TransformationType attribute, [1]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. update_geometry() psi4.core.Molecule method, [1], [2]. update_orbitals() psi4.core.IntegralTransform method, [1], [2]. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. V_potential() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. Va() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute, [1], [2]. validate_options() psi4.core.Options method, [1], [2]. ValidationError. value() psi4.core.SuperFunctional method, [1], [2]. values() psi4.core.SuperFunctional method, [1], [2]. variable() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. variables() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Vb() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VBase class in psi4.core, [1]. vdot() psi4.core.CIVector method, [1], [2]. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core, [1]. Vector3 class in psi4.core, [1]. vector_dot() psi4.core.Matrix method, [1], [2]. vector_multiply() psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:146869,variab,variable,146869,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['variab'],['variable']
Modifiability,"core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate() psi4.driver.AtomicComputer class method. validate_diis() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Vb() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_dot() psi4.core.Matrix method. psi4.core.Vector method. vector_multiply() psi4.core.CIVector method. vectors() psi4.core.FISAPT method. version() in module psi4.core. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace static method. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vv10_b() psi4.core.SuperFunctional method. vv10_c() psi4.core.SuperFunctional method. Vvals() psi4.core.OEProp m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:154168,variab,variables,154168,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['variab'],['variables']
Modifiability,"core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None; Sets the internal JK object !expert. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:24813,variab,variable,24813,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['variab'],['variable']
Modifiability,"core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:13218,variab,variable,13218,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['variab'],['variable']
Modifiability,"core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:43477,variab,variables,43477,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['variab'],['variables']
Modifiability,"core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:76578,variab,variable,76578,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variable']
Modifiability,"core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:43314,variab,variables,43314,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationErr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34833,variab,variables,34833,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['variab'],['variables']
Modifiability,"correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, gcp_engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {“d1”, “d2”, “chg”, “das2009”, “das2010”, “nl”, “dmp2”, “d3zero2b”, “d3bj2b”, “d3mzero2b”, “d3mbj2b”, “d3zeroatm”, “d3bjatm”, “d3mzeroatm”, “d3mbjatm”, “d4bjeeqatm”}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type:; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:; dict. fctldash¶; If dashparams for dashlevel ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:16241,extend,extending,16241,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['extend'],['extending']
Modifiability,"correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30545,extend,extending,30545,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,8,['extend'],['extending']
Modifiability,"correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Updating the PSI4 Users’ and Programmers’ Manual. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/documentation.html:7571,variab,variable,7571,psi4manual/1.8.x/documentation.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/documentation.html,1,['variab'],['variable']
Modifiability,"correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Updating the PSI4 Users’ and Programmers’ Manual. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/documentation.html:7571,variab,variable,7571,psi4manual/1.9.x/documentation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/documentation.html,1,['variab'],['variable']
Modifiability,"correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = p4util.kwargs_lower(kwargs); #; # plugfile = psi4.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # psi4.plugin_load(""%s"" % (plugfile)); #; # psi4.set_global_option('BASIS', 'AUG-CC-PVDZ'); # psi4.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # psi4.set_global_option('REFERENCE', 'UHF'); # psi4.set_global_option('SCF_TYPE', 'DF'); # energy('scf', **kwargs); #; # psi4.set_global_option('dft_functional', 'wB97'); # psi4.set_global_option('dft_order_spherical', 25); # psi4.set_global_option('dft_num_radial', 35); # psi4.set_global_option('omega_procedure', 'ip'); # psi4.set_global_option('maxiter', 50); # psi4.set_global_option('d_convergence', 5); # psi4.set_global_option('e_convergence', 7); # psi4.plugin(""plugin_omega.so""); #; # return psi4.get_variable('SCF TOTAL ENERGY'). # Integration with driver routines; #procedures['energy']['mp2.5'] = run_mp2_5; procedures['energy']['sherrill_gold_standard'] = sherrill_gold_standard; procedures['energy']['allen_focal_point'] = allen_focal_point; #procedures['energy']['plugin_omega'] = run_plugin_omega. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:9505,plugin,plugin,9505,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,2,['plugin'],['plugin']
Modifiability,"corresponds to. set_orbitals(self, arg0, arg1); docstring. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. tpdm(self, arg0, arg1, arg2, arg3); docstring. transform_ci_integrals(self); Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self, arg0); docstring. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type; Matrix. Cb(self: psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:9098,variab,variable,9098,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"coupled with auto:; 1; 2; 3std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso)); // Type information written down 3 TIMES!!!; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!!!!. Ensures exception safety and prevents resource leaks. Improves efficiency:; 1; 2; 3; 4// Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));; // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:; 1; 2std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/style_c-1.html:1753,variab,variables,1753,psi4manual/1.2.1/style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/style_c-1.html,2,['variab'],['variables']
Modifiability,"create scratch directories on every node, using the $PBS_NODEFILE which; points to a file containing a list of the nodes attributed to the job.; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. The next section is very important as it sets the environment variables needed; by PSI4:; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}. PSIDATADIR does not need to be set.; In the present example we unset it to make sure it does not interfere with the internal location-finding.; PSIPATH is needed only if you are using external modules or; plugins in PSI4 and should point to the directories where they can be found. In the; present example, we make sure the variable is set with if ! ( $?PSIPATH ) setenv PSIPATH """"; before adding more paths to it. Finally, PSI_SCRATCH should point to a fast, existing; local disk for temporary file storage. To use 4 threads for OpenMP parallelization; and threaded BLAS (see section Threading), we set -n4 below.; The next step is then to actually run the computation:; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; Each set of three commands below is completely equivalent, while the second set,; perhaps, is the most common usage.; >>> psi4; >>> ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:16879,variab,variable,16879,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"cript will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:6721,config,configure,6721,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,9,['config'],['configure']
Modifiability,"criptors inherited from __builtin__.int:. denominator. the denominator of a rational number in lowest terms. imag. the imaginary part of a complex number. numerator. the numerator of a rational number in lowest terms. real. the real part of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.GeometryUnits.Bohr()¶; Python Library Documentation: GeometryUnits in module psi4 object; class GeometryUnits(Boost.Python.enum). docstring. Method resolution order:. GeometryUnits. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Angstrom = psi4.GeometryUnits.Angstrom. Bohr = psi4.GeometryUnits.Bohr. names = {‘Angstrom’: psi4.GeometryUnits.Angstrom, ‘Bohr’: psi4.Geometr... values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}. ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:155954,inherit,inherited,155954,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"cs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2625,variab,variable,2625,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,6,['variab'],['variable']
Modifiability,"csd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the Psi4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses SCF conv crit since default overwritten; and Cfour module keyword trumps Psi4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in Psi4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to Psi4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the Psi4; output file and is available from input as get_gradient().; sandwich mode :=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:33512,flexible,flexible,33512,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['flexible'],['flexible']
Modifiability,"cstring. DSYMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time, nthread); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:2416,variab,variables,2416,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"cstring; | ; | C++ signature :; | void tocprint(N3psi4PSIOE {lvalue},j); | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | C++ signature :; | void tocwrite(N3psi4PSIOE {lvalue},j); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | C++ signature :; | void change_file_namespace(j,Ss,Ss); | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | C++ signature :; | Ss get_default_namespace(); | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | C++ signature :; | void set_default_namespace(Ss); | ; | shared_object(...); | shared_object() -> IO :; | ; | C++ signature :; | N5boost10shared_ptrIN3psi4PSIOEEE shared_object(); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | C++ signature :; | void crashclean(N3psi11PSIOManage",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:491670,inherit,inherited,491670,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ct Libxc and activate dependent code. Previous bullet had details. To build PSI4 from source and use; Libxc from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libxc-1.html:1887,variab,variable,1887,psi4manual/1.2.1/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libxc-1.html,2,['variab'],['variable']
Modifiability,"ct Libxc and activate dependent code. Previous bullet had details. To build PSI4 from source and use; Libxc from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/libxc-1.html:1887,variab,variable,1887,psi4manual/1.3.2/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/libxc-1.html,2,['variab'],['variable']
Modifiability,"ct[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:21956,variab,variable,21956,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,16,['variab'],['variable']
Modifiability,"cted BasisSet basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter, …); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. diis_manager(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:3605,variab,variable,3605,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,7,['variab'],['variable']
Modifiability,"ction) → List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]; Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None; Sets the requested external potential. set_frequencies(val). set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None; Sets the print level of the Wavefunction. set_reference_wavefunction(self:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:25613,variab,variable,25613,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"ction, arg0: psi::detci::CIvect, arg1: int) → None; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None; docstring. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html:15358,variab,variable,15358,psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"ction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:18799,variab,variable,18799,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"ction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:19266,variab,variable,19266,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['variab'],['variable']
Modifiability,"ction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:19417,variab,variable,19417,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variable']
Modifiability,"ction. set_reference_wavefunction(self, arg0); docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:12032,variab,variable,12032,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['variab'],['variable']
Modifiability,"ction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26344,variab,variable,26344,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:28597,variab,variable,28597,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:74528,inherit,inherited,74528,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,ctional; GaussianShell; GaussianType; GeometryUnits; get_active_molecule; get_array_variable; get_array_variables; get_datadir; get_global_option; get_global_option_list; get_local_option; get_memory; get_num_threads; get_option; get_options; get_output_file; get_variable; get_variables; get_writer_file_prefix; git_version; has_array_variable; has_global_option_changed; has_local_option_changed; has_option_changed; has_scalar_variable; has_variable; HF; IDAMAX; initialize; IntegralFactory; IntegralTransform; IntVector; IO; IOManager; IrreducibleRepresentation; JK; KineticInt; LaplaceDenominator; LibXCFunctional; Localizer; Matrix; MatrixFactory; mcscf; MemDFJK; MintsHelper; MoldenWriter; MolecularGrid; Molecule; MOSpace; MOWriter; mrcc_generate_input; mrcc_load_densities; MultipoleInt; MultipoleSymmetry; NablaInt; NBOWriter; NumIntHelper; occ; OEProp; OneBodyAOInt; OneBodySOInt; option_exists_in_module; Options; options_to_python; OrbitalSpace; outfile_name; OverlapInt; PetiteList; plugin; plugin_close; plugin_close_all; plugin_load; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyA,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:791378,plugin,plugin,791378,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugin']
Modifiability,"ction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:154149,plugin,plugin,154149,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"ctory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:6431,config,configure,6431,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['config'],['configure']
Modifiability,"ctory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading port",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:6507,plugin,plugin,6507,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ctory method. psi4.core.MintsHelper method. electric_field_value() psi4.core.MintsHelper method. ElectricFieldInt class in psi4.core. electrostatic() psi4.core.IntegralFactory method. ElectrostaticInt class in psi4.core. elst() psi4.core.FISAPT method. EmpiricalDispersion class in psi4.driver. class in psi4.driver.procrouting.empirical_dispersion. end() psi4.core.Slice method. EndLoop psi4.core.PsiReturnType attribute. energies_from_fcidump() in module psi4.driver. energy(). setting keywords. energy() in module psi4.driver. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ENERGY_LEVEL_SHIFT (DCT). engine psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. ENSURE_BT_CONVERGENCE (OPTKING). ENTHALPY. ENTHALPY CORRECTION. environment variable. ; BRIANQC_ENABLE, [1]. BRIANQC_INSTALL_PATH, [1], [2]. BRIANQC_SDK_INSTALL, [1]. CONDA_PREFIX, [1], [2]. CRAY_ADD_RPATH. CRAYPE_LINK_TYPE. HOST, [1], [2]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE, [1]. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PSIDATADIR, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20]. PYTHONPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11]. VMDPATH, [1]. EOM-CCSD ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY. EOM-CCSD ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY. EOM-CCSD ROOT n TOTAL ENERGY - h SYMMETRY. E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:51761,variab,variable,51761,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['variab'],['variable']
Modifiability,"ctory method. psi4.core.MintsHelper method. electric_field_value() psi4.core.MintsHelper method. ElectricFieldInt class in psi4.core. electrostatic() psi4.core.IntegralFactory method. ElectrostaticInt class in psi4.core. elst() psi4.core.FISAPT method. EmpiricalDispersion class in psi4.driver. class in psi4.driver.procrouting.empirical_dispersion. end() psi4.core.Slice method. EndLoop psi4.core.PsiReturnType attribute. energies_from_fcidump() in module psi4.driver. energy(). setting keywords. energy() in module psi4.driver. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ENERGY_LEVEL_SHIFT (DCT). engine psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. ENSURE_BT_CONVERGENCE (OPTKING). ENTHALPY. ENTHALPY CORRECTION. environment variable. ; BRIANQC_ENABLE, [1]. BRIANQC_INSTALL_PATH, [1], [2]. BRIANQC_SDK_INSTALL, [1]. CONDA_PREFIX, [1], [2]. CRAY_ADD_RPATH. CRAYPE_LINK_TYPE. HOST, [1], [2]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE, [1]. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PSIDATADIR, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20]. PYTHONPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11]. VMDPATH, [1]. EOM_GUESS (CCEOM). EOM_REFERENCE (CCEOM). (CCHBAR). EP2_CONVERGENCE (DFEP2). EP2_MAXITER (DFEP2). EP2_NUM_EA (DFEP2). EP2_NUM_IP (DFEP2). EP2_ORBITALS (DFEP2). E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:54642,variab,variable,54642,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['variab'],['variable']
Modifiability,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:6898,plugin,plugin,6898,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,30,['plugin'],['plugin']
Modifiability,ctronInt method. update_geometry() psi4.core.Molecule method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Vb() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_dot() psi4.core.Matrix method. vector_multiply() psi4.core.CIVector method. vectors() psi4.core.FISAPT method. version() in module psi4.core. vibanal_wfn() in module psi4.driver. vi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:148259,variab,variable,148259,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['variab'],['variable']
Modifiability,"ctupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE CHARGES¶; Per-atom valence charges [e] computed from an MBIS partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3). MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:35274,config,configuration,35274,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,1,['config'],['configuration']
Modifiability,"cular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(key). get_variables(). get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_array_variable(arg0); Is the Matrix QC variable (case-insensitive) set?. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:296754,variab,variable,296754,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"cular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.set_global_option('SCF_TYPE', 'DF'); energy('scf', **kwargs). PsiMod.set_global_option('dft_functional', 'wB97'); PsiMod.set_global_option('dft_order_spheric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:3953,plugin,plugin,3953,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,2,['plugin'],['plugin']
Modifiability,"cule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:7184,coupling,coupling,7184,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,13,['coupling'],['coupling']
Modifiability,"cule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7048,coupling,coupling,7048,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['coupling'],['coupling']
Modifiability,"cule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal Psi4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. 2aminopyridine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; 2-aminopyridine, S22 Complex Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; N -0.297712 -1.170382 0.001714; C -0.912531 0.026013 0.004723; C -0.175714 1.226496 0.003700; C 1.204216 1.176210 0.000547; C 1.842683 -0.065832 -0.001280; C 1.045154 -1.196712 0.000533; H -0.697132 2.173907 0.003778; H 1.778223 2.092763 0.001427; H 2.918377 -0.152929 -0.000909; H 1.493951 -2.183173 0.004591; N -2.277071 0.027597 -0.043650; H -2.727502 0.885639 0.221497; H -2.756811 -0.823399 0.254372. pyrazine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by Chem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:6342,coupling,coupling,6342,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['coupling'],['coupling']
Modifiability,"cule) → psi4.core.Vector¶; Prints the rotational constants of the molecule. rotational_symmetry_number(self: psi4.core.Molecule) → int¶; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Compute dispersion correction using Grimme’s DFTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; effic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:138934,extend,extended,138934,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['extend'],['extended']
Modifiability,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without du",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15911,extend,extended,15911,psi4manual/1.9.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html,2,['extend'],['extended']
Modifiability,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[list[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without du",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:15912,extend,extended,15912,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,2,['extend'],['extended']
Modifiability,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html:15763,extend,extended,15763,psi4manual/1.6.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html,6,['extend'],['extended']
Modifiability,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:15656,extend,extended,15656,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,4,['extend'],['extended']
Modifiability,"culeE {lvalue},i). psi4.Molecule.symmetrize()¶; Python Library Documentation: method symmetrize; symmetrize(...) unbound psi4.Molecule method. symmetrize( (Molecule)arg1, (float)arg2) -> None :. Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; C++ signature :. void symmetrize(N3psi8MoleculeE {lvalue},d). psi4.Molecule.translate()¶; Python Library Documentation: method translate; translate(...) unbound psi4.Molecule method. translate( (Molecule)arg1, (Vector3)arg2) -> None :. Translates molecule by arg2; C++ signature :. void translate(N3psi8MoleculeE {lvalue},N3psi7Vector3E). psi4.Molecule.units()¶; Python Library Documentation: property. Units (Angstrom or Bohr) used to define the geometry. psi4.Molecule.update_geometry()¶; Python Library Documentation: method update_geometry; update_geometry(...) unbound psi4.Molecule method. update_geometry( (Molecule)arg1) -> None :. Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; C++ signature :. void update_geometry(N3psi8MoleculeE {lvalue}). psi4.Molecule.x()¶; Python Library Documentation: method x; x(...) unbound psi4.Molecule method. x( (Molecule)arg1, (int)arg2) -> float :. x position of atom; C++ signature :. d x(N3psi8MoleculeE {lvalue},i). psi4.Molecule.y()¶; Python Library Documentation: method y; y(...) unbound psi4.Molecule method. y( (Molecule)arg1, (int)arg2) -> float :. y position of atom; C++ signature :. d y(N3psi8MoleculeE {lvalue},i). psi4.Molecule.z()¶; Python Library Documentation: method z; z(...) unbound psi4.Molecule method. z( (Molecule)arg1, (int)arg2) -> float :. z position of atom; C++ signature :. d z(N3psi8MoleculeE {lvalue},i). MultipoleInt¶. psi4.MultipoleInt.basis()¶; Python Library Documentation: property. The basis set on center one. psi4.MultipoleInt.basis1()¶; Python Library Documentation: property. The basis set on center",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:257142,variab,variable,257142,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variable']
Modifiability,"currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:89773,variab,variable,89773,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,10,['variab'],['variable']
Modifiability,"cution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:5905,plugin,plugin,5905,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,30,['plugin'],['plugin']
Modifiability,"cy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. COSXAn algorithm based on the semi-numerical “chain of spheres exchange” (COSX); approach described in [Neese:2009:98]. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See the COSX section below for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:27298,config,configurations,27298,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['config'],['configurations']
Modifiability,"d LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math library (better than MKL for AMD processors); ../configure --prefix=/usr/local/psi4 --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with-opt=-O2 --with-blas=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"" --with-lapack=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:7276,config,configure,7276,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"d LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math library (better than MKL for AMD processors); ../configure --prefix=/usr/local/psi4 --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with-opt=-O2 --with-blas=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"" --with-lapack=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install Xcode.; However, Xcode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:8076,config,configure,8076,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configure']
Modifiability,"d Windows, through the Ubuntu shell).; If using the PSI4 binary, Libint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint. Source. Note that PSI4 uses v1. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint/libint.h; Libint_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing share/cmake/Libint/LibintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint — CMake variable to force detecting pre-built Libint and not falling back on internal build; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint=ON. Build bundled shared library with ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libint-1.html:1910,variab,variable,1910,psi4manual/1.4.0/libint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libint-1.html,4,['variab'],['variable']
Modifiability,"d automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. TURN_ON_ACTV (MCSCF)¶MCSCF —. Type: integer; Default: 0. UHF_NOONS (SCF)¶SCF — The number of NOONs to print in a UHF calc. Type: string; Default: 3. UPDATE (DETCI)¶DETCI — The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. USE_DF_INTS (FNOCC)¶FNOCC (Expert) — Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. USE_SPIN_SYM (PSIMRCC)¶PSIMRCC — Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. USE_SPIN_SYMMETRY (PSIMRCC)¶PSIMRCC (Expert) — Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. VAL_EX_LEVEL (DETCI)¶DETCI — In a RAS CI, this is the additional excitation level for allowing electrons out of RAS I into RAS II. The maximum number of holes in RAS I is therefore EX_LEVEL + VAL_EX_LEVEL. Type: integer; Default: 0. VECS_CC3 (CCEOM)¶CCEOM — Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT (CCEOM)¶CCEOM — Vectors stored per root. Type: integer; Default: 12. WABEI_LOWDISK (CCHBAR)¶CCHBAR — Do use the minimal-disk algorithm for Wabei? It’s VERY slow!. Type: boolean; Default: false. WCOMBINE (SCF)¶SCF — combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Default is True for MemDFJK (itself the default for SCF_TYPE DF), False otherwise as not yet implemented. Type: boolean; Default: false. WFN (CCDENSITY)¶CCDENSITY (Expert) — Wavefunction type. Type: string; Default: SCF. WFN (CCENERGY)¶CCENERGY (Expert) — Wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:228697,config,configurations,228697,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['config'],['configurations']
Modifiability,"d automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. TURN_ON_ACTV (MCSCF)¶MCSCF —. Type: integer; Default: 0. UHF_NOONS (SCF)¶SCF — The number of NOONs to print in a UHF calc. Type: string; Default: 3. UPDATE (DETCI)¶DETCI — The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. USE_DF_INTS (FNOCC)¶FNOCC (Expert) — Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. USE_SPIN_SYM (PSIMRCC)¶PSIMRCC — Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. USE_SPIN_SYMMETRY (PSIMRCC)¶PSIMRCC (Expert) — Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. VAL_EX_LEVEL (DETCI)¶DETCI — In a RAS CI, this is the additional excitation level for allowing electrons out of RAS I into RAS II. The maximum number of holes in RAS I is therefore EX_LEVEL + VAL_EX_LEVEL. Type: integer; Default: 0. VECS_CC3 (CCEOM)¶CCEOM — Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT (CCEOM)¶CCEOM — Vectors stored per root. Type: integer; Default: 12. WABEI_LOWDISK (CCHBAR)¶CCHBAR — Do use the minimal-disk algorithm for Wabei? It’s VERY slow!. Type: boolean; Default: false. WCOMBINE (SCF)¶SCF — combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Disabled until fixed. Type: boolean; Default: false. WFN (CCDENSITY)¶CCDENSITY (Expert) — Wavefunction type. Type: string; Default: SCF. WFN (CCENERGY)¶CCENERGY (Expert) — Wavefunction type. Type: string; Default: NONE. WFN (CCEOM)¶CCEOM (Expert) — Wavefunction type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:231072,config,configurations,231072,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,6,['config'],['configurations']
Modifiability,"d auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → Annotated[List[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18337,variab,variable,18337,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"d back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/share/databases.; Alternately, append the directory containing your new database into; PSIPATH. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Customization: Adding Simple Extensions. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html:3555,variab,variable,3555,psi4manual/1.1.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"d by configuration; interaction, coupled cluster uses an exponential expansion,. (1)¶\[\begin{split}| \Psi \rangle &= e^{\hat{T}} | \Phi_0 \rangle \\; &= \left( 1 + {\hat{T}} + \frac{1}{2} {\hat{T}}^2 + \frac{1}{3!}{\hat{T}}^3 + \cdots \right) | \Phi_0 \rangle,\end{split}\]; where the cluster operator \({\hat{T}}\) is written as a sum of operators that; generate singly-excited, doubly-excited, etc., determinants:. \[{\hat{T}} = {\hat{T}_1} + {\hat{T}_2} + {\hat{T}_3} + \cdots + {\hat{T}_N},\]; with. \[\begin{split}{\hat T}_1 | \Phi_0 \rangle &= \sum_{i}^{\rm occ} \sum_a^{\rm vir} t_i^a | \Phi_i^a \rangle \\; {\hat T}_2 | \Phi_0 \rangle &= \sum_{i<j}^{\rm occ} \sum_{a<b}^{\rm vir} t_{ij}^{ab} | \Phi_{ij}^{ab} \rangle,\end{split}\]; etc. The popular coupled cluster singles and doubles (CCSD) model; [Purvis:1982] truncates the expansion at \({\hat{T}} = {\hat{T}_1}; + {\hat{T}_2}\). This model has the same number of parameters as; configuration interaction singles and doubles (CISD) but improves upon; it by approximately accounting for higher-order terms using products; of lower-order terms (e.g., the term \({\hat{T}_2}^2\) approximately; accounts for quadruple excitations). The inclusion of such products; makes coupled-cluster methods size extensive, meaning that the; quality of the computation should not degrade for larger molecules.; The computational cost for CCSD scales as \({\cal{O}}(o^2 v^4)\), where; \(o\) is the number of occupied orbitals and \(v\) is the number of virtual; orbitals.; Improving upon CCSD, the CCSD(T) method [Raghavachari:1989] includes; a perturbative estimate of the energy contributed by the \({\hat{T}_3}\); operator. The computational cost of this additional term scales as; \({\cal{O}}(o^3 v^4)\), making it rather expensive for molecules with more than; a dozen heavy atoms or so. However, when this method is affordable, it; provides very high quality results in most cases.; PSI4 is capable of computing energies and analytic gradients for a;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cc-1.html:1676,config,configuration,1676,psi4manual/1.2.1/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cc-1.html,15,['config'],['configuration']
Modifiability,"d by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list) → None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str) → None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:29508,extend,extended,29508,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['extend'],['extended']
Modifiability,"d correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:22921,config,configuration,22921,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['config'],['configuration']
Modifiability,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | DipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:22495,inherit,inherited,22495,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntegralFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntegralFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (BasisSet)arg2, (BasisSet)arg3, (BasisSet)arg4, (BasisSet)arg5) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2 [, (BasisSet)arg3]) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:63252,inherit,inherited,63252,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:34912,inherit,inherited,34912,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"d from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | occupation_a(...); | occupation_a( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_a(N3psi3scf2HFE {lvalue}); | ; | occupation_b(...); | occupation_b( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_b(N3psi3scf2HFE {lvalue}); | ; | semicanonicalize(...); | semicanonicalize( (HF)arg1) -> None :; | docstring; | ; | C++ signature :; | void semicanonicalize(N3psi3scf2HFE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca(N3psi12WavefunctionE {lvalue}); | ; | Ca_subset(...); | Ca_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca_subset(N3psi12WavefunctionE {lvalue},Ss,Ss); | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Cb(N3psi12WavefunctionE {lvalue}); | ; | Cb_subset(...); | Cb_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Cb_subset(N3psi12WavefunctionE {lvalue},Ss,Ss); | ; | Da(...",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:478678,inherit,inherited,478678,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"d gradient, as a N by 3 Matrix object. get_legacy_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_local_option((arg0: str, ...); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(() -> int); Returns the amount of memory available to Psi (in bytes). get_num_threads(() -> int); Returns the number of threads to use in SMP parallel computations. get_option((arg0: str, arg1: str) -> object); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_output_file(() -> str). get_variable((arg0: str) -> float); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(() -> Dict[str, float]); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix((arg0: str) -> str); Returns the prefix to use for writing files for external programs. git_version(() -> str); Returns the git version of this copy of Psi. has_global_option_changed((arg0: str) -> bool); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed((arg0: str, ...); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed((arg0: str, ...); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:167023,variab,variables,167023,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"d identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON); option_with_print(ENABLE_AUTO_LAPACK ""Enables CMake to auto-detect LAPACK"" ON); option_with_print(ENABLE_PLUGIN_TESTING ""Test the plugin templates build and run"" OFF); option_with_flags(ENABLE_XHOST ""Enables processor-specific optimization (with MSVC, it enables AVX2 instructions)"" ON; ""-xHost"" ""-march=native"" ""/arch:AVX2""); option_with_flags(ENABLE_CODE_COVERAGE ""Enables details on code coverage"" OFF; ""-ftest-coverage""); option_with_flags(ENABLE_BOUNDS_CHECK ""Enables bounds check in Fortran"" OFF; ""-ftrapuv -check all -fpstkchk"" ""-fcheck=all"" ""-fbounds-check -fcheck-array-temporaries""); option_with_flags(ENABLE_ASAN ""Enables address sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=address -fno-omit-frame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=thread -fPIE -pie -fno-omit-frame-pointer""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=undefined -fno-omit-frame-pointer""); option_with_flags(ENABLE_MSAN ""Enables memory sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2). Note that external projects will have their own sets of build; configuration o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:16522,plugin,plugin,16522,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['plugin'],['plugin']
Modifiability,"d name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if (core.variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:72929,variab,variable,72929,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"d name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if (core.variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:91912,variab,variable,91912,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"d or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. libint2_solid_harmonics_ordering(); The solid harmonics setting of Libint2 currently active for Psi4. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:7415,plugin,plugins,7415,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['plugin'],['plugins']
Modifiability,"d psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Update to latest Psi4 version; >>> conda update psi4. Install into a conda environment “p4env” instead of “root”. Second command only works on bash; for csh/tsch, setenv PATH /path/to/miniconda/envs/p4env/bin:$PATH instead. This creates a sandbox with just Psi4 and python (loaded as dependency).; >>> conda create -y -n p4env psi4; >>> source activate p4env. Install a particular Psi4 version; >>> conda install psi4=0.1.12. Uninstall Psi4 from current environment; >>> conda remove psi4. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for reference, 2.10 is newer than 2.7; unlike most libraries, libc generally not available in multiple versions on a computer), the Psi4 conda package won’t work.; # unsuitable computer; >>> ldd --version; ldd (GNU libc) 2.5; # suitable computer; >>> ldd --version; ldd (GNU libc) 2.17. It is of greatest importance that the Psi4 executable be linked against conda libpython.so not against any system libpython.so. This is arranged by setting RPATH to seek libraries relative to executable (thanks, conda binary relocation routine!). The conda Psi4 executable is not vulnerable to interference from your LD_LIBRARY_PATH settings. Below shows a well-linked executable. no libraries “not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/conda-1.html:13723,sandbox,sandbox,13723,psi4manual/1.0.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/conda-1.html,2,['sandbox'],['sandbox']
Modifiability,"d set_default_path(N3psi11PSIOManagerE {lvalue},Ss); | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_specific_path(N3psi11PSIOManagerE {lvalue},i,Ss); | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_specific_retention(N3psi11PSIOManagerE {lvalue},i,b); | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | C++ signature :; | void write_scratch_file(N3psi11PSIOManagerE {lvalue},Ss,Ss); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi11PSIOManagerEEE shared_object(); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __init__( (object)arg1, (int)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,i); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:494670,inherit,inherited,494670,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"d since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:2608,variab,variable,2608,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"d to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc54; CCSD dipole with user-specified basis set. cubeprop; RHF orbitals and density for water. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. sapt11; sapt example with orbital freezing with alkali metal and dMP2. scf-guess-read2; Test if the the guess read in the same basis converges. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:1706,variab,variables,1706,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"d"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html:3736,plugin,plugin,3736,psi4manual/1.3.2/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html,2,['plugin'],['plugin']
Modifiability,"d(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join([name.upper(), which_ind, 'ENERGY'])):; which_ind='IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:104937,variab,variable,104937,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"d(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:7198,plugin,plugin,7198,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['plugin'],['plugin']
Modifiability,"d(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:7196,plugin,plugin,7196,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['plugin'],['plugin']
Modifiability,"d(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None; docstring. clear_external_potentials(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:12197,variab,variables,12197,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['variab'],['variables']
Modifiability,"d); in Bohr or coordinate at posn; >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. y(atom)[source]¶; y position of atom (0-indexed) in Bohr; >>> print H2OH2O.y(4); -0.706268134631. z(atom)[source]¶; z position of atom (0-indexed) in Bohr; >>> print H2OH2O.z(4); -1.43347254509. Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; File to. dictify_database_docstrings()[source]¶. drop_duplicates(seq)[source]¶; Function that given an array or array of arrays seq, returns an; array without any duplicate entries. There is no guarantee of which; duplicate entry is dropped. useful()[source]¶. Module with non-generic exceptions classes. exception FeatureNotImplemented(msg)[source]¶; Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. exception IncompleteAtomError(msg)[source]¶; Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom forma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:63519,variab,variables,63519,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"d, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:26434,config,configurations,26434,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['config'],['configurations']
Modifiability,"d, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html:7493,extend,extend,7493,psi4manual/1.8.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html,2,['extend'],['extend']
Modifiability,"d, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]def set_output_file(ofile: str, append: bool = False, *, loglevel: int = 20, execute: bool = True) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/extras.html:6973,extend,extend,6973,psi4manual/1.7.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/extras.html,2,['extend'],['extend']
Modifiability,"d. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Single-Point Energy, energy(); Next topic; Counterpoise Correct. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/prop-1.html:1320,config,configurational,1320,psi4manual/1.0.0/prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/prop-1.html,2,['config'],['configurational']
Modifiability,"d. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. Free-atom volumes; MBIS_VOLUME_RATIOS. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in properties() function, e.g.:; properties('ccsd', properties=['dipole']). The properties() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of properties() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/oeprop.html:2650,variab,variables,2650,psi4manual/1.7.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/oeprop.html,2,['variab'],['variables']
Modifiability,"d3bjatm. hcth120-d3zero2b. hcth120-d3zeroatm. hcth147; HCTH147 GGA Exchange-Correlation Functional. hcth407; HCTH407 GGA Exchange-Correlation Functional. hcth407-d3bj2b. hcth407-d3bjatm. hcth407-d3zero2b. hcth407-d3zeroatm. hcth407p; HCTH407P GGA Exchange-Correlation Functional. hcth93; HCTH93 GGA Exchange-Correlation Functional. hcthp14; HCTHP14 GGA Exchange-Correlation Functional. hcthp76; HCTHP76 GGA Exchange-Correlation Functional. hf; Hartree–Fock theory. hf+d. hf-d3bj2b. hf-d3bjatm. hf-d3mbj2b. hf-d3mbjatm. hf-d3mzero2b. hf-d3mzeroatm. hf-d3zero2b. hf-d3zeroatm. hf-nl; Hartree–Fock theory. hf3c; Hartree Fock based 3C composite method with minimal basis set, gCP and D3(BJ). hpbeint; HPBEINT Hyb-GGA Exchange-Correlation Functional. kmlyp; KMLYP Hyb-GGA Exchange-Correlation Functional. ksdt; KSDT Exchange-Correlation Functional. kt2; KT2 GGA Exchange-Correlation Functional. lda0; LDA0 Exchange-Correlation Functional. m05; M05 Meta-GGA XC Functional. m05-2x; Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. m05-2x-d3zero2b. m05-2x-d3zeroatm. m05-d3zero2b. m05-d3zeroatm. m06; M06 Meta-GGA XC Functional. m06-2x; Hybrid M06-2X Meta-GGA XC Functional. m06-2x-d3zero2b. m06-2x-d3zeroatm. m06-d3zero2b. m06-d3zeroatm. m06-hf; Minnesota M06-HF Hybrid XC Functional. m06-hf-d3zero2b. m06-hf-d3zeroatm. m06-l; M06-L Meta-GGA XC Functional. m06-l-d3zero2b. m06-l-d3zeroatm. m08-hx; Minnesota M08-HX Hybrid XC Functional. m08-hx-d3zero2b. m08-hx-d3zeroatm. m08-so; Minnesota M08-SO Hybrid XC Functional. m11-l; M11-L Meta-GGA XC Functional. m11-l-d3bj2b. m11-l-d3bjatm. m11-l-d3zero2b. m11-l-d3zeroatm. mb3lyp-rc04; MB3LYP-RC04 Hyb-GGA Exchange-Correlation Functional. mgga_ms0; MGGA_MS0 Meta-GGA XC Functional. mgga_ms1; MGGA_MS1 Meta-GGA XC Functional. mgga_ms2; MGGA_MS2 Meta-GGA XC Functional. mgga_ms2h; MGGA_MS2h Hybrid Meta-GGA XC Functional. mgga_ms2h-d3opatm. mgga_mvs; MGGA_MVS Meta-GGA XC Functional. mgga_mvsh; MGGA_MV2h Hybrid Meta-GGA XC Functional. mn12-l; MN12-L Me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:8033,Parameteriz,Parameterized,8033,psi4manual/1.8.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html,2,['Parameteriz'],['Parameterized']
Modifiability,"d3bjatm. hcth120-d3zero2b. hcth120-d3zeroatm. hcth147; HCTH147 GGA Exchange-Correlation Functional. hcth407; HCTH407 GGA Exchange-Correlation Functional. hcth407-d3bj2b. hcth407-d3bjatm. hcth407-d3zero2b. hcth407-d3zeroatm. hcth407p; HCTH407P GGA Exchange-Correlation Functional. hcth93; HCTH93 GGA Exchange-Correlation Functional. hcthp14; HCTHP14 GGA Exchange-Correlation Functional. hcthp76; HCTHP76 GGA Exchange-Correlation Functional. hf; Hartree–Fock theory. hf+d. hf-d3bj2b. hf-d3bjatm. hf-d3mbj2b. hf-d3mbjatm. hf-d3mzero2b. hf-d3mzeroatm. hf-d3zero2b. hf-d3zeroatm. hf-nl; Hartree–Fock theory. hf3c; Hartree Fock based 3C composite method with minimal basis set, gCP and D3(BJ). hpbeint; HPBEINT Hyb-GGA Exchange-Correlation Functional. kmlyp; KMLYP Hyb-GGA Exchange-Correlation Functional. ksdt; KSDT Exchange-Correlation Functional. kt2; KT2 GGA Exchange-Correlation Functional. lda0; LDA0 Exchange-Correlation Functional. m05; M05 Meta-GGA XC Functional. m05-2x; Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. m05-2x-d3zero2b. m05-2x-d3zeroatm. m05-d3zero2b. m05-d3zeroatm. m06; M06 Meta-GGA XC Functional. m06-2x; Hybrid M06-2X Meta-GGA XC Functional. m06-2x-d3zero2b. m06-2x-d3zeroatm. m06-d3zero2b. m06-d3zeroatm. m06-hf; Minnesota M06-HF Hybrid XC Functional. m06-hf-d3zero2b. m06-hf-d3zeroatm. m06-l; M06-L Meta-GGA XC Functional. m06-l-d3zero2b. m06-l-d3zeroatm. m08-hx; Minnesota M08-HX Hybrid XC Functional. m08-hx-d3zero2b. m08-hx-d3zeroatm. m08-so; Minnesota M08-SO Hybrid XC Functional. m11-l; M11-L Meta-GGA XC Functional. m11-l-d3bj2b. m11-l-d3bjatm. m11-l-d3zero2b. m11-l-d3zeroatm. mb3lyp-rc04; MB3LYP-RC04 Hyb-GGA Exchange-Correlation Functional. mgga_ms0; MGGA_MS0 Meta-GGA XC Functional. mgga_ms1; MGGA_MS1 Meta-GGA XC Functional. mgga_ms2; MGGA_MS2 Meta-GGA XC Functional. mgga_ms2h; MGGA_MS2h Hybrid Meta-GGA XC Functional. mgga_mvs; MGGA_MVS Meta-GGA XC Functional. mgga_mvsh; MGGA_MV2h Hybrid Meta-GGA XC Functional. mn12-l; MN12-L Meta-GGA XC Functiona",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:8002,Parameteriz,Parameterized,8002,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,2,['Parameteriz'],['Parameterized']
Modifiability,d; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energie,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1768584,variab,variables,1768584,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['variab'],['variables']
Modifiability,"d; configuration interaction level of theory and root.; Deprecated in favor of CI DIPOLE. CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory.; Deprecated in favor of CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory.; Deprecated in favor of CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n QUADRUPO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:11495,config,configuration,11495,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"d; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the psi4.set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example inpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:10375,variab,variables,10375,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['variab'],['variables']
Modifiability,"d; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:12294,variab,variables,12294,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variables']
Modifiability,"d_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:9491,variab,variables,9491,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,6,['variab'],['variables']
Modifiability,"d_ptrIN3psi6MatrixEEE get_metric(N3psi13FittingMetricE {lvalue}); | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9IntVectorEEE get_pivots(N3psi13FittingMetricE {lvalue}); | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9IntVectorEEE get_reverse_pivots(N3psi13FittingMetricE {lvalue}); | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | C++ signature :; | b is_inverted(N3psi13FittingMetricE {lvalue}); | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | C++ signature :; | b is_poisson(N3psi13FittingMetricE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | C++ signature :; | d alpha(N3psi10FunctionalE {lvalue}); | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | C++ signature :; | Ss citation(N3psi10FunctionalE {lvalue}); | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | C++ signature :; | Ss description(N3psi10FunctionalE {lvalue}); | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | C++ signature :; | b is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:465429,inherit,inherited,465429,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"da install gcp -c psi4 or the newer implementation; through conda install gcp-correction -c conda-forge.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4; or conda install gcp-correction -c conda-forge.; To remove a conda installation, conda remove gcp or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:1835,variab,variables,1835,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['variab'],['variables']
Modifiability,"da install gcp -c psi4 or the newer implementation; through conda install gcp-correction -c conda-forge.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4; or conda install gcp-correction -c conda-forge.; To remove a conda installation, conda remove gcp or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672], “PBEh-3c”; [Grimme:2015:054107], “B97-3c” [Brandenburg:2018:b973c], “r2SCAN-3c” [Grimme:2021:064103],; and “wB97X-3c” [Muller:2023:014103] methods (both energy and gradient).; The interface can use classic or mctc-gcp executables but only the latter implements “B97-3c” and “r2SCAN-3c”.; The newest wB97X-3c method doesn’t use a gcp correction (it does use ECPs down to first row elements); but is listed here for completeness of the “3c” family.; A DFTD3 executable, classic or simple-dftd3, must also be available for; the HF-3c, PBEh-3c, or B97-3c methods to run.; A DFTD4 python module must also be available for; the r2SCAN-3c or wB97X-3c methods to run.; These method are defined with their own basis set and thus no basis set should be set by the user.; PSI4 will select the intended basis sets: HF-3c/MINIX, PB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gcp.html:1964,variab,variables,1964,psi4manual/1.9.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gcp.html,2,['variab'],['variables']
Modifiability,"da package for Linux and macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, Libint has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint. Source. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint/libint.h; Libint_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing share/cmake/Libint/LibintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint — CMake variable to force internal build of Libint instead of detecting pre-built. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Proje",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libint-1.html:1540,variab,variable,1540,psi4manual/1.1.0/libint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libint-1.html,2,['variab'],['variable']
Modifiability,"da package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, gau2grid has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure ga",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gau2grid-1.html:1529,variab,variable,1529,psi4manual/1.4.0/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gau2grid-1.html,9,['variab'],['variable']
Modifiability,"darray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cart",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:24086,adapt,adapted,24086,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['adapt'],['adapted']
Modifiability,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:7415,plugin,plugin,7415,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,6,['plugin'],['plugin']
Modifiability,"data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1); posnS = []; for weft in range(Nweft):; posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); posnT = []; for weft in range(Nweft - 1):; posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); posnM = []. # initialize plot; fht = Nweft * 0.8; #fig, ax = plt.subplots(figsize=(12, fht)); fig, ax = plt.subplots(figsize=(11, fht)); plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # prepara",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:17700,extend,extend,17700,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"datafile'); if(PsiMod.me() == 0):; shutil.copy(restartfile, get_psifile(1)). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = PsiMod.get_gradient(); PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; PsiMod.set_gradient(G); PsiMod.set_global_option('CART_HESS_READ', True); elif ((full_hess_every == -1) and (PsiMod.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); PsiMod.print_out('\n Final optimized geometry and variables:\n'); PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; PsiMod.print_out('\n Structure for next step:\n'); PsiMod.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'). optstash.restore(); return 0.0. ## Al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:53350,variab,variables,53350,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['variab'],['variables']
Modifiability,"dc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:3553,plugin,plugin,3553,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,6,['plugin'],['plugin']
Modifiability,"de ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may hav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:3490,variab,variable,3490,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['variab'],['variable']
Modifiability,"de does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:8775,config,configure,8775,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"de does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system rou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:9459,config,configure,9459,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"de does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:9575,config,configure,9575,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configure']
Modifiability,"de from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2316,Variab,Variables,2316,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Variab'],['Variables']
Modifiability,"de should live¶. New integral operators¶; Most of the heavy lifting in PSI4 is handled by libmints, which can be; found in the psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html:1242,variab,variables,1242,psi4manual/1.4.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html,9,['variab'],['variables']
Modifiability,"deHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. depreca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:46097,variab,variables,46097,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ded at runtime)"" OFF); option(ENABLE_psi4fockci ""Enables Psi4FockCI plugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:22679,plugin,plugins,22679,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['plugin'],['plugins']
Modifiability,"ded due to the extra I/O. Type: string; Possible Values: NONE, DISK; Default: NONE. DCFT_FUNCTIONAL¶. Chooses appropriate DCFT method. Type: string; Possible Values: DC-06, DC-12, CEPA0; Default: DC-06. DIIS_START_CONVERGENCE¶. Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. LAMBDA_MAXITER¶. Maximum number of density cumulant update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of density cumulant response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. MAXITER¶. Maximum number of the macro-iterations for both the energy and the solution of the response equations. Type: integer; Default: 40. QC_COUPLING¶. Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC only). Type: boolean; Default: true. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: UHF; Default: UHF. RESPONSE_ALGORITHM¶. The algorithm to use for the solution of the response equations for the analytic gradients and properties. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. R_CONVERGENCE¶. Convergence criterion for the RMS of the residual vector in the density cumulant updates, as well as the solution of the density cumulant and orbital response equations. In the orbital updates controls the RMS of the SCF error vector. Type: conv double; Default: 1e-10. SCF_MAXITER¶. Maximum number of the orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. Expert¶. CACHELEVEL¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html:2080,coupling,coupling,2080,psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,8,['coupling'],['coupling']
Modifiability,"default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = core.variable('CURRENT ENERGY'). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = core.variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * core.variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. core.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; core.set_variable('DFT TOTAL ENERGY', returnvalue); core.set_variable('CURRENT ENERGY', returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:61392,variab,variables,61392,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variables']
Modifiability,"dent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/simint-1.html:3190,config,configdir,3190,psi4manual/1.2.1/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/simint-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:8286,inherit,inherited,8286,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = psi4.DiagonalizeOrder.Ascending; | ; | Descending = psi4.DiagonalizeOrder.Descending; | ; | names = {'Ascending': psi4.DiagonalizeOrder.Ascending, 'Descending': p...; | ; | values = {1: psi4.DiagonalizeOrder.Ascending, 3: psi4.DiagonalizeOrder...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:15721,inherit,inherited,15721,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"des in which: [the excitation level (holes in I + II) is equal to ex_lvl] AND [there are more than max_holes_I holes in RAS I, there are more than max_parts_IV particles in RAS IV, OR there are more than max_I+IV quasiparticles in RAS I + RAS IV]. Type: array; Default: No Default. CC_MIXED¶. Do ignore block if num holes in RAS I and II is cc_ex_lvl and if any indices correspond to RAS I or IV (i.e., include only all-active higher excitations)?. Type: boolean; Default: true. CC_UPDATE_EPS¶. Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VARIATIONAL¶. Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. Expert Alternative Algorithms¶. BENDAZZOLI¶. Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. FCI_STRINGS¶. Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Expert MCSCF¶. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. This is a flag for the future. Type: string; Possible Values: ONE_STEP, TWO_STEP; Default: TWO_STEP. MCSCF_SO¶. Do second-order orbital-orbital MCSCF. Without one-step this typically slows the overall computation considerably. Type: boolean; Default: false. MCSCF_SO_START_E¶. Start second-order orbital-orbital MCSCF based on energy convergence. Type: double; Default: 1e-3. MCSCF_SO_START_GR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html:20974,extend,extended,20974,psi4manual/1.0.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html,2,['extend'],['extended']
Modifiability,"des in which: [the excitation level (holes in I + II) is equal to ex_lvl] AND [there are more than max_holes_I holes in RAS I, there are more than max_parts_IV particles in RAS IV, OR there are more than max_I+IV quasiparticles in RAS I + RAS IV]. Type: array; Default: No Default. CC_MIXED¶. Do ignore block if num holes in RAS I and II is cc_ex_lvl and if any indices correspond to RAS I or IV (i.e., include only all-active higher excitations)?. Type: boolean; Default: true. CC_UPDATE_EPS¶. Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VARIATIONAL¶. Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. Expert Alternative Algorithms¶. BENDAZZOLI¶. Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. FCI_STRINGS¶. Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Table Of Contents. DETCI; General Options; AVG_STATES; AVG_WEIGHTS; CIBLKS_PRINT; CI_NUM_THREADS; DETCI_FREEZE_CORE; EX_LEVEL; E_CONVERGENCE; FCI; ICORE; ISTOP; MAXITER; NUM_DETS_PRINT; NUM_ROOTS; REFERENCE; R_CONVERGENCE; S_SQUARED; VAL_EX_LEVEL. Specifying the CI Space; ACTIVE; A_RAS3_MAX; B_RAS3_MAX; MS0; RAS34_MAX; RAS3_MAX; RAS4_MAX; RESTRICTED_DOCC; RESTRICTED_UOCC; S. Diagonalization Methods; DIAG_METHOD; LSE; LSE_COLLAPSE; LSE_TOLERANCE; PRECONDITI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:21442,extend,extended,21442,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,16,['extend'],['extended']
Modifiability,"detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to use a local Add-On repository in the Psi4 build; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_faq-1.html:2093,config,configure,2093,psi4manual/1.4.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_faq-1.html,8,['config'],['configure']
Modifiability,"detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to use a local Add-On repository in the Psi4 build; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_faq.html:2386,config,configure,2386,psi4manual/master/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/build_faq.html,1,['config'],['configure']
Modifiability,"detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/libxc.html:1977,variab,variable,1977,psi4manual/1.7.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/libxc.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"detect that installation at compile-time. How to configure Libint for building Psi4. How to get high angular momentum integrals from conda¶; To switch from the default Libint package to the really large high AM; package, do the below. The channel/subchannel(s) containing the am8; metapackage and the high-AM Libint package must be supplied (or in; .condarc).; 1conda install am8 -c psi4. This switch-out only works for rebuilding PSI4, not for the psi4; conda package.; To go back to the default Libint package, do the below. The; channel/subchannel containing the default Libint package must be supplied; (or in .condarc); otherwise, it’ll just remove Libint and every package; depending on it.; 1conda remove --features am8 -c psi4. The default package is AM6 because of its manageable file size (on Linux,; 10MB for libint and 40MB for libderiv). The AM7 are 20/100, respectively,; and the AM8 is 50/210. How to see what build configuration options are available¶; CMake doesn’t provide a summary for this (unless you want to try the CMake; GUI, which the developers have never looked at). However, the top half of; the main CMakeLists.txt is a passable summary:; ################ Options: Overview and Not Otherwise Mentioned ###############. # <<< CMake build overview >>>; #; # >>> ls; # external/ COPYING psi4/ tests/ ...; # >>> cmake -H. -Bobjdir -DCMAKE_INSTALL_PREFIX=/path/to/install-psi4 ...; # ...; # -- Generating done; # -- Build files have been written to: /current/dir/objdir; # >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; # >>> make install. # <<< Required build dependencies that Psi4 can't build itself >>>; #; # - CMake (e.g., `conda install cmake`); # - C++ and C compilers (C++11 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - deepdiff (runtime only; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:8427,config,configuration,8427,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configuration']
Modifiability,"detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following comman",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:2595,config,configuring,2595,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configuring']
Modifiability,"determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_NUM_DOUBLET_ROOTS (MRCC); MRCC — Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS (MRCC); MRCC — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (DETCI); DETCI — Build natural orbitals? The orbtials will be reordered by occuption number. Type: boolean; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:167814,variab,variable,167814,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['variab'],['variable']
Modifiability,"dev. # if add-on updates required, try; >>> conda update psi4 -c psi4/label/dev -c psi4. How to use conda to compile Psi4 faster and easier¶; # Linux or Mac or Windows; # substitute x.x by 2.7|3.5|3.6 for alternate python versions; >>> conda create -n p4dev python=x.x psi4-dev -c psi4. Same for Linux/Mac/Windows. Substitute desired python version: 2.7, 3.5, 3.6. Fine; to choose your own env name. Activate environment, source activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For DGAS,; there’s a --disable-addons, but I don’t encourage it. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install NumPy and the executable add-ons (e.g., dftd3); >>> conda install numpy psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, and numpy. Of gcc-ness, it has minimal, run-time libraries,; not compilers, though, for Linux/Windows, full gcc and run-time gcc are the same.; It doesn’t have the run-time qc addons psi4-rt (e.g., dftd3) or build tools (e.g., sphinx and cmake).; psi4-dev - does not have psi4 itself or the run-time addons psi4-rt or numpy (though fine to install them; alongside). Does have all the link-time addons. Does have; cmake and sphinx (and python). Of gcc-ness, has full packages, that is,; compilers, not runtime packages.; Psi4conda installer - has full-featured psi4 itself, all link-time",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:7239,plugin,plugins,7239,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,4,"['plugin', 'variab']","['plugins', 'variables']"
Modifiability,"dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA¶; Code author: Shannon E. Houck; Section author: Shannon E. Houck. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed; in the paper by Houck et. al. [Houck:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the docum",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugin_psi4fockci.html:1082,plugin,plugin,1082,psi4manual/master/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/master/plugin_psi4fockci.html,1,['plugin'],['plugin']
Modifiability,"dex. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/psi/gits/hrw-demo/objdir_docs311cf_make/stage//usr/local/psi4/lib/')); except ImportError:; p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psiapi.html:1070,variab,variables,1070,psi4manual/1.8.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psiapi.html,1,['variab'],['variables']
Modifiability,"dex. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:1070,variab,variables,1070,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,1,['variab'],['variables']
Modifiability,dfmp2.txt; module__lmp2.txt; module__mcscf.txt; module__mp2.txt; module__omp2.txt; module__optking.txt; module__psimrcc.txt; module__sapt.txt; module__scf.txt. adc.txt; appendices.txt; autodoc_available_databases.txt; autodoc_available_plugins.txt; autodoc_dft_all.txt; autodoc_dft_disp.txt; autodoc_dft_energy.txt; autodoc_dft_gga.txt; autodoc_dft_hybrid.txt; autodoc_dft_lrc.txt; autodoc_dft_meta.txt; autodoc_driver.txt; autodoc_glossary_options_c.txt; autodoc_options_c_bymodule.txt; autodoc_psi4bases.txt; autodoc_psivariables_bymodule.txt; autodoc_testsuite.txt; basissets.txt; basissets_byelement.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; contributing.txt; cp.txt; customizing.txt; db.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; documentation.txt; energy.txt; external.txt; freq.txt; glossary_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; methods.txt; mrcc.txt; notes_c.txt; notes_py.txt; opt.txt; optking.txt; plugins.txt; programming.txt; prop.txt; psimod.txt; psimrcc.txt; psithonfunc.txt; psithoninput.txt; quickaddalias.txt; quickaddbasis.txt; quickadddatabase.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; tutorial.txt. /_static; ; basic.css; copybutton.js; doctools.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_sections.js; underscore.js. Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation. /autodir_options_c; ; CACHELEVEL — PSI4 [beta2] documentation; MEMORY — PSI4 [beta2] documentation; NEWTON_CONVERGENCE — PSI4 [beta2] documentation; NORM_TOLERANCE — PSI4 [beta2] documentation; NUM_AMPS_PRINT — PSI4 [beta2] documentation; POLE_MAXITER — PSI4 [beta2] documentation; PR — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; ROOTS_PER_IRREP — PSI4 [beta2] documentation; SEM_MAXITER — PSI4 [beta2] docume,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1007139,plugin,plugins,1007139,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugins']
Modifiability,dfmp2.txt; module__lmp2.txt; module__mcscf.txt; module__mp2.txt; module__omp2.txt; module__optking.txt; module__psimrcc.txt; module__sapt.txt; module__scf.txt. adc.txt; appendices.txt; autodoc_available_databases.txt; autodoc_available_plugins.txt; autodoc_dft_all.txt; autodoc_dft_disp.txt; autodoc_dft_energy.txt; autodoc_dft_gga.txt; autodoc_dft_hybrid.txt; autodoc_dft_lrc.txt; autodoc_dft_meta.txt; autodoc_driver.txt; autodoc_glossary_options_c.txt; autodoc_options_c_bymodule.txt; autodoc_psi4bases.txt; autodoc_psivariables_bymodule.txt; autodoc_testsuite.txt; basissets.txt; basissets_byelement.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; contributing.txt; cp.txt; customizing.txt; db.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; documentation.txt; energy.txt; external.txt; freq.txt; glossary_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; methods.txt; mrcc.txt; notes_c.txt; notes_py.txt; opt.txt; optking.txt; plugins.txt; programming.txt; prop.txt; psimod.txt; psimrcc.txt; psithonfunc.txt; psithoninput.txt; quickaddalias.txt; quickaddbasis.txt; quickadddatabase.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; tutorial.txt. _static; ; basic.css; copybutton.js; doctools.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_sections.js; underscore.js. <no title> — PSI4 [beta2] documentation; Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation. autodir_options_c; ; CACHELEVEL — PSI4 [beta2] documentation; MEMORY — PSI4 [beta2] documentation; NEWTON_CONVERGENCE — PSI4 [beta2] documentation; NORM_TOLERANCE — PSI4 [beta2] documentation; NUM_AMPS_PRINT — PSI4 [beta2] documentation; POLE_MAXITER — PSI4 [beta2] documentation; PR — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; ROOTS_PER_IRREP — PSI4 [beta2] documenta,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:902529,plugin,plugins,902529,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugins']
Modifiability,"dfmp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +-------------------------+-----",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:3774,variab,variables,3774,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['variab'],['variables']
Modifiability,"dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85232,variab,variable,85232,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_AT'); core.set_local_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85505,variab,variables,85505,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"di = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2275,Variab,Variables,2275,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,2,['Variab'],['Variables']
Modifiability,"di = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:2275,Variab,Variables,2275,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,1,['Variab'],['Variables']
Modifiability,"diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft], xvals[weft], None]); # thread = []; # for weft in range(Nweft - 1):; # thread.extend([xvals[weft], xvals[weft + 1], Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:14183,extend,extend,14183,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"dience. To this end, one can navigate to $(OBJDIR)/doc/sphinxman; and build the following targets.:; >>> make help # to see options; >>> make # to build html. >>> make html; >>> make html-user; >>> make html-prog; >>> make latexpdf-user; >>> make latexpdf-prog. This will build the following files, respectively.; build/html/index.html; build/html-user/index.html; build/html-prog/index.html; build/latex-prog/psi4_userman.pdf; build/latex-prog/psi4_progman.pdf. Much of the documentation is auto-generated from the source. At present,; this covers:. Physical Constants: psi4/include/physconst.h; Python Driver: docstrings from *.py files in psi4/lib/python; Databases: docstrings from *.py files in psi4/lib/databases; Basis Sets: *.gbs files in psi4/lib/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories. Some documentation is even extracted from Psi4 objects at runtime. PsiMod: docstrings for the PsiMod built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/documentation-1.html:2456,plugin,plugin,2456,psi4manual/4.0b2/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/documentation-1.html,4,['plugin'],['plugin']
Modifiability,"ding by :py:func:`~psi4.driver.p4util.set_options`. Returns; -------; Dict[str, Any]; Dictionary where keys are keyword names, either plain for those to be; set globally or mangled ""module__keyword"" for those to be set locally,; and values are keyword values. """"""; flat_options = {}; has_changed_snapshot = {module: core.options_to_python(module) for module in _modules}. for opt in core.get_global_option_list():; handled_locally = False; ghoc = core.has_global_option_changed(opt); opt_snapshot = {k: v[opt] for k, v in has_changed_snapshot.items() if opt in v}; for module, (lhoc, ohoc) in opt_snapshot.items():; if ohoc:; if lhoc:; key = module + '__' + opt; val = core.get_local_option(module, opt); else:; key = opt; val = core.get_global_option(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(curren",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:14917,plugin,plugin,14917,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,8,['plugin'],['plugin']
Modifiability,"ding new. library fragments, [1]. molecule specification. EFP class in psi4.core, [1]. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). efp_init() in module psi4.core, [1]. EFP_POL (EFP). EFP_POL_DAMPING (EFP). efp_set_options() in module psi4.core, [1]. EKT_EA (OCC). EKT_IP (DFOCC). (OCC). electric_field() psi4.core.IntegralFactory method, [1], [2]. ElectricFieldInt class in psi4.core, [1]. electrostatic() psi4.core.IntegralFactory method, [1], [2]. ElectrostaticInt class in psi4.core, [1]. EmpericalDispersion class in psi4.driver. EndLoop psi4.core.PsiReturnType attribute, [1], [2]. energy(). setting keywords. energy() in module psi4. in module psi4.driver. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. ENERGY_LEVEL_SHIFT (DCFT). ENSURE_BT_CONVERGENCE (OPTKING). environment variable. ; CRAYPE_LINK_TYPE. CRAY_ADD_RPATH. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34], [35]. PSIDATADIR, [1], [2], [3], [4], [5]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PYTHONPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9]. VMDPATH. EOM_GUESS (CCEOM). EOM_REFERENCE (CCEOM). (CCHBAR). EP_EA_POLES (OCC). EP_IP_POLES (OCC). EP_MAXITER (OCC). epsilon_a() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:38371,variab,variable,38371,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['variab'],['variable']
Modifiability,"dir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:; target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html:4659,plugin,plugin,4659,psi4manual/1.1.0/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html,2,['plugin'],['plugin']
Modifiability,"dir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install; # -or- general; >>> cmake --build objdir --target install -j`getconf _NPROCESSORS_ONLN`. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; >>> cmake -S. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> cmake --build . -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:3246,config,configuration,3246,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,6,['config'],['configuration']
Modifiability,"djust(left=0.01, right=0.99, hspace=0.3); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); ax.set_frame_on(False); if labeled:; ax.set_xticks([-0.5 * xlimit, -0.25 * xlimit, 0.0, 0.25 * xlimit, 0.5 * xlimit]); else:; ax.set_xticks([]); for tick in ax.xaxis.get_major_ticks():; tick.tick1line.set_markersize(0); tick.tick2line.set_markersize(0). # label plot and tiers; if labeled:; ax.text(-0.9 * xlimit, -0.25, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12); for weft in labels:; ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # preparation; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); slat = []; for weft in range(Nweft):; slat.extend([xvals[weft], xvals[weft], None]); thread = []; for weft in range(Nweft - 1):; thread.extend([xvals[weft], xvals[weft + 1], None]). # plotting; if Nweft == 1:; ax.plot(slat, posnS, '|', color=clr, markersize=20.0, mew=1.5, solid_capstyle='round'); else:; ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round', alpha=0.3). # converting into screen coordinates for image map; npxvals = [np.nan if val is None else val for val in xvals]; xyscreen = ax.transData.transform(zip(npxvals, positions)); xscreen, yscreen = zip(*xyscreen); posnM.extend(zip([rxn['db']] * Nweft, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * rand",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:18887,extend,extend,18887,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"dle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/interfacing.html:2154,config,configure,2154,psi4manual/1.6.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/interfacing.html,1,['config'],['configure']
Modifiability,"dled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/chemps2-1.html:8117,config,configure,8117,psi4manual/1.3.2/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/chemps2-1.html,4,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"dm_casscf::v2rdm_casscf.; Following the CMake project name (though not restricted to it –; PSI4 managment could change the pattern), the user flag to enable; an add-on is ENABLE_AddOn_name. Note that runtime-only; add-ons don’t go through this enabling process.; Internally, the ExternalProject_Add and dummy libraries as well as any; tests/ and external/ subdirectories should all be lowercase,; addon_name.; The conda package and internal to; PSI4 (that is, the ExternalProject_Add, dummy libraries, and any; tests/ and external/ subdirectories) should all be lowercase,; addon_name.; Alternatively, you can do everything mentioned here lowercase and just; have a different capitalization for an advertising name. After all,; that’s what PSI4 does. How to integrate an Add-On into build, testing, and docs¶. In all cases, put Add-Ons in alphabetic order, ignoring any “lib” in the name.; psi4/CMakeLists.txt. Add the ENABLE_AddOn_name line; Add the external_addon_name dependency to the psi4-core external project; Add the AddOn_name_DIR variable passing to the psi4-core external project. psi4/psi4/CMakeLists.txt. Add a block imitating Libint if Add-On required or CheMPS2 if not; required; If there are shared resources to the external that need; to be found by PSI4 in PSIDATADIR, follow the efpfrag; pattern of libefp to symlink them in. psi4/psi4/src/CMakeLists.txt. No changes should be required unless both (1) code in export_*; or core.cc needs the USING_AddOn_name definition or; AddOn header includes and (2) no binary PSI4 module (as; opposed to library PSI4 module with the AddOn target linked; is itself a direct dependency of target core. Basically,; try to leave this file alone, but if there are compile errors,; add the definitions/headers as needed. psi4/psi4/src/psi4/. If a module is needed to interface the AddOn to PSI4, try to; put “interface” in the name. Follow the pattern of CheMPS2 or gdma.; If non-required, be sure to conditionalize it with if(TARGET; AddOn::addon) in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html:2273,variab,variable,2273,psi4manual/1.4.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html,9,['variab'],['variable']
Modifiability,"docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html:2621,variab,variable,2621,psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,2,['variab'],['variable']
Modifiability,"docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2689,variab,variable,2689,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,6,['variab'],['variable']
Modifiability,"docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:29393,variab,variable,29393,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:12021,variab,variables,12021,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['variab'],['variables']
Modifiability,"docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; docstring. iteration_¶; docstring. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:11756,variab,variables,11756,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variables']
Modifiability,"documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:4403,plugin,plugin,4403,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,8,['plugin'],['plugin']
Modifiability,"documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/libefp-1.html:8662,config,configdir,8662,psi4manual/1.3.2/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/libefp-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"dot(dipder_q.T, B); dipder_cart = dipder_cart.T.reshape(data[""n_atom""], 9). massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); dipder_cart = (dipder_cart.T * massweighter).T. dipder_cart = dipder_cart.reshape(3 * data[""n_atom""], 3); return dipder_cart. def assemble_hessian_from_gradients(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of gradients. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2]; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]. def init_string(data):; return ("" Computing second-derivative from gradients using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} gradients passed in, including the reference geometry.\n"".format(len(displacements) + 1)). data = _initialize_findif(mol, freq_irrep_only, ""2_1"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). # For non-totally symmetric CdSALCs, a symmetry operation can convert + and - displacements.; # Good News: By taking advantage of that, we (potentially) ran less computations.; # Bad News: We need to find the - displacements from the + computations now.; # The next ~80 lines of code are dedicated to that task.; if data[""print_lvl""]:; core.print_out("" Generating complete list of displacements from unique ones.\n\n""). pg = mol.point_group(); ct = pg.char_table(); order = pg.order(). # Determine what atoms map to what other atoms under the point group operations.; # The py-side compute_atom_map will work whether mol is a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:30432,adapt,adapted,30432,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['adapt'],['adapted']
Modifiability,"double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE¶. IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP¶. Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__optking-1.html:1792,flexible,flexible,1792,psi4manual/4.0b2/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__optking-1.html,8,['flexible'],['flexible']
Modifiability,down into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:1811,config,configuration,1811,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['config'],['configuration']
Modifiability,"dratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. The electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. By default the; electronic Hessian also contains the matrix elements that couple the orbitals; and the density cumulant. The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems. If the computation of the coupling elements; is not desired, it can be turned off by setting QC_COUPLING to FALSE.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive ; cumulant updates. As a result, for the small closed-shell systems the two-step; algorithm is usually preferred, while for the larger systems and the molecules with the; open-shell character it is recommended to use the simultaneous algorithm. The; efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; and computing the terms that involve these integrals in the AO; basis. In order to d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:7938,coupling,coupling,7938,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['coupling'],['coupling']
Modifiability,"ds below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:4693,variab,variable,4693,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['variab'],['variable']
Modifiability,"ds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; # make; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install; # -or- general; >>> cmake --build objdir --target install -j`getconf _NPROCESSORS_ONLN`. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. Wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:2091,config,configuring,2091,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,3,['config'],['configuring']
Modifiability,"ds that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import my",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:3994,plugin,plugins,3994,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugins']
Modifiability,"ds: SCF to FCI ». oeprop() Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett. oeprop(wfn, *args[, title])[source]¶; Evaluate one-electron properties. Returns:None. Parameters:wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters:title (string) – label prepended to all psivars computed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). Psi4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of Psi4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s respons",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/oeprop-1.html:1187,variab,variables,1187,psi4manual/1.0.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/oeprop-1.html,2,['variab'],['variables']
Modifiability,"ds; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/interfacing-1.html:2059,config,configure,2059,psi4manual/1.5.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/interfacing-1.html,2,['config'],['configure']
Modifiability,dule psi4.core. MRCC_LEVEL (MRCC). mrcc_load_densities() in module psi4.core. MRCC_METHOD (MRCC). MRCC_NUM_DOUBLET_ROOTS (MRCC). MRCC_NUM_SINGLET_ROOTS (MRCC). MRCC_NUM_TRIPLET_ROOTS (MRCC). MRCC_OMP_NUM_THREADS (MRCC). MRCC_RESTART (MRCC). MRPT TOTAL ENERGY. MS0 (DETCI). mtd 128-POLE. mtd 128-POLE XXXXXXX. mtd 128-POLE XXXXXXY. mtd 128-POLE ZZZZZZZ. mtd 32-POLE. mtd 32-POLE XXXXX. mtd 32-POLE XXXXY. mtd 32-POLE ZZZZZ. mtd 64-POLE. mtd 64-POLE XXXXXX. mtd 64-POLE XXXXXY. mtd 64-POLE ZZZZZZ. mtd DIPOLE. mtd DIPOLE X. mtd DIPOLE Y. mtd DIPOLE Z. mtd HEXADECAPOLE. mtd HEXADECAPOLE XXXX. mtd HEXADECAPOLE XXXY. mtd HEXADECAPOLE ZZZZ. mtd OCTUPOLE. mtd OCTUPOLE XXX. mtd OCTUPOLE XXY. mtd OCTUPOLE XXZ. mtd OCTUPOLE XYY. mtd OCTUPOLE XYZ. mtd OCTUPOLE XZZ. mtd OCTUPOLE YYY. mtd OCTUPOLE YYZ. mtd OCTUPOLE YZZ. mtd OCTUPOLE ZZZ. mtd QUADRUPOLE. mtd QUADRUPOLE XX. mtd QUADRUPOLE XY. mtd QUADRUPOLE XZ. mtd QUADRUPOLE YY. mtd QUADRUPOLE YZ. mtd QUADRUPOLE ZZ. MULLIKEN CHARGES. multi-configurational self-consistent-field. ; CI. multiplicity. ; molecule. multiplicity() psi4.core.Molecule method. MultipoleInt class in psi4.core. MultipoleSymmetry class in psi4.core. multireference. N. n() psi4.core.CorrelationTable method. psi4.core.Dimension method. n_ecp_core() psi4.core.BasisSet method. n_ecp_shell_on_center() psi4.core.BasisSet method. n_frozen_core() psi4.core.BasisSet method. NablaInt class in psi4.core. nallatom() psi4.core.Molecule method. nalpha() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. nalphapi() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. name psi4.core.DerivCalcType attribut,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:91097,config,configurational,91097,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['config'],['configurational']
Modifiability,dule.txt; autodoc_testsuite_cfour.txt; autodoc_testsuite_corepsi4.txt; autodoc_testsuite_dftd3.txt; autodoc_testsuite_dmrg.txt; autodoc_testsuite_libefp.txt; autodoc_testsuite_mrcc.txt; autodoc_testsuite_pcmsolver.txt; basissets.txt; basissets_byelement.txt; basissets_byfamily.txt; basissets_tables.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; cfour.txt; cfour_table_energy.txt; cfour_table_grad.txt; chemps2.txt; conda.txt; contents.txt; contributing.txt; cubeprop.txt; customizing.txt; db.txt; dcft.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; dftd3.txt; diatomic.txt; dkh.txt; documentation.txt; energy.txt; external.txt; fchk.txt; fnocc.txt; freq.txt; gdma.txt; glossary_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; libefp.txt; methods.txt; molden.txt; mrcc.txt; mrcc_table_energy.txt; nbody.txt; notes_c.txt; notes_py.txt; occ.txt; oeprop.txt; opt.txt; optionshandling.txt; optking.txt; pcmsolver.txt; pep0001.txt; plugins.txt; proc_py.txt; prog_basissets.txt; programming.txt; prop.txt; psimrcc.txt; psipep.txt; psithonfunc.txt; psithoninput.txt; psithonmol.txt; quickaddalias.txt; quickadddatabase.txt; relativistic.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; thermo.txt; tutorial.txt. /_static; ; basic.css; doctools.js; favicon-psi4.ico; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs. /autodir_options_c; ; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; MEMORY — Psi4 [1.0.0 6a9a71b] Docs; NEWTON_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; NORM_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; POLE_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; PR — Psi4 [1.0.0 6a9a71b] Docs,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:180978,plugin,plugins,180978,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugins']
Modifiability,dule.txt; autodoc_testsuite_cfour.txt; autodoc_testsuite_corepsi4.txt; autodoc_testsuite_dftd3.txt; autodoc_testsuite_dmrg.txt; autodoc_testsuite_libefp.txt; autodoc_testsuite_mrcc.txt; autodoc_testsuite_pcmsolver.txt; basissets.txt; basissets_byelement.txt; basissets_byfamily.txt; basissets_tables.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; cfour.txt; cfour_table_energy.txt; cfour_table_grad.txt; chemps2.txt; conda.txt; contents.txt; contributing.txt; cubeprop.txt; customizing.txt; db.txt; dcft.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; dftd3.txt; diatomic.txt; dkh.txt; documentation.txt; energy.txt; external.txt; fchk.txt; fnocc.txt; freq.txt; gdma.txt; glossary_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; libefp.txt; methods.txt; molden.txt; mrcc.txt; mrcc_table_energy.txt; nbody.txt; notes_c.txt; notes_py.txt; occ.txt; oeprop.txt; opt.txt; optionshandling.txt; optking.txt; pcmsolver.txt; pep0001.txt; plugins.txt; proc_py.txt; prog_basissets.txt; programming.txt; prop.txt; psimrcc.txt; psipep.txt; psithonfunc.txt; psithoninput.txt; psithonmol.txt; quickaddalias.txt; quickadddatabase.txt; relativistic.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; thermo.txt; tutorial.txt. _static; ; basic.css; doctools.js; favicon-psi4.ico; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. Programmers’ Manual — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs. autodir_options_c; ; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; MEMORY — Psi4 [1.0.0 6a9a71b] Docs; NEWTON_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; NORM_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; POLE_MAXITER — Psi4 [1.0.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:37530,plugin,plugins,37530,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugins']
Modifiability,"dules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:1077,variab,variables,1077,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,1,['variab'],['variables']
Modifiability,"dx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1). complete[np_index] = compressed[compound_index(xyz_counts)]. return complete. def _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:25960,variab,variables,25960,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"dx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1). complete[np_index] = compressed[compound_index(xyz_counts)]. return complete. def _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:28213,variab,variables,28213,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"e %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93054,variab,variable,93054,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"e (str) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26152,variab,variable,26152,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"e -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to CheMPS2 by S. Wouters. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/chemps2.html:8040,config,configure,8040,psi4manual/1.6.x/chemps2.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/chemps2.html,2,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | -------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:60986,variab,variable,60986,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,8,['variab'],"['variable', 'variables']"
Modifiability,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:60815,variab,variable,60815,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['variab'],"['variable', 'variables']"
Modifiability,"e :; | i nirrep(N3psi12OrbitalSpaceE {lvalue}); | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi12OrbitalSpaceE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | C++ signature :; | N3psi12OrbitalSpaceE build_cabs_space(N3psi12OrbitalSpaceE,N3psi12OrbitalSpaceE,d); | ; | build_ri_space(...); | build_ri_space( (Molecule)arg1, (str)arg2, (str)arg3, (float)arg4) -> OrbitalSpace :; | docstring; | ; | C++ signature :; | N3psi12OrbitalSpaceE build_ri_space(N5boost10shared_ptrIN3psi8MoleculeEEE,Ss,Ss,d); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OverlapInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | OverlapInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:573555,inherit,inherited,573555,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"e == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130506,variab,variable,130506,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"e == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components in v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:123954,variab,variable,123954,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"e BrianQC team; Installing BrianQC; Building BrianQC’s user-built components; Building PSI4 with BrianQC; Using BrianQC from PSI4; Keywords; Environment Variables. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/interfacing-1.html:1712,config,configure,1712,psi4manual/1.4.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/interfacing-1.html,2,['config'],['configure']
Modifiability,"e H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_GUESS_SIZE (DETCI)¶DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 1000. H_BOND_CONNECT (OPTKING)¶OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. H_GUESS_EVERY (OPTKING)¶OPTKING — Re-estimate the Hessian at every step, i.e., ignore the currently stored Hessian. Type: boolean; Default: false. H_UPDATE_DEN_TOL (OPTKING)¶OPTKING — Denominator check for hessian update. Type: conv double; Default: 1e-7. HD_AVG (DETCI)¶DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI)¶DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC)¶PSIMRCC — Do include the fourth-order contributions to the eff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:142362,coupling,coupling,142362,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['coupling'],['coupling']
Modifiability,"e Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC¶. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY¶. Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING¶. Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:38424,coupling,coupling,38424,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,26,['coupling'],['coupling']
Modifiability,"e ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. def _core_has_variable(key):; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls, key):; return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key):; if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return core.array_variable(key); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls, key):; if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:18396,variab,variable,18396,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"e Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float; docstring. compute_spin_contamination(self: psi4.core.HF) → None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool; docstring. diis_enabled_; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager; docstring. diis_start_; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:14625,variab,variable,14625,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['variab'],['variable']
Modifiability,"e a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:3355,plugin,plugin,3355,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"e a modest amount of additional output over the default value of 0, which includes some useful information such as SCF eigenvectors, Fock matrix elements, etc. Type: integer; Default: 0. CFOUR_PROPS¶. Specifies whether and which molecular property is calculated. OFF (=0) means that no property is calculated, FIRST_ORDER (=1) requests computation of various one-electron first-order properties (e.g., dipole moment, quadrupole moment, electric field gradient, spin densities,etc.), SECOND_ORDER (=2, in the next release replaced by STAT_POL) computes static electric polarizabilities, DYNAMICAL (=7, in the next release replaced by DYN_POL) requests the calculation of frequency-dependent polarizabilities (note that here an additional input of the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fermi-Contact contribution to indirect spin-spin coupling constants, J_SD the calculation of the corresponding spin-dipole contribution, and J_SO the calculation of the corresponding spin-orbit contribution to J; HYPERPOL (=22) invokes a calculation of static hyperpolarizabilities, DYN_HYP (=23) requests the calculation of frequency-dependent hyperpolarizabilities, SHG (=24) the calculation of hyperpolarizabilities related to the second-harmonic generation, OPT_REC (=25) the computation of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_PROP_INTEGRAL¶. Allows storage of property integrals computed in xvdint on internal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:47074,coupling,coupling,47074,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,26,['coupling'],['coupling']
Modifiability,"e accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables; The easiest/least visible way to thread PSI4 is to set the standard OpenMP/MKL; environment variables OMP_NUM_THREADS and MKL_NUM_THREADS.; For instance, in tcsh:; setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4. PSI4 then detects these value via the API routines in <omp.h> and; <mkl.h>, and runs all applicable code with 4 threads. These environment; variables are typically defined in a .tcshrc or .bashrc.; (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() Psithon function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:5896,variab,variables,5896,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,8,['variab'],['variables']
Modifiability,"e accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables; The easiest/least visible way to thread Psi4 is to set the standard OpenMP/MKL; environment variables OMP_NUM_THREADS and MKL_NUM_THREADS.; For instance, in tcsh:; setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4. Psi4 then detects these value via the API routines in <omp.h> and; <mkl.h>, and runs all applicable code with 4 threads. These environment; variables are typically defined in a .tcshrc or .bashrc.; (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in Psi4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() Psithon function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a Psi4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:8507,variab,variables,8507,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variables']
Modifiability,"e adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. Herbst and M. Scheurer. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adcc-1.html:2844,variab,variable,2844,psi4manual/1.4.0/adcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adcc-1.html,4,"['config', 'variab']","['configure', 'variable']"
Modifiability,"e adcc backend. Type: integer; Default: -1. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. How to configure adcc for building Psi4¶; Role and Dependencies. Role — In PSI4, adcc provides additional quantum-chemical methods; (a wide range of ADC methods). In turn adcc can use PSI4 as the backend for; self-consistent field calculations and required integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) adcc; Upstream Dependencies — adcc (\(\Leftarrow\) optional) PSI4. CMake Variables. ENABLE_adcc — CMake variable toggling whether Psi4 automatically installs adcc. Examples. Build and install adcc if needed. >>> cmake -DENABLE_adcc=ON. Build without adcc. >>> cmake. table of contents. Interface to adcc by M. F. Herbst and M. Scheurer; Installation; Keywords for adcc; CUTOFF_AMPS_PRINT; KIND; MAX_NUM_VECS; MAXITER; NUM_CORE_ORBITALS; NUM_GUESSES; R_CONVERGENCE; REFERENCE; ROOTS_PER_IRREP. How to configure adcc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to adcc by M. F. Herbst and M. Scheurer. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/adcc-1.html:2844,variab,variable,2844,psi4manual/1.5.0/adcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/adcc-1.html,4,"['config', 'variab']","['configure', 'variable']"
Modifiability,"e available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of . How to install a Psi4 binary with the Psi4conda installer, download site¶; Download one of the nine installers (Linux/Mac/Windows; Py38/39/310).; bash it. Follow the prompts and do make the adjustments to; PATH and PSI_SCRATCH that it suggests at the end. Test; with psi4 --test (green and yellow good; red bad). Done. Explicit commands at How to install a Psi4 binary with the Psi4conda installer, command-line. How to install a Psi4 bi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/conda.html:1248,plugin,plugins,1248,psi4manual/1.6.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/conda.html,5,['plugin'],['plugins']
Modifiability,"e available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page.; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of . How to install a Psi4 binary with the Psi4conda installer, download site¶; Download one of the nine installers (Linux/Mac/Windows; Py36/37/38/39).; bash it. Follow the prompts and do make the adjustments to; PATH and PSI_SCRATCH that it suggests at the end. Test; with psi4 --test (green and yellow good; red bad). Done. Explicit commands at How to install a Psi4 binary with the Psi4conda installer, command-line. How to install a Psi4 b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:1248,plugin,plugins,1248,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,4,['plugin'],['plugins']
Modifiability,"e build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:6824,plugin,plugin,6824,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['plugin'],['plugin']
Modifiability,"e chosen; automatically. If you want to specify manually, use the; DF_BASIS_MP2 keyword.; DFMP2 likes memory. At a minimum, \(2Q^2\) doubles are required,; where \(Q\) is the size of the auxiliary basis set. However, there is; one disk transpose of the \((Q|ov)\) tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, \(2Qov\) doubles are required for; RHF-MP2, and \(4Qov\) doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the \((Q|ov)\) tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; \({\cal O}(N^5)\) step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. table of contents. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dfmp2-1.html:8615,variab,variable,8615,psi4manual/1.3.2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dfmp2-1.html,2,['variab'],['variable']
Modifiability,"e code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3757,plugin,plugins,3757,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"e compilers.; >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; >>> make install. Same for Linux/Mac/WSL. Substitute desired python version: 3.6, 3.7, 3.8, 3.9. Fine; to choose your own env name. Include -c psi4/label/dev to get dependencies to; build current master, as opposed to latest release.; Activate environment, conda activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For users; who want a minimal build, there’s a --disable-addons, but it is generally not; encouraged. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install the optional runtime add-ons (e.g., adcc); >>> conda install psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, numpy, and a few more python; modules for specialized functions. Of gcc-ness, it has minimal, run-time; libraries (e.g., libgcc-ng) not compilers.; It doesn’t have the run-time qc addons psi4-rt (e.g., snsmp2) or build tools (e.g., g++, sphinx, cmake).; psi4-dev - does not have psi4 itself or the run-time addons psi4-rt or numpy (though fine to install them; alongside). Does have all the link-time addons. Does have; cmake and sphinx (and python). Of gcc-ness, has full packages, that is,; compilers as well as runtime packages.; Psi4conda installer - has full-featured psi4 itself, all link-ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:10459,plugin,plugins,10459,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,18,"['plugin', 'variab']","['plugins', 'variables']"
Modifiability,"e computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:6154,flexible,flexible,6154,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,10,['flexible'],['flexible']
Modifiability,"e computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sens",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26759,flexible,flexible,26759,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['flexible'],['flexible']
Modifiability,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix; docstring. moFeff(self: psi4.core.ROHF) → psi4.core.Matrix; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rohf.html:7075,variab,variable,7075,psi4manual/1.2.1/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rohf.html,1,['variab'],['variable']
Modifiability,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:178133,variab,variable,178133,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:27299,variab,variable,27299,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,11,['variab'],['variable']
Modifiability,"e dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to ERD by N. Flocke and V. Lotrich. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/erd.html:2553,variab,variable,2553,psi4manual/1.6.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/erd.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"e discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. Expert¶. COUPLED_INDUCTION¶. Whether or not to compute coupled induction, applies only to the open-shell SAPT0 code. Coupled induction is not available for ROHF, and the option is automatically false in this case. Note that when coupled induction is turned off, the Psi variables SAPT IND20,R ENERGY and SAPT EXCH-IND20,R ENERGY actually contain the uncoupled induction! A corresponding warning is issued in the output file. Type: boolean; Default: true. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. SAPT0_E10¶. For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. SAPT0_E20DISP¶. For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. SAPT0_E20IND¶. For SAPT0 only, compute only second-order induction Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html:5218,variab,variables,5218,psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,2,['variab'],['variables']
Modifiability,"e following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). To choose the type of sieving, set; the SCREENING keyword to your desired option. For Schwarz screening, set it; to SCHWARZ, for CSAM, CSAM, and for density matrix-based screening, DENSITY. SCHWARZUses the Cauchy-Schwarz inequality to calculate an upper bounded value of a shell quartet,. \[(PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)}\]. CSAMAn extension of the Schwarz estimate that also screens over the long range 1/r operator, described in [Thompson:2017:144101]. DENSITYAn extension of the Schwarz estimate that also screens over elements of the density matrix.; For the RHF case, described in [Haser:1989:104]. \[CON(PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)} \cdot DCON(PQ, RS)\]. \[DCON(PQ, RS) = max(4D_{PQ}, 4D_{RS}, D_{PR}, D_{PS}, D_{QR}, D_{QS})\]; When using density-matrix based integral screening, it is usefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/scf-1.html:27661,extend,extended,27661,psi4manual/1.5.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/scf-1.html,4,['extend'],['extended']
Modifiability,"e following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications).; We have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE; DIRECT. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. Fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:27661,extend,extended,27661,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,2,['extend'],['extended']
Modifiability,"e is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. Table Of Contents. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Previous topic; Interface to CheMPS2 by S. Wouters; Next topic; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:8151,extend,extended,8151,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['extend'],['extended']
Modifiability,"e is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html:4615,Config,Configuration,4615,psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/ipi_broker.html,1,['Config'],['Configuration']
Modifiability,"e is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/ipi_broker.html:4615,Config,Configuration,4615,psi4manual/1.9.x/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/ipi_broker.html,1,['Config'],['Configuration']
Modifiability,"e last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:7459,config,configuration,7459,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,13,['config'],['configuration']
Modifiability,"e last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7323,config,configuration,7323,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['config'],['configuration']
Modifiability,"e last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal Psi4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. 2aminopyridine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; 2-aminopyridine, S22 Complex Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; N -0.297712 -1.170382 0.001714; C -0.912531 0.026013 0.004723; C -0.175714 1.226496 0.003700; C 1.204216 1.176210 0.000547; C 1.842683 -0.065832 -0.001280; C 1.045154 -1.196712 0.000533; H -0.697132 2.173907 0.003778; H 1.778223 2.092763 0.001427; H 2.918377 -0.152929 -0.000909; H 1.493951 -2.183173 0.004591; N -2.277071 0.027597 -0.043650; H -2.727502 0.885639 0.221497; H -2.756811 -0.823399 0.254372. pyrazine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; Pyrazine Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; C 0.696140 -1.130872 -0.001974; C -0.696140 -1.130872 -0.001974; N -1.414480 0.000953 0.003286; C -0.696730 1.129848 -0.001397; C 0.696730 1.129848 -0.001397; N 1.41448",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:6617,config,configuration,6617,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['config'],['configuration']
Modifiability,"e latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:8962,config,configuration,8962,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configuration']
Modifiability,"e latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:9646,config,configuration,9646,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configuration']
Modifiability,"e latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:9762,config,configuration,9762,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configuration']
Modifiability,"e maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 100. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE, ATOMIC; Default: OCTREE. DFT_DENSITY_TOLERANCE¶. density cutoff for LibXC. A negative value turns the feature off and LibXC defaults are used. Type: conv double; Default: -1.0. DFT_GRAC_C_FUNC¶. The gradient regularized asymptotic correction functional corr form. Type: string; Default: XC_LDA_C_VWN. DFT_GRAC_X_FUNC¶. The gradient regularized asymptotic correction functional exch form. Type: string; Default: XC_GGA_X_LB. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG0, SG1; Default: No Default. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. DFT_REMOVE_DISTANT_POINTS¶. Remove points from the quadrature grid that exceed the spatial extend of the basis functions. Type: boolean; Default: true. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. DFT_WEIGHTS_TOLERANCE¶. grid weight cutoff. Disable with -1.0. Type: conv double; Default: 1.0e-15. table of contents. SCF; General Wavefunction Info; BASIS; CHOLESKY_TOLERANCE; DF_BASIS_SCF; DF_SCF_GUESS; GUESS; GUESS_MIX; GUESS_PERSIST; INTS_TOLERANCE; MAX_MEM_BUF; MOLDEN_WRITE; ORBITALS_WRITE; PRINT_BASIS; PRINT_MOS; QCHF; REFERENCE; SAPGAU_BASIS; SAVE_JK; SCF_MEM_SAFETY_FACTOR; SCF_PROPERTIES; S_CHOLESKY_TOLERANCE; S_ORTHOGONALIZATION; S_TOLERANCE. Convergence Control/Stabilization; BASIS_GUESS; DAMPING_CONVERGENCE; DAMPING_PERCENTAGE; DF_BASIS_GUESS; DIIS; DIIS_MAX_VECS; DIIS_MIN_VECS; DIIS_RMS_ERROR; DIIS_START; D_CONVERGENCE; E_CONVERGENCE; FAIL_ON_MAXITER; INCFOCK; INCFOCK_CONVERGENCE; INCFOCK_FULL_FOCK_EVERY; LEVEL_SHIFT; LEVEL_SHIFT_CUTOFF; LINK_INTS_TOLERANCE; MAXITER; MOM_OCC; MOM_START; MOM_VIR; SCF_INITIAL_AC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html:22974,extend,extend,22974,psi4manual/1.8.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html,6,['extend'],['extend']
Modifiability,"e maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 100. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE, ATOMIC; Default: OCTREE. DFT_DENSITY_TOLERANCE¶. density cutoff for LibXC. A negative value turns the feature off and LibXC defaults are used. Type: conv double; Default: -1.0. DFT_GRAC_C_FUNC¶. The gradient regularized asymptotic correction functional corr form. Type: string; Default: XC_LDA_C_VWN. DFT_GRAC_X_FUNC¶. The gradient regularized asymptotic correction functional exch form. Type: string; Default: XC_GGA_X_LB. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG0, SG1; Default: No Default. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. DFT_REMOVE_DISTANT_POINTS¶. Remove points from the quadrature grid that exceed the spatial extend of the basis functions. Type: boolean; Default: true. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. DFT_WEIGHTS_TOLERANCE¶. grid weight cutoff. Disable with -1.0. Type: conv double; Default: 1.0e-15. table of contents. SCF; General Wavefunction Info; BASIS; CHOLESKY_TOLERANCE; DF_BASIS_SCF; DF_SCF_GUESS; GUESS; GUESS_MIX; GUESS_PERSIST; INTS_TOLERANCE; MAX_MEM_BUF; MOLDEN_WRITE; ORBITALS_WRITE; PRINT_BASIS; PRINT_MOS; QCHF; REFERENCE; SAVE_JK; SCF_MEM_SAFETY_FACTOR; SCF_PROPERTIES; S_CHOLESKY_TOLERANCE; S_ORTHOGONALIZATION; S_TOLERANCE. Convergence Control/Stabilization; BASIS_GUESS; DAMPING_CONVERGENCE; DAMPING_PERCENTAGE; DF_BASIS_GUESS; DIIS; DIIS_MAX_VECS; DIIS_MIN_VECS; DIIS_RMS_ERROR; DIIS_START; DO_LINK; D_CONVERGENCE; E_CONVERGENCE; FAIL_ON_MAXITER; INCFOCK; INCFOCK_CONVERGENCE; INCFOCK_FULL_FOCK_EVERY; LEVEL_SHIFT; LEVEL_SHIFT_CUTOFF; LINK_INTS_TOLERANCE; MAXITER; MOM_OCC; MOM_START; MOM_VIR; SCF_INITIAL_ACCELER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:22233,extend,extend,22233,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,2,['extend'],['extend']
Modifiability,"e maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 100. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE, ATOMIC; Default: OCTREE. DFT_DENSITY_TOLERANCE¶. density cutoff for LibXC. A negative value turns the feature off and LibXC defaults are used. Type: conv double; Default: -1.0. DFT_GRAC_C_FUNC¶. The gradient regularized asymptotic correction functional corr form. Type: string; Default: XC_LDA_C_VWN. DFT_GRAC_X_FUNC¶. The gradient regularized asymptotic correction functional exch form. Type: string; Default: XC_GGA_X_LB. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG0, SG1; Default: No Default. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. DFT_REMOVE_DISTANT_POINTS¶. Remove points from the quadrature grid that exceed the spatial extend of the basis functions. Type: boolean; Default: true. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. DFT_WEIGHTS_TOLERANCE¶. grid weight cutoff. Disable with -1.0. Type: conv double; Default: 1.0e-15. table of contents. SCF; General Wavefunction Info; BASIS; CHOLESKY_TOLERANCE; DF_BASIS_SCF; DF_SCF_GUESS; GUESS; GUESS_MIX; GUESS_PERSIST; INTS_TOLERANCE; MAX_MEM_BUF; MOLDEN_WRITE; ORBITALS_WRITE; PRINT_BASIS; PRINT_MOS; QCHF; REFERENCE; SAVE_JK; SCF_MEM_SAFETY_FACTOR; SCF_PROPERTIES; S_CHOLESKY_TOLERANCE; S_ORTHOGONALIZATION; S_TOLERANCE. Convergence Control/Stabilization; BASIS_GUESS; DAMPING_CONVERGENCE; DAMPING_PERCENTAGE; DF_BASIS_GUESS; DIIS; DIIS_MAX_VECS; DIIS_MIN_VECS; DIIS_RMS_ERROR; DIIS_START; D_CONVERGENCE; E_CONVERGENCE; FAIL_ON_MAXITER; INCFOCK; INCFOCK_CONVERGENCE; INCFOCK_FULL_FOCK_EVERY; LEVEL_SHIFT; LEVEL_SHIFT_CUTOFF; LINK_INTS_TOLERANCE; MAXITER; MOM_OCC; MOM_START; MOM_VIR; SCF_INITIAL_ACCELERATOR; SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:22619,extend,extend,22619,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,2,['extend'],['extend']
Modifiability,"e memory setting).; Then, we move to the working directory using PBS variable $PBS_O_WORKDIR and; we create scratch directories on every node, using the $PBS_NODEFILE which; points to a file containing a list of the nodes attributed to the job.; 1; 2; 3; 4; 5; 6; 7; 8cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. The next section is very important as it sets the environment variables needed; by PSI4:; 1; 2; 3; 4; 5unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}. PSIDATADIR does not need to be set.; In the present example we unset it to make sure it does not interfere with the internal location-finding.; PSIPATH is needed only if you are using external modules or; plugins in PSI4 and should point to the directories where they can be found. In the; present example, we make sure the variable is set with if ! ( $?PSIPATH ) setenv PSIPATH """"; before adding more paths to it. Finally, PSI_SCRATCH should point to a fast, existing; local disk for temporary file storage. To use 4 threads for OpenMP parallelization; and threaded BLAS (see section Threading), we set -n4 below.; The next step is then to actually run the computation:; 1/psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; 1; 2; 3; 4foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:15078,plugin,plugins,15078,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['plugin'],['plugins']
Modifiability,"e monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energy Reaction Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [kJ/mol] [Eh] Wt [Eh] Wt; -----------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:7580,variab,variables,7580,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,6,['variab'],['variables']
Modifiability,"e more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in sec:mcscf.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an element",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:3170,config,configuration,3170,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['config'],['configuration']
Modifiability,"e nominally applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the PSI4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten; and Cfour module keyword trumps PSI4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gradient().",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:33525,flexible,flexible,33525,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['flexible'],['flexible']
Modifiability,"e nominally applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the PSI4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten; and Cfour module keyword trumps PSI4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as gradient().; sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:33641,flexible,flexible,33641,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,4,['flexible'],['flexible']
Modifiability,"e number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:17022,variab,variable,17022,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,4,['variab'],['variable']
Modifiability,"e number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is prov",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:15924,variab,variable,15924,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,7,['variab'],['variable']
Modifiability,"e number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dimension(self, arg0); Returns the dimension of requested orbital subspace. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_opdm(self, Iroot, Jroot, spin, full_space); Returns the one-particle density or transition matrix. get_orbitals(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_tpdm(self, spin, symmetrize); Returns the two-particle density matrix. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. hamiltonian(self, arg0); docstring. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mcscf_object(self); docstring. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:4827,variab,variable,4827,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"e of a dipole field. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mp2-1; All-electron MP2 6-31G** geometry optimization of water. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:4420,variab,variables,4420,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"e one-particle density matrix if not otherwise required?. Type: boolean; Default: false. TDM¶. Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. DIPMOM¶. Do compute the dipole moment?. Type: boolean; Default: false. MPN¶. Do compute the MPn series out to kth order where k is determined by MAX_NUM_VECS ? For open-shell systems REFERENCE is ROHF, WFN is ZAPTN), DETCI will compute the ZAPTn series. GUESS_VECTOR must be set to UNIT, HD_OTF must be set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. For larger computations, additional keywords may be required, as; described in the DETCI section of the Appendix DETCI. Spin Multiplicities of Higher Roots¶; As mentioned above, DETCI works in a basis of Slater determinants, rather than; configuration state functions. The correct value of \(M_s\) is easily enforced; by fixing the number of alpha and beta electrons to be constant across all determinants; selected for the CI computation. However, determinant-based codes like DETCI do; not necessarily enforce the correct spin \(S\). For example, diagonalizing the; Hamiltonian in a space spanned by determinants with \(M_s = 0\) can yield; both singlet and triplet solutions, because triplets (\(S = 1\)) also have an; \(M_s = 0\) component. (Indeed, even higher spin multiplicities may be encountered; if the excitation level is high enough). For closed-shell references with \(M_s = 0\),; the program will assume by default that a singlet (\(S = 0\)) computation is desired,; and will utilize alpha/beta interchange symmetries to speed up the computation; (this is controlled by the advanced keyword MS0, which defaults to TRUE).; Thus, if a user requests multiple roots (NUM_ROOTS = \(n\)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:10683,config,configuration,10683,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['config'],['configuration']
Modifiability,"e origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from HF:; | ; | occupation_a(...); | occupation_a( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_a(N3psi3scf2HFE {lvalue}); | ; | occupation_b(...); | occupation_b( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_b(N3psi3scf2HFE {lvalue}); | ; | semicanonicalize(...); | semicanonicalize( (HF)arg1) -> None :; | docstring; | ; | C++ signature :; | void semicanonicalize(N3psi3scf2HFE {lvalue}); | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca(N3psi12WavefunctionE {lvalue}); | ; | Ca_subset(...); | Ca_subset( (Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:594343,inherit,inherited,594343,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"e output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. --------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:7413,variab,variable,7413,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,6,['variab'],['variable']
Modifiability,"e please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dkh-1.html:2867,variab,variable,2867,psi4manual/1.3.2/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dkh-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"e plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:8302,adapt,adapted,8302,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['adapt'],['adapted']
Modifiability,"e the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:226044,config,configuration,226044,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['config'],['configuration']
Modifiability,"e the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → psi::Matrix¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:146905,config,configuration,146905,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['config'],['configuration']
Modifiability,"e to; library source) preceding the compilation step (library source to; built library) takes far longer than in Libint1 for production builds. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/libint.html:2483,variab,variable,2483,psi4manual/1.6.x/libint.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html,20,['variab'],['variable']
Modifiability,"e total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT SAPT2+(CCD) ENERGY¶. SAPT SAPT2+(3)(CCD) ENERGY¶. SAPT SAPT2+3(CCD) EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:13807,config,configuration,13807,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"e total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:14059,config,configuration,14059,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,2,['config'],['configuration']
Modifiability,"e upon mirror reflection. Returns; First item is RMSD [A] between rgeom and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from cgeom and the optimally aligned geometry. Return type; float, tuple. qcelemental.molparse.from_arrays(*, geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, fragment_files=None, hint_types=None, geom_hints=None, geom_unsettled=None, variables=None, domain='qm', missing_enabled_return='error', np_out=True, speclabel=True, tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, copy=True, verbose=1)[source]¶; Compose a Molecule dict from unvalidated arrays and variables, returning dict.; See fields of Return molrec below. Required parameters (for QM XYZ); are geom and one of elem, elez, elbl (speclabel=True). Parameters. geom (Union[List[List[float]], numpy.ndarray]) – (nat, 3) or (3 * nat, ) ndarray or list o’lists of Cartesian coordinates.; fragment_separators (Union[List[int], numpy.ndarray]) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; elbl (Union[List[str], numpy.ndarray]) – (nat, ) Label extending elem symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose (float) – Interatom distance (native geom units) nearer than which atoms not allowed.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; speclabel (bool) – If True, interpret elbl as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., @13C_mine or; He4@4.01. If False, interpret elbl as only the user/tagging; exten",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:5457,variab,variables,5457,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['variab'],['variables']
Modifiability,"e used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL (CFOUR); CFOUR — Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV (CFOUR); CFOUR — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER (CFOUR); CFOUR — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION (CFOUR); CFOUR — Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC (CFOUR); CFOUR — Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM (CFOUR); CFOUR — Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:25938,enhance,enhance,25938,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['enhance'],['enhance']
Modifiability,"e value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing transformed integrals. Integrals less than are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD¶. Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths to be used. Type: integer; Default: 0. CFOUR_ZFIELD¶. Specifies the Z-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths to be used. Type: integer; Default: 0. Expert Psi4 Control of CFOUR¶. CFOUR_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. Table Of Contents. CFOUR; Psi4 Control of CFOUR; TRANSLATE_PSI4. CFOUR Internal; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANHARMONIC; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_CC_MAXCYC; CFOUR_CC_PROGRAM; CFOUR_CHARGE; CFOUR_CIS_CONV; CFOUR_CONTINUUM; CFOUR_CONTRACTION; CFOUR_CONVERGENCE; CFOUR_COORDINATES; CFOUR_CORE_ORBITALS; CFOUR_CPHF_CONVER; CFOUR_CPHF_MAXCYC; CFOUR_CURVILINEAR; CFOUR_DBOC; CFOUR_DCT; CFOUR_DERIV_LEVEL; CFOUR_DIFF_TYPE; CFOUR_DROPMO; CFOUR_ECP; CFOUR_EIGENVECTOR; CFOUR_EL_ANHARM; CFOUR_EOM_NONIT; CFOUR_ESTATE_CONV; CFOUR_ESTATE_MAXCYC; CFO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:65347,variab,variable,65347,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['variab'],['variable']
Modifiability,"e variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[, units, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self, arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self, i); Return the Vector3 for atom i (0-indexed without dummies). y(self, arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self, arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters. concern_mol (Union[Molecule, Molecule]) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:10720,variab,variable,10720,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,4,['variab'],['variable']
Modifiability,"e variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[, units, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self, arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self, i); Return the Vector3 for atom i (0-indexed without dummies). y(self, arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self, arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule]) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:10786,variab,variable,10786,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,8,['variab'],['variable']
Modifiability,"e variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI)¶DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI)¶DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT)¶SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT)¶SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT)¶SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC)¶OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC)¶FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC)¶FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.13. CEPA_TYPE (OCC)¶OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR)¶CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab||cd\r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:17584,config,configurations,17584,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['config'],['configurations']
Modifiability,"e wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type; Matrix. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:8190,variab,variables,8190,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variables']
Modifiability,"e “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; psi4; psi4 -i input.dat -o output.dat; psi4 input.dat output.dat. psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:8235,plugin,plugin,8235,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,4,['plugin'],['plugin']
Modifiability,"e"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:4029,Plugin,Plugin,4029,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,3,['Plugin'],['Plugin']
Modifiability,"e(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:130739,variab,variables,130739,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"e('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:79569,variab,variables,79569,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"e('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PAR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:79792,variab,variables,79792,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"e('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs); ; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:86309,variab,variable,86309,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['variab'],['variable']
Modifiability,"e(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:34077,variab,variable,34077,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"e)"" OFF); option(ENABLE_v2rdm_casscf ""Enables V2RDM_CASSCF plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_psi4fockci ""Enables Psi4FockCI plugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(). if(ENABLE_erd); message(FATAL_ERROR ""The Psi4/ERD interface is broken, probably since spring 2017. It's toast (comment this line to try), but disabling for now.""); message(WARNING ""ERD will build, link, and run in Psi4 just fine. However, it has not been hooked into Psi4 in all roles, notably gradients, LRC DFT energies, and ESP. So upon activating through ``set integral_package erd``, known failures will be caught and halted, but perhaps other types not tested and identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools). Note that external projects will have their own sets of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:21139,plugin,plugins,21139,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,1,['plugin'],['plugins']
Modifiability,"e)"" OFF); option(ENABLE_v2rdm_casscf ""Enables V2RDM_CASSCF plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_psi4fockci ""Enables Psi4FockCI plugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(). if(ENABLE_erd); message(FATAL_ERROR ""The Psi4/ERD interface is broken, probably since spring 2017. It's toast (comment this line to try), but disabling for now.""); message(WARNING ""ERD will build, link, and run in Psi4 just fine. However, it has not been hooked into Psi4 in all roles, notably gradients, LRC DFT energies, and ESP. So upon activating through ``set integral_package erd``, known failures will be caught and halted, but perhaps other types not tested and identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:19762,plugin,plugins,19762,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,5,['plugin'],['plugins']
Modifiability,"e). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:124553,variab,variable,124553,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"e)[source]¶; Function to find array inputs that are spread across multiple; lines and squash them into a single line. process_option(spaces, module, key, value, line)[source]¶; Function to process a line with set or in a set block; into global/local domain and keyword/value. process_pcm_command(matchobj)[source]¶; Function to process match of pcm name? { ... }. process_print_command(matchobj)[source]¶; Function to process match of print and transform; it to psi4.print_out(). process_pubchem_command(matchobj)[source]¶; Function to process match of pubchem in molecule block. process_set_command(matchobj)[source]¶; Function to process match of all individual set (module_list); key {[value_list] or $value or value}. process_set_commands(matchobj)[source]¶; Function to process match of set name? { ... }. process_word_quotes(matchobj)[source]¶; Function to determine if argument needs wrapping in quotes as string. quotify(string, isbasis=False)[source]¶; Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When basis; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. driver_nbody¶. nCr(n, r)[source]¶. driver_cbs¶. return_energy_components()[source]¶. driver¶; Module with a procedures dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. wrapper_autofrag¶. auto_fragments(**kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. Returns:Molecule) – fragmented molecule. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:7711,variab,variables,7711,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"e, database()¶; Code author: Lori A. Burns; Section author: Lori A. Burns. database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases:db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. PSI variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/share/scripts/ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a Psi4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:1259,variab,variable,1259,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['variab'],['variable']
Modifiability,"e, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:1863,variab,variables,1863,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"e, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/quickadddatabase.html:3483,variab,variable,3483,psi4manual/master/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/master/quickadddatabase.html,1,['variab'],['variable']
Modifiability,"e,; },; ""model"": {; ""method"": method,; ""basis"": basis,; },; ""keywords"": keywords,; ""molecule"": molecule.to_schema(dtype=2),; ""provenance"": provenance_stamp(__name__),; }). return resi. [docs]def mat2arr(mat: core.Matrix) -> List[List[float]]:; """"""Convert Matrix to List. Parameters; ----------; mat; |PSIfour| matrix. Should be flat with respect to symmetry. Returns; -------; List[List[float]]; Pure Python representation of `mat`. """"""; warnings.warn(; ""Using `psi4.driver.p4util.mat2arr` instead of `MatrixInstance.to_array().tolist()` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:18181,variab,variables,18181,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,2,['variab'],['variables']
Modifiability,"e-c1-constructed basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested ext",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:3682,variab,variable,3682,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['variab'],['variable']
Modifiability,"e-c1-constructed basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:3689,variab,variable,3689,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variable']
Modifiability,"e-pointer""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=undefined -fno-omit-frame-pointer""); option_with_flags(ENABLE_MSAN ""Enables memory sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:18329,variab,variable,18329,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"e-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:1374,config,config,1374,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['config']
Modifiability,"e-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:1374,config,config,1374,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,['config'],['config']
Modifiability,"e-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:1374,config,config,1374,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,2,['config'],['config']
Modifiability,"e. dft-jk; DFT JK on-disk test. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-alpha; Extrapolated water energies. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. mints-benchmark; run some BLAS benchmarks. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:15329,variab,variables,15329,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"e.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:28549,variab,variable,28549,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"e.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:14294,config,configured,14294,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,4,['config'],['configured']
Modifiability,"e.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:30138,variab,variable,30138,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,28,['variab'],['variable']
Modifiability,"e.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Vb() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_dot() psi4.core.Matrix method. vector_multiply() psi4.core.CIVector method. vectors() psi4.core.FISAPT method. version() in module psi4.core. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace static method. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vv10_b() psi4.core.SuperFunctional method. vv10_c() psi4.core.SuperFunctional method. Vvals() psi4.core.OEProp method. W. w() psi4.core.B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:146251,variab,variables,146251,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['variab'],['variables']
Modifiability,e.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). plan() psi4.driver.AtomicComputer method. play() psi4.core.MintsHelper method. plot() psi4.core.FISAPT method. plugin. ; v2rdm_casscf. plugin() in module psi4.core. plugin_close() in module psi4.core. plugin_close_all() in module psi4.core. plugin_load() in module psi4.core. PMLocalizer class in psi4.core. PNO_CONVERGENCE (DLPNO). point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMMbohr method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:108214,plugin,plugin,108214,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['plugin'],['plugin']
Modifiability,"e.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:14675,variab,variables,14675,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,12,['variab'],"['variable', 'variables']"
Modifiability,"e.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:25813,variab,variables,25813,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variables']
Modifiability,"e.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction) → int¶; Number of irreps in the system. nmo(self: psi4.core.Wavefunction) → int¶; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:20357,variab,variables,20357,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variables']
Modifiability,"e.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:15712,variab,variable,15712,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,14,['variab'],['variable']
Modifiability,"e.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:37686,variab,variable,37686,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"e.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:35613,variab,variable,35613,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"e.compile(r'^(?:(?P<gh1>@)|(?P<gh2>Gh\())?(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)(?(gh2)\))(?:@(?P<mass>\d+\.\d+))?$', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16367,variab,variables,16367,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,2,['variab'],"['variable', 'variables']"
Modifiability,"e.from_string(molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,. name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,. fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,. molecular_charge=None,; molecular_multiplicity=None,. missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,. return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcdb.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcdb.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcdb.molparse.from_arrays(geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/molutil.html:3377,variab,variables,3377,psi4manual/1.2.1/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/molutil.html,1,['variab'],['variables']
Modifiability,"e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scalar_variable(arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(); Returns dictionary of all double QC variables. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). set_legacy_gradient(arg0); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current leg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:298847,variab,variable,298847,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"e.get_global_option('BASIS') else 'sto-3g'; basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = core.get_gradient(); wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') == '':; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:14203,Variab,Variables,14203,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Variab'],['Variables']
Modifiability,"e.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), core.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:91962,variab,variable,91962,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"e.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:172136,variab,variables,172136,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"e.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26263,variab,variable,26263,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"e.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:28516,variab,variable,28516,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"e.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/mdi_engine.html:13535,config,configuration,13535,psi4manual/master/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/mdi_engine.html,2,['config'],['configuration']
Modifiability,"e.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:80659,variab,variable,80659,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"e; BRIANQC_SDK_INSTALL envoronment variable to 1. Building BrianQC’s user-built components¶; After the installation, build BrianQC’s example and sample programs,; which also creates the wrapper library and CMake configuration files; required to build PSI4 with BrianQC. Create a build directory to keep the source tree clean. cd <brianqc_install_path>; mkdir build; cd build. Configure project and generate makefiles with CMake.; You will require Eigen (tested with version 3.1.2); and boost (tested with version 1.62). cmake .. Build the examples and samples. make. Test the installation by starting a small calculation.; Make sure to set the BRIANQC_INSTALL_PATH environment variable to <brianqc_install_path>!. export BRIANQC_INSTALL_PATH=<brianqc_install_path>; bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz. Building PSI4 with BrianQC¶; When CMake-ing PSI4, set the ENABLE_BrianQC CMake variable to 1; and set the BrianQC_DIR CMake variable to the path where BrianQC’s; components have been built (usually <brianqc_install_path>/build), then build PSI4 normally. Using BrianQC from PSI4¶; To use BrianQC, the BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; internal computation is either performed by PSI4 (if unsupported by BrianQC),; or taken over by BrianQC, yielding the same result to within the required; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:1892,variab,variable,1892,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,18,['variab'],['variable']
Modifiability,"e; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23677,variab,variables,23677,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,8,['variab'],['variables']
Modifiability,"e; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/include/psifiles.h. Some documentation is even extracted from Psi4 objects at runtime. PsiMod: docstrings for the PsiMod built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/lib/python/basislistdunning.py and psi4/lib/python/basislistother.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; Another reStructuredText; A third reStructuredText and Sphinx; LaTeX that Sphinx can handle; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locations include the #! comment comments at the top of test case; input files, the /*- comment -*/ comments in; psi4/src/bin/psi4/read_options.cc, and the r"""""" comment """"""; docstrings in python modules. (That r"""""" makes the string read; literally, so your LaTeX symbols aren’t confused with escape characters.); For the t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/documentation-1.html:3607,variab,variables,3607,psi4manual/4.0b4/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/documentation-1.html,2,['variab'],['variables']
Modifiability,"e; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./mypl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:3864,plugin,plugin,3864,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"e; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PYTHONPATH is preferred for; Python moduels to accommodate QCEngine. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). PSIDATADIR¶; Path in which the PSI4 executable looks for its non-compiled; dependencies (i.e., basis sets, databases, quadratures, etc.).; This path is always known by the PSI4 program or shared library,; so this variable is relevant primarily to developers wanting a; non-standard location. Value should be set; to directory containing driver, basis, etc. directories, generally; ending in share/psi4. table of contents. Installation and Runtime Configuration; Scratch Files; Elementary Restart; Saving the Wavefunction; ~/.psi4rc File; Threading; PBS job file; Command Line Options; Environment Variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Installation and Runtime Configuration. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/external.html:24396,variab,variable,24396,psi4manual/1.6.x/external.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/external.html,1,['variab'],['variable']
Modifiability,"e; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:3503,config,configure,3503,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"e; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,d); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float :; | ; | C++ signature :; | d exponent(N3psi29FittedSlaterCorrelationFactorE {lvalue}); | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_params(N3psi17CorrelationFactorE {lvalue},N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (BasisSet)arg2, (bool)arg3) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi8BasisSetEEE,b); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | C++ signature :; | void form_QR_inverse(N3psi13FittingMetricE {lvalue},d); | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | C++ signature :; | void form_cholesky_inverse",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:462560,inherit,inherited,462560,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"e=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:6430,variab,variable,6430,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['variab'],['variable']
Modifiability,"eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; driver.response, and driver.frequency. auto_fragments(name, **kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT; usage: auto_fragments(‘’). call_function_in_1st_argument(funcarg, **largs)[source]¶; Function to make primary function call to energy(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tblhead(tbl_maxrgt, tbl_delimit, ttype)[source]¶; Function that prints the header for the changable-width results tables in db().; tbl_maxrgt is the number of reagent columns the table must plan for. tbl_delimit; is a string of dashes of the correct length to set off the table. ttype is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. validate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:11949,variab,variable,11949,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,6,['variab'],['variable']
Modifiability,"e]¶; Set equal to reflection in yz plane. trace()[source]¶; returns the trace of the transformation matrix. transform(r)[source]¶; This performs the transform r * this * r~. transpose()[source]¶; Transpose matrix operation. unit()[source]¶; Set equal to a unit matrix. zero()[source]¶; zero out the symop. similar(bits)[source]¶; From bits of a directionalized point group, returns array of; bits of all directions. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. bond_profile()¶; Obtain bonding topology of molecule. center_of_charge()[source]¶; Computes center of charge of molecule (does not translate molecule).; >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. format_basis_for_cfour(puream)[source]¶; Function to print the BASIS=SPECIAL block for Cfour according; to the active atoms in Molecule. Special short basis names; are used by Psi4 libmints GENBAS-writer in accordance with; Cfour constraints. format_molecule_for_cfour()[source]¶; Function to print Molecule in a form readable by Cfour. format_molecule_for_cfour_old()[source]¶; Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:18384,variab,variable,18384,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variable']
Modifiability,"e]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:116405,variab,variables,116405,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"e__ = <unnamed Boost.Python function>(...); | ; | compute(...); | compute( (Deriv)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE compute(N3psi5DerivE {lvalue}); | ; | set_deriv_density_backtransformed(...); | set_deriv_density_backtransformed( (Deriv)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_deriv_density_backtransformed(N3psi5DerivE {lvalue},b); | ; | set_ignore_reference(...); | set_ignore_reference( (Deriv)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_ignore_reference(N3psi5DerivE {lvalue},b); | ; | set_tpdm_presorted(...); | set_tpdm_presorted( (Deriv)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_tpdm_presorted(N3psi5DerivE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = psi4.DiagonalizeOrder.Ascending; | ; | Descending = psi4.DiagonalizeOrder.Descending; | ; | names = {'Ascending': psi4.DiagonalizeOrder.Ascending, 'Descending': p...; | ; | values = {1: psi4.DiagonalizeOrder.Ascending, 3: psi4.DiagonalizeOrder...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:425384,inherit,inherited,425384,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). h2o = psi4.geometry(""""""; O; H 1 R; H 1 R 2 A; """"""). Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). psi4.set_options({""basis"": ""cc-pvdz"",; ""e_convergence"": 11}); for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; psi4.energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below. PSIthonPsiAPImolecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(100, 103, 2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. h2o = psi4.geometry(""""""; O; H 1 R; H 1 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:14139,flexible,flexible,14139,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['flexible'],['flexible']
Modifiability,"e_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_array` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only).""). def _core_wavefunction_arrays(cls):; """"""; .. deprecat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:47027,variab,variables,47027,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"e_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will sto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:21314,variab,variable,21314,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variable']
Modifiability,"e_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:34991,variab,variable,34991,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"ead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, which is necessary for C programs to link; Fortran-interface libraries such as BLAS and LAPACK. This option should; on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:9126,config,configure,9126,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"ead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol conven",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:9810,config,configure,9810,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"ead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, which is necessary for C programs to link; Fortran-interface libraries such as BLAS and LAPACK. This option should; on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:9926,config,configure,9926,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configure']
Modifiability,"eakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:8050,inherit,inherited,8050,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"eakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoBodyAOInt(Boost.Python.instance); | docstring; | ; | Method resolution order:; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoElectronInt(TwoBodyAOInt); | docstring; | ; | Method resolution order:; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:134722,inherit,inherited,134722,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:16987,variab,variables,16987,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,6,['variab'],['variables']
Modifiability,"ean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16980,variab,variables,16980,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['variab'],['variables']
Modifiability,"ear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:4965,config,configuration,4965,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,15,['config'],['configuration']
Modifiability,"ear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy();",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:3791,variab,variable,3791,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"ear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:3798,variab,variable,3798,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['variab'],['variable']
Modifiability,"ebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmak",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:20529,config,configure,20529,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"ebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage/prefix. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:19578,config,configure,19578,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"ec:appendices:qcvars>` *key* from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:42866,variab,variables,42866,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ecent computation. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:284474,plugin,plugin,284474,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,4,['plugin'],['plugin']
Modifiability,"ecent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:10946,variab,variable,10946,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ecent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:113251,adapt,adapted,113251,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['adapt'],['adapted']
Modifiability,"ecessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Lib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/interfacing-1.html:1264,config,configure,1264,psi4manual/1.2.1/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/interfacing-1.html,4,['config'],['configure']
Modifiability,"eck_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components by v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:167128,variab,variable,167128,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ecosystem will get tested by c-f) by running; pytest ../tests/ -n auto (psithon and psiapi tests). Possibly you may have to step back for; dependency versions from what master needs.; Start Tweak Conda for postrelease PR at conda-forge. This will thoroughly test the ecosystem.; If more changes are needed, git tag -d v1.8.2 to delete the tag, then make more commits,; retag, push, and repeat. Try to finalize the postrelease tag within a session or a day, so; tentative tags don’t linger.; Start the draft parts of Publish GitHub postrelease from the backported PRs assembled here. Tweak Conda for postrelease¶. Start a PR to https://github.com/conda-forge/psi4-feedstock . Always store the PR branch on your; fork, never on the conda-forge feedstock (or your branch itself will get publically packaged).; https://github.com/conda-forge/psi4-feedstock/pull/15 is an example. Always: edit version and commit jinja variables.; Possibly: edit source/url field for trial locations.; Always: edit sha256 jinja variable from e.g., curl -sL https://github.com/psi4/psi4/archive/v1.8.2.tar.gz | openssl sha256; Always: edit build/number. Either reset to 0 if version increments or bump if version doesn’t increment.; Possibly: uncomment skip: true  # [py != 310] if you want to test one Python version on all; architectures before the whole build matrix (currently 16 builds). After editing this (and; opening the PR), you’ll have to issue a comment @conda-forge-admin, please rerender for the; matrix slimming to take effect.; Possibly: remove any old patches that are now in the main codebase.; Possibly: add in or remove any dependency or ecosystem packages.; Possibly: for any relevant addition, make sure -D CMAKE_INSIST_FIND_PACKAGE_<project>=ON or; -D ENABLE_<project>=ON is set in build.sh and bld.bat.; Possibly: add or release version constraints or architecture constraints (e.g., [not win]) on packages. Submit the PR and rerender (cmd above). Monitor the CI.; When all CI lanes are passing and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/manage_release.html:7581,variab,variable,7581,psi4manual/1.9.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/manage_release.html,2,['variab'],['variable']
Modifiability,"ect LibECPInt and activate dependent code.; To remove a conda installation, conda remove libecpint. Source. If using PSI4 built from source and you want LibECPInt built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/ecpint.html:1785,config,config,1785,psi4manual/master/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/master/ecpint.html,1,['config'],['config']
Modifiability,"ect LibECPInt and activate dependent code.; To remove a conda installation, conda remove libecpint. Source. If using PSI4 built from source and you want LibECPInt built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/ecpint.html:1776,config,config,1776,psi4manual/1.6.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/ecpint.html,1,['config'],['config']
Modifiability,"ect LibECPInt and activate dependent code.; To remove a conda installation, conda remove libecpint. Source. If using PSI4 built from source and you want LibECPInt built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/ecpint.html:1776,config,config,1776,psi4manual/1.7.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/ecpint.html,1,['config'],['config']
Modifiability,"ect LibECPInt and activate dependent code.; To remove a conda installation, conda remove libecpint. Source. If using PSI4 built from source and you want LibECPInt built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/ecpint.html:1778,config,config,1778,psi4manual/1.8.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/ecpint.html,1,['config'],['config']
Modifiability,"ect LibECPInt and activate dependent code.; To remove a conda installation, conda remove libecpint. Source. If using PSI4 built from source and you want LibECPInt built from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/ecpint.html:1778,config,config,1778,psi4manual/1.9.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/ecpint.html,1,['config'],['config']
Modifiability,"ect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/libxc.html:1979,variab,variable,1979,psi4manual/1.8.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/libxc.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/libxc.html:1979,variab,variable,1979,psi4manual/1.9.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/libxc.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ect)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | Re-initializes the dimension object; | ; | n(...); | n( (Dimension)arg1) -> int :; | The order of the dimension; | ; | print_out(...); | print_out( (Dimension)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | name; | The name of the dimension. Used in printing.; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | DipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:21515,inherit,inherited,21515,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ection author: Andrew C. Simmonett. psi4.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns; None. Parameters; wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters. title (str) – label prepended to all psivars computed; wfn (psi4.core.Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/oeprop.html:1322,variab,variables,1322,psi4manual/1.6.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html,1,['variab'],['variables']
Modifiability,"ection author: Lori A. Burns. PSI4, particularly libmints utterly relies upon the Libint library; developed by E. Valeev from early roots by J. Fermann. Libint requires no; additional licence, downloads, or configuration. Conversely, PSI4; cannot build without Libint. Installation¶; Binary. Libint is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, Libint has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint. Source. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint/libint.h; Libint_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing share/cmake/Libint/LibintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint — CMake variable to force internal build of Libint instead of detecting pre-built. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libint-1.html:1210,config,configure,1210,psi4manual/1.1.0/libint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libint-1.html,2,['config'],['configure']
Modifiability,"ectory containing share/cmake/CheMPS2/CheMPS2Config.cmake; CMAKE_DISABLE_FIND_PACKAGE_CheMPS2 — CMake variable to force internal build of CheMPS2 instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_CheMPS2=ON. Build without CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when buil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/chemps2-1.html:6833,plugin,plugin,6833,psi4manual/1.1.0/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/chemps2-1.html,4,['plugin'],['plugin']
Modifiability,"ectory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:2264,plugin,plugins,2264,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,6,['plugin'],['plugins']
Modifiability,"ed class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:33598,variab,variable,33598,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,18,['variab'],['variable']
Modifiability,"ed configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:22580,config,configuration,22580,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['config'],['configuration']
Modifiability,"ed conjugate gradient iterations. Type: integer; Default: 30. RELAXED¶. Do consider orbital response contributions for PDMs and GFM?. Type: boolean; Default: true. REMP_A¶. mixing parameter for the REMP hybrid perturbation theory, A specifies the Moller-Plesset fraction. Type: double; Default: 0.15e0. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html:7363,variab,variable,7363,psi4manual/1.7.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html,8,['variab'],['variable']
Modifiability,"ed correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Updating the PSI4 Users’ and Programmers’ Manual. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/documentation.html:7569,variab,variable,7569,psi4manual/1.7.x/documentation.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/documentation.html,1,['variab'],['variable']
Modifiability,"ed executables (; dmrcc for MRCC and; dftd3 for DFTD3; ) should be placed in this colon-separated list.; Psi4 is designed so that user extensions that are findable through; PSIPATH can be used in input files entirely like their; built-in counterparts, without additional tagging as non-standard.; The typical search path is first the built-in libraries, next each; PSIPATH directory in order, and finally the execution; directory (I won’t swear everything tacks on the execution directory).; Path in which the Python interpreter looks for modules to import. For; Psi4, these are generally plugins (see Plugins: Adding New Functionality to Psi4) or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh; >>> setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # bash; >>> export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; Psi4, these are generally plugins (see Plugins: Adding New Functionality to Psi4) or databases. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh/tcsh; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; # sh/bash; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every Psi4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). PSIDATADIR¶; Path in which the Psi4 executable looks for its non-compiled; dependencies (i.e., Python driver, basis sets, databases, etc.).; Not used when running from an installed (make install) executable; or when running from a conda binary,; so this variable is relevant primarily to developers running the; executable di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:17843,plugin,plugins,17843,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['plugin'],['plugins']
Modifiability,"ed for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:1482,variab,variables,1482,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"ed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21635,variab,variable,21635,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['variab'],['variable']
Modifiability,"ed into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:8132,plugin,plugin,8132,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,10,['plugin'],['plugin']
Modifiability,"ed myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; Psi4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3517,plugin,plugins,3517,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"ed since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:22834,variab,variable,22834,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,16,['variab'],['variable']
Modifiability,"ed states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 .. table:: MRCC methods +——-+————–+————————————————————-+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +——-+————–+————————————————————-+ + 2 + CC(n-1)[n] + + +——-+————–+————————————————————-+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +——-+————–+————————————————————-+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Previous topic; OMEGA_ERF; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__mrcc-1.html:2591,variab,variable,2591,psi4manual/4.0b5/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__mrcc-1.html,4,['variab'],['variable']
Modifiability,"ed states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 .. table:: MRCC methods +——-+————–+————————————————————-+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +——-+————–+————————————————————-+ + 2 + CC(n-1)[n] + + +——-+————–+————————————————————-+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +——-+————–+————————————————————-+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Previous topic; OMEGA_ERF; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__mrcc-1.html:2449,variab,variable,2449,psi4manual/4.0b4/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__mrcc-1.html,4,['variab'],['variable']
Modifiability,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:2558,plugin,plugin,2558,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:2558,plugin,plugin,2558,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:2543,plugin,plugin,2543,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"ed with; -DBUILD_SHARED_LIBS=ON (easier to notice changes). And to trigger; Add-On library rebuild, rm -rf {objdir}/external/upstream/addon/; and rm -rf {objdir}/stage/share/cmake/AddOn. This should; re-clone the Add-On, rebuild and install it, rebuild any parts of; PSI4 that interface to it, and relink the main core.so.; If you’re modifying the Add-On’s file or directory structure, be; smart and rm all traces of it within {objdir}/stage/,; especially any *.pyc files.; Alternatively and preferentially to the above, you can instead build and install the; Add-On library yourself, external to the PSI4 repository. This; is especially useful if you want to avoid full recompiles of the; Add-On at each change to the Add-On’s source. Build the Add-On; library dynamically (-DBUILD_SHARED_LIBS=ON) and mind any; “Psi4 wants” in the Add-On’s top-level CMakeLists.txt. Install the; Add-On and note the full path to AddOnConfig.cmake. Pass; the path containing that file to PSI4‘s CMake as; -DAddon_DIR=/path/to/config/usually/ending/in/share/cmake/AddON; and build PSI4. The main core.so should be dynamically linked; to your dev AddOn dynamic lib and update automatically when you rebuild; the AddOn lib. Naturally, you may need to delete core.so and remake; as needed. How to use logging in Psi4¶; A log file is generated alongside the output file and has extension; .log. Selected key information is sent to it. The log file contents; are provisional and haphazard, so don’t start relying upon them. It is; tentatively envisioned that log files will have much of the same results as output; files but more as structured data than narrative, nicely formatted data.; In some cases where external calls are involved, the most detailed; information may only be collectable in the log file. It is; worthwhile to check the log file if expected results are missing from; the usual output file. If the log file is empty, the logging level may; be set too low.; To change the logging level to DEBUG from the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:59495,config,config,59495,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,5,['config'],['config']
Modifiability,"ed with; -DBUILD_SHARED_LIBS=ON (easier to notice changes). And to trigger; Add-On library rebuild, rm -rf {objdir}/external/upstream/addon/; and rm -rf {objdir}/stage/share/cmake/AddOn. This should; re-clone the Add-On, rebuild and install it, rebuild any parts of; PSI4 that interface to it, and relink the main core.so.; If you’re modifying the Add-On’s file or directory structure, be; smart and rm all traces of it within {objdir}/stage/,; especially any *.pyc files.; Alternatively and preferentially to the above, you can instead build and install the; Add-On library yourself, external to the PSI4 repository. This; is especially useful if you want to avoid full recompiles of the; Add-On at each change to the Add-On’s source. Build the Add-On; library dynamically (-DBUILD_SHARED_LIBS=ON) and mind any; “Psi4 wants” in the Add-On’s top-level CMakeLists.txt. Install the; Add-On and note the full path to AddOnConfig.cmake. Pass; the path containing that file to PSI4‘s CMake as; -DAddon_DIR=/path/to/config/usually/ending/in/share/cmake/AddON; and build PSI4. The main core.so should be dynamically linked; to your dev AddOn dynamic lib and update automatically when you rebuild; the AddOn lib. Naturally, you may need to delete core.so and remake; as needed. table of contents. Compiling and Installing from Source; Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda; How to see what build configuration options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to choose the compilation directory, {objdir}; How to save co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:59149,config,config,59149,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['config'],['config']
Modifiability,"ed(...); has_global_option_changed( (str)arg1) -> bool :; docstring; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; docstring; ; has_option_changed(...); has_option_changed( (str)arg1) -> bool :; docstring; ; libfock(...); libfock() -> int :; docstring; ; mcscf(...); mcscf() -> float :; docstring; ; me(...); me() -> int :; docstring; ; mints(...); mints() -> int :; docstring; ; mp2(...); mp2() -> float :; docstring; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; docstring; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; docstring; ; nproc(...); nproc() -> int :; docstring; ; nthread(...); nthread() -> int :; docstring; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> int :; docstring; ; opt_clean(...); opt_clean() -> None :; docstring; ; optking(...); optking() -> int :; docstring; ; outfile_name(...); outfile_name() -> str :; docstring; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; docstring; ; print_global_options(...); print_global_options() -> None :; docstring; ; print_options(...); print_options() -> None :; docstring; ; print_out(...); print_out( (str)arg1) -> None :; docstring; ; print_variables(...); print_variables() -> None :; docstring; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; docstring; ; psimrcc(...); psimrcc() -> float :; docstring; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; docstring; ; reopen_outfile(...); reopen_outfile() -> None :; docstring; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; docstring; ; revoke_local_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:95308,plugin,plugin,95308,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['plugin'],['plugin']
Modifiability,"ed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:7150,variab,variable,7150,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['variab'],['variable']
Modifiability,"ed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Scf Total Energy <==. -----------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; -----------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00011520 -5.71020576 1 -2.85516048 -2; RGC1-HeHe-1.0 0.00000153 -5.71031943 1 -2.85516048 -2; RGC1-HeHe-1.5 -0.00000000 -5.71032096 1 -2.85516048 -2; -----------------------------------------------------------------------------------. ==> Natom <==. -----------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:6813,variab,variable,6813,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,8,['variab'],['variable']
Modifiability,"ed.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]; def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/ipi_broker.html:4622,Config,Configuration,4622,psi4manual/master/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/ipi_broker.html,1,['Config'],['Configuration']
Modifiability,"ed[List[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. module(self: psi4.core.Wavefunction) → str¶; Name of the last/highest level of theory module (interna",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18494,variab,variable,18494,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"edundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configurat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:21719,config,configuration,21719,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['config'],['configuration']
Modifiability,"ef _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:35792,variab,variables,35792,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ef assemble_hessian_from_energies(findifrec: Dict, freq_irrep_only: int) -> np.ndarray:; """"""Compute the Hessian by finite difference of energies. Parameters; ----------; findifrec; Dictionary of finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:37157,adapt,adapted,37157,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['adapt'],['adapted']
Modifiability,"ef_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components in v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:124653,variab,variable,124653,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ef_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161864,variab,variables,161864,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"ef_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); if core.get_option('FNOCC', 'NAT_ORBS'):; mints = core.MintsHelper(ref_wfn.basisset()); mi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:162893,variab,variables,162893,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"ef_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:166325,variab,variables,166325,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"efault Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 gcc; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc. # create and compile plugin; >>> psi4 --new-plugin testplugin # generate new plugin; >>> cd testplugin # move into plugin directory; >>> make # compile the plugin to product testplugin.so; >>> psi4 # run sample input.dat; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:5243,plugin,plugins,5243,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"efault"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:2756,Config,Configuration,2756,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,1,['Config'],['Configuration']
Modifiability,"efault. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. How to configure CheMPS2 for building Psi4¶; Role and Dependencies. Role — In PSI4, CheMPS2 is a library that provides additional; quantum chemical capabilities (DMRG).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) CheMPS2; Upstream Dependencies — CheMPS2 \(\Leftarrow\) BLAS/LAPACK, HDF5 \(\Leftarrow\) zlib. CMake Variables. ENABLE_CheMPS2 — CMake variable toggling whether Psi4 builds with CheMPS2; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For CheMPS2, set to an installation directory containing include/chemps2/DMRG.h; CheMPS2_DIR — CMake variable to specify where pre-built CheMPS2 can be found. Set to installation directory containing share/cmake/CheMPS2/CheMPS2Config.cmake; CMAKE_DISABLE_FIND_PACKAGE_CheMPS2 — CMake variable to force internal build of CheMPS2 instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_CheMPS2 — CMake variable to force detecting pre-built CheMPS2 and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_CheMPS2=ON. Build without CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/chemps2-1.html:6184,variab,variable,6184,psi4manual/1.2.1/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/chemps2-1.html,26,['variab'],['variable']
Modifiability,"efault: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. Expert¶. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. table of contents. PSIMRCC; General; CC_NUM_THREADS; CORR_ANSATZ; CORR_CCSD_T; CORR_CHARGE; CORR_MULTP; CORR_WFN; COUPLING; COUPLING_TERMS; DAMPING_PERCENTAGE; DIAGONALIZE_HEFF; DIAGONAL_CCSD_T; DIIS_MAX_VECS; DIIS_START; E_CONVERGENCE; FAVG_CCSD_T; FOLLOW_ROOT; HEFF4; HEFF_PRINT; LOCK_SINGLET; MAXITER; MP2_CCSD_METHOD; MP2_GUESS; NO_SINGLES; OFFDIAGONAL_CCSD_T; PERTURB_CBS; PERTURB_CBS_COUPLING; PT_ENERGY; R_CONVERGENCE; SMALL_CUTOFF; TIKHONOW_MAX; TIKHONOW_OMEGA; TRIPLES_ALGORITHM; TRIPLES_DIIS; USE_SPIN_SYM; WFN_SYM; ZERO_INTERNAL_AMPS. Expert; TIKHONOW_TRIPLES; USE_SPIN_SYMMETRY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__psimrcc.html:4827,config,configurations,4827,psi4manual/master/autodir_options_c/module__psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__psimrcc.html,3,"['COUPLING', 'config']","['COUPLING', 'configurations']"
Modifiability,"efaults to 4.0 bohr each. Type: array; Default: No Default. Orbital Visualization with VMD¶; Included in Psi4 is functionality to automatically render specified surfaces, including molecular orbitals,; densities, and basis functions, using VMD. The vmd_cube.py script takes the .cube files generated; in a calculation and generates images alinged with user-input specifications. The script is located; in psi4//share/scripts/vmd_cube.py. Script Prerequisites¶. VMD must be installed, and it can be downloaded for free at (http://www.ks.uiuc.edu/Research/vmd/). Additionally,; the script needs to know where to find the VMD executable, and this is defined as VMDPATH. VMDPATH must be defined as; an environment variable.; To generate images with multiple surfaces, ImageMagick must also be installed. ImageMagick is a free program which; can be installed using homebrew/pip or from http://www.imagemagick.org/script/binary-releases.php .; With ImageMagick installed, an environment variable called MONTAGE needs to be created which points to the montage executable.; This executable can be found in the /bin/ sub-directory wherever ImageMagick was installed. Running the Script¶. Run a Psi4 calculation, generating .cube files as detailed in the above documentation. Copy vmd_script.py into a directory where the image files are desired, and pass the directory; pointing to the .cube files as an argument to run:; python vmd_cube.py /path/to/cube/files/. Alternatively, the script can be run in the same directory as the cube files with no need to pass the; directory as an argument. For an additional image containing all surfaces in an array (very useful for hand-picking orbital spaces), set the montage; flag to True:; python vmd_cube.py /path/to/cube/files/ --montage=True. As an example, take the cube files generated from the water calculation from the above input file. Using the script and montage,; the alpha molecular orbitals, for example, can be rendered and output in one image with:; py",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cubeprop-1.html:5637,variab,variable,5637,psi4manual/1.0.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cubeprop-1.html,2,['variab'],['variable']
Modifiability,"eference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:32655,Config,Configuration,32655,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Config'],['Configuration']
Modifiability,"eference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8494,variab,variables,8494,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['variab'],['variables']
Modifiability,"eference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:44087,variab,variable,44087,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['variab'],['variable']
Modifiability,"eferred for; executables to accommodate QCEngine. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; plugins, and; interfaced executables (; dmrcc for MRCC and; dftd3 for DFTD3; ) should be placed in this colon-separated list.; PSI4 is designed so that user extensions that are findable through; PSIPATH can be used in input files entirely like their; built-in counterparts, without additional tagging as non-standard.; The typical search path is first the built-in libraries, next each; PSIPATH directory in order, and finally the execution; directory (I won’t swear everything tacks on the execution directory).; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to im",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:22069,plugin,plugins,22069,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['plugin'],['plugins']
Modifiability,"efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Returns:; energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to perturb.; do_shift (bool or array-like, optional) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specifi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:29273,extend,extended,29273,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['extend'],['extended']
Modifiability,"efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:7806,variab,variable,7806,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,26,['variab'],['variable']
Modifiability,"efunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (str) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26026,variab,variable,26026,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"efunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on self. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[, assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename, do_virtual, use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters:. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns:; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type:; Matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:7656,variab,variable,7656,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,8,['variab'],['variable']
Modifiability,"eger; Default: 1. SOLVER_NORM (CPHF); CPHF — DL Solver minimum corrector norm to add to subspace. Type: double; Default: 1.0e-6. SOLVER_PRECONDITION (CPHF); CPHF — Solver precondition type. Type: string; Possible Values: SUBSPACE, JACOBI, NONE; Default: JACOBI. SOLVER_PRECONDITION_MAXITER (CPHF); CPHF — Solver precondtion max steps. Type: integer; Default: 1. SOLVER_PRECONDITION_STEPS (CPHF); CPHF — Solver precondition step type. Type: string; Possible Values: CONSTANT, TRIANGULAR; Default: TRIANGULAR. SOLVER_QUANTITY (CPHF); CPHF — Solver residue or eigenvector delta. Type: string; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF); CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SORTED_TEI_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_MO_TEI. SOS_SCALE (OMP2); OMP2 —. Type: double; Default: 1.3. SOS_SCALE2 (OMP2); OMP2 —. Type: double; Default: 1.2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM —. Type: integer; Default: 5. STEP_TYPE (OPTKING); OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. T2_COUPLED (CCENERGY); CCENERGY — Do ?. Type: boolean; Default: false. T3_WS_INCORE (CCENERGY); CCENERGY — Do ?. Type: boolean; Default: false. T3_WS_INCORE (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. T_AMPS (CCHBAR); CCHBAR — Do compute the Tamplitude equa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:94553,adapt,adapted,94553,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Modifiability,"eger; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. Expert¶. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. table of contents. PSIMRCC; General; CC_NUM_THREADS; CORR_ANSATZ; CORR_CCSD_T; CORR_CHARGE; CORR_MULTP; CORR_WFN; COUPLING; COUPLING_TERMS; DAMPING_PERCENTAGE; DIAGONALIZE_HEFF; DIAGONAL_CCSD_T; DIIS_MAX_VECS; DIIS_START; E_CONVERGENCE; FAVG_CCSD_T; FOLLOW_ROOT; HEFF4; HEFF_PRINT; LOCK_SINGLET; MAXITER; MP2_CCSD_METHOD; MP2_GUESS; NO_SINGLES; OFFDIAGONAL_CCSD_T; PERTURB_CBS; PERTURB_CBS_COUPLING; PT_ENERGY; R_CONVERGENCE; SMALL_CUTOFF; TIKHONOW_MAX; TIKHONOW_OMEGA; TRIPLES_ALGORITHM; TRIPLES_DIIS; USE_SPIN_SYM; WFN_SYM; ZERO_INTERNAL_AMPS. Expert; TIKHONOW_TRIPLES; USE_SPIN_SYMMETRY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__psimrcc.html:4820,config,configurations,4820,psi4manual/1.8.x/autodir_options_c/module__psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__psimrcc.html,3,"['COUPLING', 'config']","['COUPLING', 'configurations']"
Modifiability,"eger; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. Expert¶. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. table of contents. PSIMRCC; General; CC_NUM_THREADS; CORR_ANSATZ; CORR_CCSD_T; CORR_CHARGE; CORR_MULTP; CORR_WFN; COUPLING; COUPLING_TERMS; DAMPING_PERCENTAGE; DIAGONALIZE_HEFF; DIAGONAL_CCSD_T; DIIS_MAX_VECS; DIIS_START; E_CONVERGENCE; FAVG_CCSD_T; FOLLOW_ROOT; HEFF4; HEFF_PRINT; LOCK_SINGLET; MAXITER; MP2_CCSD_METHOD; MP2_GUESS; NO_SINGLES; OFFDIAGONAL_CCSD_T; PERTURB_CBS; PERTURB_CBS_COUPLING; PT_ENERGY; R_CONVERGENCE; SMALL_CUTOFF; TIKHONOW_MAX; TIKHONOW_OMEGA; TRIPLES_ALGORITHM; TRIPLES_DIIS; USE_SPIN_SYM; WFN_SYM; ZERO_INTERNAL_AMPS. Expert; TIKHONOW_TRIPLES; USE_SPIN_SYMMETRY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__psimrcc.html:4820,config,configurations,4820,psi4manual/1.9.x/autodir_options_c/module__psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__psimrcc.html,3,"['COUPLING', 'config']","['COUPLING', 'configurations']"
Modifiability,"egralFactory method). (psi4.core.MintsHelper method). electric_field_value() (psi4.core.MintsHelper method). ElectricFieldInt (class in psi4.core). electrostatic() (psi4.core.IntegralFactory method). electrostatic_potential_value() (psi4.core.MintsHelper method). ElectrostaticInt (class in psi4.core). elevation (psi4.driver.p4util.InPsight attribute). elst() (psi4.core.FISAPT method). embedding_charges (psi4.driver.driver_nbody.ManyBodyComputer attribute). EmpiricalDispersion (class in psi4.driver). (class in psi4.driver.procrouting.empirical_dispersion). end() (psi4.core.Slice method). energies_from_fcidump() (in module psi4.driver). (in module psi4.driver.p4util). energy(). setting keywords. energy() (in module psi4.driver). (psi4.core.Wavefunction method). ENERGY_LEVEL_SHIFT (DCT). engine (psi4.driver.EmpiricalDispersion attribute). (psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute). ENSURE_BT_CONVERGENCE (OPTKING). ENTHALPY. ENTHALPY CORRECTION. environment variable. ; BRIANQC_ENABLE, [1]. BRIANQC_INSTALL_PATH, [1], [2]. BRIANQC_SDK_INSTALL, [1]. CONDA_PREFIX, [1], [2]. CRAY_ADD_RPATH. CRAYPE_LINK_TYPE. HOST, [1], [2]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE, [1]. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PSIDATADIR, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18]. PYTHONPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. VMDPATH, [1]. EOM_GUESS (CCEOM). EOM_REFERENCE (CCEOM). (CCHBAR). EP2_CONVERGENCE (DFEP2). EP2_MAXITER (DFEP2). EP2_NUM_EA (DFEP2). EP2_NUM_IP (DFEP2). EP2_ORBITALS (DFEP2). EP_EA_P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:47169,variab,variable,47169,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['variab'],['variable']
Modifiability,"ei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:4345,variab,variable,4345,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,4,['variab'],['variable']
Modifiability,"eing computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 384; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ErfComplementERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ErfComplementERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:32422,inherit,inherited,32422,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:297643,plugin,plugins,297643,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['plugin'],['plugins']
Modifiability,"el of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:10104,variab,variable,10104,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['variab'],['variable']
Modifiability,"el,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/ta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:3958,variab,variables,3958,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,6,['variab'],['variables']
Modifiability,"el=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:44185,variab,variables,44185,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"elation energy component [E_h]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:23154,config,configuration,23154,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['config'],['configuration']
Modifiability,"elation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:4698,variab,variable,4698,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['variab'],['variable']
Modifiability,"elation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY¶; The oscillator strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY¶; The rotatory strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:49398,variab,variable,49398,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,2,['variab'],['variable']
Modifiability,"elation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY¶; The oscillator strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY¶; The rotatory strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html:49466,variab,variable,49466,psi4manual/1.5.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html,2,['variab'],['variable']
Modifiability,"elation in SCS methods, forces alpha = 1.0; },. ""dispersion"": { definition of dispersion corrections; ""type"": """", dispersion type - ""d2"", ""d3zero"", ""d3bj"" etc., see empirical_dispersion.py; ""params"": {}, parameters for the dispersion correction; ""nlc"": False (optional) logical switch to turn off nlc (e.g. VV10) correction defined by LibXC; ""citation"": """", special reference for the dispersion correction parameters, appended to output; (if defined in driver, not if defined in input file); },. One can also use the dft_functional keyword argument to use the; orbitals generated by DFT for correlated wavefunction methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing the IP fitting procedure, for example. table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:31749,variab,variables,31749,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['variab'],['variables']
Modifiability,"elds = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165246,variab,variable,165246,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"elf .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:1862,config,configuration,1862,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,2,['config'],['configuration']
Modifiability,"elf); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:4276,variab,variable,4276,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,2,['variab'],['variable']
Modifiability,"elf); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction’s gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction’s Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction’s electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:4260,variab,variable,4260,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,1,['variab'],['variable']
Modifiability,"elf); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Summary. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). gradient(self); Returns the Wavefunction’s gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). hessian(self); Returns the Wavefunction’s Hessian. legacy_frequencies(). mo_extents(self); returns the wavefunction’s electronic orbital extents. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:3756,variab,variable,3756,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"elf, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:3370,variab,variables,3370,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['variab'],['variables']
Modifiability,"elf, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val). shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. variable(key). variables(). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fa_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:6264,variab,variables,6264,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variables']
Modifiability,"elf.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %d %s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %d %s %d %s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:16934,variab,variables,16934,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['variab'],['variables']
Modifiability,"elf.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32246,variab,variable,32246,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['variab'],['variable']
Modifiability,"elf.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print(""""""Molecule already fragmented so no further action by auto_fragments().""""""); return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:26363,variab,variable,26363,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['variab'],['variable']
Modifiability,"elf: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.CdSalc¶; Bases: pybind11_builtins.pybind11_object; Cartesian displacement SALC. irrep(self: psi4.core.CdSalc) → str¶; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc) → int¶; Return the irrep index. print_out(self: psi4.core.CdSalc) → None¶; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:50792,inherit,inherited,50792,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"elf: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, block: psi::BlockOPoints, force_compute: bool=True) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:210097,inherit,inherited,210097,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"elf: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet]) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_bu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:227868,inherit,inherited,227868,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"elf: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, block: psi::BlockOPoints, force_compute: bool=True) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:256854,inherit,inherited,256854,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"elf: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. exists(self: psi4.core.IO, unit: int) → bool¶; Check if the unit exists. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:109288,inherit,inherited,109288,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:3053,variab,variables,3053,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,1,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:37408,variab,variables,37408,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html:3048,variab,variables,3048,psi4manual/1.3.2/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html,1,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:196715,variab,variables,196715,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html:3303,variab,variables,3303,psi4manual/1.3.2/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html,1,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:214305,variab,variables,214305,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html:3048,variab,variables,3048,psi4manual/1.3.2/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html,1,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:243472,variab,variables,243472,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:95888,variab,variables,95888,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"elf: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:29185,variab,variables,29185,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variables']
Modifiability,"elf: psi4.core.Molecule, ...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass((self: psi4.core.Molecule, ...); Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(...); Uses the point group object obtain by calling point_group(). fsymbol((self: psi4.core.Molecule, ...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx((self: psi4.core.Molecule, ...); x position of atom arg1 (0-indexed including dummies in Bohr). fy((self: psi4.core.Molecule, ...); y position of atom arg1 (0-indexed including dummies in Bohr). fz((self: psi4.core.Molecule, ...); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(...); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(...); Gets point group name such as C3v or S8. get_variable((self: psi4.core.Molecule, ...); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(...). is_variable((self: psi4.core.Molecule, ...); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label((self: psi4.core.Molecule, ...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass((self: psi4.core.Molecule, ...); Gets mass of atom arg1 (0-indexed). molecular_charge(...); Gets the charge on full molecule. move_to_com((self: psi4.core.Molecule) -> None); Moves molecule to center of mass. multiplicity((self: psi4.core.Molecule) -> int); Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(...); Gets the number of active (non-ghosted) fragments in the molecule. nallatom((self: psi4.core.Molecule) -> int); Number of real and dummy atoms. name((self: psi4.core.Molecule) -> str); Gets molecule name. natom((self: psi4.core.Molecule) -> int); Number of real atoms. nfragments((self: psi4.core.Molecule) -> i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:3172,variab,variable,3172,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['variab'],['variable']
Modifiability,"elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:44827,variab,variable,44827,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['variab'],['variable']
Modifiability,"elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:42675,variab,variables,42675,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"elization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir. cd {top-level-psi4-dir} && cmake -S. -Bobjdir; cd {top-level-psi4-dir} && cmake -S. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:22231,config,configured,22231,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,1,['config'],['configured']
Modifiability,"eloper libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:2284,config,configuring,2284,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configuring']
Modifiability,"eloper version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR)¶CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR)¶CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR)¶CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VTRAN (CFOUR)¶CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR)¶C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:83619,adapt,adapted,83619,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['adapt'],['adapted']
Modifiability,"elow more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total electronic energy in Hartrees. PSI variables. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:2729,variab,variables,2729,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['variab'],['variables']
Modifiability,"elp¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:9661,variab,variables,9661,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['variab'],['variables']
Modifiability,"elp¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4). Table Of Contents. Configuration: Preparing PSI4’s Environment; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Previous topic; A PSI4 Tutorial; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:8655,variab,variables,8655,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['variab'],['variables']
Modifiability,"ely with derivatives, so stopping.'). # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +-------------------------+-----------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:4134,variab,variables,4134,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"em below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total electronic energy in Hartrees. PSI variables. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:1962,variab,variables,1962,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['variab'],['variables']
Modifiability,"em below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]¶; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:1943,variab,variables,1943,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['variab'],['variables']
Modifiability,"em gets the smoke label. psi4/doc/sphinxman/; Create a new .rst page, copying one of the Add-Ons with similar; language and dependency requirements. Edit it; as appropriate. Add this page to the list in; psi4/doc/sphinxman/source/interfacing.rst.; Add a bullet to psi4/doc/sphinxman/source/build_planning.rst; Add the new page to the long list in; psi4/doc/sphinxman/CMakeLists.txt. If there are any files or; images referred to, add them to the file, too, following precedent. else¶. Build conda packages; Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together; Obligations of the External Project owners are to:; allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:; leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. table of contents. Adding Add-Ons; How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs; else. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Managing: Git, Conda, CMake and all that. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/manage_addon-1.html:6039,sandbox,sandbox,6039,psi4manual/1.1.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/manage_addon-1.html,4,"['plugin', 'sandbox']","['plugins', 'sandbox']"
Modifiability,"em with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:1586,plugin,plugin-compile,1586,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,4,['plugin'],['plugin-compile']
Modifiability,"ems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:1729,config,configuring,1729,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['config'],['configuring']
Modifiability,"em}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:38014,variab,variable,38014,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"en a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performed; source activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:24567,config,configuration,24567,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configuration']
Modifiability,"en core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]. Get dict of converged T amplitudes. amps : dict (spacestr, SharedMatrix); spacestr is a description of the amplitude set using the following conventions.; I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF: “tIA”, “tIjAb”; UHF: tIA, tia, tIjAb, tIJAB, tijab; ROHF: tIA, tia, tIjAb, tIJAB, tijab. Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”“”; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self: psi4.core.Wavefunction, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ccwavefunction.html:7801,variab,variable,7801,psi4manual/1.3.2/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ccwavefunction.html,1,['variab'],['variable']
Modifiability,"en determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FISAPT_CHARGE_COMPLETENESS (FISAPT)¶FISAPT — Amount of fragment charge completeness to distinguish link bonds. Type: double; Default: 0.8. FISAPT_CUBE_DENSMAT (FISAPT)¶FISAPT — Generate cube files for fragment density matrices?. Type: boolean; Default: false. FISAPT_CUBE_LINKIBOS (FISAPT)¶FISAPT — Generate cube files for unsplit link orbitals (IBOs)?. Type: boolean; Default: false. FISAPT_CUBE_LINKIHOS (FISAPT)¶FISAPT — Generate cube files for split link orbitals (IHOs)?. Type: boolean; Default: false. FISAPT_DO_FSAPT (FISAPT)¶FISAPT — Do an F-SAPT analysis?. Type: boolean; Default: true. FISAPT_DO_FSAPT_DISP (FISAPT)¶FISAPT — Do F-SAPT Dispersion?. Type: boolean; Default: true. FISAPT_DO_PLOT (FISAPT)¶FISAPT — Plot a scalar-field analysis. Type: boolean; Default: false. FISAPT_EXCH_PARPERP (FISAPT)¶FISAPT — Calculate separate exchange corrections for parallel and perpendicular spin coupling of link orbitals? When false, only the averaged out exchange corrections are computed. Type: boolean; Default: false. FISAPT_FSAPT_EXCH_SCALE (FISAPT)¶FISAPT — Do F-SAPT exchange scaling? (ratio of S^infty to S^2). Type: boolean; Default: true. FISAPT_FSAPT_FILEPATH (FISAPT)¶FISAPT — Filepath to drop F-SAPT data within input file directory. Type: string; Default: fsapt/. FISAPT_FSAPT_IND_RESPONSE (FISAPT)¶FISAPT — Do F-SAPT coupled response? (not recommended). Type: boolean; Default: false. FISAPT_FSAPT_IND_SCALE (FISAPT)¶FISAPT — Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction). Type: boolean; Default: true. FISAPT_FSSAPT_FILEPATH (FISAPT)¶FISAPT — Filepath to drop sSAPT0 exchange-scaling F-SAPT data within input file directory. Type: string; Default: s-fsapt/. FISAPT_LINK_ASSIGNMENT (FISAPT)¶FISAPT — Where do sigma links go (to C, AB, or split into IHOs)?. Type: string; Possible Values: C, AB, SAO0, SAO1, SAO2, SIAO0, SIAO1, SIAO2; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_glossary_options_c.html:133860,coupling,coupling,133860,psi4manual/1.8.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_glossary_options_c.html,3,['coupling'],['coupling']
Modifiability,"en list. insert((self: List[psi::Matrix], i: int, ...); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove((self: List[psi::Matrix], ...); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix) → None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None; Remove the first item from the list whose value is x. It is an error if there is no such item. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html:1665,extend,extend,1665,psi4manual/1.1.0/api/psi4.core.vectormatrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vectormatrix.html,1,['extend'],['extend']
Modifiability,"en optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with external charge on trimer. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:17304,variab,variable,17304,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variable']
Modifiability,"en touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:7254,plugin,plugins,7254,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['plugin'],['plugins']
Modifiability,"en touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:7252,plugin,plugins,7252,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['plugin'],['plugins']
Modifiability,"ence rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:9779,variab,variables,9779,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['variab'],['variables']
Modifiability,"end( (matrix_vector)arg1, (object)arg2) -> None :. C++ signature :. void append(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE). psi4.matrix_vector.extend()¶; Python Library Documentation: method extend; extend(...) unbound psi4.matrix_vector method. extend( (matrix_vector)arg1, (object)arg2) -> None :. C++ signature :. void extend(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE). vector_of_doubles¶. psi4.vector_of_doubles.append()¶; Python Library Documentation: method append; append(...) unbound psi4.vector_of_doubles method. append( (vector_of_doubles)arg1, (object)arg2) -> None :. C++ signature :. void append(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE). psi4.vector_of_doubles.extend()¶; Python Library Documentation: method extend; extend(...) unbound psi4.vector_of_doubles method. extend( (vector_of_doubles)arg1, (object)arg2) -> None :. C++ signature :. void extend(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE). Full Docs Output¶; Python Library Documentation: built-in module psi4. NAME; psi4. FILE; (built-in). CLASSES; Boost.Python.enum(__builtin__.int); DiagonalizeOrder; GeometryUnits; PsiReturnType; Boost.Python.instance(__builtin__.object); AOShellCombinationsIterator; BasisSet; BasisSetParser; Gaussian94BasisSetParser; CIVector; CdSalcList; CorrelationFactor; FittedSlaterCorrelationFactor; CubeProperties; DFChargeFitter; DFTensor; Deriv; Dimension; Dispersion; DoublePyBuffer; EFP; Environment; ExternalPotential; FCHKWriter; FittingMetric; Functional; GaussianShell; IO; IOManager; IntVector; IntegralFactory; JK; LaplaceDenominator; LibParallelHelper; Localizer; BoysLocalizer; PMLocalizer; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OneBodyAOInt; AngularMomentumInt; DipoleInt; ElectricFieldInt; ElectrostaticInt; KineticInt; MultipoleInt; NablaInt; OverlapInt; PotentialInt; PseudospectralInt; QuadrupoleI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:370217,extend,extend,370217,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['extend'],['extend']
Modifiability,"ended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:4181,config,configuration,4181,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configuration']
Modifiability,"endencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpenMP. MKL_ROOT¶; Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location. MATH_ROOT¶; Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so). Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present); If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE. Build with Intel MKL. >>> source /path/to/intel/vers/linux/mkl/bin/mklvars.sh intel64 # adjust sh/csh and arch as needed; >>> cmake. >>> MATH_ROOT=/path/to/intel/vers/linux/mkl/ cmake. Build with Intel MKL from conda (install mkl-devel package from defaults channel). >>> cmake -DLAPACK_LIBRARIES=""${CONDA_PREFIX}/lib/libmkl_rt.so"" -DLAPACK_INCLUDE_DIRS=""${CONDA_PREFIX}/include"". OpenBLAS - see note below. >>> MATH_ROO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:41830,variab,variable,41830,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['variab'],['variable']
Modifiability,"enerate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html:4776,plugin,plugin,4776,psi4manual/1.3.2/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html,2,['plugin'],['plugin']
Modifiability,"enerated. Collect new authors¶. Survey contributions to current Milestone. Add new contributors to the release notes GitHub issue.; Figure out any new “Additional Contributors” authors since last release.; Get permission of new authors and their particulars for codemeta.json.; Edit psi4/header.py accordingly and make PR. Run long tests¶. Run the full test suite with threading parallelism on. There’s one CC test that’s a known fail; in parallel b/c it sets memory very low, iirc. CTest (CLI):; +++ b/tests/runtest.py; @@ -104,7 +104,7 @@ def backtick(exelist):. # run psi4 and collect testing status from any compare_* in input file; if os.path.isfile(infile):; - exelist = [psi, infile, outfile, '-l', psidatadir]; + exelist = [psi, infile, outfile, '-l', psidatadir, '-n2']; # On Windows set Python interpreter explicitly as the shebang is ignored; if sys.platform.startswith('win'):. Pytest (API):; +++ b/tests/pytests/conftest.py; @@ -22,6 +22,7 @@ def pytest_collection_modifyitems(config, items):; def set_up_overall(request, tmp_path_factory):; import psi4. + psi4.core.set_num_threads(2); psi4.set_output_file(""pytest_output.dat"", False); os.chdir(tmp_path_factory.getbasetemp()); request.addfinalizer(tear_down). +++ b/tests/pytests/conftest.py; @@ -34,6 +34,7 @@ def set_up():; psi4.core.clean(); psi4.core.clean_timers(); psi4.core.clean_options(); + psi4.set_num_threads(2); psi4.set_output_file(""pytest_output.dat"", True). Pytest (CLI):; +++ b/tests/pytests/addons.py; @@ -223,8 +223,8 @@ def ctest_runner(inputdatloc, *, extra_infiles: List = None, outfiles: List = No; if Path(psi4.executable).suffix == "".exe"":; command = [psi4.executable, inputdat]; else:; - command = [sys.executable, psi4.executable, inputdat]; - _, output = execute(command, infiles_with_contents, outfiles, environment=env, scratch_messy=False); + command = [sys.executable, psi4.executable, inputdat, ""-n2""]; + _, output = execute(command, infiles_with_contents, outfiles, environment=env, scratch_messy=True)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/manage_release.html:3480,config,config,3480,psi4manual/1.9.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/manage_release.html,2,['config'],['config']
Modifiability,"energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = energy('ccsd(t)', bsse_type = 'cp'). psi4.print_out(""\n""); psi4.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); psi4.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi_hartree2kcalmol; psi4.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the scan across the potential energy surface.; Below the molecule block, you can see the Rvals array; specified. This is a Python array holding the interatomic distances we; want to consider. In Python, arrays are surrounded by square brackets, and; elements are separated by commas.; The next lines, set basis aug-cc-pVDZ and set freeze_core True,; are familiar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:18854,variab,variable,18854,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,15,['variab'],['variable']
Modifiability,"energies. Called as part of any coupled cluster computation. (T) CORRECTION ENERGY; A-(T) CORRECTION ENERGY; A-CCSD(T) CORRELATION ENERGY; A-CCSD(T) TOTAL ENERGY; AAA (T) CORRECTION ENERGY; AAB (T) CORRECTION ENERGY; ABB (T) CORRECTION ENERGY; BBB (T) CORRECTION ENERGY; BRUECKNER CONVERGED; CC CORRELATION ENERGY; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC ROOT n CORRELATION ENERGY; CC ROOT n DIPOLE; CC ROOT n DIPOLE X; CC ROOT n DIPOLE Y; CC ROOT n DIPOLE Z; CC ROOT n QUADRUPOLE; CC ROOT n QUADRUPOLE XX; CC ROOT n QUADRUPOLE XY; CC ROOT n QUADRUPOLE XZ; CC ROOT n QUADRUPOLE YY; CC ROOT n QUADRUPOLE YZ; CC ROOT n QUADRUPOLE ZZ; CC ROOT n TOTAL ENERGY; CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-CCSD CORRELATION ENERGY; SCS-CCSD TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CCENERGY. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__ccenergy-1.html:2014,Variab,Variables,2014,psi4manual/1.4.0/autodir_psivariables/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__ccenergy-1.html,2,['Variab'],['Variables']
Modifiability,"energies. Called as part of any coupled cluster computation. (T) CORRECTION ENERGY; A-(T) CORRECTION ENERGY; A-CCSD(T) CORRELATION ENERGY; A-CCSD(T) TOTAL ENERGY; AAA (T) CORRECTION ENERGY; AAB (T) CORRECTION ENERGY; ABB (T) CORRECTION ENERGY; BBB (T) CORRECTION ENERGY; BRUECKNER CONVERGED; CC CORRELATION ENERGY; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC ROOT n CORRELATION ENERGY; CC ROOT n DIPOLE; CC ROOT n DIPOLE X; CC ROOT n DIPOLE Y; CC ROOT n DIPOLE Z; CC ROOT n QUADRUPOLE; CC ROOT n QUADRUPOLE XX; CC ROOT n QUADRUPOLE XY; CC ROOT n QUADRUPOLE XZ; CC ROOT n QUADRUPOLE YY; CC ROOT n QUADRUPOLE YZ; CC ROOT n QUADRUPOLE ZZ; CC ROOT n TOTAL ENERGY; CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-CCSD CORRELATION ENERGY; SCS-CCSD TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Module; CCENERGY. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__ccenergy-1.html:2014,Variab,Variables,2014,psi4manual/1.5.0/autodir_psivariables/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__ccenergy-1.html,2,['Variab'],['Variables']
Modifiability,"energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, gcp_engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {“d1”, “d2”, “chg”, “das2009”, “das2010”, “nl”, “dmp2”, “d3zero2b”, “d3bj2b”, “d3mzero2b”, “d3mbj2b”, “d3zeroatm”, “d3bjatm”, “d3mzeroatm”, “d3mbjatm”, “d4bjeeqatm”}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type:; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type:; str. description¶; Tagline for dispersion dashlevel. Type:; str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type:; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type:; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:16925,flexible,flexible,16925,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['flexible'],['flexible']
Modifiability,"energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:125463,variab,variable,125463,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"ength gauge, computed at (x) wavelength, (x) rounded to nearest integer. CCD TOTAL ENERGY¶. CCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the coupled-cluster doubles level of theory. CC ALPHA-ALPHA PAIR ENERGIES¶. CCSD ALPHA-ALPHA PAIR ENERGIES¶. CC2 ALPHA-ALPHA PAIR ENERGIES¶. CC3 ALPHA-ALPHA PAIR ENERGIES¶. MP2 ALPHA-ALPHA PAIR ENERGIES¶; Restricted-reference same-spin pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC ALPHA-BETA PAIR ENERGIES¶. CCSD ALPHA-BETA PAIR ENERGIES¶. CC2 ALPHA-BETA PAIR ENERGIES¶. CC3 ALPHA-BETA PAIR ENERGIES¶. MP2 ALPHA-BETA PAIR ENERGIES¶; Restricted-reference opposite-spin (alpha first) pair energies for coupled-cluster; theories. Size number of active doubly occupied orbitals, square. CC SINGLET PAIR ENERGIES¶. CCSD SINGLET PAIR ENERGIES¶. CC2 SINGLET PAIR ENERGIES¶. CC3 SINGLET PAIR ENERGIES¶. MP2 SINGLET PAIR ENERGIES¶; Restricted-reference singlet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC TRIPLET PAIR ENERGIES¶. CCSD TRIPLET PAIR ENERGIES¶. CC2 TRIPLET PAIR ENERGIES¶. CC3 TRIPLET PAIR ENERGIES¶. MP2 TRIPLET PAIR ENERGIES¶; Restricted-reference triplet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:17579,adapt,adapted,17579,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['adapt'],['adapted']
Modifiability,"enominator), I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do.; I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions there. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4. Contribute Back; Not applicable as not under git control. Conda Binary Package¶. Get Initially; The pre-compiled conda packages at https://anaconda.org/psi4/psi4; can be installed into an existing Anaconda or Miniconda distribution; according to directions. Locally, install into; a conda environment as below.; >>> conda create -n p4env psi4 -c psi4; >>> conda activate p4env. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html:2125,plugin,plugin,2125,psi4manual/1.3.2/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html,2,['plugin'],['plugin']
Modifiability,"ensity() (psi4.core.TwoBodyAOInt method). update_geometry() (psi4.core.Molecule method). (psi4.driver.p4util.InPsight method). update_orbitals() (psi4.core.IntegralTransform method). UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() (psi4.core.HF method). Va() (psi4.core.HF method). VAL_EX_LEVEL (DETCI). valid_methods (psi4.core.OEProp attribute). validate_diis() (psi4.core.HF method). validate_options() (psi4.core.Options method). ValidationError. value (psi4.core.DerivCalcType attribute). (psi4.core.DiagonalizeOrder attribute). (psi4.core.FragmentType attribute). (psi4.core.GaussianType attribute). (psi4.core.GeometryUnits attribute). (psi4.core.PrimitiveType attribute). (psi4.core.PsiReturnType attribute). (psi4.core.SaveType attribute). value() (psi4.core.SuperFunctional method). values() (psi4.core.SuperFunctional method). variable() (in module psi4.core). (psi4.core.Wavefunction method). variables() (in module psi4.core). (psi4.core.Wavefunction method). Vb() (psi4.core.HF method). VBase (class in psi4.core). vdot() (psi4.core.CIVector method). VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector (class in psi4.core). Vector3 (class in psi4.core). vector_axpy() (psi4.driver.p4util.SolverEngine method). vector_copy() (psi4.driver.p4util.SolverEngine method). vector_dot() (psi4.core.Matrix method). (psi4.core.Vector method). (psi4.driver.p4util.SolverEngine static method). vector_multiply() (psi4.core.CIVector method). vector_scale() (psi4.driver.p4util.SolverEngine method). vectors() (psi4.core.FISAPT method). verbose (psi4.driver.driver_cbs.CompositeComputer attribute). version() (in module psi4.core). vibanal_wfn() (in module psi4.driver). vibrational analysis. ; function call. output. vir() (psi4.core.MOSpace static method). visualization, [1]. VMDPATH. vmfc. ; setting keywords. vmfc (psi4.driver.driver_nbody.BsseEnum attribute). vv10_b() (psi4.core.SuperFunctional method). vv10_c() (p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:129677,variab,variables,129677,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['variab'],['variables']
Modifiability,"ensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables; The easiest/least visible way to thread PSI4 is to set the standard OpenMP/MKL; environment variables OMP_NUM_THREADS and MKL_NUM_THREADS.; For instance, in tcsh:; setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4. PSI4 then detects these value via the API routines in <omp.h> and; <mkl.h>, and runs all applicable code with 4 threads. These environment; variables are typically defined in a .tcshrc or .bashrc.; (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() Psithon function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:5221,variab,variables,5221,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,8,['variab'],['variables']
Modifiability,"ensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in Psi4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled Psi4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in Psi4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables; The easiest/least visible way to thread Psi4 is to set the standard OpenMP/MKL; environment variables OMP_NUM_THREADS and MKL_NUM_THREADS.; For instance, in tcsh:; setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4. Psi4 then detects these value via the API routines in <omp.h> and; <mkl.h>, and runs all applicable code with 4 threads. These environment; variables are typically defined in a .tcshrc or .bashrc.; (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in Psi4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() Psithon function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a Psi4 input file. An example input for this feature is:; # A bit small-ish, but you ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:7832,variab,variables,7832,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variables']
Modifiability,"ent, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. from qcelemental.models import Molecule. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). meta, ids = client.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:3731,Config,Config,3731,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['Config'],['Config']
Modifiability,"ent, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3756,Config,Config,3756,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,1,['Config'],['Config']
Modifiability,"ent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""core.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nomi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:22670,variab,variable,22670,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['variab'],['variable']
Modifiability,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:23547,variab,variables,23547,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,4,['variab'],['variables']
Modifiability,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:27875,variab,variables,27875,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['variab'],['variables']
Modifiability,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:23415,variab,variables,23415,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,11,['variab'],['variables']
Modifiability,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in ran",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:24917,variab,variables,24917,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['variab'],['variables']
Modifiability,"ent_types(self: psi4.core.Molecule) → List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float; Returns the value of variable arg0 in the structural variables list. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str; Gets molecule name. natom(self: psi4.core.Molecule) → int; Number of real atoms. nfragments(self: psi4.core.Molecule) → int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:49362,variab,variable,49362,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,2,['variab'],"['variable', 'variables']"
Modifiability,"ental.datum. Source code for qcelemental.datum; """"""; Datum Object Model; """""". from decimal import Decimal; from typing import Any, Dict, Optional. import numpy as np; from pydantic import BaseModel, validator. [docs]class Datum(BaseModel):; r""""""Facilitates the storage of quantum chemical results by labeling them with basic metadata. Attributes; ----------; label : str; Official label for `data`, often qcvar. May contain spaces.; units : str; ASCII, LaTeX-like representation of units, without square brackets.; data : float or decimal.Decimal or numpy.ndarray; Value for `label`.; comment : str; Additional notes.; doi : str; Literature citation or definition DOI link.; glossary : str; Extended description or definition.; numeric : bool; Whether `data` is numeric. Pass `True` to disable validating `data` as float/Decimal/np.ndarray. """""". numeric: bool; label: str; units: str; data: Any; comment: str = """"; doi: Optional[str] = None; glossary: str = """". class Config:; extra = ""forbid""; allow_mutation = False; json_encoders = {np.ndarray: lambda v: v.flatten().tolist(), complex: lambda v: (v.real, v.imag)}. def __init__(self, label, units, data, *, comment=None, doi=None, glossary=None, numeric=True):; kwargs = {""label"": label, ""units"": units, ""data"": data, ""numeric"": numeric}; if comment is not None:; kwargs[""comment""] = comment; if doi is not None:; kwargs[""doi""] = doi; if glossary is not None:; kwargs[""glossary""] = glossary. super().__init__(**kwargs). @validator(""data""); def must_be_numerical(cls, v, values, **kwargs):; try:; 1.0 * v; except TypeError:; try:; Decimal(""1.0"") * v; except TypeError:; if values[""numeric""]:; raise ValueError(f""Datum data should be float, Decimal, or np.ndarray, not {type(v)}.""); else:; values[""numeric""] = True; else:; values[""numeric""] = True. return v. def __str__(self, label=""""):; width = 40; text = [""-"" * width, ""{:^{width}}"".format(""Datum "" + self.label, width=width)]; if label:; text.append(""{:^{width}}"".format(label, width=width)); te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:1067,Config,Config,1067,psi4manual/1.4.0/_modules/qcelemental/datum.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html,3,['Config'],['Config']
Modifiability,"entation(True); molecule.fix_com(True); molecule.update_geometry(). if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; core.set_global_option('REFERENCE', 'UHF'); elif user_reference == 'RKS':; core.set_global_option('REFERENCE', 'UKS'). core.set_global_option('WRITER_FILE_LABEL', user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(f""Optimization exceeded cycles for {rgt}""); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); core.print_out("" Database Contributions Map:\n {}\n"".format('-' * 75)); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; core.print_out(' reagent {} contributes by {:.4f} to reaction {}\n'.format(rgt, RXNM[db_rxn][rgt], db_rxn)); core.print_out('\n'); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not mak",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:17278,variab,variable,17278,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['variab'],['variable']
Modifiability,entation. /master; . /_downloads; . /15093ea218ca0a61a6f46db92e78ed97; ; gdma-2.3.pdf. /_modules; . /psi4; . /driver; . /p4util; ; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util. /procrouting; ; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc. /qcdb; ; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib. psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.pluginutil; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database. psi4.extras. /qcdb; ; qcdb.vib. /qcelemental; ; qcelemental.testing. Overview: module code. /_static; ; autodoc_pydantic.css; basic.css; cloud.base.js; cloud.css; cloud.js; doctools.js; documentation_options.js; favicon-psi4.ico; graphviz.css; jquery.cookie.js; language_data.js; nbsphinx-code-cells.css; psi4.css; pygments.css; searchtools.js; sphinx_highlight.js; tabs.css; tabs.js. /api; ; AngularMomentumInt; AOShellCombinationsIterator; array_variable; array_variables; BasisExtents; BasisFunctions; BasisSet; be_quiet; be_quiet; benchmark_blas1; benchmark_blas2; benchmark_blas3; benchmark_disk; benchmark_integrals; benchmark_math; BlockOPoints; BoysLocalizer; BSVec; ccdensity; ccenergy; cceom; cchbar; cclambda; ccresponse; cctransort; cctriples; CCWavefunction; CdSalc; CdSalcList; CharacterTable; CIVector; CIWavefunction; clean; clean_options; clean_timers; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1733301,plugin,pluginutil,1733301,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['pluginutil']
Modifiability,"ential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_vector(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_ci_H0block(self: psi4.core.CIWavefunction) → None¶; docstring. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:26150,variab,variables,26150,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variables']
Modifiability,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:55739,adapt,adapted,55739,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,14,['adapt'],['adapted']
Modifiability,"ent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:24043,variab,variable,24043,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,12,['variab'],"['variable', 'variables']"
Modifiability,"ent}. get_fragments(self: psi4.core.Molecule) → list[tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → list[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:24277,variab,variable,24277,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,4,['variab'],"['variable', 'variables']"
Modifiability,"envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:18256,variab,variable,18256,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['variab'],['variable']
Modifiability,"en’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/interfacing-1.html:1262,config,configure,1262,psi4manual/1.1.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/interfacing-1.html,10,['config'],['configure']
Modifiability,"eometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.get('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:52991,variab,variable,52991,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['variab'],['variable']
Modifiability,"eometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:49509,variab,variables,49509,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scalar_variable(arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. psi4.core.scalar_variables() → Dict[str, float]¶; Returns dictionary of all double QC variables. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:286692,adapt,adapted,286692,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:235469,adapt,adapted,235469,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_environment(arg0: str, arg1: str) → str¶; Set enviromental vairable. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in the 3N-6 Vector ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:156054,adapt,adapted,156054,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"epa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:29940,variab,variables,29940,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"ependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to ERD by N. Flocke and V. Lotrich. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/erd-1.html:2553,variab,variable,2553,psi4manual/1.4.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/erd-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to ERD by N. Flocke and V. Lotrich. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/erd-1.html:2553,variab,variable,2553,psi4manual/1.5.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/erd-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"epo.continuum.io/miniconda/Miniconda2-latest-Linux-x86_64.sh""; >>> curl -o Miniconda-latest.sh ""https://repo.continuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh"". >>> bash; >>> bash Miniconda-latest.sh -b -p $HOME/miniconda # agrees to conda's license terms; >>> echo ""export PATH=$HOME/miniconda/bin:\$PATH"" >> ~/.bashrc; # log out, log back in so conda in path; >>> conda update --yes --all; >>> conda config --add channels http://conda.anaconda.org/psi4; >>> conda install --yes psi4; >>> psi4 ""$(dirname $(which psi4))""/../share/psi4/samples/sapt1/test.in # test installation. works b/c PSI_SCRATCH defaults to /tmp. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. Now you need only specify a scratch directory; (see Scratch Files and Elementary Restart) by replacing the placeholder in the following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. Detailed Installation of Miniconda¶. Sanity check. If you already have Miniconda or Anaconda, skip to step 5. The whole installation takes ~5 min; reading this page takes far longer.; Get bzip2. You’ll need this slightly exotic command so run which to test for availability, and install from yum, source, etc. if unavailable. You’ll also need an internet connection for downloading; computers behind a firewall or with restricted login domains are eligible. So long as you can ssh into the computer to an account with write permissions and can connect to the internet from the computer, all is well. # check; >>> which bzip2; /usr/bin/bzip2; >>> curl -O ""http://psicode.org/psi4manual/master/introduction.html""; >>> ls -1; introduction.html. Get Minicon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/conda-1.html:6129,variab,variable,6129,psi4manual/1.0.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/conda-1.html,2,['variab'],['variable']
Modifiability,"epository in the Psi4 build¶; For each Add-On, PSI4 pulls source from a specific online Git; repository and a specific tag/branch/commit in it. This ensures success; of the PSI4 build, reproducibility of the runtime results, and; freedom for continued upstream development. Sometimes, you’re the one; doing that development, and you need the CMake superbuild to pull source; from a local path rather than the approved codeset.; Find the CMakeLists.txt governing the target Add-On in; psi4/external and make changes analogous to the below:; #GIT_REPOSITORY https://github.com/jturney/ambit; #GIT_TAG 1.0; DOWNLOAD_COMMAND """"; SOURCE_DIR ""/path/to/ambit-directclone"". If you’re changing the PSI4 repo codebase between compiles, there’s; nothing more to do as CMake will handle the code rebuild deps for you.; If you’re changing the local Add-On repo codebase between compiles,; CMake does not know when libaddon.[a|so|dylib] needs rebuilding. It; is recommended that the PSI4 build be initially configured with; -DBUILD_SHARED_LIBS=ON (easier to notice changes). And to trigger; Add-On library rebuild, rm -rf {objdir}/external/upstream/addon/; and rm -rf {objdir}/stage/share/cmake/AddOn. This should; re-clone the Add-On, rebuild and install it, rebuild any parts of; PSI4 that interface to it, and relink the main core.so.; If you’re modifying the Add-On’s file or directory structure, be; smart and rm all traces of it within {objdir}/stage/,; especially any *.pyc files.; Alternatively and preferentially to the above, you can instead build and install the; Add-On library yourself, external to the PSI4 repository. This; is especially useful if you want to avoid full recompiles of the; Add-On at each change to the Add-On’s source. Build the Add-On; library dynamically (-DBUILD_SHARED_LIBS=ON) and mind any; “Psi4 wants” in the Add-On’s top-level CMakeLists.txt. Install the; Add-On and note the full path to AddOnConfig.cmake. Pass; the path containing that file to PSI4‘s CMake as; -DAddon_DI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:58131,config,configured,58131,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['config'],['configured']
Modifiability,"equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC (CFOUR)¶CFOUR — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY (CFOUR)¶CFOUR — Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR)¶CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL (CFOUR)¶CFOUR — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:57444,coupling,coupling,57444,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,['coupling'],['coupling']
Modifiability,"equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:106085,adapt,adapted,106085,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['adapt'],['adapted']
Modifiability,"equencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.cuhf.html:11205,variab,variable,11205,psi4manual/1.2.1/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.cuhf.html,12,['variab'],"['variable', 'variables']"
Modifiability,"equires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Cre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3553,plugin,plugin,3553,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugin']
Modifiability,"equires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html:3549,plugin,plugin,3549,psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,2,['plugin'],['plugin']
Modifiability,"er Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugin_snsmp2-1.html:1687,adapt,adapted,1687,psi4manual/1.4.0/plugin_snsmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugin_snsmp2-1.html,2,['adapt'],['adapted']
Modifiability,"er Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/plugin_snsmp2-1.html:1687,adapt,adapted,1687,psi4manual/1.5.0/plugin_snsmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/plugin_snsmp2-1.html,2,['adapt'],['adapted']
Modifiability,"er SAPT, traditional definition. sapt2+; SAPT including all 2nd-order terms. sapt2+(3); SAPT including perturbative triples. sapt2+3;  . sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation. sapt2-ct; SAPT2 plus CT. sapt2+-ct; SAPT2+ plus CT. sapt2+(3)-ct; SAPT2+(3) plus CT. sapt2+3-ct; SAPT2+3 plus CT. cc2; approximate coupled cluster singles and doubles (CC2). ccsd; coupled cluster singles and doubles (CCSD). bccd; Brueckner coupled cluster doubles (BCCD). cc3; approximate coupled cluster singles, doubles, and triples (CC3). ccsd(t); CCSD with perturbative triples. bccd(t); BCCD with perturbative triples. ccenergy; expert full control over ccenergy module. mpn; nth-order Moller–Plesset perturbation theory. zaptn; nth-order z-averaged perturbation theory (ZAPT). cisd; configuration interaction (CI) singles and doubles (CISD). cisdt; CI singles, doubles, and triples (CISDT). cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ). cin; nth-order CI. fci; full configuration interaction (FCI). detci; expert full control over detci module. adc; 2nd-order algebraic diagrammatic construction (ADC). eom-cc2; EOM-CC2. eom-ccsd; equation of motion (EOM) CCSD. eom-cc3; EOM-CC3. cepa(n); coupled electron pair approximation, variants 0, 1, and 3. acpf; averaged coupled-pair functional. aqcc; averaged quadratic coupled cluster. omp2; orbital-optimized second order Moller–Plesset perturbation theory. scs-omp2; spin-component scaled OMP2. sos-omp2; spin-opposite scaled OMP2. omp3; orbital-optimized third order Moller–Plesset perturbation theory. scs-omp3; spin-component scaled OMP3. sos-omp3; spin-opposite scaled OMP3. name; calls method (aliases to name = ‘scf’). hf; HF. rhf; HF with restricted reference. uhf; HF with unrestricted reference. rohf; HF with restricted open-shell reference. rscf; HF or DFT with restricted reference. uscf; HF or DFT with unrestricted reference. roscf; HF or DFT with restricted open-shell reference. df-scf; HF or DFT with density fitti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/energy-1.html:1836,config,configuration,1836,psi4manual/4.0b3/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/energy-1.html,2,['config'],['configuration']
Modifiability,"er SAPT, traditional definition. sapt2+; SAPT including all 2nd-order terms. sapt2+(3); SAPT including perturbative triples. sapt2+3;  . sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation. sapt2-ct; SAPT2 plus CT. sapt2+-ct; SAPT2+ plus CT. sapt2+(3)-ct; SAPT2+(3) plus CT. sapt2+3-ct; SAPT2+3 plus CT. cc2; approximate coupled cluster singles and doubles (CC2). ccsd; coupled cluster singles and doubles (CCSD). bccd; Brueckner coupled cluster doubles (BCCD). cc3; approximate coupled cluster singles, doubles, and triples (CC3). ccsd(t); CCSD with perturbative triples. bccd(t); BCCD with perturbative triples. ccenergy; expert full control over ccenergy module. mpn; nth-order Moller–Plesset perturbation theory. zaptn; nth-order z-averaged perturbation theory (ZAPT). cisd; configuration interaction (CI) singles and doubles (CISD). cisdt; CI singles, doubles, and triples (CISDT). cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ). cin; nth-order CI. fci; full configuration interaction (FCI). detci; expert full control over detci module. adc; 2nd-order algebraic diagrammatic construction (ADC). eom-cc2; EOM-CC2. eom-ccsd; equation of motion (EOM) CCSD. eom-cc3; EOM-CC3. name; calls method (aliases to name = ‘scf’). hf; HF. rhf; HF with restricted reference. uhf; HF with unrestricted reference. rohf; HF with restricted open-shell reference. rscf; HF or DFT with restricted reference. uscf; HF or DFT with unrestricted reference. roscf; HF or DFT with restricted open-shell reference. df-scf; HF or DFT with density fitting. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional. b3lyp5-d; B3LYP5 Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/energy-1.html:1771,config,configuration,1771,psi4manual/4.0b2/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/energy-1.html,2,['config'],['configuration']
Modifiability,"er for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:1709,variab,variable,1709,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,9,['variab'],['variable']
Modifiability,"er is listed in content. Only the filenumber; is necessary for the driver to appropriately rename the file for the next PSI4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; 1energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; 1psi4 -m. ~/.psi4rc File¶; If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file.; To set up the scratch path:; 1psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the checkpoint file and instruct PSI4 not to delete it:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 insta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:8385,variab,variable,8385,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,4,['variab'],['variable']
Modifiability,"er of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. functional(self); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:6743,variab,variable,6743,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variable']
Modifiability,"er of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. functional(self); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); The MintsHelper object. moFa(self); docstring. moFb(self); docstring. moFeff(self); docstring. mo_extents(self); returns the wavefunction's electronic orbital extents. mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html:6802,variab,variable,6802,psi4manual/1.6.x/api/psi4.core.ROHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html,2,['variab'],['variable']
Modifiability,"er of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. functional(self); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); The MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:6744,variab,variable,6744,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,6,['variab'],['variable']
Modifiability,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull inform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:87808,variab,variable,87808,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['variab'],['variable']
Modifiability,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull informat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:87779,variab,variable,87779,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:79759,variab,variable,79759,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"er type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC); DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF); SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF); SCF — Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF); SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF); SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF); SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF); SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after conve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:212442,adapt,adapted,212442,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['adapt'],['adapted']
Modifiability,"er — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:14158,variab,variable,14158,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['variab'],['variable']
Modifiability,"er(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction’s electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:5852,variab,variable,5852,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variable']
Modifiability,"er/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/pcmsolver.html:5139,variab,variable,5139,psi4manual/master/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/master/pcmsolver.html,1,['variab'],['variable']
Modifiability,"er/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/pcmsolver.html:5130,variab,variable,5130,psi4manual/1.7.x/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/pcmsolver.html,1,['variab'],['variable']
Modifiability,"er/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/pcmsolver.html:5132,variab,variable,5132,psi4manual/1.8.x/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/pcmsolver.html,1,['variab'],['variable']
Modifiability,"er/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/pcmsolver.html:5132,variab,variable,5132,psi4manual/1.9.x/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/pcmsolver.html,1,['variab'],['variable']
Modifiability,"er:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dkh-1.html:3190,config,configdir,3190,psi4manual/1.4.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dkh-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"er:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dkh-1.html:3190,config,configdir,3190,psi4manual/1.5.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dkh-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"eraged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:23391,variab,variable,23391,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['variab'],['variable']
Modifiability,"erbst and M. Scheurer; Installation; Keywords for adcc; How to configure adcc for building Psi4. Interface to the BrianQC GPU module by the BrianQC team; Installing BrianQC; Building BrianQC’s user-built components; Building PSI4 with BrianQC; Using BrianQC from PSI4; Keywords; Environment Variables. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/interfacing-1.html:1553,config,configure,1553,psi4manual/1.4.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/interfacing-1.html,2,['config'],['configure']
Modifiability,"erd from conda without thinking, consult sec:condapsi4dev.; To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/erd-1.html:2634,variab,variable,2634,psi4manual/1.2.1/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/erd-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ere; are problems with the stability of the correlation hole. Don’t worry, it; will definitely NaN on you if you try to use it. Meta FunctionalsWe have recently implemented the M05 classes of meta functionals in; PSI4. Note that these functionals are not appropriate for modeling; dispersion interactions, as they lack dispersion physics. A -D functional (Such; as the much cheaper B97-D) should be used instead. Hybrid FunctionalsMany common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the; B97 series are also quite good for many thermochemical problems. LRC FunctionalsLRC functionals are a particular area of interest of the PSI4 DFT team.; LRC functionals are all denoted by a lower-case “w” in front of the standard DFA; functional, such as wPBE. We offer a stable implementation of the Gill; association function for wS and Head-Gordon’s wB97/wB97X functionals.; Additionally, we are pleased to have recently completed a heavily conditioned; implementation of the HJS exchange-hole model, which provides an analytical form; for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a; physics perspective, this implementation of wPBE is extremely useful for; theoretical investigations, as it is parameter free, and properly integrated; against the partition function in the exchange hole. We would like to thank Dr.; Scuseria for providing helpful advice and a reference implementations of the; older HSE exchange-hole model which led to the successful implementation of the; HJS model. Double-Hybrid FunctionalsDouble hybrids are percolating into PSI4. Note that these are; only available with density-fitted, not conventional, MP2 algorithms. -D FunctionalsWe have several -D2 functionals implemented. -D3 functionls are available; with the installation of Grimme’s DFTD3 program.; For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort to rigo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:17914,enhance,enhancement,17914,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['enhance'],['enhancement']
Modifiability,"erence( (Deriv)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_ignore_reference(N3psi5DerivE {lvalue},b). psi4.Deriv.set_tpdm_presorted()¶; Python Library Documentation: method set_tpdm_presorted; set_tpdm_presorted(...) unbound psi4.Deriv method. set_tpdm_presorted( (Deriv)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_tpdm_presorted(N3psi5DerivE {lvalue},b). DiagonalizeOrder¶. psi4.DiagonalizeOrder.Ascending()¶; Python Library Documentation: DiagonalizeOrder in module psi4 object; class DiagonalizeOrder(Boost.Python.enum). docstring. Method resolution order:. DiagonalizeOrder. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Ascending = psi4.DiagonalizeOrder.Ascending. Descending = psi4.DiagonalizeOrder.Descending. names = {‘Ascending’: psi4.DiagonalizeOrder.Ascending, ‘Descending’: p... values = {1: psi4.DiagonalizeOrder.Ascending, 3: psi4.DiagonalizeOrder... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:106842,inherit,inherited,106842,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/relativistic.html:4761,extend,extended,4761,psi4manual/master/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/master/relativistic.html,1,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/relativistic-1.html:4814,extend,extended,4814,psi4manual/1.2.1/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/relativistic-1.html,2,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/relativistic-1.html:4814,extend,extended,4814,psi4manual/1.3.2/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/relativistic-1.html,2,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/relativistic-1.html:4752,extend,extended,4752,psi4manual/1.4.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/relativistic-1.html,2,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/relativistic-1.html:4752,extend,extended,4752,psi4manual/1.5.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/relativistic-1.html,2,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/relativistic.html:4752,extend,extended,4752,psi4manual/1.6.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/relativistic.html,1,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/relativistic.html:4752,extend,extended,4752,psi4manual/1.7.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/relativistic.html,1,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 Octobe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/relativistic.html:4754,extend,extended,4754,psi4manual/1.8.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/relativistic.html,1,['extend'],['extended']
Modifiability,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 Februar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/relativistic.html:4754,extend,extended,4754,psi4manual/1.9.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/relativistic.html,1,['extend'],['extended']
Modifiability,"ergy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/{prefix}/lib/psi4/core.so ../psi4/core.so; >>> python ../psi4/run_psi4.py --inplace input.dat. How to set PSIDATADIR and why¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additiona",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:24082,variab,variable,24082,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ergy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:9119,extend,extend,9119,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,15,['extend'],['extend']
Modifiability,"erint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45894,extend,extended,45894,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,2,['extend'],['extended']
Modifiability,"eriori dispersion corrections are available in; PSI4. While most are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] through dftd3; [\(s_6\), \(\alpha_6\)]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\)]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\beta\)]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. Footnotes. [1]Note that th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:5238,variab,variable,5238,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,2,['variab'],['variable']
Modifiability,"eriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] through dftd3; [\(s_6\), \(\alpha_6\)]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\)]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\beta\)]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. Footnotes. [1]Note that th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:5401,variab,variable,5401,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,2,['variab'],['variable']
Modifiability,"eriori dispersion corrections are available in; PSI4. While some are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of dispersion corrections¶. Extension [1]; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; -D1; -D2; -D3; -D3ZERO; -D3BJ; -D3(BJ); -D3M; -D3MZERO; -D3MBJ; -D3M(BJ); -NL; -CHG; -DAS2009; -DAS2010; alias to -D2; -D1 [2]; -D2 [3]; alias to -D3ZERO; -D3 [4] w/ original zero-damping; -D3 [5] w/ newer Becke-Johnson rational damping; alias to -D3BJ; alias to -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping; alias to -D3MBJ; Grimme’s -NL (DFT plus VV10 correlation) [7]; Chai & Head-Gordon dispersion formula [8]; Podeszwa & Szalewicz dispersion formula [9]; Podeszwa & Szalewicz dispersion formula [10]; PSI4’s libdisp; PSI4’s libdisp OR dftd3; dftd3; dftd3; dftd3; dftd3; PSI4’s nl; PSI4’s libdisp; PSI4’s libdi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dftd3-1.html:5384,variab,variable,5384,psi4manual/1.3.2/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dftd3-1.html,2,['variab'],['variable']
Modifiability,"erited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE aotoso(N3psi10PetiteListE {lvalue}); | ; | print(...); | print( (PetiteList)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void print(N3psi10PetiteListE {lvalue},Ss); | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE sotoao(N3psi10PetiteListE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __init__( (object)arg1, (str)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,Ss); | ; | __reduce__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:578481,inherit,inherited,578481,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"erivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch details and such; # try:; # import psi4; # except ImportError as err:; # isP4regime = False; # else:; # isP4regime = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); if isP4regime:; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(uuid.uuid4())[:8]; else:; dftd3_tmpdir = os.environ['HOME'] + os.sep + 'dftd3_' + str(uuid.uuid4())[:8]; if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:4346,variab,variables,4346,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['variab'],['variables']
Modifiability,"ero2b. hcth120-d3zeroatm. hcth147; HCTH147 GGA Exchange-Correlation Functional. hcth407; HCTH407 GGA Exchange-Correlation Functional. hcth407-d3bj2b. hcth407-d3bjatm. hcth407-d3zero2b. hcth407-d3zeroatm. hcth407p; HCTH407P GGA Exchange-Correlation Functional. hcth93; HCTH93 GGA Exchange-Correlation Functional. hcthp14; HCTHP14 GGA Exchange-Correlation Functional. hcthp76; HCTHP76 GGA Exchange-Correlation Functional. hf; Hartree–Fock theory. hf+d. hf-d3bj2b. hf-d3bjatm. hf-d3mbj2b. hf-d3mbjatm. hf-d3mzero2b. hf-d3mzeroatm. hf-d3zero2b. hf-d3zeroatm. hf-nl; Hartree–Fock theory. hf3c; Hartree Fock based 3C composite method with minimal basis set, gCP and D3(BJ). hpbeint; HPBEINT Hyb-GGA Exchange-Correlation Functional. kmlyp; KMLYP Hyb-GGA Exchange-Correlation Functional. ksdt; KSDT Exchange-Correlation Functional. kt2; KT2 GGA Exchange-Correlation Functional. lda0; LDA0 Exchange-Correlation Functional. m05; M05 Meta-GGA XC Functional (10.1063/1.2126975). m05-2x; Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. m05-2x-d3zero2b. m05-2x-d3zeroatm. m05-d3zero2b. m05-d3zeroatm. m06; M06 Meta-GGA XC Functional (10.1007/s00214-007-0310-x). m06-2x; Hybrid M06-2X Meta-GGA XC Functional (10.1007/s00214-007-0310-x). m06-2x-d3zero2b. m06-2x-d3zeroatm. m06-d3zero2b. m06-d3zeroatm. m06-hf; Minnesota M06-HF Hybrid XC Functional (10.1021/jp066479k). m06-hf-d3zero2b. m06-hf-d3zeroatm. m06-l; M06-L Meta-GGA XC Functional. m06-l-d3zero2b. m06-l-d3zeroatm. m08-hx; Minnesota M08-HX Hybrid XC Functional (10.1021/ct800246v). m08-hx-d3zero2b. m08-hx-d3zeroatm. m08-so; Minnesota M08-SO Hybrid XC Functional (10.1021/ct800246v). m11-l; M11-L Meta-GGA XC Functional. m11-l-d3bj2b. m11-l-d3bjatm. m11-l-d3zero2b. m11-l-d3zeroatm. mb3lyp-rc04; MB3LYP-RC04 Hyb-GGA Exchange-Correlation Functional. mgga_ms0; MGGA_MS0 Meta-GGA XC Functional. mgga_ms1; MGGA_MS1 Meta-GGA XC Functional. mgga_ms2; MGGA_MS2 Meta-GGA XC Functional. mgga_ms2h; MGGA_MS2h Hybrid Meta-GGA XC Functional. mgga_mvs; MGGA_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.opt.html:8151,Parameteriz,Parameterized,8151,psi4manual/1.9.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.opt.html,4,['Parameteriz'],['Parameterized']
Modifiability,"ers:; Ubuntu gfortran; conda gfortran_linux-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be semicolon-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present); If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:35571,variab,variable,35571,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ers; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/interfacing.html:1919,config,configure,1919,psi4manual/1.6.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/interfacing.html,1,['config'],['configure']
Modifiability,"ersion 1.62). cmake .. Build the examples and samples. make. Test the installation by starting a small calculation.; Make sure to set the BRIANQC_INSTALL_PATH environment variable to <brianqc_install_path>!. export BRIANQC_INSTALL_PATH=<brianqc_install_path>; bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz. Building PSI4 with BrianQC¶; When CMake-ing PSI4, set the ENABLE_BrianQC CMake variable to 1; and set the BrianQC_DIR CMake variable to the path where BrianQC’s; components have been built (usually <brianqc_install_path>/build), then build PSI4 normally. Using BrianQC from PSI4¶; To use BrianQC, the BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; internal computation is either performed by PSI4 (if unsupported by BrianQC),; or taken over by BrianQC, yielding the same result to within the required; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computations, including Fock and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and DFT frequency analysis. Note that not every term of every calculation can be handled by BrianQC, thus,; the actual speedup depends on the specifics of the calculation. Necessary and recommended option values¶; To ensure that a calculation works with BrianQC, the following options need to; be set when en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:2432,variab,variable,2432,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,18,['variab'],['variable']
Modifiability,"ersion. 1.0 and 1.1 really shouldn’t be mixed. >>> conda update psi4 -c psi4. # if psi4 channel in defaults (true for Psi4conda installers); >>> conda update psi4. Conda command to update an existing PSI4 conda installation to the; latest development head (roughly nightly).; >>> conda update psi4 -c psi4/label/dev. # if add-on updates required, try; >>> conda update psi4 -c psi4/label/dev -c psi4. How to use conda to compile Psi4 faster and easier¶; # Linux or Mac or Windows; # substitute x.x by 2.7|3.5|3.6 for alternate python versions; >>> conda create -n p4dev python=x.x psi4-dev -c psi4. Same for Linux/Mac/Windows. Substitute desired python version: 2.7, 3.5, 3.6. Fine; to choose your own env name. Activate environment, source activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For DGAS,; there’s a --disable-addons, but I don’t encourage it. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install NumPy and the executable add-ons (e.g., dftd3); >>> conda install numpy psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, and numpy. Of gcc-ness, it has minimal, run-time libraries,; not compilers, though, for Linux/Windows, full gcc and run-time gcc are the same.; It doesn’t have the run-time qc addons psi4-rt (e.g., dftd3) or build tools (e.g., sphinx and cmake).; psi4-dev - does not have p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:6920,config,configure,6920,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,2,['config'],['configure']
Modifiability,"ert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi::Matrix], x: psi::Matrix) → None; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None; Remove the first item from the list whose value is x. It is an error if there is no such item. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vectormatrix.html:1603,extend,extend,1603,psi4manual/1.2.1/api/psi4.core.vectormatrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vectormatrix.html,1,['extend'],['extend']
Modifiability,"erticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=18). # plot reaction errors and threads; for rxn in data:. # preparation; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); slat = []; for weft in range(Nweft):; slat.extend([xvals[weft], xvals[weft], None]); thread = []; for weft in range(Nweft - 1):; thread.extend([xvals[weft], xvals[weft + 1], None]). # plotting; if Nweft == 1:; ax.plot(slat, posnS, '|', color=clr, markersize=20.0, mew=1.5, solid_capstyle='round'); else:; ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round', alpha=0.3). # converting into screen coordinates for image map; npxvals = [np.nan if val is None else val for val in xvals]; xyscreen = ax.transData.transform(zip(npxvals, positions)); xscreen, yscreen = zip(*xyscreen); posnM.extend(zip([rxn['db']] * Nweft, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8); ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8). # plot trimmings; if mae is not None:; ax.plot([-x for x in mae], positions, 's', color='black'); if labeled:; if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); plt.axvline(0, color='#cccc00'). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:19520,extend,extend,19520,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"erties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. optstash.restore(); core.tstop(); return dfmp2_wfn. def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_det",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:82732,variab,variable,82732,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"erties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; 1oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in property() function, e.g.:; 1property('ccsd', properties=['dipole']). The property() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of property() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; glob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/oeprop-1.html:2423,variab,variables,2423,psi4manual/1.1.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/oeprop-1.html,6,['variab'],['variables']
Modifiability,"es HDF5)"" OFF); option(ENABLE_cppe ""Enables CPPE for Polarizable Embedding"" OFF); option(ENABLE_adcc ""Enables adcc for algebraic-diagrammatic construction methods (requires libtensorlight; can also be added at runtime)"" OFF); option(ENABLE_ddx ""Enables ddx for domain-decomposition contiuum solvation models (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_dkh ""Enables DKH integrals (requires Fortran)"" OFF); option(ENABLE_ecpint ""Enables libecpint for effective core potentials (ECP)"" OFF); option(ENABLE_libefp ""Enables LIBEFP and PylibEFP for fragments"" OFF); option(ENABLE_erd ""Enables use of ERD instead of Libint (requires Fortran)"" OFF); option(ENABLE_simint ""Enables use of SIMINT two-electron integral library"" OFF); option(ENABLE_gdma ""Enables Stone's GDMA multipole code (requires Fortran)"" OFF); option(ENABLE_PCMSolver ""Enables PCMSolver library (requires Fortran)"" OFF); option(ENABLE_snsmp2 ""Enables SNSMP2 plugin (can also be added at runtime)"" OFF); option(ENABLE_v2rdm_casscf ""Enables V2RDM_CASSCF plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_psi4fockci ""Enables Psi4FockCI plugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:20921,plugin,plugin,20921,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,6,['plugin'],['plugin']
Modifiability,"es against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:259060,variab,variables,259060,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"es dummies) in Bohr; >>> print H2OH2O.fz(4); 0.0. geometry()[source]¶; Returns the geometry in Bohr as a N X 3 array.; >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. get_anchor_atom(vstr, line)[source]¶; Attempts to interpret a string vstr as an atom specifier in; a zmatrix. Takes the current line for error message printing.; Returns the atom number (adjusted to zero-based counting). get_coord_value(vstr)[source]¶; Attempts to interpret a string as a double, if not it assumes it’s a variable. get_full_point_group()[source]¶; NYI Return point group name such as C3v or S8.; (method name in libmints is full_point_group). get_variable(vstr)[source]¶; Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. has_inversion(origin, tol=1e-08)[source]¶; Does the molecule have an inversion center at origin. has_symmetry_element(op, tol=1e-08)[source]¶; NYI Whether molecule satisfies the vector symmetry operation op. has_zmatrix()[source]¶; Gets the presence of any zmatrix entry; >>> print H2OH2O.has_zmatrix(); False. inertia_tensor()[source]¶; Compute inertia tensor.; >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. init_with_checkpoint(chkpt)[source]¶; NYI Pull information from the chkpt object passed; (method name in libmints is init_with_chkpt). init_with_io(psio)[source]¶; NYI Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). classmethod init_with_xyz(xyzfilename)[source]¶; Pull information from an XYZ file. No fragment or chg/mult info detected.; >>> H2O =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:51119,variab,variable,51119,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['variab'],['variable']
Modifiability,"es dummies) in Bohr; >>> print H2OH2O.fz(4); 0.0. geometry()[source]¶; Returns the geometry in Bohr as a N X 3 array.; >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. get_anchor_atom(vstr, line)[source]¶; Attempts to interpret a string vstr as an atom specifier in; a zmatrix. Takes the current line for error message printing.; Returns the atom number (adjusted to zero-based counting). get_coord_value(vstr)[source]¶; Attempts to interpret a string as a double, if not it assumes it’s a variable. get_full_point_group()[source]¶; NYI Return point group name such as C3v or S8.; (method name in libmints is full_point_group). get_variable(vstr)[source]¶; Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. has_inversion(origin, tol=1e-08)[source]¶; Does the molecule have an inversion center at origin. has_symmetry_element(op, tol=1e-08)[source]¶; NYI Whether molecule satisfies the vector symmetry operation op. inertia_tensor()[source]¶; Compute inertia tensor.; >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. init_with_checkpoint(chkpt)[source]¶; NYI Pull information from the chkpt object passed; (method name in libmints is init_with_chkpt). init_with_io(psio)[source]¶; NYI Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). classmethod init_with_xyz(xyzfilename)[source]¶; Pull information from an XYZ file. No fragment or chg/mult info detected.; >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). irrep_labels()[source]¶; NYI Returns the irrep labels. is_axis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:47142,variab,variable,47142,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['variab'],['variable']
Modifiability,"es molecule to center of charge. print_ring_planes(entity1, entity2, entity3=None, entity4=None)[source]¶; (reals only, 1-indexed). rotor_type(tol=1e-08)[source]¶; Returns the rotor type.; >>> H2OH2O.rotor_type(); RT_ASYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(save_ghosts=True, save_natom=False)[source]¶; Save a string for a XYZ-style file.; >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. backtransform(chgeMol, permMol, chgeGrad=None, chgeDip=None)[source]¶; Here, chgeMol and chgeGrd need to be turned into the native Cfour; orientation embodied by permMol. Currently for vpt2. cfour_gradient_list()[source]¶; Return an array of Cfour methods with analytical gradients.; Appended to procedures[‘gradient’]. cfour_list()[source]¶; Return an array of Cfour methods with energies. Appended; to procedures[‘energy’]. cfour_psivar_list()[source]¶; Return a dict with ke",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:23884,extend,extended,23884,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['extend'],['extended']
Modifiability,"es of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the requested Beta Density subset. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:16743,inherit,inherited,16743,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['inherit'],['inherited']
Modifiability,"es of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. class psi4.core.CIVector¶; Bases: pybind11_builtins.pybind11_object; docstring. axpy(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int, arg3: int) → None¶; docstring. close_io_files(self: psi4.core.CIVector, arg0: int) → None¶; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int) → None¶; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int) → float¶; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int) → None¶; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool) → None¶; docstring. norm(self: psi4.core.CIVector, arg0: int) → float¶; docstring. np¶; Returns a view of the CIVector’s buffer. read(self: psi4.core.CIVector, arg0: int, arg1: int) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:19380,inherit,inherited,19380,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"es of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memory(self: psi4.core.DFHelper) → int¶. get_method(self: psi4.core.DFHelper) → str¶. get_schwarz_cutoff(self: psi4.core.DFHelper) → float¶. get_space_size(self: psi4.core.DFHelper, arg0: str) → int¶. get_tensor(*args, **kwargs)¶; Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:65892,inherit,inherited,65892,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"es of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.array_variable(arg0: str) → psi::Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. psi4.core.array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of all Matrix QC variables. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:276607,inherit,inherited,276607,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['inherit'],['inherited']
Modifiability,"es or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:42783,variab,variables,42783,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"es or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:44852,variab,variables,44852,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23443,variab,variable,23443,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['variab'],['variable']
Modifiability,"es    .    .    .    .  · ; 1.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4_1495011512596/work/build/stage//scratch/psilocaluser/conda-builds/psi4_1495011512596/_b_env_placehold_placehold/lib/python3.5/site-packag",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:1080,variab,variables,1080,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,2,['variab'],['variables']
Modifiability,"es — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/libint.html:3049,config,configdir,3049,psi4manual/1.8.x/libint.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/libint.html,3,"['config', 'variab']","['configdir', 'configure', 'variables']"
Modifiability,"es — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/libint.html:3049,config,configdir,3049,psi4manual/1.9.x/libint.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/libint.html,3,"['config', 'variab']","['configdir', 'configure', 'variables']"
Modifiability,"es, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:29834,Variab,VariableValue,29834,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Variab'],['VariableValue']
Modifiability,"es,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules Cross-module Redundancies. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); fourth-order perturbation theory, minus triples contribution; MP_TYPE CONV. mp4; full fourth-order perturbation theory; MP_TYPE CONV. lccd; linear ccd; CC_TYPE CONV. cepa(0), lccsd; coupled electron pair approximation, variant 0; CC_TYPE CONV. cepa(1); coupled electron pair approximation, variant 1; CC_TYPE CONV. cepa(3); coupled electron pair approximation, variant 3; CC_TYPE CONV. acpf; averaged coupled-pair functional; CC_TYPE CONV. aqcc; averaged quadratic coupled-cluster; CC_TYPE CONV. cisd; configuration interaction with single and double excitations; CI_TYPE CONV. fno-qcisd; qcisd with frozen natural orbitals; CI_TYPE CONV. fno-qcisd(t); qcisd(t) with frozen natural orbitals; CI_TYPE CONV. fno-ccsd; coupled cluster singles doubles with frozen natural orbitals; CC_TYPE CONV, DF, CD. fno-ccsd(t); ccsd with perturbative triples and frozen natural orbitals; CC_TYPE CONV, DF, CD. fno-mp3; mp3 with frozen natural orbitals; MP_TYPE CONV. fno-mp4(sdq); mp4(sdq) with frozen natural orbitals; MP_TYPE CONV. fno-mp4; mp4 with frozen natural orbitals; MP_TYPE CONV. fno-lccd; linear ccd with frozen natural orbitals; CC_TYPE CONV. fno-cepa(0), fno-lccsd; cepa(0) with frozen natural orbitals; CC_TYPE CONV. fno-cepa(1); cepa(1) with frozen natural orbitals; CC_TYPE CONV. fno-cepa(3); cepa(3) with frozen natural orbitals; CC_TYPE CONV. fno-acpf; acpf with frozen natural orbitals; CC_TYPE CONV. fno-aqcc; aqcc with frozen natural orbitals; CC_TYPE CONV. fno-cisd; cisd with frozen natural orbitals; CI_TYPE CONV. Basic FNOCC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:11767,config,configuration,11767,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['config'],['configuration']
Modifiability,"es.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banne",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:1550,variab,variable,1550,psi4manual/4.0b2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html,6,['variab'],['variable']
Modifiability,"es/sapt1/test.in # test installation. works b/c PSI_SCRATCH defaults to /tmp. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. Now you need only specify a scratch directory; (see Scratch Files) by replacing the placeholder in the following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. Detailed Installation of Miniconda¶; https://docs.conda.io/en/latest/miniconda.html. Detailed Installation of PSI4¶. Subscribe to PSI4. Subscribe to our channel at https://anaconda.org/psi4 that contains the PSI4 package and several dependency packages. Make sure this shows up in your ~/.condarc file. >>> conda config --add channels http://conda.anaconda.org/psi4; # check; >>> cat ~/.condarc; channels:; - http://conda.anaconda.org/psi4; - defaults. Install PSI4. You can install into the main conda environment so that whenever commands conda or (Ana/Miniconda’s) python are available, then psi4 is available, too. >>> conda install psi4; # check; >>> which psi4; /path/to/miniconda/bin/psi4. Or, you can install into a conda environment that places PSI4 and its dependencies (including python) into a sandbox unaffected by any other software installed in Ana/Miniconda. This is recommended for developers to avoid interference between multiple versions (including github/conda versions) or to test python versions, etc.. In practical terms, installing into a conda environment means you can turn PSI4‘s availability on/off by switching conda environments without turning on/off the whole Ana/Miniconda installation. Below, PSI4 is installed into an environment called p4env. Then the environment is activated, removing t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:14607,config,config,14607,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,9,['config'],['config']
Modifiability,"es: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC)¶PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING)¶OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPHF_MEM_SAFETY_FACTOR (CPHF)¶CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF)¶CPHF — Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. CUBEPROP_BASIS_FUNCTIONS (GLOBALS)¶GLOBALS — List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBEPROP_FILEPATH (GLOBALS)¶GLOBALS — Directory to which to write cube files. Default is the input file directory. Type: string; Default: No Default. CUBEPROP_ISOCONTOUR_THRESHOLD (GLOBALS)¶GLOBALS — Fraction of density captured by adaptive isocontour values. Type: double; Default: 0.85. CUBEPROP_ORBITALS (GLOBALS)¶GLOBALS — List of orbital indices for which cube files are generated (1-based, \(+\) for alpha, \(-\) for beta). All orbitals computed if empty. Type: array; Default: No Default. CUBEPROP_TASKS (GLOBALS)¶GLOBALS — Properties to compute. Valid tasks include: DENSITY - Da, Db, Dt, Ds; ESP - Dt, ESP; ORBITALS - Psi_a_N, Psi_b_N; BASIS_FUNCTIONS - Phi_N; LOL - LOLa, LOLb; ELF - ELFa, ELFb; FRONTIER_ORBITALS - Psi_a_N_HOMO + Psi_a_N_LUMO; DUAL_DESCRIPTOR - DUAL_N_HOMO-M_LUMO. Type: array; Default: No Default. CUBIC_BASIS_TOLERANCE (FISAPT)¶FISAPT (Expert) — CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BASIS_TOLERANCE (GLOBALS)¶GLOBALS (Expert) — CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS (FISAPT)¶FISAPT (Expert) — CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:90590,adapt,adaptive,90590,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,8,['adapt'],['adaptive']
Modifiability,"es: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. Type: string; Possible Values: TT, OFF; Default: TT. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCFT); DCFT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING); OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user inpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:116789,extend,extended,116789,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['extend'],['extended']
Modifiability,"es; for more advanced usage a user-provided GDMA data file should be provided. Type: integer; Default: 2. GDMA_ORIGIN¶. The origin (in Angstrom, expressed as an [x, y, z] array) about which the total multipoles will be computed during DMA. Useful for determining single site expansions at an arbitrary point. Type: array; Default: No Default. GDMA_MULTIPOLE_UNITS¶. Whether to print DMA results in atomic units or SI. Type: string; Possible Values: AU; Default: AU SI. GDMA_RADIUS¶. The radii to be used, overriding the defaults. Specified as an array [ n1, r1, n2, r2, ... ] where n1,n2,n3... are atom type strings and r1,r2,r3 are radii in Angstrom. Type: array; Default: No Default. GDMA_SWITCH¶. The value to switch between the older standard DMA and the new grid-based approach. Pairs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gdma-1.html:5129,config,configure,5129,psi4manual/1.1.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gdma-1.html,2,['config'],['configure']
Modifiability,"es; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; k01 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); k02 = k01 * k01; k04 = k02 * k02; fun.set_parameter('PW91_a1', 0.19645 / (2.0 * k01)); fun.set_parameter('PW91_a2', 7.79560 / (2.0 * k01)); fun.set_parameter('PW91_a3', 0.27430 / (4.0 * k02)); fun.set_parameter('PW91_a4', 0.15080 / (4.0 * k02)); fun.set_parameter('PW91_a5', 100.000 / (4.0 * k02)); fun.set_parameter('PW91_a6', 0.00400 / (16.0 * k04)). # => End User-Customization <= #. return fun. [docs]def build_b97_x_functional(name):. # Call this first; fun = psi4.Functional.build_base('B97_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('B97_X'); # Tab in, trailing newlines; fun.set_description(' B97 Parameterized GGA Exchange\n'); # Tab in, trailing newlines; fun.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('B97_gamma', 0.004). # => End User-Customization <= #. return fun. [docs]def build_vwn5_c_functional(name):. # Call this first; fun = psi4.Functional.build_base('VWN5_C'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('VWN5_C'); # Tab in, trailing newlines; fun.set_description(' VWN5 LSDA Correlation\n'); # Tab in, trailing newlines; fun.set_citation(' S.H. Vosko, L. Wilk, and M. Nusair, Can. J. Phys., 58, 1200-1211, 1980\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(False); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('EcP_2', -0.10498",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:8156,Parameteriz,Parameterized,8156,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,1,['Parameteriz'],['Parameterized']
Modifiability,"es['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:79244,variab,variables,79244,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"es['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:79467,variab,variables,79467,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"es_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:14064,extend,extend,14064,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"ese thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; Using the dft_functional keyword argument in the energy procedure call, one is able to use the orbitals generated by DFT for correlated wavefunction methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing IP fitting procedure, for example.; Furthermore, new DFT functionals can be created from scratch from within the input file:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:28010,variab,variables,28010,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['variab'],['variables']
Modifiability,"esser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import Any, Dict, Optional, Tuple, Union. from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. class BaseComputer(qcel.models.ProtoModel):; @abc.abstractmethod; def compute(self):; pass. @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description=""AtomicResult return.""); result_id: Optional[str] = Field(None, description=""The optional ID ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html:1886,Config,Config,1886,psi4manual/1.6.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html,1,['Config'],['Config']
Modifiability,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4808,plugin,plugin,4808,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"et basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Ei",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:25319,variab,variable,25319,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263743,flexible,flexible,263743,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['flexible'],['flexible']
Modifiability,"et('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:58094,variab,variables,58094,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"et) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int, arg2: psi4.core.Matrix, arg3: psi4.core.CIVector) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:14773,variab,variable,14773,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"et_array_variable(key):; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:22808,variab,variables,22808,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"et_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96694,variab,variable,96694,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"et_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. optstash.restore(); core.tstop(); return dfmp2_wfn. def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:82457,variab,variable,82457,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"et_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:61242,variab,variable,61242,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['variab'],['variable']
Modifiability,"et_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40537,variab,variable,40537,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"eta Fock Matrix. Fb_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self: psi4.core.Wavefunction) → bool; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. arrays(). atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:19063,variab,variables,19063,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variables']
Modifiability,"etch and build it and activate dependent code. Input¶; For all electron calculations one can use the Douglas-Kroll-Hess (DKH); Hamiltonian to take into account scalar relativistic effects.; Minimal input for DKH single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; Mg; }. set basis aug-cc-pvdz-dk; set relativistic dkh. energy('scf'). By default a 2nd-order DKH calculation is performed. To change the default; order use the DKH_ORDER option. The version of the code found in; PSI4 is capable of up to 4th-order DKH calculations. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dkh-1.html:2009,config,configure,2009,psi4manual/1.1.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dkh-1.html,2,['config'],['configure']
Modifiability,"etch and build it and activate dependent code. Input¶; For all electron calculations one can use the Douglas-Kroll-Hess (DKH); Hamiltonian to take into account scalar relativistic effects.; Minimal input for DKH single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; Mg; }. set basis aug-cc-pvdz-dk; set relativistic dkh. energy('scf'). By default a 2nd-order DKH calculation is performed. To change the default; order use the DKH_ORDER option. The version of the code found in; PSI4 is capable of up to 4th-order DKH calculations. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dkh-1.html:2142,config,configure,2142,psi4manual/1.2.1/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dkh-1.html,4,['config'],['configure']
Modifiability,"ete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.end",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html:3090,plugin,plugin,3090,psi4manual/1.3.2/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html,2,['plugin'],['plugin']
Modifiability,"ete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3120,plugin,plugin,3120,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugin']
Modifiability,"ete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = os.environ.get('PSIDATADIR', None); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html:3065,plugin,plugin,3065,psi4manual/1.1.0/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html,1,['plugin'],['plugin']
Modifiability,ethod. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method. plot() psi4.core.FISAPT method. plugin. ; v2rdm_casscf. plugin() in module psi4.core. plugin_close() in module psi4.core. plugin_close_all() in module psi4.core. plugin_load() in module psi4.core. PMLocalizer class in psi4.core. PNO_CONVERGENCE (DLPNO). point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMM method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction meth,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:104907,plugin,plugin,104907,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['plugin'],['plugin']
Modifiability,ethod. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method. plot() psi4.core.FISAPT method. plugin. ; v2rdm_casscf. plugin() in module psi4.core. plugin_close() in module psi4.core. plugin_close_all() in module psi4.core. plugin_load() in module psi4.core. PMLocalizer class in psi4.core. point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMM method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:103618,plugin,plugin,103618,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['plugin'],['plugin']
Modifiability,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:53935,variab,variable,53935,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,4,['variab'],['variable']
Modifiability,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53368,variab,variable,53368,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:46835,variab,variable,46835,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:53360,variab,variable,53360,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"ethods¶. H0_BLOCKSIZE¶. This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 400. HD_AVG¶. How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:14366,coupling,coupling,14366,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,16,['coupling'],['coupling']
Modifiability,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:3493,config,configuration,3493,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,8,['config'],['configuration']
Modifiability,"etrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR)¶CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR)¶CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR)¶CFOUR — Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. CFOUR_RELATIVISTIC (CFOUR)¶CFOUR — Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin contribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-orbit corrections), SF-DPT6 (scalar-relativistic part of sixth-order direct perturbation theory), SFREE (spin-free treatment), X2C1E (spin-free X2C-1e treatment), or DPT (synonym with DPT2). Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:70819,config,configurational,70819,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['config'],['configurational']
Modifiability,"etry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:5073,plugin,plugin,5073,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:3821,variab,variable,3821,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['variab'],['variable']
Modifiability,"ets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:24167,variab,variable,24167,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,14,['variab'],['variable']
Modifiability,"ets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self, arg0); Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units, return_type]); Serializes instance into JSON or YAML according to schema dtype. to_string(dtype[, units, atom_format, …]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg2. units(self); Returns units used to define the geometry, i.e. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self, arg0); x position of atom. y(self, arg0); y position of atom. z(self, arg0); z position of atom. Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcdb.align.B787() for qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:; concern_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to match.; atoms_map (bool, optional) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:9002,variab,variable,9002,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['variab'],['variable']
Modifiability,"ets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8065,variab,variables,8065,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,16,['variab'],['variables']
Modifiability,"eturn driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:47619,variab,variables,47619,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"eturn returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_option('SCF', 'SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). returnvalue = run_scf_gradient(name, **kwargs). optstash.restore(); return returnvalue. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'DETCI'); PsiMod.set_local_option('DETCI', 'WFN', 'DETCI'); PsiMod.set_local_option('DETCI', 'MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:24980,config,configuration,24980,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,2,['config'],['configuration']
Modifiability,"eturn_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error(molinit, {""efp"": processed}); if molinit[""efp""] == {}:; del molinit[""efp""]. efp_present = enable_efp and ""efp"" in molinit and bool(len(molinit[""efp""][""geom_hints""])); if efp_present:; fix_com = True; fix_orientation = True; fix_symmetry = ""c1"". if enable_qm:; dm = ""qmvz"" if geom_unsettled else ""qm""; processed = from_arrays(; domain=dm,; missing_enabled_return=missing_enabled_return_qm,; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; geom_unsettled=geom_unsettled,; variables=variables,; # processing details; speclabel=speclabel,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:2864,variab,variables,2864,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,12,['variab'],['variables']
Modifiability,"eturns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:33083,variab,variables,33083,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,18,['variab'],['variables']
Modifiability,"eturns the two-particle density matrix. Parameters. spin (str) – {“AA”, “AB”, “BB”, “SUM”}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool) – Return a genuine TPDM element (false) or an “average” of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <ψ|a^p a^r a_s a_q|ψ>.; If symmetrize is true, element pqrs is obtained by summing over all “flips” of p/s, q/r, and multiplying by 0.5. Return type; Matrix. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix¶; docstring. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF¶; docstring. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:20617,variab,variable,20617,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"etween roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:22443,config,configuration,22443,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['config'],['configuration']
Modifiability,"etwork/disk/for/scratch/files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 12; contains information about the internal coordiantes of a geometry optimization.; The user may want to retain this in the working directory; (i.e., where PSI4 was launched from) to analyze the optimization. This is; accomplished by the commands below:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:6172,variab,variable,6172,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"evel of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:8743,config,configuration,8743,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['config'],['configuration']
Modifiability,"evel of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:8235,config,configuration,8235,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,8,['config'],['configuration']
Modifiability,"evel of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]; Two-electron Hessian-vector products. variable(key)¶. variables()¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:25535,inherit,inherited,25535,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,3,"['inherit', 'variab']","['inherited', 'variable', 'variables']"
Modifiability,"eveloper use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additional custom compiler flags for C++ source.; CMAKE_C_FLAGS — CMake variable to specify any additional custom compiler flags for C source. Examples. Build with detected compilers from PATH. >>> cmake. Build with specific (Intel) compilers from PATH. >>> cmake -DCMAKE_CXX_COMPILER=icpc -DCMAKE_C_COMPILER=icc. Build with specific (GNU) compilers not in PATH. >>> cmake -DCMAKE_CXX_COMPILER=/path/to/gcc6.2/bin/g++ -DCMAKE_C_COMPILER=/path/to/gcc6.2/bin/gcc. Build with specific (Intel) compilers from PATH based on GCC not in PATH. >>> cmake -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gcc-name=${GCC5}/bin/gcc"" \; -DCMAKE_CXX_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"". Build with specific (Intel) compilers from PATH based on GCC not in PATH and also building Fortran Add-Ons. >>> cmake -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_Fortran_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:28314,variab,variable,28314,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,15,['variab'],['variable']
Modifiability,"ewidth(0.5)"",tooltip=""Error called when the specified value of *option* requires some""];; ""PsiException"" -> ""PastureRequiredError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""PsiException"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error class for Psi.""];; ""PsiImportError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called for problems import python dependencies. Prints error message""];; ""PsiException"" -> ""PsiImportError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""QMMM"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)""];; ""Table"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Class defining a flexible Table object for storing data.""];; ""TestComparisonError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called when a test case fails due to a failed""];; ""PsiException"" -> ""TestComparisonError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""ValidationError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called for problems with the input file. Prints""];; ""PsiException"" -> ""ValidationError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; }. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. Navigation. Index. modules    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:204555,flexible,flexible,204555,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['flexible'],['flexible']
Modifiability,"ex. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, Psi4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; Psi4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level Psi4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all Psi4 input files.; For convenience, the physical constants used within the Psi4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:1071,variab,variables,1071,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"ex. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably for months before the 1.1 release and while we believe we’ve gotten everything nicely arranged within the psi4. namespace, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only be called via input files like input.dat, it is now interactive, able to be loaded directly as a Python module. Here, we will explore the basics of using Psi4 in this new style by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:1071,variab,variables,1071,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,2,['variab'],['variables']
Modifiability,"ex. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.prop¶. psi4.driver.prop(name, **kwargs)¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html:1217,config,configurational,1217,psi4manual/1.1.0/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.prop.html,1,['config'],['configurational']
Modifiability,"example,. PSIthonPsiAPIenergy('mp2', bsse_type='cp'). psi4.energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,. PSIthonPsiAPI# all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). energy('mp2/cc-pv[dt]z'). # all equivalent. psi4.energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). psi4.energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,. PSIthonPsiAPIdatabase('mp2', 'S22', cp=1, benchmark='S22B'). psi4.wrapper_database.database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:17237,config,configured,17237,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['config'],['configured']
Modifiability,"external_command() in module inputparser. process_extract_command() in module inputparser. process_filename() in module inputparser. PROCESS_GRID (SCF). process_input() in module inputparser. process_memory_command() in module inputparser. process_molecule_command() in module inputparser. process_multiline_arrays() in module inputparser. process_option() in module inputparser. process_pcm_command() in module inputparser. process_print_command() in module inputparser. process_pubchem_command() in module inputparser. process_set_command() in module inputparser. process_set_commands() in module inputparser. process_word_quotes() in module inputparser. prop(); . see property(); . PROP_ALL (CCDENSITY). (CCLAMBDA). PROP_ROOT (CCDENSITY). (CCEOM). (CCLAMBDA). PROP_SYM (CCDENSITY). (CCEOM). (CCLAMBDA). PROPERTIES (GLOBALS). PROPERTIES_ORIGIN (GLOBALS). PROPERTY (CCENERGY). (CCRESPONSE). (CCSORT). property(); . setting keywords. property() in module driver. psi4 command line option; . --new-plugin <name>. -V, --version. -a, --append. -d, --debug. -h, --help. -i <filename>, --input <filename>. -m, --messy. -n <threads>, --nthread <threads>. -o <filename>, --output <filename>. -p <prefix>, --prefix <prefix>. -v, --verbose. -w, --wipe. psi4.get_global_option() (built-in function). psi4.get_local_option() (built-in function). psi4.get_option() (built-in function). psi4.has_global_option_changed() (built-in function). psi4.has_local_option_changed() (built-in function). psi4.has_option_changed() (built-in function). psi4.revoke_global_option_changed() (built-in function). psi4.revoke_local_option_changed() (built-in function). psi4.set_global_option() (built-in function). psi4.set_local_option() (built-in function). psi4rc. PSI_SCRATCH, [1], [2]. PsiException. psiexceptions module. PSIMRCC (TRANSQT). psioh. psirc. PT_ENERGY (PSIMRCC). PubChem. pubchem module. PubChemObj class in pubchem. PUREAM (GLOBALS). push_sect() Getkw method. GetkwParser method. PYTHONPATH, [1], [2], [3]. Q. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:37259,plugin,plugin,37259,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['plugin'],['plugin']
Modifiability,"extsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [Eh] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [Eh] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [Eh] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [Eh] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the requeste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:19048,config,configuration,19048,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['config'],['configuration']
Modifiability,"ext{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). Return type:; List[Dict[str, Any]]. Additional composite aliases are easy to define by the; user. Follow models in psi4/psi4/driver/aliases.py; and cbs-xtpl-nbody and use the; psi4.driver.driver_cbs_helper.register_composite_function(); to make user-defined functions known to PSI4. psi4.driver.driver_cbs_helper.register_composite_function(func)[source]¶; Register a user-defined composite method function to use like a built-in one. Parameters:; func (Callable) – A Python function that defines a configuration of the psi4.driver.cbs() wrapper.; See psi4/psi4/driver/aliases.py and cbs-xtpl-nbody for examples. API¶. pydantic model psi4.driver.driver_cbs.CompositeComputer[source]¶. Show JSON schema{; ""title"": ""CompositeComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""$ref"": ""#/definitions/DriverEnum""; },; ""keywords"": {; ""title"": ""Keywords"",; ""default"": {},; ""type"": ""object""; },; ""metadata"": {; ""title"": ""Metadata""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""verbose"": {; ""title"": ""Verbose"",; ""default"": 1,; ""type"": ""integer""; },; ""cbsrec"": {; ""title"": ""Cbsrec"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""trove"": {;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:32911,config,configuration,32911,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,4,['config'],['configuration']
Modifiability,"ey):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45942,variab,variable,45942,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ey); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. libint2_solid_harmonics_ordering(); The solid harmonics setting of Libint2 currently active for Psi4. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:7581,plugin,plugin,7581,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['plugin'],['plugin']
Modifiability,"ey); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19607,variab,variable,19607,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"ey] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45341,variab,variables,45341,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"e},N5boost10shared_ptrIN3psi6MatrixEEE {lvalue}); | ; | set_reference_wavefunction(...); | set_reference_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool :; | ; | C++ signature :; | b __contains__(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},P7_object); | ; | __delitem__(...); | __d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:658799,inherit,inherited,658799,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"e¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:151325,variab,variables,151325,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,4,['variab'],['variables']
Modifiability,"e¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:24676,variab,variable,24676,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"f ""{:s}_scheme"".format(sn) in kwargs:; stage[""scheme""] = kwargs[""{:s}_scheme"".format(sn)]; if ""{:s}_wfn_lesser"".format(sn) in kwargs:; stage[""wfn_lo""] = kwargs[""{:s}_wfn_lesser"".format(sn)]; if ""cbs_{:s}_alpha"".format(sn) in kwargs:; stage[""alpha""] = kwargs[""cbs_{:s}_alpha"".format(sn)]; elif ""{:s}_alpha"".format(sn) in kwargs:; stage[""alpha""] = kwargs[""{:s}_alpha"".format(sn)]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are act",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:33963,variab,variables,33963,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['variab'],['variables']
Modifiability,"f Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32387,adapt,adapted,32387,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"f Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,d); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float :; | ; | C++ signature :; | d exponent(N3psi29FittedSlaterCorrelationFactorE {lvalue}); | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_params(N3psi17CorrelationFactorE {lvalue},N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (BasisSet)arg2, (bool)arg3) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi8BasisSetEEE,b); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:462380,inherit,inherited,462380,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"f T; ; class F12DoubleCommutator(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12DoubleCommutator; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12G12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12G12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:39808,inherit,inherited,39808,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,4,['inherit'],['inherited']
Modifiability,"f _NPROCESSORS_ONLN`. # <<< Required build dependencies that Psi4 can't build itself >>>; #; # - CMake (e.g., `conda install cmake`); # - C++ and C compilers (C++17 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - networkx >=2.4 (runtime only; e.g., `conda install networkx`); # - pint >=0.10 (runtime only; e.g., `conda install pint -c conda-forge`); # - pydantic >=1.0 (runtime only; e.g., `conda install pydantic -c conda-forge`); # - msgpack-python (runtime only; e.g., `conda install msgpack-python`); # - Eigen (for Libint2; e.g., `conda install eigen`); # - SciPy (runtime only; e.g., `conda install scipy`); # - py-cpuinfo (runtime only; e.g., `conda install py-cpuinfo`); # - psutil (runtime only; e.g., `conda install psutil`). # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - Python_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python3.7)""; # - Python_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python3.7.so)""; # - Python_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python3.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, ecpint, libefp, erd, gau2grid, gdma, Libint2, PCMSolver, pybind11, pylibefp,; # qcelemental, qcengine, optking, simint, Libxc; # - CMAKE_PREFIX_PATH ""Set to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:15789,variab,variables,15789,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"f _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:43850,variab,variables,43850,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"f _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26135,variab,variable,26135,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"f _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`nu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:28388,variab,variable,28388,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"f _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:33719,variab,variables,33719,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"f all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:2564,variab,variable,2564,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,4,['variab'],['variable']
Modifiability,"f atom; | ; | C++ signature :; | d z(N3psi8MoleculeE {lvalue},i); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8MoleculeEEE create_molecule_from_string(Ss); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | units; | Units (Angstrom or Bohr) used to define the geometry; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | MultipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:559812,inherit,inherited,559812,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"f len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole; for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.variable(name + "" DIPOLE "" + cart)). # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:75201,variab,variable,75201,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"f name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:100699,variab,variable,100699,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"f requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:35377,variab,variables,35377,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variables']
Modifiability,"f set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging. from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = loggin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/extras.html:8642,inherit,inherited,8642,psi4manual/1.9.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/extras.html,4,['inherit'],['inherited']
Modifiability,"f set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable if ``execute=True``.) By default,; writes if file is truncated (``append=False``) but not if appended.; inherit_loglevel; If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used in; preference to it as this additionally sets up logging. """"""; out = Path(ofile); log = out.with_suffix("".log""). # Get the custom logger; import logging; from psi4 import logger; if not inherit_loglevel:; logger.setLevel(loglevel). # Create formatters; # * detailed: example: 2019-11-20:01:13:46,811 DEBUG [psi4.driver.task_base:156]; f_format_detailed = logging.Formatter(""%(asctime)s,%(msecs)d %(levelname)-8s [%(name)s:%(lineno)d] %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""); # * light: example: 2019-11-20:10:45:21 FINDIFREC CLASS INIT DATA; f_format_light = logging.Formatter(""%(asctime)s %(message)s"", datefmt=""%Y-%m-%d:%H:%M:%S""). # Create handlers, add formatters to handlers, and add handlers to logger (StreamHandler() also available); filemode = ""a"" if append else ""w""; f_handler = loggin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html:8591,inherit,inherited,8591,psi4manual/1.8.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html,2,['inherit'],['inherited']
Modifiability,"f the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1); where we have chosen the intermediate normalization,; , and the symbols ; and represent single and double excitation operators. The; QCISD equations can be obtained by omitting all but two terms that; are nonlinear in and :. (2); QCISD is slightly cheaper that CCSD computationally, but it retains the; complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to pertur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:2390,config,configuration,2390,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,12,['config'],['configuration']
Modifiability,"f theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the label",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:22174,config,configuration,22174,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['config'],['configuration']
Modifiability,"f these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math library (better than MKL for AMD processors); ../configure --prefix=/usr/local/psi4 --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:6388,config,configuration,6388,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,['config'],['configuration']
Modifiability,"f these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:7368,config,configuration,7368,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configuration']
Modifiability,"f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Star",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:120061,variab,variables,120061,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,10,['variab'],['variables']
Modifiability,"f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13046,variab,variables,13046,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,8,['variab'],['variables']
Modifiability,"f' : run_scf,; 'rscf' : run_scf,; 'uscf' : run_scf,; 'roscf' : run_scf,; 'qcisd' : run_fnocc,; 'qcisd(t)' : run_fnocc,; 'mp4(sdq)' : run_fnocc,; 'fno-ccsd' : run_fnocc,; 'fno-ccsd(t)' : run_fnocc,; 'fno-qcisd' : run_fnocc,; 'fno-qcisd(t)' : run_fnocc,; 'fno-mp3' : run_fnocc,; 'fno-mp4(sdq)' : run_fnocc,; 'fno-mp4' : run_fnocc,; 'fnocc-mp' : run_fnocc,; 'df-ccsd' : run_fnodfcc,; 'df-ccsd(t)' : run_fnodfcc,; 'fno-df-ccsd' : run_fnodfcc,; 'fno-df-ccsd(t)': run_fnodfcc,; 'fno-cepa(0)' : run_cepa,; 'fno-cepa(1)' : run_cepa,; 'fno-cepa(3)' : run_cepa,; 'fno-acpf' : run_cepa,; 'fno-aqcc' : run_cepa,; 'fno-sdci' : run_cepa,; 'fno-dci' : run_cepa,; 'cepa(0)' : run_cepa,; 'cepa(1)' : run_cepa,; 'cepa(3)' : run_cepa,; 'acpf' : run_cepa,; 'aqcc' : run_cepa,; 'sdci' : run_cepa,; 'dci' : run_cepa,; # Upon adding a method to this list, add it to the docstring in energy() below; # If you must add an alias to this list (e.g., dfmp2/df-mp2), please search the; # whole driver to find uses of name in return values and psi variables and; # extend the logic to encompass the new alias.; },; 'gradient' : {; 'scf' : run_scf_gradient,; 'ccsd' : run_cc_gradient,; 'ccsd(t)' : run_cc_gradient,; 'mp2' : run_mp2_select_gradient,; 'conv-mp2' : run_mp2_gradient,; 'df-mp2' : run_dfmp2_gradient,; 'dfmp2' : run_dfmp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient,; 'omp2' : run_omp2_gradient,; 'omp3' : run_omp3_gradient,; 'mp3' : run_mp3_gradient,; 'mp2.5' : run_mp2_5_gradient,; 'omp2.5' : run_omp2_5_gradient,; 'cepa0' : run_cepa0_gradient,; 'ocepa' : run_ocepa_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'df-mp2' : run_dfmp2_property,; 'dfmp2' : run_dfmp2_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; # Up",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:3798,variab,variables,3798,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,8,"['extend', 'variab']","['extend', 'variables']"
Modifiability,"f):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:27524,variab,variable,27524,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['variab'],['variable']
Modifiability,"f); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Nu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:6841,variab,variable,6841,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variable']
Modifiability,"f); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); The MintsHelper object. moFa(self); docstring. moFb(self); docstring. moFeff(self); docstring. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html:6900,variab,variable,6900,psi4manual/1.6.x/api/psi4.core.ROHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html,2,['variab'],['variable']
Modifiability,"f); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); The MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:6842,variab,variable,6842,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,6,['variab'],['variable']
Modifiability,"f); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:4594,variab,variable,4594,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,4,['variab'],['variable']
Modifiability,"f); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val). shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. variable(key). variables(). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:5951,variab,variable,5951,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"f, arg0, arg1); Sets the requested auxiliary basis. set_energies(self, arg0, arg1); docstring. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_cpscf_perturbation(self, name, …); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_jk(self, arg0); Sets the internal JK object !expert. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:10683,variab,variable,10683,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:31792,variab,variable,31792,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['variab'],['variable']
Modifiability,"f: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:19141,variab,variable,19141,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"f: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:19640,variab,variable,19640,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,10,['variab'],['variable']
Modifiability,"f: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:19791,variab,variable,19791,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variable']
Modifiability,"f: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:41021,variab,variables,41021,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['variab'],['variables']
Modifiability,"f: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension; docstring. get_opdm(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: str, arg3: bool) → psi4.core.Matrix; docstring. get_orbitals(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Matrix; docstring. get_tpdm(self: psi4.core.CIWavefunction, arg0: str, arg1: bool) → psi4.core.Matrix; docstring. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix; docstring. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF; docstring. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. ndet(self: psi4.core.CIWavefunction) → int; docstrin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:9367,variab,variable,9367,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"f: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.CdSalc¶; Bases: pybind11_builtins.pybind11_object; Cartesian displacement SALC. irrep(self: psi4.core.CdSalc) → str¶; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc) → int¶; Return the irrep index. print_out(self: psi4.core.CdSalc) → None¶; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:51112,variab,variable,51112,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"f: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, block: psi::BlockOPoints, force_compute: bool=True) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:210417,variab,variable,210417,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"f: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet]) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList object used in creating this SO basis. class psi4.core.SOMCSCF¶; Bases: pybind11_builtins.pybi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:228188,variab,variable,228188,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"f: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, block: psi::BlockOPoints, force_compute: bool=True) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:257174,variab,variable,257174,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"f: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. exists(self: psi4.core.IO, unit: int) → bool¶; Check if the unit exists. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:109608,variab,variable,109608,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"f; energy('scf', brokensymmetry=True). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:10040,enhance,enhanced,10040,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,6,['enhance'],['enhanced']
Modifiability,"f; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:24381,variab,variable,24381,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['variab'],['variable']
Modifiability,"f; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; 1set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a PSI4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26#!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. The top section features PBS-specific commands. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:12621,variab,variables,12621,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['variab'],['variables']
Modifiability,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:81833,inherit,inherited,81833,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"f_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = core.variable('CURRENT ENERGY'). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = core.variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * core.variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. core.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; core.set_variable('DFT TOTAL ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:60641,variab,variable,60641,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"f_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # reta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:51439,variab,variable,51439,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,10,['variab'],['variable']
Modifiability,"face to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/interfacing.html:2360,config,configure,2360,psi4manual/1.6.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/interfacing.html,5,['config'],['configure']
Modifiability,"fault for the second and later iterations; of geometry optimizations. SAD [Default]Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. SADNONatural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]. GWHA generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:17905,extend,extended,17905,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,2,['extend'],['extended']
Modifiability,"faults to decontracted orbital basis. Type: string; Default: No Default. BENCH¶. Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BRIANQC_ENABLE¶. Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. CC_TYPE¶. Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. CI_TYPE¶. Algorithm to use for CI computation (e.g., CID or CISD). See Cross-module Redundancies for details. Type: string; Possible Values: CONV; Default: CONV. CUBEPROP_BASIS_FUNCTIONS¶. List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBEPROP_FILEPATH¶. Directory to which to write cube files. Default is the input file directory. Type: string; Default: No Default. CUBEPROP_ISOCONTOUR_THRESHOLD¶. Fraction of density captured by adaptive isocontour values. Type: double; Default: 0.85. CUBEPROP_ORBITALS¶. List of orbital indices for which cube files are generated (1-based, \(+\) for alpha, \(-\) for beta). All orbitals computed if empty. Type: array; Default: No Default. CUBEPROP_TASKS¶. Properties to compute. Valid tasks include: DENSITY - Da, Db, Dt, Ds; ESP - Dt, ESP; ORBITALS - Psi_a_N, Psi_b_N; BASIS_FUNCTIONS - Phi_N; LOL - LOLa, LOLb; ELF - ELFa, ELFb; FRONTIER_ORBITALS - Psi_a_N_HOMO + Psi_a_N_LUMO; DUAL_DESCRIPTOR - DUAL_N_HOMO-M_LUMO. Type: array; Default: No Default. CUBIC_GRID_OVERAGE¶. CubicScalarGrid spatial extent in bohr [O_X, O_Y, O_Z]. Defaults to 4.0 bohr each. Type: array; Default: No Default. CUBIC_GRID_SPACING¶. CubicScalarGrid grid spacing in bohr [D_X, D_Y, D_Z]. Defaults to 0.2 bohr each. Type: array; Default: No Default. DF_BASIS_CC¶. The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DOCC¶. An array co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html:1438,adapt,adaptive,1438,psi4manual/1.4.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html,10,['adapt'],['adaptive']
Modifiability,"ference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:84521,variab,variables,84521,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"ference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:; 1; 2; 3; 4; 5; 6; 7; 8// Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks. Improves efficiency:; 1; 2; 3; 4; 5// Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:; 1; 2std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/prog_style_c-1.html:1513,variab,variable,1513,psi4manual/1.3.2/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/prog_style_c-1.html,2,['variab'],['variable']
Modifiability,"ff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). Table Of Contents. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Previous topic; Introduction; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next   ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:10873,plugin,plugins,10873,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['plugin'],['plugins']
Modifiability,fgrad; scfgrad; scfhess; scfhess; set_active_molecule; set_active_molecule; set_array_variable; set_array_variable; set_datadir; set_datadir; set_global_option; set_global_option; set_global_option_python; set_global_option_python; set_gradient; set_gradient; set_legacy_gradient; set_legacy_gradient; set_legacy_molecule; set_legacy_molecule; set_legacy_wavefunction; set_legacy_wavefunction; set_local_option; set_local_option; set_local_option_python; set_local_option_python; set_memory_bytes; set_memory_bytes; set_num_threads; set_num_threads; set_output_file; set_output_file; set_psi_file_prefix; set_psi_file_prefix; set_scalar_variable; set_scalar_variable; set_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; TaskListComputer; ThreeCenterOverlapInt; timer_off; timer_off; timer_on; timer_on; TracelessQuadrupoleInt; triplet; triplet; tstart; tstart; tstop; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variable; variables; variables; VBase; Vector; Vector3; version; version; Wavefunction; activate; activate; ancestor; ancestor; banner; banner; basis_helper; basis_helper; cbs; cbs; check_iwl_file_from_scf_type; check_iwl_file_from_scf_type; compare_fchkfiles; compare_fchkfiles; compare_fcidumps; compare_fcidumps; ConvergenceError; copy_file_from_scratch; copy_file_from_scratch; copy_file_to_scratch; copy_file_to_scratch; create_plugin; create_plugin; CSXError; cubeprop; cubeprop; Dftd3Error; dynamic_variable_bind; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fchkfile_to_string; fchkfile_to_string; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; free_atom_volumes; free_atom_volumes; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; gradient; gradient; hessian; hessian; ipi_broker; ipi_broker,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:551295,variab,variables,551295,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['variab'],['variables']
Modifiability,"fically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, …]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, …); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, …); Error called for problems with TDSCF iterations. Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn’t and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:22517,flexible,flexible,22517,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['flexible'],['flexible']
Modifiability,"ficient for same spin correlation in SCS methods, forces alpha = 1.0; ""os"": 0.0, coefficient for opposite spin correlation in SCS methods, forces alpha = 1.0; },. ""dispersion"": { definition of dispersion corrections; ""type"": """", dispersion type - ""d2"", ""d3zero"", ""d3bj"" etc., see empirical_dispersion.py; ""params"": {}, parameters for the dispersion correction; ""nlc"": False (optional) logical switch to turn off nlc (e.g. VV10) correction defined by LibXC; ""citation"": """", special reference for the dispersion correction parameters, appended to output. One can also use the dft_functional keyword argument to use the; orbitals generated by DFT for correlated wavefunction methods:; # MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing the IP fitting procedure, for example. table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:33100,variab,variables,33100,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['variab'],['variables']
Modifiability,"figuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++11 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (2.7, 3.5, or 3.6) https://www.python.org/; CMake (3.3+) http://www.cmake.org/download/; NumPy (needed at runtime and buildtime) http://www.numpy.org/; mpmath (only needed if you build gau2grid to angular momentum >16) http://mpmath.org/; System utilities: GNU make, GNU install, POSIX threads ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:3361,config,configure,3361,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,"['config', 'variab']","['configure', 'variables']"
Modifiability,"figuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run Psi4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that Python,; CMake, NumPy, and Libint (and even C++ compilers on Linux) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++11 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (2.7, 3.5, or 3.6) https://www.python.org/; CMake (3.3+) http://www.cmake.org/download/; NumPy (needed at runtime, not buildtime) http://www.numpy.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:3359,config,configure,3359,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,"['config', 'variab']","['configure', 'variables']"
Modifiability,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:7250,plugin,plugin,7250,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,6,['plugin'],['plugin']
Modifiability,"file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:33472,variab,variable,33472,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,18,['variab'],['variable']
Modifiability,"file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:5628,variab,variables,5628,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,15,['variab'],['variables']
Modifiability,"files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135310,variab,variable,135310,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:131104,variab,variable,131104,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5254,plugin,plugin,5254,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"fills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:1225,config,configure,1225,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,2,['config'],['configure']
Modifiability,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:5793,plugin,plugin,5793,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,12,['plugin'],['plugin']
Modifiability,"fined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | Re-initializes the dimension object; | ; | n(...); | n( (Dimension)arg1) -> int :; | The order of the dimension; | ; | print_out(...); | print_out( (Dimension)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | name; | The name of the dimension. Used in printing.; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | DipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | --------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:21335,inherit,inherited,21335,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"fitting). dcft; density cumulant functional theory. mcscf; multiconfigurational self consistent field (SCF). sapt0; 0th-order symmetry adapted perturbation theory (SAPT). sapt2; 2nd-order SAPT, traditional definition. sapt2+; SAPT including all 2nd-order terms. sapt2+(3); SAPT including perturbative triples. sapt2+3;  . sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation. sapt2-ct; SAPT2 plus CT. sapt2+-ct; SAPT2+ plus CT. sapt2+(3)-ct; SAPT2+(3) plus CT. sapt2+3-ct; SAPT2+3 plus CT. cc2; approximate coupled cluster singles and doubles (CC2). ccsd; coupled cluster singles and doubles (CCSD). bccd; Brueckner coupled cluster doubles (BCCD). cc3; approximate coupled cluster singles, doubles, and triples (CC3). ccsd(t); CCSD with perturbative triples. bccd(t); BCCD with perturbative triples. ccenergy; expert full control over ccenergy module. mpn; nth-order Moller–Plesset perturbation theory. zaptn; nth-order z-averaged perturbation theory (ZAPT). cisd; configuration interaction (CI) singles and doubles (CISD). cisdt; CI singles, doubles, and triples (CISDT). cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ). cin; nth-order CI. fci; full configuration interaction (FCI). detci; expert full control over detci module. adc; 2nd-order algebraic diagrammatic construction (ADC). eom-cc2; EOM-CC2. eom-ccsd; equation of motion (EOM) CCSD. eom-cc3; EOM-CC3. cepa(n); coupled electron pair approximation, variants 0, 1, and 3. acpf; averaged coupled-pair functional. aqcc; averaged quadratic coupled cluster. omp2; orbital-optimized second order Moller–Plesset perturbation theory. scs-omp2; spin-component scaled OMP2. sos-omp2; spin-opposite scaled OMP2. omp3; orbital-optimized third order Moller–Plesset perturbation theory. scs-omp3; spin-component scaled OMP3. sos-omp3; spin-opposite scaled OMP3. name; calls method (aliases to name = ‘scf’). hf; HF. rhf; HF with restricted reference. uhf; HF with unrestricted reference. rohf; HF with restricted open-shell refer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/energy-1.html:1636,config,configuration,1636,psi4manual/4.0b3/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/energy-1.html,2,['config'],['configuration']
Modifiability,"float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3269,plugin,plugin,3269,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugin']
Modifiability,"float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html:3265,plugin,plugin,3265,psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,2,['plugin'],['plugin']
Modifiability,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:89649,inherit,inherited,89649,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | docstring; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -> None; | ; | __init__( (object)arg1, (Vector3)arg2) -> None; | ; | __isub__(...); | __isub__( (object)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:78839,inherit,inherited,78839,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → list[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_names(self: psi4.core.OEProp, arg0: set[str]) → None¶; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str) → None¶; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html:2890,variab,variables,2890,psi4manual/master/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html,2,['variab'],['variables']
Modifiability,"fn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:101185,variab,variable,101185,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"fn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:80410,variab,variable,80410,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"fn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89620,variab,variable,89620,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variable']
Modifiability,"fn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_AT'); core.set_local_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89893,variab,variables,89893,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"fn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:4326,variab,variable,4326,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"fold. So, the effective secular equation is solved for; several times for the specific state due to the eigenvalue dependence of; the effective response matrix. Only the S component of the transition; amplitude is obtained explicitly and the squared norm of the S block; and the rotation angle from the corresponding CIS vector are given; below the element of the amplitude. The difference between the ADC(2); value and its non-iterative counterpart is mostly negligible if the; mixture among the CIS excited states is small and the quasi-degeneracy; in the excited state is tolerably weak. But if there is a significant; discrepancy in these energies, or the rotation angle is visibly large,; special care may have to be taken for the strong effects caused by the; higher excited states. Partial Renormalization Scheme¶; The ADC code is capable of performing the partially-renormalized; ADC(2) computation, termed PR-ADC(2). In the perturbative treatment of; the singly-excited state, the doubly and triply excited configurations; are accounted for as in the case of CIS(D). In the language of; CIS(D), the former is regarded to introduce the orbital relaxation (OR); effect while the latter is argued to give rise to the differential; correlation (DC) correction to the excited state. In the PR-ADC(2); scheme, the DC term is corrected according to the ground state; PR-MP2 correlation, in which the correlation between the electron pairs; is accounted for in size-consistent and unitary-invariant fashion by; modulating the MP1 amplitude. By utilizing the PR scheme, substantial; resistance against quasi-degeneracy is readily granted as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/adc-1.html:4173,config,configurations,4173,psi4manual/1.2.1/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/adc-1.html,6,['config'],['configurations']
Modifiability,"fold. So, the effective secular equation is solved for; several times for the specific state due to the eigenvalue dependence of; the effective response matrix. Only the S component of the transition; amplitude is obtained explicitly and the squared norm of the S block; and the rotation angle from the corresponding CIS vector are given; below the element of the amplitude. The difference between the ADC(2); value and its non-iterative counterpart is mostly negligible if the; mixture among the CIS excited states is small and the quasi-degeneracy; in the excited state is tolerably weak. But if there is a significant; discrepancy in these energies, or the rotation angle is visibly large,; special care may have to be taken for the strong effects caused by the; higher excited states. Partial Renormalization Scheme¶; The ADC code is capable of performing the partially-renormalized; ADC(2) computation, termed PR-ADC(2). In the perturbative treatment of; the singly-excited state, the doubly and triply excited configurations; are accounted for as in the case of CIS(D). In the language of; CIS(D), the former is regarded to introduce the orbital relaxation (OR); effect while the latter is argued to give rise to the differential; correlation (DC) correction to the excited state. In the PR-ADC(2); scheme, the the DC term is corrected according to the ground state; PR-MP2 correlation, in which the correlation between the electron pairs; is accounted for in size-consistent and unitary-invariant fashion by; modulating the MP1 amplitude. By utilizing the PR scheme, substantial; resistance against quasi-degeneracy is readily granted as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/adc-1.html:4271,config,configurations,4271,psi4manual/1.0.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/adc-1.html,10,['config'],['configurations']
Modifiability,"for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_SCS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. IP_POLES¶. Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html:2722,extend,extended,2722,psi4manual/1.4.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html,10,['extend'],['extended']
Modifiability,"for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_SCS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS¶. Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. IP_POLES¶. Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html:2542,extend,extended,2542,psi4manual/1.7.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html,8,['extend'],['extended']
Modifiability,"for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:3836,variab,variables,3836,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['variab'],['variables']
Modifiability,"for four-virtual case is avoided. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. scf-response2; Compute the dipole polarizability for water with custom basis set. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. cisd-sp; 6-31G** H2O Test CISD Energy Point. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. casscf-fzc-sp; CASSCF/6-31G** energy point. sapt-sf1; Tests the Psi4 SF-SAPT code. sad-scf-type; Test SAD SCF guesses on noble gas atom. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cc13d; Tests analytic CC2 gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cubeprop-esp; RHF orbitals and density for water. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawfor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:19971,variab,variables,19971,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:25539,variab,variables,25539,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['variab'],['variables']
Modifiability,"for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:28505,variab,variables,28505,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"for the next Psi4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing Psi4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. ~/.psi4rc File¶; If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file,; namely:; psi4_io.set_default_path('/scratch/user'). to set up the scratch path,; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). to set up the scratch path from a variable $MYSCRATCH,; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). to set up a specific path for the checkpoint file and instruct Psi4 not to delete it.; The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every Psi4 instance. Threading¶; Most new modules in Psi4 are designed to run efficiently on SMP architectures; via application of several th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:5654,variab,variable,5654,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is $$(gg|gg)$$. Installation¶; Binary. SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). The conda package is compiled to least-common-denominator, namely SSE instruction set. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; simint can be obtained through conda install simint.; Then enable it as a feature with ENABLE_simint,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect simint and activate dependent code.; To remove a conda installation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/simint-1.html:1480,config,configure,1480,psi4manual/1.1.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/simint-1.html,2,['config'],['configure']
Modifiability,"for; a CCSD, CC2, and CC3 calculation. run_ccenergy_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DCFT gradient calculation. run_detcas(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_detci_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 property calculation. run_dfocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. run_dfocc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dfocc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dft(name, **kwargs)[sour",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:161637,config,configuration,161637,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['config'],['configuration']
Modifiability,"formation matrices, and a point of origin. The origin is not; respected by the symmetry operations, so if you want to use a point; group with a nonzero origin, first translate all your coordinates to; the origin and then set the origin to zero. """""". def __init__(self, *args):; """"""Constructor"""""". # Schoenflies symbol; self.symb = 'c1'; # point of origin; self.PYorigin = [0.0, 0.0, 0.0]; # bit representation of point group; self.PYbits = 0. # Divert to constructor functions; # if len(args) == 0:; # self.constructor_zero_ao_basis(); if len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); elif len(args) == 2 and \; isinstance(args[0], basestring) and \; len(args[1]) == 3:; self.constructor_schoenflies_origin(*args); elif len(args) == 2 and \; isinstance(args[0], int) and \; len(args[1]) == 3:; self.constructor_bits_origin(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. # libmints: These 2 constructors do not work right now.; [docs] def constructor_schoenflies(self, s):; """"""This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_schoenflies_origin(self, s, origin):; """"""Like the above, but this constructor also takes a point of; origin as an argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. [docs] def constructor_bits(self, bits):; """"""Using the bitwise representation construct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:39070,config,configuration,39070,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['config'],['configuration']
Modifiability,"formed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:7395,variab,variable,7395,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['variab'],['variable']
Modifiability,"fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP); EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP); EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCFT); DCFT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING); OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, gues",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:119414,extend,extended,119414,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['extend'],['extended']
Modifiability,"fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise Validatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:8688,variab,variables,8688,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,6,['variab'],['variables']
Modifiability,"framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:24597,config,configure,24597,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['config'],['configure']
Modifiability,"from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class KineticInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | KineticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Localizer(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:67892,inherit,inherited,67892,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OverlapInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | OverlapInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PMLocalizer(Localizer); | docstring; | ; | Method resolution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:104676,inherit,inherited,104676,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"from gradients, for a given irrep. fd_geoms_1_0(...); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0((arg0: psi::Molecule, ...); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1((arg0: psi::Molecule, ...); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(() -> None). fisapt((arg0: psi::Wavefunction) -> float); Runs the functional-group intramolecular symmetry adapted perturbation theory code. flush_outfile(() -> None); Flushes the output file. fnocc(...); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(() -> psi4.core.EFP); Returns the currently active EFP object. get_active_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_array_variable((arg0: str) -> psi::Matrix); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(() -> Dict[str, psi::Matrix]); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(() -> psi::Vector); Returns the most recently computed atomic point charges, as a double * object. get_efp_torque(() -> psi::Matrix); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_environment((arg0: str) -> str); Get enviromental vairable. get_frequencies(() -> psi::Vector); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option((arg0: str) -> object); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(() -> List[str]); Returns a list of all global options. get_gradient(() -> psi::Matrix); Returns the most recently computed gradient, as a N by 3 Matrix object. get_le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:165042,variab,variables,165042,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,4,['variab'],['variables']
Modifiability,"from python dictionary. from_schema(molschema[, return_dict, verbose]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, …]). fx(self, arg0); x position of atom arg1 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg1 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_variable(self, arg0); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self, arg0); Gets the original label of the atom as given in the input file (C2, H4). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repuls",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:3406,variab,variable,3406,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['variab'],['variable']
Modifiability,"from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/ecpint.html:2282,config,configdir,2282,psi4manual/1.8.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/ecpint.html,2,['config'],"['configdir', 'configure']"
Modifiability,"from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/ecpint.html:2282,config,configdir,2282,psi4manual/1.9.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/ecpint.html,2,['config'],"['configdir', 'configure']"
Modifiability,"frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:4572,variab,variable,4572,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"fting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:57335,variab,variable,57335,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,5,['variab'],['variable']
Modifiability,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9964,variab,variable,9964,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,4,['variab'],['variable']
Modifiability,"function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:10876,inherit,inherited,10876,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:106853,inherit,inherited,106853,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"function)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CUHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | CUHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from HF:; | ; | occupation_a(...); | occupation_a( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_a(N3psi3scf2HFE {lvalue}); | ; | occupation_b(...); | occupation_b( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_b(N3psi3scf2HFE {lvalue}); | ; | semicanonicalize(...); | semicanonicalize( (HF)arg1) -> None :; | docstring; | ; | C++ signature :; | void semicanonicalize(N3psi3scf2HFE {lvalue}); | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca(N3psi12WavefunctionE {lvalue}); | ; | Ca_subset(...); | Ca_subset( (Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:404971,inherit,inherited,404971,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"function.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:43699,variab,variable,43699,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building document",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:6331,plugin,plugin,6331,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NablaInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | NablaInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:97420,inherit,inherited,97420,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:54341,inherit,inherited,54341,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"function_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45868,variab,variable,45868,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"function`; The wavefunction which had its Hessian computed.; hess : ndarray of float, optional; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep : int or string; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans : boolean; Should translations be projected in the harmonic analysis?; project_rot : boolean; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impost",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:74876,variab,variables,74876,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"functional(name):. # Call this first; fun = PsiMod.Functional.build_base('PBE_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('PBEsol_X'); # Tab in, trailing newlines; fun.set_description(' PBEsol GGA Exchange Hole (Parameter Free)\n'); # Tab in, trailing newlines; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('PBE_kp', 0.804); fun.set_parameter('PBE_mu', 10.0 / 81.0). # => End User-Customization <= #. return fun. [docs]def build_pw91_x_functional(name):. # Call this first; fun = PsiMod.Functional.build_base('PW91_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('PW91_X'); # Tab in, trailing newlines; fun.set_description(' PW91 Parameterized GGA Exchange\n'); # Tab in, trailing newlines; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; k01 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); k02 = k01 * k01; k04 = k02 * k02; fun.set_parameter('PW91_a1', 0.19645 / (2.0 * k01)); fun.set_parameter('PW91_a2', 7.79560 / (2.0 * k01)); fun.set_parameter('PW91_a3', 0.27430 / (4.0 * k02)); fun.set_parameter('PW91_a4', 0.15080 / (4.0 * k02)); fun.set_parameter('PW91_a5', 100.000 / (4.0 * k02)); fun.set_parameter('PW91_a6', 0.00400 / (16.0 * k04)). # => End User-Customization <= #. return fun. [docs]def build_b97_x_functional(name):. # Call this first; fun = PsiMod.Functional.build_base('B97_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('B97_X'); # Tab in, trailing newlines; fun.set_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:4073,Parameteriz,Parameterized,4073,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,3,['Parameteriz'],['Parameterized']
Modifiability,"g Code; Miscellaneous. Obtaining PSI4; How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}; Find-the-code Quiz; Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository; Tarball from GitHub Repository; Psi3 from SourceForge; What is the suggested GitHub workflow. Compiling and Installing from Source; Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies; How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda; How to see what build configuration options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to fix error “RuntimeError: value for ERI”; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:802,config,configure,802,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,12,['config'],"['configuration', 'configure']"
Modifiability,"g Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); if(psi4_SKIP_ENABLE_Fortran); message(STATUS ""NOT Enabling Fortran""); else(); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(); endif(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:22865,variab,variable,22865,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,1,['variab'],['variable']
Modifiability,"g commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. todo how to check if current py is compatible with compilation. How to configure paths for PsiAPI¶; If you know the location of the PSI4 executable (bin/psi4); for Psithon mode and want to know the corresponding location to add to; PYTHONPATH for PsiAPI mode, execute psi4 --psiapi-path. It; will return bash commands to set PATH (for correct python; interpreter) and PYTHONPATH (to find psi4 module) correctly,; after which import psi4 will work.; >>> psi4 --psiapi-path; export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:22663,config,configure,22663,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"g in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:; dummy (bool, optional) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool, optional) – Whether or not to treat ghost atoms as dummies. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:59862,variab,variable,59862,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,2,['variab'],"['variable', 'variables']"
Modifiability,"g in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir. cd {top-level-psi4-dir} && cmake -S. -Bobjdir; cd {top-level-psi4-dir} && cmake -S. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; >>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -S. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); incl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:23142,config,configuration,23142,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,18,['config'],"['configuration', 'configure']"
Modifiability,"g some problems with Intel 2018 compilers. presently disabled in conda package. Installation¶; Binary. SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; The conda package is compiled to least-common-denominator, namely SSE instruction set.; If using the PSI4 binary, simint has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; simint can be obtained through conda install simint -c psi4.; Then enable it as a feature with ENABLE_simint,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect simint and activate dependent code. To remove a conda installation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/simint-1.html:1711,config,configure,1711,psi4manual/1.4.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/simint-1.html,9,['config'],['configure']
Modifiability,"g that file to PSI4’s CMake as; -DAddon_DIR=/path/to/config/usually/ending/in/share/cmake/AddON; and build PSI4. The main core.so should be dynamically linked; to your dev AddOn dynamic lib and update automatically when you rebuild; the AddOn lib. Naturally, you may need to delete core.so and remake; as needed. table of contents. Compiling and Installing from Source; Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies; How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda; How to see what build configuration options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to fix error “RuntimeError: value for ERI”; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:51721,config,configure,51721,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,12,['config'],"['configuration', 'configure']"
Modifiability,"g the $PBS_NODEFILE which; points to a file containing a list of the nodes attributed to the job.; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. The next section is very important as it sets the environment variables needed; by Psi4:; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}. PSIDATADIR does not need to be set if Psi4 has been properly installed.; In the present example we unset it to make sure it does not interfere with the location; of the installed directory. PSIPATH is needed only if you are using external modules or; plugins in Psi4 and should point to the directories where they can be found. In the; present example, we make sure the variable is set with if ! ( $?PSIPATH ) setenv PSIPATH """"; before adding more paths to it. Finally, PSI_SCRATCH should point to a fast,; local disk for temporary file storage. The next step is then to actually run the computation:; /psi/install/directory/bin/psi4 -i input.in -o input.out. And then to clean up the scratch directories previously created:; foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; Psi4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; >>> psi4; >>> psi4 -i input.dat -o output.dat; >>> psi4 input.dat output.dat. >>> psi4 descriptive_filename.in descriptive_filename.out. Comm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:12570,variab,variable,12570,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"g,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` inste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:22742,variab,variable,22742,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variable']
Modifiability,"g. psi4.PotentialInt.set_enable_pybuffer()¶; Python Library Documentation: method set_enable_pybuffer; set_enable_pybuffer(...) unbound psi4.PotentialInt method. set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b). Process¶. psi4.Process.environment()¶; Python Library Documentation: Environment in module psi4 object; class Environment(Boost.Python.instance). Method resolution order:. Environment. Boost.Python.instance. __builtin__.object. Methods defined here:. __getitem__(...). __getitem__( (Environment)arg1, (str)arg2) -> str :. docstring. C++ signature :. Ss __getitem__(N3psi7Process11EnvironmentE {lvalue},Ss). __init__(...). __init__( (object)arg1) -> None :. C++ signature :. void __init__(P7_object). __reduce__ = <unnamed Boost.Python function>(...). ———————————————————————-. Data and other attributes defined here:. __instance_size__ = 464. ———————————————————————-. Data descriptors inherited from Boost.Python.instance:. __dict__. __weakref__. ———————————————————————-. Data and other attributes inherited from Boost.Python.instance:. __new__ = <built-in method __new__ of Boost.Python.class object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. PseudoTrial¶. psi4.PseudoTrial.getA()¶; Python Library Documentation: method getA; getA(...) unbound psi4.PseudoTrial method. getA( (PseudoTrial)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE getA(N3psi11PseudoTrialE {lvalue}). psi4.PseudoTrial.getI()¶; Python Library Documentation: method getI; getI(...) unbound psi4.PseudoTrial method. getI( (PseudoTrial)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE getI(N3psi11PseudoTrialE {lvalue}). psi4.PseudoTrial.getIPS()¶; Python Library Documentation: method getIPS; getIPS(...) unbound psi4.PseudoTrial method. getIPS( (PseudoTrial)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:272531,inherit,inherited,272531,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"g. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_orbitals(self, arg0, arg1); docstring. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. tpdm(self, arg0, arg1, arg2, arg3); docstring. transform_ci_integrals(self); Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self, arg0); docstring. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:8406,variab,variable,8406,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"g. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_orbitals(self, arg0, arg1); docstring. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. tpdm(self, arg0, arg1, arg2, arg3); docstring. transform_ci_integrals(self); Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self, arg0); docstring. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:8295,variab,variable,8295,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"g0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a strin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247088,plugin,plugin,247088,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['plugin'],['plugin']
Modifiability,"g1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:134297,variab,variable,134297,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['variab'],['variable']
Modifiability,"g1) -> float :; | docstring; | ; | C++ signature :; | d x_alpha(N3psi15SuperFunctionalE {lvalue}); | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10FunctionalEEE x_functional(N3psi15SuperFunctionalE {lvalue},Ss); | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | C++ signature :; | d x_omega(N3psi15SuperFunctionalE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi15SuperFunctionalEEE blank(); | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi15SuperFunctionalEEE build(Ss,i,i); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | Set equal to E; | ; | C++ signature :; | void E(N3psi17Sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:627072,inherit,inherited,627072,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"g1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None¶; docstring. pitzer_to_ci_order_twoel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None¶; docstring. print_vector(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:31743,variab,variable,31743,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"g2 fragments Real; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:55137,variab,variable,55137,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['variab'],['variable']
Modifiability,"g2) -> None :. Uses the point group object obtain by calling point_group(); C++ signature :. void form_symmetry_information(N3psi8MoleculeE {lvalue},d). psi4.Molecule.geometry()¶; Python Library Documentation: method geometry; geometry(...) unbound psi4.Molecule method. geometry( (Molecule)arg1) -> Matrix :. Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); C++ signature :. N3psi6MatrixE geometry(N3psi8MoleculeE {lvalue}). psi4.Molecule.get_full_point_group()¶; Python Library Documentation: method get_full_point_group; get_full_point_group(...) unbound psi4.Molecule method. get_full_point_group( (Molecule)arg1) -> str :. Gets point group name such as C3v or S8; C++ signature :. Ss get_full_point_group(N3psi8MoleculeE {lvalue}). psi4.Molecule.get_variable()¶; Python Library Documentation: method get_variable; get_variable(...) unbound psi4.Molecule method. get_variable( (Molecule)arg1, (str)arg2) -> float :. Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; C++ signature :. d get_variable(N3psi8MoleculeE {lvalue},Ss). psi4.Molecule.is_variable()¶; Python Library Documentation: method is_variable; is_variable(...) unbound psi4.Molecule method. is_variable( (Molecule)arg1, (str)arg2) -> bool :. Checks if variable arg2 is in the list, returns true if it is, and returns false if not; C++ signature :. b is_variable(N3psi8MoleculeE {lvalue},Ss). psi4.Molecule.label()¶; Python Library Documentation: method label; label(...) unbound psi4.Molecule method. label( (Molecule)arg1, (int)arg2) -> str :. Gets the original label of the atom as given in the input file (C2, H4); C++ signature :. Ss label(N3psi8MoleculeE {lvalue},i). psi4.Molecule.mass()¶; Python Library Documentation: method mass; mass(...) unbound psi4.Molecule method. mass( (Molecule)arg1, (int)arg2) -> float :. Gets mass of atom arg2; C++ signature :. d mass(N3psi8MoleculeE {lvalue},i). psi4.Molecule.molecular_charge()¶; Python Library Docum",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:243367,variab,variable,243367,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variable']
Modifiability,"g2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Summary. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:2217,variab,variable,2217,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"g2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg1. units¶; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:89203,variab,variable,89203,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,4,['variab'],"['variable', 'variables']"
Modifiability,"g2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:19421,variab,variable,19421,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,2,['variab'],"['variable', 'variables']"
Modifiability,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:31678,inherit,inherited,31678,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"g; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF); CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SORTED_TEI_FILE (TRANSQT); TRANSQT — MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SOS_SCALE (OMP2); OMP2 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE (OMP3); OMP3 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2 (OMP2); OMP2 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_SCALE2 (OMP3); OMP3 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE (OMP2); OMP2 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OMP3); OMP3 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:117730,adapt,adapted,117730,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Modifiability,"g\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34237,variab,variables,34237,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"g_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3147,variab,variable,3147,psi4manual/1.0.0/_modules/qcdb/pdict.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html,1,['variab'],['variable']
Modifiability,"gation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html:1867,Variab,Variables,1867,psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html,2,['Variab'],['Variables']
Modifiability,"gation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__dfocc-1.html:1867,Variab,Variables,1867,psi4manual/1.5.0/autodir_psivariables/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__dfocc-1.html,2,['Variab'],['Variables']
Modifiability,"gation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. General¶. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CORR_ANSATZ¶. The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP¶. The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN¶. The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: intege",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__psimrcc.html:998,coupling,coupling,998,psi4manual/1.8.x/autodir_options_c/module__psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__psimrcc.html,2,['coupling'],['coupling']
Modifiability,"gation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. General¶. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CORR_ANSATZ¶. The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T¶. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE¶. The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP¶. The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN¶. The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: intege",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__psimrcc.html:998,coupling,coupling,998,psi4manual/1.9.x/autodir_options_c/module__psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__psimrcc.html,2,['coupling'],['coupling']
Modifiability,"gau2grid and activate dependent code. Previous bullet had details. To build PSI4 from source and use; gau2grid from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gau2grid-1.html:1974,variab,variable,1974,psi4manual/1.3.2/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gau2grid-1.html,8,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"ge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:37058,variab,variables,37058,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['variab'],['variables']
Modifiability,"generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBIC_GRID_SPACING¶. CubicScalarGrid grid spacing in bohr [D_X, D_Y, D_Z]. Defaults to 0.2 bohr each. Type: array; Default: No Default. CUBIC_GRID_OVERAGE¶. CubicScalarGrid spatial extent in bohr [O_X, O_Y, O_Z]. Defaults to 4.0 bohr each. Type: array; Default: No Default. Orbital Visualization with VMD¶; Included in Psi4 is functionality to automatically render specified surfaces, including molecular orbitals,; densities, and basis functions, using VMD. The vmd_cube.py script takes the .cube files generated; in a calculation and generates images alinged with user-input specifications. The script is located; in psi4//share/scripts/vmd_cube.py. Script Prerequisites¶. VMD must be installed, and it can be downloaded for free at (http://www.ks.uiuc.edu/Research/vmd/). Additionally,; the script needs to know where to find the VMD executable, and this is defined as VMDPATH. VMDPATH must be defined as; an environment variable.; To generate images with multiple surfaces, ImageMagick must also be installed. ImageMagick is a free program which; can be installed using homebrew/pip or from http://www.imagemagick.org/script/binary-releases.php .; With ImageMagick installed, an environment variable called MONTAGE needs to be created which points to the montage executable.; This executable can be found in the /bin/ sub-directory wherever ImageMagick was installed. Running the Script¶. Run a Psi4 calculation, generating .cube files as detailed in the above documentation. Copy vmd_script.py into a directory where the image files are desired, and pass the directory; pointing to the .cube files as an argument to run:; python vmd_cube.py /path/to/cube/files/. Alternatively, the script can be run in the same directory as the cube files with no need to pass the; directory as an argument. For an additional image containing all surfaces in an array (very useful for hand-picking orbital spaces), set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cubeprop-1.html:5366,variab,variable,5366,psi4manual/1.0.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cubeprop-1.html,2,['variab'],['variable']
Modifiability,"geom: str, name: str = ""default"") -> core.Molecule:; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; # beware if qcel and psi4 choose different sets of constants; geom = geom / constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except Exception:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]; def activate(mol: core.Molecule):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.molutil. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/molutil.html:8139,variab,variables,8139,psi4manual/1.9.x/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/molutil.html,2,['variab'],['variables']
Modifiability,"geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:38956,variab,variable,38956,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__mrcc-1.html:1896,variab,variable,1896,psi4manual/1.1.0/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__mrcc-1.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__mrcc.html:1934,variab,variable,1934,psi4manual/master/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__mrcc.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__mrcc-1.html:1898,variab,variable,1898,psi4manual/1.2.1/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__mrcc-1.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html:1921,variab,variable,1921,psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__mrcc-1.html:1925,variab,variable,1925,psi4manual/1.4.0/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__mrcc-1.html,4,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__mrcc-1.html:1925,variab,variable,1925,psi4manual/1.5.0/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__mrcc-1.html,4,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__mrcc.html:1925,variab,variable,1925,psi4manual/1.6.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__mrcc.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__mrcc.html:1925,variab,variable,1925,psi4manual/1.7.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__mrcc.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__mrcc.html:1927,variab,variable,1927,psi4manual/1.8.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__mrcc.html,2,['variab'],['variable']
Modifiability,"ger; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__mrcc.html:1927,variab,variable,1927,psi4manual/1.9.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__mrcc.html,2,['variab'],['variable']
Modifiability,"ges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:2644,variab,variable,2644,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,2,['variab'],['variable']
Modifiability,"get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45152,variab,variable,45152,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:18079,variab,variable,18079,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"ghly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved.; CD; A threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications).; We have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE; DIRECT. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:22622,extend,extended,22622,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,2,['extend'],['extended']
Modifiability,"ght)\]. \[\chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right)\]; The \(\delta_{HF}^{(2)}\) and \(\delta_{HF}^{(3)}\) terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree–Fock supermolecular interaction energy; \(E_{int}^{HF}\) and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (7)¶\[\delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)}; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)})\]. (8)¶\[\delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)}; + E_{ind,resp}^{(30)})\]; Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. \[\delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)})\]. \[\delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)})\]; where \(E_{int}^{MP2, corr}\) is the correlation part of the supermolecular MP2; interaction energy. \(\delta_{MP2}^{(2)}\) and \(\delta_{MP2}^{(3)}\) also improve the; description of electrostatically dominated complexes. \(\delta_{MP2}^{(2)}\); can be applied to SAPT2+ or SAPT2+(3) energies whereas \(\delta_{MP2}^{(3)}\); should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:5800,coupling,coupling,5800,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['coupling'],['coupling']
Modifiability,"gin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to ddx by A. Mikhalev, A. Jha, M. Nottoli and M. F. Herbst; Installation; Using dd-based continum solvation models; Solvent model and solvent cavity definition; Numerical integration and discretisation parameters; Iterative solver parameters; Further keywords for ddx; How to configure ddx for building Psi4. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/interfacing.html:2173,config,configure,2173,psi4manual/1.7.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/interfacing.html,3,['config'],['configure']
Modifiability,"gin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to ddx by A. Mikhalev, A. Jha, M. Nottoli and M. F. Herbst; Installation; Using dd-based continum solvation models; Solvent model and solvent cavity definition; Numerical integration and discretisation parameters; Iterative solver parameters; Further keywords for ddx; How to configure ddx for building Psi4. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/interfacing.html:2182,config,configure,2182,psi4manual/master/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/master/interfacing.html,1,['config'],['configure']
Modifiability,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:5080,plugin,plugin,5080,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,8,"['PLUGIN', 'Plugin', 'plugin']","['PLUGIN', 'Plugin', 'plugin', 'pluginutil']"
Modifiability,"gin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/pluginutil.html:5069,plugin,plugin,5069,psi4manual/1.9.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/pluginutil.html,8,"['PLUGIN', 'Plugin', 'plugin']","['PLUGIN', 'Plugin', 'plugin', 'pluginutil']"
Modifiability,"gine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([('libdisp', ['d1', 'd2', 'chg', 'das2009', 'das2010']),; ('dftd3', ['d2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj']),; ('nl', ['nl']),; ('mp2d', ['dmp2']),; ]) # yapf: disable. _capable_engines_for_disp = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; _capable_engines_for_disp[disp].append(eng). [docs]class EmpiricalDispersion(object):; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {'d1', 'd2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj', 'chg', 'das2009', 'das2010', 'nl', 'dmp2'}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashlevel`. Resolved into a complete set (keys of; dashcoeff[dashlevel]['default']) from `name_hint` and/or; `dashcoeff_supplement` and/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""ble",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:2314,flexible,flexible,2314,psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['flexible'],['flexible']
Modifiability,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:3048,plugin,plugin,3048,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,20,['plugin'],['plugin']
Modifiability,"gins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:4549,plugin,plugin,4549,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuratio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:3613,config,configure,3613,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configure']
Modifiability,"given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.fisapt(arg0: psi::Wavefunction) → float¶; Runs the functional-group intramolecular symmetry adapted perturbation theory code. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_environment(arg0: str) → str¶; Get enviromental vairable. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the curren",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:149384,variab,variables,149384,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:7118,plugin,plugin,7118,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['plugin'],['plugin']
Modifiability,"global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched statu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:7116,plugin,plugin,7116,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,2,['plugin'],['plugin']
Modifiability,"gma^+\) state of the CN radical, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. aediis-1; ADIIS test case, from 10.1063/1.3304922. scf-response2; Compute the dipole polarizability for water with custom basis set. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cisd-sp; 6-31G** H2O Test CISD Energy Point. tdscf-7; TD-HF test variable access. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. mints3; Test individual integral objects for correctness. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:5536,variab,variable,5536,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variable']
Modifiability,"gment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP)¶EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP)¶EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP)¶EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP)¶EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP)¶EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC)¶OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC)¶DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC)¶OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCT)¶DCT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING)¶OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM)¶CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:120566,extend,extended,120566,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['extend'],['extended']
Modifiability,"gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables before running cmake.; CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... CRAYPE_LINK_TYPE¶; Set to allow PSI4 to build as shared library on Cray supercomputers. CRAY_ADD_RPATH¶; Set to true to allow PSI4 to build on Cray supercomputers. How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies. PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:. Ubuntu gfortran; conda gfortran_linux-64 or gfortran_osx-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gfortran_osx-64 conda package. This provides; gfortran compilers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and eff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:39730,variab,variable,39730,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,8,['variab'],['variable']
Modifiability,"go, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/text.html:4226,extend,extend,4226,psi4manual/master/_modules/psi4/driver/p4util/text.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/text.html,2,['extend'],['extend']
Modifiability,"gorithm is used. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2007-2023, The Psi4 P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/testsuite.html:48637,variab,variables,48637,psi4manual/1.8.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/testsuite.html,1,['variab'],['variables']
Modifiability,"gorithm is used. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. © Copyright 2007-2023",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:47915,variab,variables,47915,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,1,['variab'],['variables']
Modifiability,"grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85184,variab,variable,85184,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('FCI', 'TRUE'); elif (name.lower() == 'cisd'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 2); el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18675,config,configuration,18675,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,2,['config'],['configuration']
Modifiability,"gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Tur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:3358,variab,variables,3358,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,4,['variab'],['variables']
Modifiability,"grals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7](1, 2, 3) For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxilia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:32352,flexible,flexible,32352,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['flexible'],['flexible']
Modifiability,"gram orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR); CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR); CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The tw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:61028,variab,variable,61028,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['variab'],['variable']
Modifiability,"gram python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following comman",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:2415,config,configuring,2415,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configuring']
Modifiability,"grangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type; Matrix. Cb(self: psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:7871,variab,variable,7871,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,14,['variab'],['variable']
Modifiability,"gs, **kwargs)¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.prop-1.html:1238,config,configurational,1238,psi4manual/1.2.1/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.prop-1.html,2,['config'],['configurational']
Modifiability,"gs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = core.variable('CURRENT ENERGY'). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = core.variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * core.variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. core.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; core.set_variable('DFT TOTAL ENERGY', returnvalue); core.set_variable('CURRENT ENERGY', returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:61335,variab,variable,61335,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"gstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self._",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36010,variab,variable,36010,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,2,['variab'],"['variable', 'variables']"
Modifiability,"gth gauge, computed at (x) wavelength, (x) rounded to nearest integer. CCD TOTAL ENERGY¶. CCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the coupled-cluster doubles level of theory. CC ALPHA-ALPHA PAIR ENERGIES¶. CCSD ALPHA-ALPHA PAIR ENERGIES¶. CC2 ALPHA-ALPHA PAIR ENERGIES¶. CC3 ALPHA-ALPHA PAIR ENERGIES¶. MP2 ALPHA-ALPHA PAIR ENERGIES¶; Restricted-reference same-spin pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC ALPHA-BETA PAIR ENERGIES¶. CCSD ALPHA-BETA PAIR ENERGIES¶. CC2 ALPHA-BETA PAIR ENERGIES¶. CC3 ALPHA-BETA PAIR ENERGIES¶. MP2 ALPHA-BETA PAIR ENERGIES¶; Restricted-reference opposite-spin (alpha first) pair energies for coupled-cluster; theories. Size number of active doubly occupied orbitals, square. CC SINGLET PAIR ENERGIES¶. CCSD SINGLET PAIR ENERGIES¶. CC2 SINGLET PAIR ENERGIES¶. CC3 SINGLET PAIR ENERGIES¶. MP2 SINGLET PAIR ENERGIES¶; Restricted-reference singlet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC TRIPLET PAIR ENERGIES¶. CCSD TRIPLET PAIR ENERGIES¶. CC2 TRIPLET PAIR ENERGIES¶. CC3 TRIPLET PAIR ENERGIES¶. MP2 TRIPLET PAIR ENERGIES¶; Restricted-reference triplet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:17788,adapt,adapted,17788,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['adapt'],['adapted']
Modifiability,"gths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing transformed integrals. Integrals less than \(10^{-N}\) are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD¶. Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_ZFIELD¶. Specifies the Z-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. Expert Psi4 Control of CFOUR¶. CFOUR_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. table of contents. CFOUR; Psi4 Control of CFOUR; TRANSLATE_PSI4. CFOUR Internal; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANHARMONIC; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_CC_MAXCYC; CFOUR_CC_PROGRAM; CFOUR_CHARGE; CFOUR_CIS_CONV; CFOUR_CONTINUUM; CFOUR_CONTRACTION; CFOUR_CONVERGENCE; CFOUR_COORDINATES; CFOUR_CORE_ORBITALS; CFOUR_CPHF_CONVER; CFOUR_CPHF_MAXCYC; CFOUR_CURVILINEAR; CFOUR_DBOC; CFOUR_DCT; CFOUR_DERIV_LEVEL; CFOUR_DIFF_TYPE; CFOUR_DROPMO; CFOUR_ECP; CFOUR_EIGENVECTOR; CFOUR_EL_ANHARM; CFOUR_EOM_NONIT; CFOUR_ESTATE_CONV; CFOUR_ESTATE_MAXCYC; CFO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:65635,variab,variable,65635,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['variab'],['variable']
Modifiability,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:3158,plugin,plugin,3158,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"gy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:6622,config,configuration,6622,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['config'],['configuration']
Modifiability,"gy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI scalar and array variables that have been set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. dmrg(arg0); Runs the DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:294194,config,configuration,294194,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['config'],['configuration']
Modifiability,"gy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). table of contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; E_CONVERGENCE; MAXITER; DIIS_MAX_VECS; NAT_ORBS; OCC_TOLERANCE; TRIPLES_LOW_MEMORY; CC_TIMINGS; DF_BASIS_CC; CHOLESKY_TOLERANCE; CEPA_NO_SINGLES; DIPMOM. Advanced FNOCC Keywords; SCS_MP2; MP2_SCALE_OS; MP2_SCALE_SS; SCS_CCSD; CC_SCALE_OS; CC_SCALE_SS; RUN_MP2; RUN_MP3; RUN_MP4; RUN_CCSD; RUN_CEPA; COMPUTE_TRIPLES; COMPUTE_MP4_TRIPLES; DFCC; CEPA_LEVEL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:19403,config,configuration,19403,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,2,['config'],['configuration']
Modifiability,"gy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). table of contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; E_CONVERGENCE; MAXITER; DIIS_MAX_VECS; NAT_ORBS; OCC_TOLERANCE; TRIPLES_LOW_MEMORY; CC_TIMINGS; DF_BASIS_CC; CHOLESKY_TOLERANCE; CEPA_NO_SINGLES; DIPMOM. Advanced FNOCC Keywords; SCS_MP2; MP2_SCALE_OS; MP2_SCALE_SS; SCS_CCSD; CC_SCALE_OS; CC_SCALE_SS; RUN_MP2; RUN_MP3; RUN_MP4; RUN_CCSD; RUN_CEPA; COMPUTE_TRIPLES; COMPUTE_MP4_TRIPLES; DFCC; CEPA_LEVEL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/fnocc-1.html:19403,config,configuration,19403,psi4manual/1.5.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/fnocc-1.html,2,['config'],['configuration']
Modifiability,"h = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:83433,variab,variables,83433,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2676,config,configuration,2676,psi4manual/4.0b2/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html,4,['config'],['configuration']
Modifiability,"h conda install simint.; Then enable it as a feature with ENABLE_simint,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect simint and activate dependent code.; To remove a conda installation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/simint-1.html:2014,variab,variable,2014,psi4manual/1.1.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/simint-1.html,2,['variab'],['variable']
Modifiability,"h i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. The top section features PBS-specific commands. These depend on the; specific characteristics of your PBS queuing system but they may include:; #!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. The PBS -j oe option instructs PBS to write any output or error message; from the queuing system in dedicated files. PBS -l pmem=2120mb requests; 2120 MB of memory for each thread on the node. The total memory requested for; the job by PBS should generally be slightly greater than what indicated; in the input file (see memory setting).; In the next section, we define OMP_NUM_THREADS and MKL_NUM_THREADS; to use 4 threads for OpenMP parallelization and in threaded BLAS (see section Threading).; setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4. Then, we move to the working directory using PBS variable $PBS_O_WORKDIR and; we create scratch directories on every node, using the $PBS_NODEFILE which; points to a file containing a list of the nodes attributed to the job.; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. The next section is very important as it sets the environment variables needed; by Psi4:; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}. PSIDATADIR does not need to be set if Psi4 has been properly installed.; In the present example we unset it to make sure it does not interfere with the location; of the installed directory. PSIPATH is needed only if you are using external modules or; plugins in Psi4 and should point to the directories where they can be found. In the; present example, we make sure the variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:11515,variab,variable,11515,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"h the Ubuntu shell). If using the PSI4 binary, DFTD3 has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the dftd3 executable can be obtained through conda install dftd3. To remove a conda installation, conda remove dftd3. Source. If using PSI4 built from source and you want to build DFTD3 from; from source also,; follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:1405,variab,variables,1405,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,2,['variab'],['variables']
Modifiability,"h-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math library (better than MKL for AMD processors); ../configure --prefix=/usr/local/psi4 --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with-opt=-O2 --with-blas=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"" --with-lapack=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:7932,config,configuring,7932,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configuring']
Modifiability,"h-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math library (better than MKL for AMD processors); ../configure --prefix=/usr/local/psi4 --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with-opt=-O2 --with-blas=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"" --with-lapack=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install Xcode.; However, Xcode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:8732,config,configuring,8732,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configuring']
Modifiability,"h-order Moller--Plesset perturbation theory |; +-------------------------+---------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) |; +-------------------------+---------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) |; +-------------------------+---------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) |; +-------------------------+---------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) |; +-------------------------+---------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI |; +-------------------------+---------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) |; +-------------------------+---------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------+; | adc | 2nd-order algebraic diagrammatic construction (ADC) |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-cc2 | EOM-CC2 |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 |; +-------------------------+---------------------------------------------------------------------------------------+.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:10653,config,configuration,10653,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['config'],['configuration']
Modifiability,"h: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Note; If you know the location of the PSI4 executable; (bin/psi4) and want to know the corresponding location to add to; PYTHONPATH, execute psi4 --psiapi-path. It will return; bash commands to set PATH (for correct python interpreter); and PYTHONPATH (to find psi4 module) correctly, after which; python -c ""import psi4"" will work. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performed; source activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:21192,config,configuration,21192,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['config'],['configuration']
Modifiability,"ha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. ndet(self); docstring. new_civector(self, arg0, arg1, arg2, arg3); docstring. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. opdm(self, arg0, arg1, arg2, arg3); docstring. options(self); Returns the Wavefunction's options object. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. reset_ci_H0block(self); docstring. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:6695,variab,variable,6695,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"hancing PSI4 Capabilities¶; PSI4‘s capabilities have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/interfacing-1.html:1159,config,configure,1159,psi4manual/1.1.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/interfacing-1.html,2,['config'],['configure']
Modifiability,"hancing PSI4 Capabilities¶; PSI4’s capabilities have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Netw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/interfacing-1.html:1161,config,configure,1161,psi4manual/1.2.1/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/interfacing-1.html,4,['config'],['configure']
Modifiability,"handles arbitrary order; angular momentum, but compiling that is prohibitive. The default of 5; is generally good. 6 has met all of a research group’s needs for; years. 4 is handy for quickly testing other parts of the build. Build with Higher Angular Momentum; >>> cmake -DMAX_AM_ERI=6. Relevant CMake Options:; MAX_AM_ERI=N # The maximum angular momentum level (1=p, 2=d, 3=f,; # etc.) for the libint integrals and derivative; # integrals. A value of N implies a maximum first; # derivative of N-1, and maximum second derivative of; # N-2, so for an atom such as Neon, the default 5 gets; # you conventional cc-pV5Z for energies, cc-pVQZ for; # gradients, cc-pVTZ for frequencies and density-fitted; # cc-pVQZ for energies, cc-pVTZ for gradients, cc-pVDZ; # for frequencies. [default: 5]. Note that since PSI4 1.1, it is possible to build Libint; independently (or install just the libint conda package), then have; any/all PSI4 builds detect that installation at compile-time. How to configure Libint for building Psi4. How to get high angular momentum integrals from conda¶; To switch from the default Libint package to the really large high AM; package, do the below. The channel/subchannel(s) containing the am8; metapackage and the high-AM Libint package must be supplied (or in; .condarc).; 1conda install am8 -c psi4. This switch-out only works for rebuilding PSI4, not for the psi4; conda package.; To go back to the default Libint package, do the below. The; channel/subchannel containing the default Libint package must be supplied; (or in .condarc); otherwise, it’ll just remove Libint and every package; depending on it.; 1conda remove --features am8 -c psi4. The default package is AM6 because of its manageable file size (on Linux,; 10MB for libint and 40MB for libderiv). The AM7 are 20/100, respectively,; and the AM8 is 50/210. How to see what build configuration options are available¶; CMake doesn’t provide a summary for this (unless you want to try the CMake; GUI, which the dev",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:7545,config,configure,7545,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"handles arbitrary order; angular momentum, but compiling that is prohibitive. The default of 5; is generally good. 6 has met all of a research group’s needs for; years. 4 is handy for quickly testing other parts of the build. Build with Higher Angular Momentum; >>> cmake -DMAX_AM_ERI=6. Relevant CMake Options:; MAX_AM_ERI=N # The maximum angular momentum level (1=p, 2=d, 3=f,; # etc.) for the libint integrals and derivative; # integrals. A value of N implies a maximum first; # derivative of N-1, and maximum second derivative of; # N-2, so for an atom such as Neon, the default 5 gets; # you conventional cc-pV5Z for energies, cc-pVQZ for; # gradients, cc-pVTZ for frequencies and density-fitted; # cc-pVQZ for energies, cc-pVTZ for gradients, cc-pVDZ; # for frequencies. [default: 5]. Note that since PSI4 1.1, it is possible to build Libint; independently (or install just the libint conda package), then have; any/all PSI4 builds detect that installation at compile-time. How to configure Libint for building Psi4. How to get high angular momentum integrals from conda¶; To switch from the default libint package to the really large high AM; package, do the below. The channel/subchannel(s) containing the am8; metapackage and the high-AM libint package must be supplied (or in; .condarc).; 1conda install am8 -c psi4. To go back to the default libint package, do the below. The; channel/subchannel containing the default libint package must be supplied; (or in .condarc); otherwise, it’ll just remove libint and every package; depending on libint.; 1conda remove --features am8 -c psi4. The default package is AM6 because of its manageable file size (on Linux,; 10MB for libint and 40MB for libderiv). The AM7 are 20/100, respectively,; and the AM8 is 50/210. How to see what build configuration options are available¶; CMake doesn’t provide a summary for this (unless you want to try the CMake; GUI, which the developers have never looked at). However, the top half of; the main CMakeLists.t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:6959,config,configure,6959,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['config'],['configure']
Modifiability,"handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file.:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running sim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:3206,variab,variable,3206,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['variab'],['variable']
Modifiability,"hannel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=0.1.12 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 –channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.6 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=0.1.12 -c psi4/label/dev. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for reference, 2.10 is newer than 2.7; unlike most libraries, libc generally not available in multiple versions on a computer), the PSI4 conda package won’t work.; 1; 2; 3; 4; 5; 6# unsuitable computer; >>> ldd --version; ldd (GNU libc) 2.5; # suitable computer; >>> ldd --version; ldd (GNU libc) 2.17. It is of greatest importance that the PSI4 executable be linked against conda libpython.so not against any system libpython.so. This is arranged by setting RPATH to seek libraries relative to executable (thanks, conda binary relocation routine!). The conda PSI4 executable is not vulnerable to interference from your LD_LIBRARY_PATH settings. Below shows a well-linked executable. no libraries “not found”; fundamen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:21715,sandbox,sandbox,21715,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,2,['sandbox'],['sandbox']
Modifiability,"hared_ptrIN3psi8MoleculeEEE). psi4.occ()¶; Python Library Documentation: built-in function occ in module psi4; occ(...). occ( (Wavefunction)arg1) -> Wavefunction :. Runs the orbital optimized CC codes.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE occ(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.opt_clean()¶; Python Library Documentation: built-in function opt_clean in module psi4; opt_clean(...). opt_clean() -> None :. Cleans up the optimizer’s scratch files.; C++ signature :. void opt_clean(). psi4.optking()¶; Python Library Documentation: built-in function optking in module psi4; optking(...). optking() -> int :. Runs the geometry optimization / frequency analysis code.; C++ signature :. i optking(). psi4.outfile_name()¶; Python Library Documentation: built-in function outfile_name in module psi4; outfile_name(...). outfile_name() -> str :. Returns the name of the output file.; C++ signature :. Ss outfile_name(). psi4.plugin()¶; Python Library Documentation: built-in function plugin in module psi4; plugin(...). plugin( (str)arg1, (Wavefunction)arg2) -> Wavefunction :. docstring; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE plugin(Ss,N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.plugin_close()¶; Python Library Documentation: built-in function plugin_close in module psi4; plugin_close(...). plugin_close( (str)arg1) -> None :. docstring; C++ signature :. void plugin_close(Ss). psi4.plugin_close_all()¶; Python Library Documentation: built-in function plugin_close_all in module psi4; plugin_close_all(...). plugin_close_all() -> None :. docstring; C++ signature :. void plugin_close_all(). psi4.plugin_load()¶; Python Library Documentation: built-in function plugin_load in module psi4; plugin_load(...). plugin_load( (str)arg1) -> int :. docstring; C++ signature :. i plugin_load(Ss). psi4.prepare_options_for_module()¶; Python Library Documentation: built-in function prepare_options_for_module in module psi4; prepare_options_for_modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:35526,plugin,plugin,35526,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['plugin'],['plugin']
Modifiability,"harges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.molparse.from_arrays. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:23174,variab,variables,23174,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,9,"['Variab', 'variab']","['Variables', 'variables']"
Modifiability,"harges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; qcelemental.molparse.from_arrays. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html:23174,variab,variables,23174,psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html,9,"['Variab', 'variab']","['Variables', 'variables']"
Modifiability,"has been touched in the scope of the specified module arg1, by either user or code. has_option_changed((arg0: str, ...); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Runs a CPHF calculation, using libfock. mcscf(...); Runs the MCSCF code, (N.B. mrcc_generate_input(...); Generates an input for Kallay’s MRCC code. mrcc_load_densities(...); Reads in the density matrices from Kallay’s MRCC code. occ(...); Runs the orbital optimized CC codes. opt_clean(() -> None); Cleans up the optimizer’s scratch files. optking(() -> int); Runs the geometry optimization / frequency analysis code. outfile_name(() -> str); Returns the name of the output file. plugin((arg0: str, ...); Call the plugin of name arg0. plugin_close((arg0: str) -> None); Close the plugin of name arg0. plugin_close_all(() -> None); Close all open plugins. plugin_load((arg0: str) -> int); Load the plugin of name arg0. prepare_options_for_module((arg0: str) -> None); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(() -> None); Prints the currently set global (all modules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multireference coupled cluster code. reopen_outfile(() -> None); Reopens the output file. revoke_global_option_changed((a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:168495,plugin,plugin,168495,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:84223,variab,variables,84223,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:31702,variab,variable,31702,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"hat performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:6351,maintainab,maintainability,6351,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,2,"['maintainab', 'plugin']","['maintainability', 'plugins']"
Modifiability,"hat these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI”¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:20093,config,configuration,20093,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,4,['config'],"['configuration', 'configure']"
Modifiability,"hat these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI”¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage/prefix. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:19142,config,configuration,19142,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['config'],"['configuration', 'configure']"
Modifiability,"he Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in Psi4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to Psi4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the Psi4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceeding or following jobs, it is prudent to; separate them with the following:; clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be spcified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run Psi4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. Table Of Contents. Interface to CFOUR by J. Stanton and J. Gauss; Installation; Cfour for Psi4 Users; Psi4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Previous topic; Interfaces: Enhancing Psi4 Capabilities; Next topic; Interface to CheMPS2 by S. Wouters. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:35182,variab,variable,35182,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['variab'],['variable']
Modifiability,"he Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 400. HD_AVG¶. How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. Expert Density Matrices¶. OPDM_KE¶. Do compute the kinetic energy contribution from the correlated part ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:14587,coupling,coupling,14587,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,16,['coupling'],['coupling']
Modifiability,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html:2742,config,configuration,2742,psi4manual/1.1.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html,11,['config'],['configuration']
Modifiability,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psimrcc.html:2784,config,configuration,2784,psi4manual/1.7.x/psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psimrcc.html,4,['config'],['configuration']
Modifiability,"he O2 molecule with 6-31G basis set. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. cbs-xtpl-dict; Extrapolated water energies. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dft-omega; Test omega is setable updated wb97x_20,wb97x_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:21901,variab,variables,21901,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"he SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); PSIMRCC — Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FOLLOW_VECTOR (DETCI); DETCI (Expert) — In following a particular root (see FOLLOW_ROOT), sometimes the root number changes. To follow a root of a particular character, one can specify a list of determinants and their coefficients, and the code will follow the root with the closest overlap. The user specifies arrays containing the absolute alpha string indices (A_i below), absolute beta indices (B_i below), and CI coefficients (C_i below) to form the desired vector. The format is FOLLOW_VECTOR = [ [[A_1, B_1], C_1], [[A_2, B_2], C_2], ...]. Type: array; Default: No Default. FORCE_RESTART (CCENERGY); CCENERGY (Expert) — Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. FORCE_TWOCON (MCSCF); MCSCF — Do attempt to force a two configruation solution by starting with CI coefficents of ?. Type: boolean; Default: false. FRAC_DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD (SCF); SCF — Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC (SCF); SCF — The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE (SCF); SCF — Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START (SCF); SCF — The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL (SCF); SCF — The occupations of the orbital indices specified above (). Type: array; Default: No Default. FRAG_MODE (OPTKING); OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:34882,config,configruation,34882,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['config'],['configruation']
Modifiability,"he alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta orbitals are the same. set_array(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]; Returns the map of all internal variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:21442,variab,variable,21442,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,3,['variab'],"['variable', 'variables']"
Modifiability,"he basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gcp-1.html:3467,extend,extended,3467,psi4manual/1.3.2/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gcp-1.html,2,['extend'],['extended']
Modifiability,"he cumulant and the orbitals is achieved. As in the two-step algorithm, the DIIS; extrapolation is used to accelerate the convergence.; 3) Quadratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. The electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. By default the; electronic Hessian also contains the matrix elements that couple the orbitals; and the density cumulant. The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems. If the computation of the coupling elements; is not desired, it can be turned off by setting QC_COUPLING to FALSE.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive ; cumulant updates. As a result, for the small closed-shell systems the two-step; algorithm is usually preferred, while for the larger systems and the molecules with the; open-shell character it is recommended to use the simultaneous algorithm. The; efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:7767,coupling,coupling,7767,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['coupling'],['coupling']
Modifiability,"he current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.hf.html:11031,variab,variable,11031,psi4manual/1.2.1/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.hf.html,1,['variab'],['variable']
Modifiability,"he distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:4376,config,configure,4376,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,6,['config'],"['configuration', 'configure']"
Modifiability,"he keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR); CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR); CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:60978,variab,variable,60978,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['variab'],['variable']
Modifiability,"he one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectrostaticInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectrostaticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:445676,inherit,inherited,445676,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"he psi4/psi4/src/psi4/libmints directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the gener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html:1346,variab,variables,1346,psi4manual/1.4.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html,9,['variab'],['variables']
Modifiability,"he reference wavefunction. reset_ci_H0block(self: psi4.core.CIWavefunction) → None¶; docstring. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:26476,variab,variable,26476,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"he run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4). Table Of Contents. Configuration: Preparing PSI4’s Environment; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Previous topic; A PSI4 Tutorial; Next topic; Psithon: Structuring an Input File; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:8987,variab,variable,8987,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,4,"['plugin', 'variab']","['plugins', 'variable']"
Modifiability,"he same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:23221,config,configure,23221,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['config'],['configure']
Modifiability,"heMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to CheMPS2 by S. Wouters. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/chemps2.html:8042,config,configure,8042,psi4manual/1.8.x/chemps2.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/chemps2.html,2,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"heMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to CheMPS2 by S. Wouters. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/chemps2.html:8042,config,configure,8042,psi4manual/1.9.x/chemps2.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/chemps2.html,2,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"hell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:5350,variab,variables,5350,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['variab'],['variables']
Modifiability,"hellInfo) → None¶; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None; Remove the first item from the list whose value is x. It is an error if there is no such item. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.bsvec.html:1726,extend,extend,1726,psi4manual/1.2.1/api/psi4.core.bsvec.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.bsvec.html,1,['extend'],['extend']
Modifiability,"hen ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a supplementary test suite is available to be; run via pytest. Running a limited number of “smoke” tests is; generally sufficient to verify an installation. From the executable; # smoke tests only in serial; psi4 --test; # smoke tests only in parallel; psi4 --test -n`getconf _NPROCESSORS_ONLN`; # most tests; psi4 --test full. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.); # smoke tests only; python -c ""import psi4; psi4.test('smoke')""; # most tests; python -c ""import psi4; psi4.test()"". From pytest directly. If package pytest-xdist is installed, can run in parallel.; # smoke tests only; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -m smoke -n auto; # all tests; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n auto. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_addons.py::test_libefp PASSED; test_addons.py::test_pcmsolver PASSED; test_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:55398,config,configure,55398,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,5,['config'],['configure']
Modifiability,"hen ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a supplementary test suite is available to be; run via pytest. Running a limited number of “smoke” tests is; generally sufficient to verify an installation. From the executable; # smoke tests only in serial; psi4 --test; # smoke tests only in parallel; psi4 --test -n`getconf _NPROCESSORS_ONLN`; # most tests; psi4 --test full. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.); # smoke tests only; python -c ""import psi4; psi4.test('smoke')""; # most tests; python -c ""import psi4; psi4.test()"". From pytest directly. If package pytest-xdist is installed, can run in parallel.; # smoke tests only; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -m smoke -n`getconf _NPROCESSORS_ONLN`; # all tests; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n`getconf _NPROCESSORS_ONLN`. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_addons.py::test_libefp PASSED; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:55008,config,configure,55008,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['config'],['configure']
Modifiability,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:85563,extend,extend,85563,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['extend'],['extend']
Modifiability,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class vector_of_doubles(Boost.Python.instance); | docstring; | ; | Method resolution order:; | vector_of_doubles; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (vector_of_doubles)arg1, (object)arg2) -> bool; | ; | __delitem__(...",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:146115,extend,extend,146115,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['extend'],['extend']
Modifiability,"her response theories as CC2-LR, CIS(D) and CIS(D\(_n\)) has; been addressed [Haettig:2002] by Hattig et al. In the ADC theory,; the residue calculus of the propagator is translated into the eigenvalue; problem with respect to the correlated response matrix, also known as the; shifted-Hamiltonian. The σ-vectors (Hamiltonian-vector products); are constructed several times in the simultaneous expansion method (SEM); to solve the eigenvalue problem, and each σ-vector construction; has a computational cost that scales as \({\cal O}(N^5)\). In addition,; the tensorial form of the σ-vector resembles to that of the; doubles correction in the CIS(D) energetic equation. As a consequence,; the pre-factor in the polynomial scaling becomes far larger than that; of the CIS(D) even though the quasi-degeneracy of the excited state is; properly accounted for in the ADC(2) model.; The ADC code makes use of the libtrans library for efficient and flexible; integral-transformation and also the libdpd library to; utilize molecular symmetry in the tensorial manipulations in framework; of the direct-product decomposition algorithm. By this feature, the Ritz; space and intermediate tensors are blocked according to the irreducible; representations of the point group, and the excited states that belong; to different symmetry are sought separately.; In the output of ADC, the ADC(2) results may look as follows:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13-> 1 B1 state : 0.2565095 (a.u.), 6.9799824 (eV); Non-iterative: 0.2565636 (a.u.), 6.9814532 (eV); Occ Vir Coefficient; ---------------------------------------------; 3 0 -0.9017047264; 3 2 0.3038332241; 3 1 0.2907567119; 3 5 -0.0790167706; 3 4 -0.0425829926. Converged in 4 iteration.; Squared norm of the S component: 0.9315336; The S vector is rotated up to 8.102 (deg.). in which the ADC(2) excitation energy is indicated with arrow symbol; and the pseudo-perturbative value, which is calculated in very similar; fashion to the CIS(D) energy, is al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/adc-1.html:1902,flexible,flexible,1902,psi4manual/1.2.1/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/adc-1.html,6,['flexible'],['flexible']
Modifiability,"here. The Wavefunction class; psi4/psi4/src/psi4/libmints/wavefunction.h is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods¶; A new method that is not a modification of existing code belongs in its own; folder in psi4/psi4/src/psi4; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to psi4/psi4/src/psi4/CMakeLists.txt. There are also a number of; variables that can be exported to be available to the user, as detailed in; PSI Variables. To set these variables, the following member of; Wavefunction should be called:; set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; psi4/doc/sphinxman/source/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html:1470,variab,variable,1470,psi4manual/1.4.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html,9,['variab'],['variable']
Modifiability,"hes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR); CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:42496,adapt,adapted,42496,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Modifiability,"hes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR); CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:42534,adapt,adapted,42534,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['adapt'],['adapted']
Modifiability,"hes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR)¶CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR)¶CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR)¶CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:42877,adapt,adapted,42877,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['adapt'],['adapted']
Modifiability,"hf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:12525,enhance,enhanced,12525,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['enhance'],['enhanced']
Modifiability,"hf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In Psi4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In Psi4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:10620,enhance,enhanced,10620,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['enhance'],['enhanced']
Modifiability,"hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. Previous bullet had details. To build PSI4 from source and use; libefp from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source psi4/psi4/share/psi4/efpfrag. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all on one line: efp and; fragname are followed by two sets of three numbers: the coordinate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:2036,variab,variable,2036,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,4,['variab'],['variable']
Modifiability,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:17052,inherit,inherited,17052,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,hod. tstart() in module psi4.core. tstop() in module psi4.core. TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt class in psi4.core. twoel_Hx() psi4.core.HF method. twoel_Hx_full() psi4.core.RHF method. TwoElectronInt class in psi4.core. U. U psi4.core.Localizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unify_part2() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. up psi4.driver.p4util.InPsight attribute. UPDATE (DETCI). update() psi4.core.SOMCSCF method. update_density() psi4.core.TwoBodyAOInt method. update_geometry() psi4.core.Molecule method. psi4.driver.p4util.InPsight method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.HF method. Va() psi4.core.HF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_diis() psi4.core.HF method. validate_options() psi4.core.Options method. ValidationError. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.Wavefunction method. Vb() psi4.core.HF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_axpy() psi4.driver.p4util.SolverEngine method. vector_copy() psi4.driver.p4util.SolverE,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:125295,plugin,plugin,125295,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['plugin'],['plugin']
Modifiability,"hods¶. H0_BLOCKSIZE¶. This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 1000. Note that the program may change the given size for Ms=0 cases MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 1000. HD_AVG¶. How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:14558,coupling,coupling,14558,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,26,['coupling'],['coupling']
Modifiability,"hoice of installation location. You may need to replace the filename below with the correct filename for the OS/version of installer you downloaded. Execute with bash regardless of csh/bash shell. If you’re a bash user, it’s convenient to agree to its offer to prepend conda commands to your PATH in ~/.bashrc. If you’re a csh/tcsh user, it’s convenient to do the same by hand to your ~/.tcshrc: setenv PATH /path/to/miniconda/bin:${PATH}. Further directions assume that the conda command is in your path; you may have to log out and log back in for which conda to return correctly. >>> bash Miniconda-latest-Linux-x86_64.sh; # check; >>> which conda; /path/to/miniconda/bin/conda. Update conda. This updates the package manager itself. >>> conda update conda. Detailed Installation of PSI4¶. Subscribe to PSI4. Subscribe to our channel at http://anaconda.org/psi4 that contains the PSI4 package and several dependency packages. Make sure this shows up in your ~/.condarc file. >>> conda config --add channels http://conda.anaconda.org/psi4; # check; >>> cat ~/.condarc; channels:; - http://conda.anaconda.org/psi4; - defaults. Install PSI4. You can install into the main conda environment so that whenever commands conda or (Ana/Miniconda’s) python are available, then psi4 is available, too. >>> conda install psi4; # check; >>> which psi4; /path/to/miniconda/bin/psi4. Or, you can install into a conda environment that places PSI4 and its dependencies (including python) into a sandbox unaffected by any other software installed in Ana/Miniconda. This is recommended for developers to avoid interference between multiple versions (including github/conda versions) or to test python versions, etc.. If your main conda is not python=2.7, then PSI4 must be installed into a conda environment. In practical terms, installing into a conda environment means you can turn PSI4‘s availability on/off by switching conda environments without turning on/off the whole Ana/Miniconda installation. Below, PSI4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:13384,config,config,13384,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,2,['config'],['config']
Modifiability,"hoice of installation location. You may need to replace the filename below with the correct filename for the OS/version of installer you downloaded. Execute with bash regardless of csh/bash shell. If you’re a bash user, it’s convenient to agree to its offer to prepend conda commands to your PATH in ~/.bashrc. If you’re a csh/tcsh user, it’s convenient to do the same by hand to your ~/.tcshrc: setenv PATH /path/to/miniconda/bin:${PATH}. Further directions assume that the conda command is in your path; you may have to log out and log back in for which conda to return correctly. >>> bash Miniconda-latest-Linux-x86_64.sh; # check; >>> which conda; /path/to/miniconda/bin/conda. Update conda. This updates the package manager itself. >>> conda update conda. Detailed Installation of PSI4¶. Subscribe to PSI4. Subscribe to our channel at http://anaconda.org/psi4 that contains the PSI4 package and several dependency packages. Make sure this shows up in your ~/.condarc file. >>> conda config --add channels http://conda.anaconda.org/psi4; # check; >>> cat ~/.condarc; channels:; - http://conda.anaconda.org/psi4; - defaults. Install PSI4. You can install into the main conda environment so that whenever commands conda or (Ana/Miniconda’s) python are available, then psi4 is available, too. >>> conda install psi4; # check; >>> which psi4; /path/to/miniconda/bin/psi4. Or, you can install into a conda environment that places PSI4 and its dependencies (including python) into a sandbox unaffected by any other software installed in Ana/Miniconda. This is recommended for developers to avoid interference between multiple versions (including github/conda versions) or to test python versions, etc.. In practical terms, installing into a conda environment means you can turn PSI4’s availability on/off by switching conda environments without turning on/off the whole Ana/Miniconda installation. Below, PSI4 is installed into an environment called p4env. Then the environment is activated, removing t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:15807,config,config,15807,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,4,['config'],['config']
Modifiability,"hoice of installation location. You may need to replace the filename below with the correct filename for the OS/version of installer you downloaded. Execute with bash regardless of csh/bash shell. If you’re a bash user, it’s convenient to agree to its offer to prepend conda commands to your PATH in ~/.bashrc. If you’re a csh/tcsh user, it’s convenient to do the same by hand to your ~/.tcshrc: setenv PATH /path/to/miniconda/bin:${PATH}. Further directions assume that the conda command is in your path; you may have to log out and log back in for which conda to return correctly. >>> bash Miniconda-latest-Linux-x86_64.sh; # check; >>> which conda; /path/to/miniconda/bin/conda. Update conda. This updates the package manager itself. >>> conda update conda. Detailed Installation of Psi4¶. Subscribe to Psi4. Subscribe to our channel at http://anaconda.org/psi4 that contains the Psi4 package and several dependency packages. Make sure this shows up in your ~/.condarc file. >>> conda config --add channels http://conda.anaconda.org/psi4; # check; >>> cat ~/.condarc; channels:; - http://conda.anaconda.org/psi4; - defaults. Install Psi4. You can install into the main conda environment so that whenever commands conda or (Ana/Miniconda’s) python are available, then psi4 is available, too. >>> conda install psi4; # check; >>> which psi4; /path/to/miniconda/bin/psi4. Or, you can install into a conda environment that places Psi4 and its dependencies (including python) into a sandbox unaffected by any other software installed in Ana/Miniconda. This is recommended for developers to avoid interference between multiple versions (including github/conda versions) or to test python versions, etc.. If your main conda is not python=2.7, then Psi4 must be installed into a conda environment. In practical terms, installing into a conda environment means you can turn Psi4‘s availability on/off by switching conda environments without turning on/off the whole Ana/Miniconda installation. Below, Psi4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/conda-1.html:8658,config,config,8658,psi4manual/1.0.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/conda-1.html,2,['config'],['config']
Modifiability,"home/user/psiadditions:/home/user/gbs. # bash; >>> export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; Psi4, these are generally plugins (see Plugins: Adding New Functionality to Psi4) or databases. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh/tcsh; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; # sh/bash; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every Psi4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). PSIDATADIR¶; Path in which the Psi4 executable looks for its non-compiled; dependencies (i.e., Python driver, basis sets, databases, etc.).; Not used when running from an installed (make install) executable; or when running from a conda binary,; so this variable is relevant primarily to developers running the; executable directly from the compilation directory. Value should be set; to directory containing driver, basis, etc. directories, generally; psi4/share. Table Of Contents. Installation and Runtime Configuration; Obtaining Psi4; Installing from Binary; Compiling and Installing from Source; Scratch Files and Elementary Restart; ~/.psi4rc File; Threading; PBS job file; Command Line Options; Environment Variables. Previous topic; <no title>; Next topic; Binary Distribution. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:18791,variab,variable,18791,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PYTHONPATH is preferred for; Python moduels to accommodate QCEngine. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). PSIDATADIR¶; Path in which the PSI4 executable looks for its non-compiled; dependencies (i.e., basis sets, databases, quadratures, etc.).; This path is always known by the PSI4 program or shared library,; so this variable is relevant primarily to developers wanting a; non-standard location. Value should be set; to directory containing driver, basis, etc. directories, generally; ending in share/psi4. table of contents. Installation and Runtime Configuration; Scratch Files; Elementary Restart; Saving the Wavefunction; ~/.psi4rc File; Threading; PBS job file; Command Line Options; Environment Variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:24405,variab,variable,24405,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,1,['variab'],['variable']
Modifiability,"hon object type. set_gradient((arg0: psi::Matrix) -> None); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(...); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(...); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python((arg0: str, ...); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes((memory: int, ...); Sets the memory available to Psi (in bytes). set_num_threads((nthread: int, ...); Sets the number of threads to use in SMP parallel computations. set_output_file((arg0: str, arg1: bool) -> None). set_parent_symmetry((arg0: str) -> None); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix((arg0: str) -> None). set_variable((arg0: str, arg1: float) -> None); Sets a PSI variable, by name. thermo((arg0: psi::Wavefunction, ...); Computes thermodynamic data. tstart(() -> None); docstring. tstop(() -> None); docstring. version(() -> str); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; docstring. BSVec. BasisSet; docstring. BasisSetParser; docstring. BoysLocalizer; docstring. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; docstring. CorrelationFactor; docstring. CorrelationTable; docstring. CubeProperties; docstring. DFChargeFitter; docstring. DFSOMCSCF; docstring. DFTensor; docstring. Deriv; docstring. DiagonalizeOrder; docstring. Dimension; docstring. DipoleInt; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; docstring. ElectricFieldInt; docstring. ElectrostaticInt; docstring. ErfComplementERI; docstring. ErfERI; docstring. ExternalPotential; docstring. F12; docstring. F12DoubleCommutator; docstring",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:171902,variab,variable,171902,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"hon sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; >>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additiona",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:31734,variab,variable,31734,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['variab'],['variable']
Modifiability,"hon(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:11120,variab,variables,11120,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['variab'],['variables']
Modifiability,"hon(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:11120,variab,variables,11120,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"hon.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE matrix(N3psi10CdSalcListE {lvalue}); | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi10CdSalcListE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,j); | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None :; | ; | C++ signature :; | void __init__(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:416922,inherit,inherited,416922,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"hon.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudospectralInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | PseudospectralInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = psi4.PsiReturnType.Balk; | ; | EndLoop = psi4.PsiReturnType.EndLoop; | ; | Fai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:113810,inherit,inherited,113810,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"hroughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:; 1; 2; 3std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso)); // Type information written down 3 TIMES!!!; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!!!!. Ensures exception safety and prevents resource leaks. Improves efficiency:; 1; 2; 3; 4// Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));; // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:; 1; 2std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. «; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/style_c-1.html:1519,variab,variable,1519,psi4manual/1.2.1/style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/style_c-1.html,2,['variab'],['variable']
Modifiability,"i(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. ndet(self); docstring. new_civector(self, arg0, arg1, arg2, arg3); docstring. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. opdm(self, arg0, arg1, arg2, arg3); docstring. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since vers",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:6711,variab,variables,6711,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variables']
Modifiability,"i4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 gcc; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc. # create and compile plugin; >>> psi4 --new",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3871,plugin,plugins,3871,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"i4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3536,plugin,plugins,3536,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"i4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». Geometry Optimization, optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry projection module. optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimiz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:1053,variab,variables,1053,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['variab'],['variables']
Modifiability,"i4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build. Installing from Binary; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/external-1.html:2197,config,configure,2197,psi4manual/1.3.2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/external-1.html,24,['config'],['configure']
Modifiability,"i4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to gau2grid by D. G. A. Smith. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gau2grid.html:1887,variab,variable,1887,psi4manual/1.7.x/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gau2grid.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"i4.Wavefunction.sobasisset()¶; Python Library Documentation: method sobasisset; sobasisset(...) unbound psi4.Wavefunction method. sobasisset( (Wavefunction)arg1) -> SOBasisSet :. docstring; C++ signature :. N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}). psi4.Wavefunction.soccpi()¶; Python Library Documentation: method soccpi; soccpi(...) unbound psi4.Wavefunction method. soccpi( (Wavefunction)arg1) -> Dimension :. docstring; C++ signature :. N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}). matrix_vector¶. psi4.matrix_vector.append()¶; Python Library Documentation: method append; append(...) unbound psi4.matrix_vector method. append( (matrix_vector)arg1, (object)arg2) -> None :. C++ signature :. void append(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE). psi4.matrix_vector.extend()¶; Python Library Documentation: method extend; extend(...) unbound psi4.matrix_vector method. extend( (matrix_vector)arg1, (object)arg2) -> None :. C++ signature :. void extend(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE). vector_of_doubles¶. psi4.vector_of_doubles.append()¶; Python Library Documentation: method append; append(...) unbound psi4.vector_of_doubles method. append( (vector_of_doubles)arg1, (object)arg2) -> None :. C++ signature :. void append(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE). psi4.vector_of_doubles.extend()¶; Python Library Documentation: method extend; extend(...) unbound psi4.vector_of_doubles method. extend( (vector_of_doubles)arg1, (object)arg2) -> None :. C++ signature :. void extend(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE). Full Docs Output¶; Python Library Documentation: built-in module psi4. NAME; psi4. FILE; (built-in). CLASSES; Boost.Python.enum(__builtin__.int); DiagonalizeOrder; GeometryUnits; PsiReturnType; Boost.Python.instance(__builtin__.object); AOShellCombinationsIterator; BasisSet; BasisSetP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:369539,extend,extend,369539,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['extend'],['extend']
Modifiability,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1811,extend,extend,1811,psi4manual/1.8.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html,3,"['Extend', 'extend']","['Extend', 'extend']"
Modifiability,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:1811,extend,extend,1811,psi4manual/1.9.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html,3,"['Extend', 'extend']","['Extend', 'extend']"
Modifiability,i4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method. plot() psi4.core.FISAPT method. plugin. ; v2rdm_casscf. plugin() in module psi4.core. plugin_close() in module psi4.core. plugin_close_all() in module psi4.core. plugin_load() in module psi4.core. PMLocalizer class in psi4.core. PNO_CONVERGENCE (DLPNO). point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMM method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.cor,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:104931,plugin,plugin,104931,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['plugin'],['plugin']
Modifiability,i4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method. plot() psi4.core.FISAPT method. plugin. ; v2rdm_casscf. plugin() in module psi4.core. plugin_close() in module psi4.core. plugin_close_all() in module psi4.core. plugin_load() in module psi4.core. PMLocalizer class in psi4.core. point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMM method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.R,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:103642,plugin,plugin,103642,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['plugin'],['plugin']
Modifiability,"i4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension; docstring. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_opdm(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: str, arg3: bool) → psi4.core.Matrix; docstring. get_orbitals(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Matrix; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_tpdm(self: psi4.core.CIWavefunction, arg0: str, arg1: bool) → psi4.core.Matrix; docstring. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix; docstring. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.ciwavefunction.html:10580,variab,variable,10580,psi4manual/1.2.1/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"i4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:21937,variab,variable,21937,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"i4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; docstring. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:26196,variab,variable,26196,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"i4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. module(self: psi4.core.Wavefunction) → str¶; Name of the last/highest level of theory module (internal or external)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:18236,variab,variable,18236,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"i4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:131969,variab,variables,131969,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['variab'],['variables']
Modifiability,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32275,variab,variables,32275,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_deriv(self:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:170518,variab,variables,170518,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, arg3: int) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList object used in creating this SO basis. class psi4.core.S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:183288,variab,variables,183288,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_deriv(self:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:206592,variab,variables,206592,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the file, if necessary. set_default_namespace(ns: str) → None¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:80409,variab,variables,80409,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"i4.core.Wavefunction) → int¶; Number of irreps in the system. nmo(self: psi4.core.Wavefunction) → int¶; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. occupation_a(self: psi4.core.HF) → psi4.core.Vector¶; Returns the Alpha occupation numbers. occupation_b(self: psi4.core.HF) → psi4.core.Vector¶; Returns the Beta occupation numbers. onel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; One-electron Hessian-vector products. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_energies()¶. print_header(self: psi4.core.HF) → None¶; docstring. print_orbitals(self: psi4.core.HF) → None¶; docstring. print_preiterations(small=False)¶. push_back_external_potential(self: psi4.core.HF, V: psi4.core.Matrix) → None¶; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:27224,variab,variable,27224,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"i4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:24592,variab,variable,24592,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"i4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (str) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requeste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:24594,variab,variable,24594,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"i4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21934,variab,variables,21934,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"i4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:21662,variab,variables,21662,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variables']
Modifiability,"i4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:21754,variab,variables,21754,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"i4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.fisapt(arg0: psi::Wavefunction) → float¶; Runs the functional-group intramolecular symmetry adapted perturbation theory code. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:148714,adapt,adapted,148714,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,i4.driver.p4util). PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() (psi4.core.MintsHelper method). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() (psi4.core.MintsHelper method). (psi4.core.SOBasisSet method). petite_list1() (psi4.core.MintsHelper method). PetiteList (class in psi4.core). PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() (psi4.core.CIWavefunction method). pitzer_to_ci_order_twoel() (psi4.core.CIWavefunction method). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). plan() (psi4.driver.AtomicComputer method). (psi4.driver.driver_cbs.CompositeComputer method). (psi4.driver.driver_findif.FiniteDifferenceComputer method). (psi4.driver.driver_nbody.ManyBodyComputer method). (psi4.driver.task_base.BaseComputer method). play() (psi4.core.MintsHelper method). plugin. ; v2rdm_casscf. plugin() (in module psi4.core). plugin_close() (in module psi4.core). plugin_close_all() (in module psi4.core). plugin_load() (in module psi4.core). plump_qcvar() (in module psi4.driver.p4util). PMLocalizer (class in psi4.core). PNO_CONVERGENCE (DLPNO). point_group() (psi4.core.Molecule method). point_values() (psi4.core.PointFunctions method). PointFunctions (class in psi4.core). PointGroup (class in psi4.core). POINTS (FINDIF). pop() (psi4.core.BSVec method). populateExtern() (psi4.driver.QMMMbohr method). position_camera() (psi4.driver.p4util.InPsight method). potential_grad() (psi4.core.MintsHelper method). potential_integral() (psi4.core.NumIntHelper method). potential_variable() (psi4.core.Wavefunction method). potential_variables() (psi4.core.Wavefunction method). PotentialInt (class in psi4.core). POTFILE (PE). power() (psi4.core.Matrix method). PPL_TYPE (DFOCC). precondition() (psi4.driver.p4util.SolverEngine method). PRECONDITIONER (DETCI). prefactor_ecd(,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:90238,plugin,plugin,90238,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['plugin'],['plugin']
Modifiability,"i4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:25022,variab,variable,25022,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['variab'],['variable']
Modifiability,"i4/share/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:2484,variab,variable,2484,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['variab'],['variable']
Modifiability,"i4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is made, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, Psi4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; Psi4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, Psi4 will complain.; >>> psi4 --new-plugin myplugin. Psi4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; Psi4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:2241,plugin,plugin,2241,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"iMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.set_global_option('SCF_TYPE', 'DF'); energy('scf', **kwargs). PsiMod.set_global_option('dft_functional', 'wB97'); PsiMod.set_global_option('dft_order_spherical', 25); PsiMod.set_global_option('dft_num_radial', 35); PsiMod.set_global_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:4036,plugin,plugins,4036,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,2,['plugin'],['plugins']
Modifiability,"iable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32376,variab,variables,32376,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"iable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. version",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45718,variab,variable,45718,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"iable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85313,variab,variable,85313,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"iable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:37004,variab,variable,37004,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"iable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29469,variab,variable,29469,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"iable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28794,variab,variable,28794,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"iable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the dou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:7420,plugin,plugin,7420,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['plugin'],['plugin']
Modifiability,"iable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:7418,plugin,plugin,7418,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['plugin'],['plugin']
Modifiability,"iables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_array` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only).""). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.arrays"", ""psi4.core.Wavefunction.variables"", 1.9, f"" Replace `psi4.core.Wavefunction.arrays` with `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only).""). core.Wavefunction.get_variable = _core_wavefunction_get_variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:47477,variab,variables,47477,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"iables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_array` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only).""). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.arrays"", ""psi4.core.Wavefunction.variables"", 1.9, f"" Replace `psi4.core.Wavefunction.arrays` with `psi4.core.Wavefunction.variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:47322,variab,variable,47322,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:2925,variab,variable,2925,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,1,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:37280,variab,variable,37280,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html:2920,variab,variable,2920,psi4manual/1.3.2/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html,1,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:196587,variab,variable,196587,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html:3175,variab,variable,3175,psi4manual/1.3.2/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html,1,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:214177,variab,variable,214177,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html:2920,variab,variable,2920,psi4manual/1.3.2/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html,1,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:243344,variab,variable,243344,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ial + Kinetic) Integrals. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:95760,variab,variable,95760,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ial. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:4323,variab,variable,4323,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"ial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. diis_enabled_¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. diis_start_¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:5606,variab,variable,5606,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,14,['variab'],['variable']
