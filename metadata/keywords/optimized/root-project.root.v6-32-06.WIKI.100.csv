quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"xx:3699; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or Pad ""pad"" (default). The viewer is created via the plugin manager, attached to pad, and the interface returned. Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g. v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();; The BeginScene call will cause the viewer to suspend redraws etc, and after the EndScene the viewer will reset the camera to frame the new scene and redraw. [x3d viewer does not support changing of scenes - objects added after the first Open/CloseScene pair will be ignored.]. Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some need the 3D object positions in the global frame, others can cope with local frames + a translation matrix - which can give considerable performance benefits. To cope with these situations the object buffer is filled out in negotiation with the viewer. TBuffer3D classes are conceptually divided into enumerated sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw) are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section in derived shape specific classes allows a more abstract shape description (""a sphere of inner radius x, outer radius y""). This enables a viewer which knows how to draw (tessellate) the shape itself to do so, which can bring considerable performance and quality benefits, while providing a generic fallback suitable for all viewers.; The rules for client negotiation with the view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:2991,perform,performance,2991,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['perform'],['performance']
Performance,"xx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8C.html:7007,optimiz,optimization,7007,doc/master/rf603__multicpu_8C.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html,1,['optimiz'],['optimization']
Performance,"xx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Types::kFDA@ kFDADefinition Types.h:92; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kPDEFoam@ kPDEFoamDefinition Types.h:94; TMVA::Types::kMLP@ kMLPDefinition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:40130,load,loader,40130,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,2,['load'],['loader']
Performance,"xxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g.; v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();>; The BeginScene call will cause the viewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:2872,perform,performance,2872,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['perform'],['performance']
Performance,"xy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:72211,cache,cache,72211,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"xy > p)Definition TTreeReader.h:281; TTreeReader::EEntryStatusEEntryStatusDefinition TTreeReader.h:152; TTreeReader::kEntryNotFound@ kEntryNotFoundthe tree entry number does not existDefinition TTreeReader.h:156; TTreeReader::kIndexedFriendNoMatch@ kIndexedFriendNoMatchA friend with TTreeIndex doesn't have an entry for this index.Definition TTreeReader.h:162; TTreeReader::kEntryUnknownError@ kEntryUnknownErrorLoadTree return less than -6, likely a 'newer' error code.Definition TTreeReader.h:164; TTreeReader::kEntryDictionaryError@ kEntryDictionaryErrorproblem reading dictionary info from treeDefinition TTreeReader.h:159; TTreeReader::kEntryChainSetupError@ kEntryChainSetupErrorproblem in accessing a chain element, e.g. file without the treeDefinition TTreeReader.h:157; TTreeReader::kMissingBranchWhenSwitchingTree@ kMissingBranchWhenSwitchingTreeA branch was not found when switching to the next TTree in the chain.Definition TTreeReader.h:163; TTreeReader::kEntryNotLoaded@ kEntryNotLoadedno entry has been loaded yetDefinition TTreeReader.h:154; TTreeReader::kEntryBeyondEnd@ kEntryBeyondEndlast entry loop has reached its endDefinition TTreeReader.h:160; TTreeReader::kEntryChainFileError@ kEntryChainFileErrorproblem in opening a chain's fileDefinition TTreeReader.h:158; TTreeReader::kEntryNoTree@ kEntryNoTreethe tree does not existDefinition TTreeReader.h:155; TTreeReader::kEntryBadReader@ kEntryBadReaderOne of the readers was not successfully initialized.Definition TTreeReader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if during the LoadTree execution triggered by SetEntryBase.Definition TTreeReader.h:338; TTreeReader::fValuesstd::deque< ROOT::Internal::TTreeReaderValueBase * > fValuesreaders that use our directorDefinition TTreeReader.h:327; TTreeReader::RegisterValueReaderbool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase *reader)Add a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:21866,load,loaded,21866,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['load'],['loaded']
Performance,"xyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumCdf.h>. Inheritance diagram for RooNumCdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNumCdf() [1/2]. RooNumCdf::RooNumCdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf, . RooRealVar & ; _x, . const char * ; bname = ""cache"" . ). Construct a cumulative distribution function from given input p.d.f over observable x. ; using a numeric sampling algorithm. Use binning named 'bname' to control sampling granularity ; Definition at line 44 of file RooNumCdf.cxx. ◆ RooNumCdf() [2/2]. RooNumCdf::RooNumCdf ; (; const RooNumCdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 20 of file RooNumCdf.h. Member Function Documentation. ◆ Class(). static TClass * RooNumCdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumCdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumCdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 29 of file RooNumCdf.h. ◆ clone(). TObject * RooNumCdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 21 of file RooNumCdf.h. ◆ DeclFileNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:64076,cache,cache,64076,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Sep 23 20:00:25 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumRunningInt.html:35265,cache,cached,35265,root/html528/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html528/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 30 14:34:41 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:39896,cache,cached,39896,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Mar 10 17:18:18 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumRunningInt.html:38392,cache,cached,38392,root/html534/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html534/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:57832,cache,cache,57832,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['cache'],['cache']
Performance,"y (including subdirectories). A new key is created in the KEYS linked list for each object. The list of keys is then saved on the file (via WriteKeys) as a single data record. For values of opt see TObject::Write(). The directory header info is rewritten on the directory header record. The linked list of FREE segments is written. The file header is written (bytes 1->fBEGIN). ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, TXMLFile, and TParallelMergingFile.; Definition at line 2436 of file TFile.cxx. ◆ WriteBuffer(). Bool_t TFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). virtual . Write a buffer to the file. ; This is the basic low level write operation. Returns kTRUE in case of failure. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, TNetFile, TDavixFile, TXNetFile, and TNetXNGFile.; Definition at line 2476 of file TFile.cxx. ◆ WriteBufferViaCache(). Int_t TFile::WriteBufferViaCache ; (; const char * ; buf, . Int_t ; len . ). protected . Write buffer via cache. ; Returns 0 if cache is not active, 1 in case write via cache was successful, 2 in case write via cache failed. ; Definition at line 2519 of file TFile.cxx. ◆ WriteFree(). void TFile::WriteFree ; (; ). virtual . Write FREE linked list on the file. ; The linked list of FREE segments (fFree) is written as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2543 of file TFile.cxx. ◆ WriteHeader(). void TFile::WriteHeader ; (; ). virtual . Write File Header. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2615 of file TFile.cxx. ◆ WriteProcessID(). UShort_t TFile::WriteProcessID ; (; TProcessID * ; pid). virtual . Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the local file list. ; Definition at line 3763 of file TFile.cxx. ◆ WriteStreamerInfo(). void TFile::WriteStreamerInfo ; (; ). virtual . Write the list of TStreamerInfo as a single object in this file The class Streamer des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:101326,cache,cache,101326,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance,"y *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477730,optimiz,optimization,477730,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,"y = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions;  RooChi2Var (const char *name, const char *title, RooAbsReal &func, RooDataHist &data, const RooArgSet &projDeps, FuncMode funcMode, RooAbsTestStatistic::Configuration const &cfg, RooDataHist::ErrorType etype);  . Additional Inherited Members;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:65528,cache,cache,65528,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"y = kFALSE) const; Bool_tisSelectedComp() const; virtual Bool_tisValid() const; virtual Bool_tisValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidplotOnCompSelect(RooArgSet* selNodes) const; RooPlot*plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tplotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidselectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:28126,optimiz,optimizeDirtyHook,28126,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"y = kFALSE) const; Bool_tisSelectedComp() const; virtual Bool_tisValid() const; virtual Bool_tisValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tplotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidselectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:25832,optimiz,optimizeDirtyHook,25832,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"y GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:34503,load,loaded,34503,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['load'],['loaded']
Performance,"y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplot6.py Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplotOld.CExample displaying two histograms and their ratio ;  rebin.C Rebin a variable bin-width histogram ;  reverseaxis.C Example showing an histogram with reverse axis ;  sparsehist.CEvaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C Different charges depending on region ;  tprofile2polyRealisticModuleErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:124582,perform,performance,124582,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['perform'],['performance']
Performance,"y cheap to copy and it's possible to both pass them to (or move them into) functions and to return them from functions. However, in general each dataframe node will have a different C++ type, which includes all available compile-time information about what that node does. One way to cope with this complication is to use template functions and/or C++14 auto return types: template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode: // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:59335,perform,performance,59335,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['performance']
Performance,"y corresponding to major and minor number.Definition TTree.cxx:5927; TTree::MergeTreesstatic TTree * MergeTrees(TList *list, Option_t *option="""")Static function merging the trees in the TList into a new tree.Definition TTree.cxx:6851; TTree::MemoryFullbool MemoryFull(Int_t nbytes)Check if adding nbytes to memory we are still below MaxVirtualsize.Definition TTree.cxx:6837; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:454190,load,loading,454190,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loading']
Performance,"y from the file to memory.Definition TChain.cxx:1002; TChain::SetPacketSizevirtual void SetPacketSize(Int_t size=100)Set number of entries per packet for parallel root.Definition TChain.cxx:2991; TChain::fTreeNumberInt_t fTreeNumber! Current Tree number in fTreeOffset tableDefinition TChain.h:38; TChain::Lookupvoid Lookup(bool force=false)Check / locate the files in the chain.Definition TChain.cxx:1760; TChain::GetLeafTLeaf * GetLeaf(const char *branchname, const char *leafname) overrideReturn a pointer to the leaf name in the current tree.Definition TChain.cxx:1078; TChain::kProofLite@ kProofLiteDefinition TChain.h:64; TChain::kAutoDelete@ kAutoDeleteDefinition TChain.h:62; TChain::kProofUptodate@ kProofUptodateDefinition TChain.h:63; TChain::kGlobalWeight@ kGlobalWeightDefinition TChain.h:61; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetListvirtual TList * GetList() constDefinition TDirectory.h:222; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:131641,load,load,131641,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['load']
Performance,"y loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we request the loading; 1507 // here *or* the user explicitly instantiate the template; 1508 // we would not have a ClassInfo for the template; 1509 // instantiation.; 1510 fCanLoadClassInfo = kTRUE;; 1511 // Here we check and grab the info from the rootpcm.; 1512 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 1513 if (proto); 1514 proto->FillTClass(this);; 1515 }; 1516 if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {; 1517 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1518 if (fClassInfo) {; 1519 // This should be moved out of GetCheckSum itself however the last time; 1520 // we tried this cause problem, in particular in the end-of-process operation.; 1521 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1522 } else {; 1523 if (!fClassInfo) {; 1524 if (IsZombie()) {; 1525 TClass::RemoveClass(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:58205,load,loading,58205,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"y loaded; 1554 if (fState <= kEmulated); 1555 fState = kInterpreted;; 1556 }; 1557 }; 1558 ; 1559 // We need to check if the class it is not fwd declared for the cases where we; 1560 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1561 // fClassInfo will always be nullptr.; 1562 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1563 ; 1564 if (fState == kHasTClassInit) {; 1565 // If the TClass is being generated from a ROOT dictionary,; 1566 // even though we do not seem to have a CINT dictionary for; 1567 // the class, we will will try to load it anyway UNLESS; 1568 // the class is an STL container (or string).; 1569 // This is because we do not expect the CINT dictionary; 1570 // to be present for all STL classes (and we can handle; 1571 // the lack of CINT dictionary in that cases).; 1572 // However, the cling the dictionary no longer carries; 1573 // an instantiation with it, unless we request the loading; 1574 // here *or* the user explicitly instantiate the template; 1575 // we would not have a ClassInfo for the template; 1576 // instantiation.; 1577 fCanLoadClassInfo = kTRUE;; 1578 // Here we check and grab the info from the rootpcm.; 1579 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 1580 if (proto); 1581 proto->FillTClass(this);; 1582 }; 1583 if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {; 1584 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1585 if (fClassInfo) {; 1586 // This should be moved out of GetCheckSum itself however the last time; 1587 // we tried this cause problem, in particular in the end-of-process operation.; 1588 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1589 } else {; 1590 if (!fClassInfo) {; 1591 if (IsZombie()) {; 1592 TClass::RemoveClass(this);; 1593 return;; 1594 }; 1595 }; 1596 }; 1597 }; 1598 }; 1599 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:60956,load,loading,60956,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"y must be dimensioned to the size of the existing parameters) ;  ; const ROOT::Minuit2::MnUserParameterState & State ();  return the minimizer state (containing values, step size , etc..) ;  ; int VariableIndex (const std::string &name) const override;  get index of variable given a variable given a name return -1 if variable is not found ;  ; std::string VariableName (unsigned int ivar) const override;  get name of variables (override if minimizer support storing of variable names) ;  ; const double * X () const override;  return pointer to X values at the minimum ;  ;  Public Member Functions inherited from ROOT::Math::Minimizer;  Minimizer ();  Default constructor. ;  ;  Minimizer (Minimizer &&)=delete;  ;  Minimizer (Minimizer const &)=delete;  ; virtual ~Minimizer ();  Destructor (no operations). ;  ; double ErrorDef () const;  return the statistical scale used for calculate the error is typically 1 for Chi2 and 0.5 for likelihood minimization ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; void SetDefaultOptions ();  reset the default options (defined in MinimizerOptions) ;  ; void SetErrorDef (double up);  set scale for calculating the errors ;  ; void SetExtraOptions (const IOptions &extraOptions);  set o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:8686,perform,performed,8686,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['perform'],['performed']
Performance,"y of simultaneous PDF; ConditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const char *name, const char *title, RooAbsReal& func, RooDataHist& hdata,		 const RooArgSet& projDeps, RooChi2Var::FuncMode fmode, const char* cutRange, const char* addCoefRange, 		 Int_t nCPU, Bool_t interleave, Bool_t verbose, Bool_t splitCutRange, RooDataHist::ErrorType etype); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:39360,load,load,39360,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,1,['load'],['load']
Performance,"y of simultaneous PDF; ConditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooArgSet& projDeps, RooChi2Var::FuncMode funcMode, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpreta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:39944,load,load,39944,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,3,['load'],['load']
Performance,"y owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. The proxied argument is also added as value and/or shape server ; Definition at line 1329 of file RooAbsArg.cxx. ◆ registerProxy() [2/3]. void RooAbsArg::registerProxy ; (; RooListProxy & ; proxy). protected . Register an RooListProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1408 of file RooAbsArg.cxx. ◆ registerProxy() [3/3]. void RooAbsArg::registerProxy ; (; RooSetProxy & ; proxy). protected . Register an RooSetProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1373 of file RooAbsArg.cxx. ◆ removeServer(). void RooAbsArg::removeServer ; (; RooAbsArg & ; server, . bool ; force = false . ). Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ; Definition at line 378 of file RooAbsArg.cxx. ◆ removeStringAttribute(). void RooAbsArg::removeStringAttribute ; (; const Text_t * ; key). Delete a string attribute with a given key. ; Definition at line 266 of file RooAbsArg.cxx. ◆ replaceServer(). void RooAbsArg::replaceServer ; (; RooAbsArg & ; oldServer, . RooAbsArg & ; newServer, . bool ; propValue, . bool ; propShape . ). Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ; WarningThis function should not be used! This method is quite unsafe for many reasons. For once, the new server will be put at the end of the server list, no matt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:93516,cache,cached,93516,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"y this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void SetCacheSize(Long64_t cacheSize); Set the cache size of the underlying TTree,; See TTree::SetCacheSize. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char *bname, void* add, TBranch** ptr); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:50756,cache,cacheSize,50756,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"y to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  ►CRooNumRunningIntClass RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral ; \[ RI(f(x)) = \int_{xlow}^{x} f(x') dx' \]. that is calculated internally with a numeric technique: The input function is first sampled into a histogram, which is then numerically integrated ;  CRICacheElem;  CRooObjCacheManagerClass RooObjCacheManager is an implementation of class RooCacheManager<RooAbsCacheElement> and specializes in the storage of cache elements that contain RooAbsArg objects ;  CRooParamBinningClass RooParamBinning is an implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects ;  CRooParametricStepFunction;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ; \[ f(x) = \sum_{i} a_{i} * x^i \]. By default coefficient a_0 is chosen to be 1, as polynomial probability density functions have one degree of freedome less than polynomial functions due to the normalization condition ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ; \[f(x) = \sum_{i} a_{i}x \]. Class RooPolyvar implements analytical integrals of all polynomials it can define ;  CRooPrintableRooPlotable is a 'mix-in' base class that d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:98966,cache,cache,98966,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['cache'],['cache']
Performance,"y used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:30294,optimiz,optimize,30294,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,5,['optimiz'],['optimize']
Performance,"y with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const ROOT::Fit::FitResult& ). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:5315,perform,performed,5315,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['perform'],['performed']
Performance,"y(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the internal type of fMethod and thus can not be made public.; 4353/// It also never 'loads' the content of the list.; 4354 ; 4355TListOfFunctions *TClass::GetMethodList(); 4356{; 4357 if (!fMethod.load()) {; 4358 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4359 TListOfFunctions* expected = nullptr;; 4360 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4361 temp.release();; 4362 }; 4363 }; 4364 return fMethod;; 4365}; 4366 ; 4367 ; 4368////////////////////////////////////////////////////////////////////////////////; 4369/// Return pointer to method without looking at parameters.; 4370/// Does not look in (possible) base classes.; 4371/// Has the side effect of loading all the TMethod object in the list; 4372/// of the class.; 4373 ; 4374TMethod *TClass::GetMethodAny(const char *method); 4375{; 4376 if (!HasInterpreterInfo()) return nullptr;; 4377 return (TMethod*) GetMethodList()->FindObject(method);; 4378}; 4379 ; 4380////////////////////////////////////////////////////////////////////////////////; 4381/// Return pointer to method without looking at parameters.; 4382/// Does look in all base classes.; 4383 ; 4384TMethod *TClass::GetMethodAllAny(const char *method); 4385{; 4386 if (!HasInterpreterInfo()) return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:164840,load,load,164840,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"y(""TClass::Move"",arenaFrom,arenaTo,this);; 4402 }; 4403}; 4404 ; 4405////////////////////////////////////////////////////////////////////////////////; 4406/// Return the list of menu items associated with the class.; 4407 ; 4408TList *TClass::GetMenuList() const {; 4409 if (!fClassMenuList) {; 4410 fClassMenuList = new TList();; 4411 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4412 }; 4413 return fClassMenuList;; 4414}; 4415 ; 4416////////////////////////////////////////////////////////////////////////////////; 4417/// Return (create an empty one if needed) the list of functions.; 4418/// The major difference with GetListOfMethod is that this returns; 4419/// the internal type of fMethod and thus can not be made public.; 4420/// It also never 'loads' the content of the list.; 4421 ; 4422TListOfFunctions *TClass::GetMethodList(); 4423{; 4424 if (!fMethod.load()) {; 4425 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4426 TListOfFunctions* expected = nullptr;; 4427 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4428 temp.release();; 4429 }; 4430 }; 4431 return fMethod;; 4432}; 4433 ; 4434 ; 4435////////////////////////////////////////////////////////////////////////////////; 4436/// Return pointer to method without looking at parameters.; 4437/// Does not look in (possible) base classes.; 4438/// Has the side effect of loading all the TMethod object in the list; 4439/// of the class.; 4440 ; 4441TMethod *TClass::GetMethodAny(const char *method); 4442{; 4443 if (!HasInterpreterInfo()) return nullptr;; 4444 return (TMethod*) GetMethodList()->FindObject(method);; 4445}; 4446 ; 4447////////////////////////////////////////////////////////////////////////////////; 4448/// Return pointer to method without looking at parameters.; 4449/// Does look in all base classes.; 4450 ; 4451TMethod *TClass::GetMethodAllAny(const char *method); 4452{; 4453 if (!HasInterpreterInfo()) return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:167591,load,load,167591,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"y(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:1505,load,load,1505,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['load'],['load']
Performance,"y() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:26493,cache,cache,26493,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,3,['cache'],['cache']
Performance,"y(). Int_t TBufferIO::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; This function assumes that the value in 'obj' is the value stored in a pointer to a ""ptrClass"". The actual type of the object pointed to can be any class derived from ""ptrClass"". Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). If 'cacheReuse' is true (default) upon seeing an object address a second time, we record the offset where its was written the first time rather than streaming the object a second time. If 'cacheReuse' is false, we always stream the object. This allows the (re)use of temporary object to store different data in the same buffer. ; Implements TBuffer.; Definition at line 492 of file TBufferIO.cxx. ◆ WriteObjectClass(). virtual void TBufferIO::WriteObjectClass ; (; const void * ; actualObjStart, . const TClass * ; actualClass, . Bool_t ; cacheReuse . ). protectedpure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ WriteProcessID(). UShort_t TBufferIO::WriteProcessID ; (; TProcessID * ; pid). overridevirtual . Check if the ProcessID pid is already in the file. ; If not, add it and return the index number in the local file list. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 456 of file TBufferIO.cxx. Member Data Documentation. ◆ fClassMap. TExMap* TBufferIO::fClassMap {nullptr}. protected . Map containing object,class pairs for reading. ; Definition at line 40 of file TBufferIO.h. ◆ fDisplacement. Int_t TBufferIO::fDisplacement {0}. protected . Value to be added to the map offsets. ; Definition at line 37 of file TBufferIO.h. ◆ fgMapSize. Int_t TBufferIO::fgMapSize = kMapSize. staticprotected . Default map size for all TBuffer objects. ; Definition at line 42 of file TBufferIO.h. ◆ fMap. TExMap* TBufferIO::fMap {nullptr}. protected . Map containing object,offset pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:43762,cache,cacheReuse,43762,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance,"y(void *dirp); 1405{; 1406 TSystem *helper = FindHelper(nullptr, dirp);; 1407 if (helper) {; 1408 helper->FreeDirectory(dirp);; 1409 return;; 1410 }; 1411 ; 1412 if (dirp); 1413 ::closedir((DIR*)dirp);; 1414}; 1415 ; 1416////////////////////////////////////////////////////////////////////////////////; 1417/// Get next Unix file system directory entry. Returns 0 if no more entries.; 1418 ; 1419const char *TUnixSystem::GetDirEntry(void *dirp); 1420{; 1421 TSystem *helper = FindHelper(nullptr, dirp);; 1422 if (helper); 1423 return helper->GetDirEntry(dirp);; 1424 ; 1425 if (dirp); 1426 return UnixGetdirentry(dirp);; 1427 ; 1428 return nullptr;; 1429}; 1430 ; 1431////////////////////////////////////////////////////////////////////////////////; 1432/// Change directory. Returns kTRUE in case of success, kFALSE otherwise.; 1433 ; 1434Bool_t TUnixSystem::ChangeDirectory(const char *path); 1435{; 1436 Bool_t ret = (Bool_t) (::chdir(path) == 0);; 1437 if (fWdpath != """"); 1438 fWdpath = """"; // invalidate path cache; 1439 return ret;; 1440}; 1441 ; 1442////////////////////////////////////////////////////////////////////////////////; 1443/// Return working directory.; 1444 ; 1445const char *TUnixSystem::WorkingDirectory(); 1446{; 1447 // don't use cache as user can call chdir() directly somewhere else; 1448 //if (fWdpath != """"); 1449 // return fWdpath.Data();; 1450 ; 1451 R__LOCKGUARD2(gSystemMutex);; 1452 ; 1453 static char cwd[kMAXPATHLEN];; 1454 FillWithCwd(cwd);; 1455 fWdpath = cwd;; 1456 ; 1457 return fWdpath.Data();; 1458}; 1459 ; 1460//////////////////////////////////////////////////////////////////////////////; 1461/// Return working directory.; 1462 ; 1463std::string TUnixSystem::GetWorkingDirectory() const; 1464{; 1465 char cwd[kMAXPATHLEN];; 1466 FillWithCwd(cwd);; 1467 return std::string(cwd);; 1468}; 1469 ; 1470//////////////////////////////////////////////////////////////////////////////; 1471/// Fill buffer with current working directory.; 1472 ; 1473void TUnixSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:43653,cache,cache,43653,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['cache'],['cache']
Performance,"y(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenCategory.html:15583,cache,cache,15583,root/html526/RooGenCategory.html,https://root.cern,https://root.cern/root/html526/RooGenCategory.html,4,['cache'],['cache']
Performance,"y, RooLognormal, RooMomentMorph, RooNDKeysPdf, RooNonCPEigenDecay, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooPowerSum, RooTFnPdfBinding, RooUniform, RooVoigtian, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooCachedPdf, RooEfficiency, RooEffProd, RooExtendedTerm, RooExtendPdf, RooFFTConvPdf, RooGenericPdf, RooHistPdf, RooMultiVarGaussian, RooNumConvPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooResolutionModel, RooSimultaneous, RooTruthModel, RooWrapperPdf, and RooNonCentralChiSquare. ◆ StreamerNVirtual(). void RooAbsPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 351 of file RooAbsPdf.h. ◆ syncNormalization(). bool RooAbsPdf::syncNormalization ; (; const RooArgSet * ; nset, . bool ; adjustProxies = true . ); const. protectedvirtual . Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ; If not, the cached normalization integral (if any) is deleted and a new integral is constructed for use with 'nset'. Elements in 'nset' can be discrete and real, but must be lvalues.; For functions that declare to be self-normalized by overloading the selfNormalized() function, a unit normalization is always constructed. ; Definition at line 481 of file RooAbsPdf.cxx. ◆ traceEvalPdf(). bool RooAbsPdf::traceEvalPdf ; (; double ; value); const. private . Check that passed value is positive and not 'not-a-number'. ; If not, print an error, until the error counter reaches its set maximum. ; Definition at line 384 of file RooAbsPdf.cxx. ◆ verboseEval() [1/2]. Int_t RooAbsPdf::verboseEval ; (; ). static . Return global level of verbosity for p.d.f. evaluations. ; Definition at line 2418 of file RooAbsPdf.cxx. ◆ verboseEval() [2/2]. void RooAbsPdf::verboseEval ; (; Int_t ; stat). static . Change global level of verbosity for p.d.f. evaluations. ; Definition at line 2408 of file RooAbsPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAbsReal. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:156214,cache,cached,156214,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['cache'],['cached']
Performance,"y, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063961,perform,performance,1063961,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"y, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22462,load,loaded,22462,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"y->Remove(this);; 3803 //delete the file cache if it points to this Tree; 3804 MoveReadCache(file,nullptr);; 3805 fDirectory = nullptr;; 3806 ResetBit(kMustCleanup);; 3807 }; 3808 ; 3809 // Delete object from CINT symbol table so it can not be used anymore.; 3810 gCling->DeleteGlobal(this);; 3811 ; 3812 // Warning: We have intentional invalidated this object while inside a member function!; 3813 delete this;; 3814}; 3815 ; 3816 ///////////////////////////////////////////////////////////////////////////////; 3817 /// Called by TKey and TObject::Clone to automatically add us to a directory; 3818 /// when we are read from a file.; 3819 ; 3820void TTree::DirectoryAutoAdd(TDirectory* dir); 3821{; 3822 if (fDirectory == dir) return;; 3823 if (fDirectory) {; 3824 fDirectory->Remove(this);; 3825 // Delete or move the file cache if it points to this Tree; 3826 TFile *file = fDirectory->GetFile();; 3827 MoveReadCache(file,dir);; 3828 }; 3829 fDirectory = dir;; 3830 TBranch* b = nullptr;; 3831 TIter next(GetListOfBranches());; 3832 while((b = (TBranch*) next())) {; 3833 b->UpdateFile();; 3834 }; 3835 if (fBranchRef) {; 3836 fBranchRef->UpdateFile();; 3837 }; 3838 if (fDirectory) fDirectory->Append(this);; 3839}; 3840 ; 3841////////////////////////////////////////////////////////////////////////////////; 3842/// Draw expression varexp for specified entries.; 3843///; 3844/// \return -1 in case of error or number of selected events in case of success.; 3845///; 3846/// This function accepts TCut objects as arguments.; 3847/// Useful to use the string operator +; 3848///; 3849/// Example:; 3850///; 3851/// ~~~ {.cpp}; 3852/// ntuple.Draw(""x"",cut1+cut2+cut3);; 3853/// ~~~; 3854 ; 3855 ; 3856Long64_t TTree::Draw(const char* varexp, const TCut& selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 3857{; 3858 return TTree::Draw(varexp, selection.GetTitle(), option, nentries, firstentry);; 3859}; 3860 ; 3861//////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:150444,cache,cache,150444,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"y. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The prot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:26966,load,load,26966,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"y::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFile.html:13703,cache,cache,13703,root/html532/TNetFile.html,https://root.cern,https://root.cern/root/html532/TNetFile.html,2,['cache'],['cache']
Performance,"y::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:13782,cache,cache,13782,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,6,['cache'],['cache']
Performance,"yBase. ;  ; std::vector< std::string > fSuppressErrorsForMissingBranches {};  ; TTree * fTree = nullptr;  tree that's read ;  ; std::deque< ROOT::Internal::TTreeReaderValueBase * > fValues;  readers that use our director ;  ; bool fWarnAboutLongerFriends {true};  . Friends; class ROOT::Internal::TTreeReaderArrayBase;  ; class ROOT::Internal::TTreeReaderValueBase;  . #include <TTreeReader.h>. Inheritance diagram for TTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ iterator. typedef Iterator_t TTreeReader::iterator. Definition at line 150 of file TTreeReader.h. ◆ NamedProxies_t. using TTreeReader::NamedProxies_t = std::unordered_map<std::string, std::unique_ptr<ROOT::Internal::TNamedBranchProxy> >. protected . Definition at line 273 of file TTreeReader.h. Member Enumeration Documentation. ◆ EEntryStatus. enum TTreeReader::EEntryStatus. EnumeratorkEntryValid data read okay . kEntryNotLoaded no entry has been loaded yet . kEntryNoTree the tree does not exist . kEntryNotFound the tree entry number does not exist . kEntryChainSetupError problem in accessing a chain element, e.g. file without the tree . kEntryChainFileError problem in opening a chain's file . kEntryDictionaryError problem reading dictionary info from tree . kEntryBeyondEnd last entry loop has reached its end . kEntryBadReader One of the readers was not successfully initialized. . kIndexedFriendNoMatch A friend with TTreeIndex doesn't have an entry for this index. . kMissingBranchWhenSwitchingTree A branch was not found when switching to the next TTree in the chain. . kEntryUnknownError LoadTree return less than -6, likely a 'newer' error code. . Definition at line 152 of file TTreeReader.h. ◆ ELoadTreeStatus. enum TTreeReader::ELoadTreeStatus. EnumeratorkNoTree default state, no TTree is connected (formerly 'Zombie' state) . kLoadTreeNone Notify has not been called yet. . kInternalLoadTree Notify/LoadTree was last c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:22265,load,loaded,22265,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['load'],['loaded']
Performance,"yContainer, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general three-vector. A TVector3 may be expressed in Cartesian, polar, or cylindrical coordinates. Methods include dot and cross products, unit vectors and magnitudes, angles between vectors, and rotations and boosts. There are also functions of particular use to HEP, like pseudo-rapidity, projections, and transverse part of a TVector3, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles.; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857884,load,load,857884,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"yCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileInfoClass describing a generic file including meta information.Definition TFileInfo.h:39; TFileInfo::GetCurrentUrlTUrl * GetCurrentUrl() constReturn the current url.Definition TFileInfo.cxx:249; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileStagerDefinition TFileStager.h:36; TFileStager::Matchesvirtual Bool_t Matches(const char *s)Definition TFileStager.h:46; TFileStager::Openstatic TFileStager * Open(const char *stager)Open a stager, after having loaded the relevant plug-in.Definition TFileStager.cxx:101; TFileStager::Locatevirtual Int_t Locate(const char *u, TString &f)Just check if the file exists locally.Definition TFileStager.cxx:146; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreevirtual TTree * GetTree()Return pointer to friend TTree.Definition TFriendElement.cxx:217; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:135969,cache,cache,135969,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['cache'],['cache']
Performance,"yDataSource.C This tutorial illustrates how to take advantage of a lazy data source creating a data frame from columns of one or multiple parent dataframe(s), delaying the creation of the columns to the actual usage of the daughter data frame ;  df016_vecOps.C This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis ;  df016_vecOps.py This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis ;  df017_vecOpsHEP.C This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis ;  df017_vecOpsHEP.py This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis ;  df018_customActions.C This tutorial shows how to implement a custom action ;  df019_Cache.C This tutorial shows how the content of a data frame can be cached in memory in form of a data frame ;  df019_Cache.py This tutorial shows how the content of a data frame can be cached in memory in form of a data frame ;  df020_helpers.C This tutorial shows usage of the RDF helper tools, contained in ROOT/RDFHelpers.hxx ;  df021_createTGraph.C This tutorial shows how to fill a TGraph using the Dataframe ;  df021_createTGraph.py This tutorial shows how to fill a TGraph using the Dataframe ;  df022_useKahan.C This tutorial shows how to implement a Kahan summation custom action ;  df023_aggregate.C This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column ;  df024_Display.C This tutorial shows how to use the Display action ;  df024_Display.py This tutorial shows how to use the Display action ;  df025_RNode.C RNode is a generic type which represents any transformation node in the computation graph ;  df101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a RDataFrame ;  d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:101563,cache,cached,101563,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['cache'],['cached']
Performance,"yI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormulaManager.html:7464,load,loaded,7464,root/html534/TTreeFormulaManager.html,https://root.cern,https://root.cern/root/html534/TTreeFormulaManager.html,1,['load'],['loaded']
Performance,"yL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. histhistincTGraphMultiErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25631,perform,perform,25631,doc/master/TGraphMultiErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html,1,['perform'],['perform']
Performance,"yLine(const TBuffer3D& buffer); ~TGLPolyLine(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPolyLine.html:1796,cache,cached,1796,root/html528/TGLPolyLine.html,https://root.cern,https://root.cern/root/html528/TGLPolyLine.html,3,['cache'],['cached']
Performance,"yListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(). RooXYChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataSet& xydata, Bool_t integrate). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each point for the chi^2 calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:35706,cache,cache,35706,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"yListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(); coverity[UNINIT_CTOR]. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:35972,cache,cache,35972,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"ySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CCvSplit;  CCvSplitKFolds;  CCvSplitKFoldsExpr;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImplementation of a Decision Tree ;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeAbstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP ;  CEvent;  CExpectedErrorPruneToolA helper class to prune a decision tree using the expected error (C4.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:80281,perform,perform,80281,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['perform'],['perform']
Performance,"y_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:45016,cache,cache,45016,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['cache'],['cache']
Performance,"ybridCalculator: public RooStats::HypoTestCalculator, public TNamed. HybridCalculator class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the following interesting references:; - Alex Read, ""Presentation of search results: the CLs technique"",; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; see http://www.iop.org/EJ/abstract/0954-3899/28/10/313/. - Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)"" CERN 2000-005 (30 May 2000). - V. Bartsch, G.Quas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridCalculator.html:1294,perform,performed,1294,root/html526/RooStats__HybridCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridCalculator.html,1,['perform'],['performed']
Performance,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23490,load,loaded,23490,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"ygroup=2, Int_t nzgroup=2, const char *newname="""")Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.Definition TH3.cxx:2957; TH3::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH3.cxx:264; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::InterpolateDouble_t Interpolate(Double_t x, Double_t y) const overrideNot yet implemented.Definition TH3.cxx:1441; TH3::GetRandom3virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:205854,perform,performing,205854,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['perform'],['performing']
Performance,"yle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8711 of file TTree.cxx. ◆ SetChainOffset(). virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210330,cache,cacheSize,210330,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"yle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; UnBinData.h; ROOT::Fit::BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:41608,perform,performed,41608,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['perform'],['performed']
Performance,"yleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooLegendre; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:52193,cache,cached,52193,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,2,['cache'],"['cache', 'cached']"
Performance,"yleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTChain::fNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*TChain::fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TDSet*fSetTDSet; TList*TChain::fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*TChain::fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTChain::fTreeNumber! Current Tree number in fTreeOffset table; Long64_t*TChain::fTreeOffset[fTreeOffsetLen] Array of variables; Int_tTChain::fTreeOffsetLenCurrent size of fTreeOffset a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofChain.html:25119,load,loading,25119,root/html530/TProofChain.html,https://root.cern,https://root.cern/root/html530/TProofChain.html,2,['load'],['loading']
Performance,ymError(RooAbsReal* real); Bool_thasError(RooAbsReal* real); virtual Bool_thasFilledCache() const; Bool_tisFullReal(RooAbsReal* real); voidTObject::MakeZombie(); vector<RealFullVector*>&realfStoreList(); vector<RealVector*>&realStoreList(). private:. voidsetAllBuffersNative(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Bool_t_forcedUpdate! Request for forced cache update ; Int_t_nCat; In,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:10256,cache,cached,10256,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,2,"['cache', 'load']","['cached', 'loading']"
Performance,"ymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:6906,cache,cache,6906,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"ymous)TObject::kSingleKey; static TFile::(anonymous)kStartBigFile; static TFile::EFileTypekWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitskWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*fArchive!Archive file from which we read this file; Long64_tfArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusfAsyncOpenStatus!Status of an asynchronous open request; Long64_tfBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tfBytesReadNumber of bytes read from this file; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tfBytesWriteNumber of bytes written to this file; TFileCacheRead*fCacheRead!Pointer to the read cache (if any); TMap*fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*fCacheWrite!Pointer to the write cache (if any); TArrayC*fClassIndex!Index of TStreamerInfo classes written to this file; Int_tfCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tfDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tfENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*fFreeFree segments linked list table; TList*fInfoCache!Cached list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsPcmFile!True if the file is a ROOT pcm file.; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:20200,cache,cache,20200,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,6,['cache'],['cache']
Performance,"ymous)TObject::kZombie. protected:. TString_convVarNameName of convolution variable; RooRealVar*_cvModelConvolution variable in resModel event; RooRealVar*_cvOutConvolution variable in output event; RooRealVar*_cvPdfConvolution variable in PDFxTruth event; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooArgSet*_modelCloneSetOwner of resModel clone; RooAbsGenContext*_modelGenResolution model generator context; RooArgSet*_modelVarsHolder of resModel event; RooArgSet*_modelVarsOwnedOwning version of modelVars ;; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet*_pdfCloneSetOwner of PDF clone; RooAbsGenContext*_pdfGenPhysics model generator context; RooArgSet*_pdfVarsHolder of PDF x truth event; RooArgSet*_pdfVarsOwnedOwning version of pdfVars ;; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvGenContext(const RooAbsAnaConvPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor for specialized generator context for analytical convolutions. Builds a generator for the physics PDF convoluted with the truth model; and a generator for the res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvGenContext.html:10041,load,load,10041,root/html602/RooConvGenContext.html,https://root.cern,https://root.cern/root/html602/RooConvGenContext.html,2,['load'],['load']
Performance,"yname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheFile.html:12137,cache,cacheDir,12137,root/html532/TDCacheFile.html,https://root.cern,https://root.cern/root/html532/TDCacheFile.html,2,['cache'],['cacheDir']
Performance,"yout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:2802,perform,performed,2802,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performed']
Performance,"ype or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054094,load,loaded,1054094,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],"['loaded', 'loading']"
Performance,"ype with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called by the TClass constructor when replacing an emulated class by the real class ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerObject.html:3238,cache,cache,3238,doc/master/classTStreamerObject.html,https://root.cern,https://root.cern/doc/master/classTStreamerObject.html,2,['cache'],['cache']
Performance,"ype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsAnaConvPdf::makeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:33499,optimiz,optimizeDirtyHook,33499,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,18,['optimiz'],['optimizeDirtyHook']
Performance,"ype;  ; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  . Public Member Functions;  WrappedMultiTF1Templ (const WrappedMultiTF1Templ< T > &rhs);  Copy constructor. ;  ;  WrappedMultiTF1Templ (TF1 &f, unsigned int dim=0);  constructor from a function pointer to a TF1 If dim = 0 dimension is taken from TF1::GetNdim(). ;  ;  ~WrappedMultiTF1Templ () override;  Destructor (no operations). ;  ; WrappedMultiTF1Templ & operator= (const WrappedMultiTF1Templ< T > &rhs);  Assignment operator. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionMultiDimTempl< T >;  ~IParametricGradFunctionMultiDimTempl () override;  Virtual Destructor (no operations) ;  ; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  ; T ParameterDerivative (const T *x, const double *p, unsigned int ipar=0) const;  Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ;  ; T ParameterDerivative (const T *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const T *x, T *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  . interface inherited from IParamFunction; bool fLinear;  ; bool fPolynomial;  ; bool fOwnFunc;  ; TF1 * fFunc;  ; unsigned int fDim;  ; IMultiGenFunctionTempl< T > * Clone () const override;  Clo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html:2634,cache,cached,2634,doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,1,['cache'],['cached']
Performance,"ype==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1735 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1736 return fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;; 1737 else if ( (fProperties & kIsAssociative) && read); 1738 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1739 else; 1740 return fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;; 1741}; 1742 ; 1743////////////////////////////////////////////////////////////////////////////////; 1744/// Return the set of action necessary to stream in this collection member-wise coming from; 1745/// the old value class layout refered to by 'version'.; 1746 ; 1747TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:57883,load,load,57883,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"ypeinfo)Forward to TROOT::GetClass().Definition TBuffer.cxx:328; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::fModeBool_t fModeDefinition TBuffer.h:48; TBuffer::GetReAllocFuncReAllocCharFun_t GetReAllocFunc() constReturn the reallocation method currently used.Definition TBuffer.cxx:277; TBuffer::fReAllocFuncReAllocCharFun_t fReAllocFuncDefinition TBuffer.h:55; TBuffer::fBufferchar * fBufferDefinition TBuffer.h:51; TBuffer::fParentTObject * fParentDefinition TBuffer.h:54; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and givin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:20830,load,load,20830,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['load'],['load']
Performance,"ypename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredWeightGradients. protected . The sum of the square of the past weight gradients associated with the deep net. ; Definition at line 55 of file RMSProp.h. ◆ fRho. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fRho. protected . The Rho constant used by the optimizer. ; Definition at line 52 of file RMSProp.h. ◆ fWeightUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWeightUpdates. protected . The accumulation of the past Weights for performing updates. ; Definition at line 59 of file RMSProp.h. ◆ fWorkBiasTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor1. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 64 of file RMSProp.h. ◆ fWorkBiasTensor2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor2. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 68 of file RMSProp.h. ◆ fWorkWeightTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:13331,perform,performing,13331,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['perform'],['performing']
Performance,"ypes defined (in range named rangeName if rangeName!=nullptr) ;  ; Int_t getIndex () const;  Retrieve the current index. Use getCurrentIndex() for more clarity. ;  ; const char * getLabel () const;  Retrieve current label. Use getCurrentLabel() for more clarity. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCategory.h>. Inheritance diagram for RooAbsCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ value_type. using RooAbsCategory::value_type = int. The type used to denote a specific category state. ; Definition at line 36 of file RooAbsCategory.h. Constructor & Destructor Documentation. ◆ RooAbsCategory() [1/3]. RooAbsCategory::RooAbsCategory ; (; ). Definition at line 76 of file RooAbsCategory.cxx. ◆ RooAbsCategory() [2/3]. RooAbsCategory::RooAbsCategory ; (; const char * ; name, . const char * ; title . ). Constructor. ; Definition at line 82 of file RooAbsCategory.cxx. ◆ Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:45367,cache,cache,45367,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"ypes::EMVA theMethod, TString methodTitle,; 2359 const char *theOption); 2360{; 2361 uint64_t x = 0;; 2362 uint64_t y = 0;; 2363 ; 2364 // getting number of variables and variable names from loader; 2365 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2366 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2367 ; 2368 if (nbits > 60) {; 2369 Log() << kERROR << ""Number of combinations is too large , is 2^"" << nbits << Endl;; 2370 return nullptr;; 2371 }; 2372 long int range = sum(nbits);; 2373 // std::cout<<range<<std::endl;; 2374 // vector to save importances; 2375 std::vector<Double_t> importances(nbits);; 2376 for (int i = 0; i < nbits; i++); 2377 importances[i] = 0;; 2378 ; 2379 Double_t SROC, SSROC; // computed ROC value; 2380 ; 2381 x = range;; 2382 ; 2383 std::bitset<VIBITS> xbitset(x);; 2384 if (x == 0); 2385 Log() << kFATAL << ""Error: need at least one variable.""; // data loader need at least one variable; 2386 ; 2387 // creating loader for seed; 2388 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2389 ; 2390 // adding variables from seed; 2391 for (int index = 0; index < nbits; index++) {; 2392 if (xbitset[index]); 2393 seedloader->AddVariable(varNames[index], 'F');; 2394 }; 2395 ; 2396 // Loading Dataset; 2397 DataLoaderCopy(seedloader, loader);; 2398 ; 2399 // Booking Seed; 2400 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2401 ; 2402 // Train/Test/Evaluation; 2403 TrainAllMethods();; 2404 TestAllMethods();; 2405 EvaluateAllMethods();; 2406 ; 2407 // getting ROC; 2408 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2409 ; 2410 // cleaning information to process sub-seeds; 2411 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2412 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2413 smethod->GetMethodName(), Types::kTesting, Types::kClassification);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:99619,load,loader,99619,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance,"ypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:150885,load,load,150885,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"ypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:151061,load,load,151061,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"ypewhat', e.g. 'std:max:'; type = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same plot (default); dofit = 0 no fit; 1 fit with the relevant '1st degree related' function; 2 fit with the relevant '2nd degree related' function; 3 fit with varying rcpu function; n0 = for dofit == 3, number of real cores; n1 = for dofit == 3, number of total cores (real + hyperthreaded). TGraphErrors * GetGraph(TDirectory* d, const char* pfn, Int_t& nb, Double_t& xmi, Double_t& xmx, Double_t& ymi, Double_t& ymx, Int_t& kmx, TProfile*& pf); Get from TDirectory 'd' the TProfile named 'pfn' and create the graph.; Return also the max y in mx. void AssertFittingFun(Double_t mi, Double_t mx); Make sure that the fitting functions are defined. void GetPerfSpecs(const char* path = ""."", Int_t degfit = 1); Get performance specs. Check file 'path', or files in directory 'path'; (default current directory).; The degree of the polynomial used for the fit is 'degfit' (default 1). Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard plot; 'stdx:' draw standard plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:11063,perform,performance,11063,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,3,['perform'],['performance']
Performance,ys validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts r,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:36592,cache,cache,36592,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,"ys with the sorted values.Definition TGraph.cxx:2592; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::SaveArrayTString SaveArray(std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr)Save array as C++ code Returns name of created array.Definition TGraph.cxx:2175; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:38716,perform,perform,38716,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:3609,cache,cache,3609,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,['cache'],['cache']
Performance,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:3568,cache,cache,3568,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['cache'],['cache']
Performance,"ys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTEveJetConeGL::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetConeProjectedGL.html:1879,cache,cached,1879,root/html528/TEveJetConeProjectedGL.html,https://root.cern,https://root.cern/root/html528/TEveJetConeProjectedGL.html,3,['cache'],['cached']
Performance,"ys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackGL.html:1819,cache,cached,1819,root/html528/TEveTrackGL.html,https://root.cern,https://root.cern/root/html528/TEveTrackGL.html,3,['cache'],['cached']
Performance,"ysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetConeGL.html:1806,cache,cached,1806,root/html528/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html528/TEveJetConeGL.html,3,['cache'],['cached']
Performance,"ysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjectionAxesGL.html:1848,cache,cached,1848,root/html528/TEveProjectionAxesGL.html,https://root.cern,https://root.cern/root/html528/TEveProjectionAxesGL.html,7,['cache'],['cached']
Performance,"ystem.; Definition at line 3786 of file TWinNTSystem.cxx. ◆ GetGUIThreadHandle(). void * TWinNTSystem::GetGUIThreadHandle ; (; ); const. inline . Definition at line 114 of file TWinNTSystem.h. ◆ GetGUIThreadId(). ULong_t TWinNTSystem::GetGUIThreadId ; (; ); const. inline . Definition at line 115 of file TWinNTSystem.h. ◆ GetHomeDirectory(). std::string TWinNTSystem::GetHomeDirectory ; (; const char * ; userName = nullptr); const. overridevirtual . Return the user's home directory. ; Reimplemented from TSystem.; Definition at line 2214 of file TWinNTSystem.cxx. ◆ GetHostByName(). TInetAddress TWinNTSystem::GetHostByName ; (; const char * ; server). overridevirtual . Get Internet Protocol (IP) address of host. ; Reimplemented from TSystem.; Definition at line 4688 of file TWinNTSystem.cxx. ◆ GetLibraries(). const char * TWinNTSystem::GetLibraries ; (; const char * ; regexp = """", . const char * ; options = """", . Bool_t ; isRegexp = kTRUE . ). overridevirtual . Return a space separated list of loaded shared libraries. ; This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of: S: shared libraries loaded at the start of the executable, because they were specified on the link line. D: shared libraries dynamically loaded after the start of the program. L: list the .LIB rather than the .DLL (this is intended for linking) [This options is not the default] ; Reimplemented from TSystem.; Definition at line 4307 of file TWinNTSystem.cxx. ◆ GetLinkedLibraries(). const char * TWinNTSystem::GetLinkedLibraries ; (; ). overrideprivatevirtual . Get list of shared libraries loaded at the start of the executable. ; Returns 0 in case list cannot be obtained or in case of error. ; Reimplemented from TSystem.; Definition at line 4153 of file TWinNTSystem.cxx. ◆ GetMemInfo(). Int_t TWinNTSystem::GetMemInfo ; (; MemInfo_t * ; info); const. overridevirtual . Returns ram and swap memory usage info into the MemInfo_t structure. ; Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:53674,load,loaded,53674,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['load'],['loaded']
Performance,"ystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::MakeDirectoryvirtual int MakeDirectory(const char *name)Make a directory.Definition TSystem.cxx:827; TSystem::ExpandFileNamevirtual const char * ExpandFileName(const char *fname)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1098; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:197276,load,loaded,197276,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"ystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::IsInterruptingSyscallsBool_t IsInterruptingSyscalls() constDefinition TTimer.h:82; TTimer::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:194959,optimiz,optimization,194959,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"ystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; nconst Int_t nDefinition legend1.C:16; CpuInfo_tDefinition TSystem.h:163; CpuInfo_t::~CpuInfo_tvirtual ~CpuInfo_t()Definition TSystem.h:173; CpuInfo_t::fIdleFloat_t fIdleDefinition TSystem.h:170; CpuInfo_t::fLoad15mFloat_t fLoad15mDefinition TSystem.h:166; CpuInfo_t::fUserFloat_t fUserDefinition TSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:63867,optimiz,optimization,63867,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['optimiz'],['optimization']
Performance,"ytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207604,cache,cacheSize,207604,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cacheSize']
Performance,"ytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8534 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210095,cache,cacheSize,210095,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['cache'],['cacheSize']
Performance,"ytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::GetSeekFreevirtual Long64_t GetSeekFree() constDefinition TFile.h:252; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefiniti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:27589,cache,cache,27589,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"z<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:341269,cache,cached,341269,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['cache'],['cached']
Performance,"zation argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooDataHist::ErrorType _etype;  Error type store in associated RooDataHist. ;  ; FuncMode _funcMode;  Function, P.d.f. or extended p.d.f? ;  ;  Protected Attributes inherited from RooAbsOptTestStatistic; RooArgSet _cachedNodes;  ! List of nodes that are cached as constant expressions ;  ; RooAbsData * _dataClone = nullptr;  Pointer to internal clone if input data. ;  ; RooAbsReal * _funcClone = nullptr;  Pointer to internal clone of input function. ;  ; RooArgSet * _funcCloneSet = nullptr;  Set owning all components of internal clone of input function. ;  ; RooArgSet * _funcObsSet = nullptr;  List of observables in the pdf expression. ;  ; double _integrateBinsPrecision {-1.};  ; RooArgSet * _normSet = nullptr;  Pointer to set with observables used for normalization. ;  ; bool _optimized = false;  ! ;  ; RooAbsData * _origData = nullptr;  Original data. ;  ; RooAbsReal * _origFunc = nullptr;  Original function. ;  ; bool _ownData = false;  Do we own the dataset. ;  ; RooArgSet * _projDeps = nullptr;  Set of projected observable. ;  ; bool _sealed = false;  Is test statistic sealed – i.e. no access to data. ;  ; TString _sealNotice;  User-defined notice shown when reading a sealed likelihood. ;  ; bool _skipZeroWeights = false;  ! W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:59876,cache,cached,59876,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cached']
Performance,"ze ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStringVar.h>. Inheritance diagram for RooStringVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooStringVar() [1/3]. RooStringVar::RooStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:37204,cache,cache,37204,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,1,['cache'],['cache']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Interpolator.html:3314,perform,performed,3314,root/html526/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Interpolator.html:3314,perform,performed,3314,root/html528/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Interpolator.html:3316,perform,performed,3316,root/html530/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Interpolator.html:3316,perform,performed,3316,root/html532/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). bool SetVariableInitialRange(unsigned int , double , double ); set the initial range of an existing variable. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. const double * X() const; return pointer to X values at the minimum. double Edm() const; return expected distance reached from the minimum (re-implement if minimizer provides it. { return -1; }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return NULL; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NIterations() const; number of iterations to reach the minimum. { return NCalls(); }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; (re-implement if minimizer supports bounded parameters). { return NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Minimizer.html:7779,perform,perform,7779,root/html602/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Minimizer.html,2,['perform'],['perform']
Performance,"ze_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; double; int; TMath::MaxElementT MaxElement(Long64_t n, const T *a)Returns maximum of array a of length n.Definition TMath.h:968; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; Drawth1 Draw(). treetreeplayersrcTTreePerfStats.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:06 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:45568,perform,performance,45568,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['perform'],['performance']
Performance,"zed function has error status.; Returning maximum FCN so far (-775.389) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.72761 a1=-0.375581 mean=5.04879 nbkg=141.143 nsig=137.402 sig1frac=0.495257; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#0] WARNING:Generation -- Fit parameter 'sigma1' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#0] WARNING:Generation -- Fit parameter 'sigma2' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#1] INFO:ObjectHandling -- RooWorkspace::import() importing RooRealVar::meanpull; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pullGauss_over_pullGauss_Int[meanpull]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pullGauss_over_pullGauss_Int[meanpull]_fitParData_model) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorWouter Verkerke ; Definition in file rf801_mcstudy.C. tutorialsroofitrf801_mcstudy.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:29688,optimiz,optimization,29688,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['optimiz'],['optimization']
Performance,"zed value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 _normSet = tmp ;; 328 ; 329 return TMath::IsNaN(val) ? 0. : val;; 330 }; 331 ; 332 ; 333 // Process change in last data set used; 334 bool nintChanged(false) ;; 335 if (!isActiveNormSet(nset) || _norm==nullptr) {; 336 nintChanged = syncNormalization(nset) ;; 337 }; 338 ; 339 // Return value of object. Calculated if dirty, otherwise cached value is returned.; 340 if (isValueDirty() || nintChanged || _norm->isValueDirty()) {; 341 ; 342 // Evaluate numerator; 343 const double rawVal = evaluate();; 344 ; 345 // Evaluate denominator; 346 const double normVal = _norm->getVal();; 347 ; 348 _value = normalizeWithNaNPacking(rawVal, normVal);; 349 ; 350 clearValueAndShapeDirty();; 351 }; 352 ; 353 return _value ;; 354}; 355 ; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information).; 359///; 360/// This function applies the normalization specified by `normSet` to the integral returned; 361/// by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; 362/// to return a normalized answer.; 363 ; 364double RooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 365{; 366 cxcoutD(Eval) << ""RooAbsPdf::analytic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:12738,cache,cached,12738,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"zero, the result parameter will be swapped with a std::any variable on the Python side. You need to define this variable yourself, and it needs to be of type std::any and its name needs to be ""_anyresult"" by default. Like this, you can pass information from Python back to C++.; Parameters. cmdThe Python command to be executed as a string. ; resultOptional pointer to a std::any object that can be used to transfer results from Python to C++. ; resultNameName of the Python variable that is swapped over to the std::any result. The default value is ""_anyresult"". . Returnsbool Returns true if the command was successfully executed, otherwise returns false. ; Definition at line 425 of file TPython.cxx. ◆ ExecScript(). void TPython::ExecScript ; (; const char * ; name, . int ; argc = 0, . const char ** ; argv = nullptr . ). static . Execute a python stand-alone script, with argv CLI arguments. ; example of use: const char* argv[] = { ""1"", ""2"", ""3"" }; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv ); ; Definition at line 381 of file TPython.cxx. ◆ Import(). Bool_t TPython::Import ; (; const char * ; name). static . Import the named python module and create Cling equivalents for its classes and methods. ; Definition at line 237 of file TPython.cxx. ◆ Initialize(). Bool_t TPython::Initialize ; (; ). staticprivate . Initialization method: setup the python interpreter and load the ROOT module. ; Definition at line 137 of file TPython.cxx. ◆ LoadMacro(). void TPython::LoadMacro ; (; const char * ; name). static . Execute the give python script as if it were a macro (effectively an execfile in main), and create Cling equivalents for any newly available python classes. ; Definition at line 305 of file TPython.cxx. The documentation for this class was generated from the following files:; bindings/tpython/inc/TPython.h; bindings/tpython/src/TPython.cxx. TPython. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPython.html:6410,load,load,6410,doc/master/classTPython.html,https://root.cern,https://root.cern/doc/master/classTPython.html,1,['load'],['load']
Performance,"zipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:3540,cache,cache,3540,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,zjh ; Definition at line 186 of file MethodANNBase.h. ◆ fLayerSpec. TString TMVA::MethodANNBase::fLayerSpec. private . layout specification option ; Definition at line 221 of file MethodANNBase.h. ◆ fNcycles. Int_t TMVA::MethodANNBase::fNcycles. protected . number of epochs to train ; Definition at line 192 of file MethodANNBase.h. ◆ fNetwork. TObjArray* TMVA::MethodANNBase::fNetwork. Definition at line 139 of file MethodANNBase.h. ◆ fNeuronInputType. TString TMVA::MethodANNBase::fNeuronInputType. protected . name of neuron input calculator class ; Definition at line 195 of file MethodANNBase.h. ◆ fNeuronType. TString TMVA::MethodANNBase::fNeuronType. protected . name of neuron activation function class ; Definition at line 194 of file MethodANNBase.h. ◆ fOutput. TActivation* TMVA::MethodANNBase::fOutput. protected . Definition at line 164 of file MethodANNBase.h. ◆ fOutputNeurons. std::vector<TNeuron*> TMVA::MethodANNBase::fOutputNeurons. private . cache this for fast access ; Definition at line 220 of file MethodANNBase.h. ◆ fRandomSeed. Int_t TMVA::MethodANNBase::fRandomSeed. protected . random seed for initial synapse weights ; Definition at line 190 of file MethodANNBase.h. ◆ fRegulatorIdx. std::vector<Int_t> TMVA::MethodANNBase::fRegulatorIdx. protected . Definition at line 169 of file MethodANNBase.h. ◆ fRegulators. std::vector<Double_t> TMVA::MethodANNBase::fRegulators. protected . Definition at line 170 of file MethodANNBase.h. ◆ frgen. TRandom3* TMVA::MethodANNBase::frgen. protected . Definition at line 166 of file MethodANNBase.h. ◆ fSynapses. TObjArray* TMVA::MethodANNBase::fSynapses. protected . Definition at line 162 of file MethodANNBase.h. ◆ fUseRegulator. bool TMVA::MethodANNBase::fUseRegulator. protected . zjh ; Definition at line 187 of file MethodANNBase.h. Libraries for TMVA::MethodANNBase:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/MethodANNBase.h; tmva/tmva/src/MethodANNBase.cxx. TMVA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:45921,cache,cache,45921,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['cache'],['cache']
Performance,"{ fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21949,perform,perform,21949,root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,3,['perform'],['perform']
Performance,"{ kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSlaveLite.html:7676,perform,performance,7676,root/html530/TSlaveLite.html,https://root.cern,https://root.cern/root/html530/TSlaveLite.html,2,['perform'],['performance']
Performance,"{ kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSlave(const char* url, const char* ord, Int_t perf, const char* image",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSlave.html:7845,perform,performance,7845,root/html530/TXSlave.html,https://root.cern,https://root.cern/root/html530/TXSlave.html,2,['perform'],['performance']
Performance,"{ kUseBoundingBox; kUseVoxels; kUseGsord; };; enum EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoAtt.html:3124,optimiz,optimization,3124,root/html528/TGeoAtt.html,https://root.cern,https://root.cern/root/html528/TGeoAtt.html,4,['optimiz'],['optimization']
Performance,"{ return fClassGenerators; }; 252 TSeqCollection *GetListOfSecContexts() const { return fSecContexts; }; 253 TSeqCollection *GetListOfProofs() const { return fProofs; }; 254 TSeqCollection *GetClipboard() const { return fClipboard; }; 255 TSeqCollection *GetListOfDataSets() const { return fDataSets; }; 256 TCollection *GetListOfEnums(Bool_t load = kFALSE);; 257 TCollection *GetListOfFunctionTemplates();; 258 TList *GetListOfBrowsables() const { return fBrowsables; }; 259 TDataType *GetType(const char *name, Bool_t load = kFALSE) const;; 260 TFile *GetFile() const override { if (gDirectory && gDirectory != this) return gDirectory->GetFile(); else return nullptr;}; 261 TFile *GetFile(const char *name) const;; 262 TFunctionTemplate*GetFunctionTemplate(const char *name);; 263 TStyle *GetStyle(const char *name) const;; 264 TObject *GetFunction(const char *name) const;; 265 TGlobal *GetGlobal(const char *name, Bool_t load = kFALSE) const;; 266 TGlobal *GetGlobal(const TObject *obj, Bool_t load = kFALSE) const;; 267 TFunction *GetGlobalFunction(const char *name, const char *params = nullptr, Bool_t load = kFALSE);; 268 TFunction *GetGlobalFunctionWithPrototype(const char *name, const char *proto = nullptr, Bool_t load = kFALSE);; 269 TObject *GetGeometry(const char *name) const;; 270 const TObject *GetSelectedPrimitive() const { return fPrimitive; }; 271 TVirtualPad *GetSelectedPad() const { return fSelectPad; }; 272 Int_t GetNclasses() const;; 273 Int_t GetNtypes() const;; 274 TFolder *GetRootFolder() const { return fRootFolder; }; 275 TProcessUUID *GetUUIDs() const { return fUUIDs; }; 276 const TString &GetWebDisplay() const { return fWebDisplay; }; 277 void Idle(UInt_t idleTimeInSec, const char *command = nullptr);; 278 Int_t IgnoreInclude(const char *fname, const char *expandedfname);; 279 Bool_t IsBatch() const { return fBatch; }; 280 Bool_t IsExecutingMacro() const { return fExecutingMacro; }; 281 Bool_t IsFolder() const override { return kTRUE; }; 282 Bool_t IsInterr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:13111,load,load,13111,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['load'],['load']
Performance,"{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined as \( (\lambda_i -; \lambda_{gen})/\sigma(\lambda_i) \), where \( \lambda_i \) is the fitted parameter and \( \sigma(\lambda_i) \) its uncertainty for pseudoexperiment number i. If the fit is unbiased and the parameter uncertainties are estimated correctly, the pull distribution should be a Gaussian centered around zero with a width of one. ; #include ""TH1D.h""; #include ""TCanvas.h""; #include ""TROOT.h""; #include ""TStyle.h""; #include ""TRandom3.h""; #include ""TLegend.h""; #include ""RooRealVar.h""; #include ""RooFitResult.h""; #include ""RooDataSet.h""; #include ""RooPolynomial.h""; ; using namespace RooFit;; ; void rf611_weightedfits(int acceptancemodel = 2); {; // I n i t i a l i s a t i o n a n d S e t u p; //------------------------------------------------; ; // plotting options; gStyle->SetPaintTextFormat("".1f"");; gStyle->SetEndErrorSize(6.0);; gStyle->SetTitleSize(0.05, ""XY"");; gStyle->SetLa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:2300,perform,performance,2300,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,1,['perform'],['performance']
Performance,"{; 1838 if (s->sa.sa_family == AF_INET); 1839 return s->sin.sin_port;; 1840#if defined(USE_IPV6); 1841 if (s->sa.sa_family == AF_INET6); 1842 return s->sin6.sin6_port;; 1843#endif; 1844 return 0;; 1845}; 1846#endif; 1847#if defined(USE_IPV6); 1848#define USA_IN_PORT_UNSAFE(s) \; 1849 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1850#else; 1851#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1852#endif; 1853 ; 1854/* Describes a string (chunk of memory). */; 1855struct vec {; 1856 const char *ptr;; 1857 size_t len;; 1858};; 1859 ; 1860struct mg_file_stat {; 1861 /* File properties filled by mg_stat: */; 1862 uint64_t size;; 1863 time_t last_modified;; 1864 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1865 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:57514,queue,queued,57514,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queued']
Performance,"{; 1839 if (s->sa.sa_family == AF_INET); 1840 return s->sin.sin_port;; 1841#if defined(USE_IPV6); 1842 if (s->sa.sa_family == AF_INET6); 1843 return s->sin6.sin6_port;; 1844#endif; 1845 return 0;; 1846}; 1847#endif; 1848#if defined(USE_IPV6); 1849#define USA_IN_PORT_UNSAFE(s) \; 1850 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1851#else; 1852#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1853#endif; 1854 ; 1855/* Describes a string (chunk of memory). */; 1856struct vec {; 1857 const char *ptr;; 1858 size_t len;; 1859};; 1860 ; 1861struct mg_file_stat {; 1862 /* File properties filled by mg_stat: */; 1863 uint64_t size;; 1864 time_t last_modified;; 1865 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1866 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:57546,queue,queued,57546,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queued']
Performance,"{; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:11587,cache,cache,11587,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['cache'],['cache']
Performance,"{; 4026 Long_t increment = proxy.GetIncrement();; 4027 sequence->fLoopConfig = new TVectorLoopConfig(increment);; 4028 // sequence->fLoopConfig = new TAssocLoopConfig(proxy); */; 4029 } else {; 4030 sequence->fLoopConfig = new TGenericLoopConfig(&proxy, /* read */ kFALSE);; 4031 }; 4032 for (UInt_t i = 0; i < ndata; ++i) {; 4033 TStreamerElement *element = (TStreamerElement*) info->GetElements()->At(i);; 4034 if (!element) {; 4035 break;; 4036 }; 4037 if (element->GetType() < 0) {; 4038 // -- Skip an ignored TObject base class.; 4039 // Note: The only allowed negative value here is -1, and signifies that Build() has found a TObject; 4040 // base class and TClass::IgnoreTObjectStreamer() was called. In this case the compiled version of the; 4041 // elements omits the TObject base class element, which has to be compensated for by TTree::Bronch(); 4042 // when it is making branches for a split object.; 4043 continue;; 4044 }; 4045 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 4046 // Skip element cached for reading purposes.; 4047 continue;; 4048 }; 4049 if (element->GetType() >= TVirtualStreamerInfo::kArtificial && !element->TestBit(TStreamerElement::kWrite)) {; 4050 // Skip artificial element used for reading purposes.; 4051 continue;; 4052 }; 4053 TStreamerInfo::TCompInfo *compinfo = sinfo->fCompFull[i];; 4054 Int_t oldType = element->GetType();; 4055 Int_t offset = element->GetOffset();; 4056#if defined(CDJ_NO_COMPILE); 4057 Int_t newType = element->GetNewType();; 4058 ; 4059 if (newType != oldType) {; 4060 if (newType > 0) {; 4061 if (oldType != TVirtualStreamerInfo::kCounter) {; 4062 oldType += TVirtualStreamerInfo::kConv;; 4063 }; 4064 } else {; 4065 oldType += TVirtualStreamerInfo::kSkip;; 4066 }; 4067 }; 4068 if ( IsDefaultVector(proxy); 4069 /*|| (proxy.GetCollectionType() == ROOT::kSTLset || proxy.GetCollectionType() == ROOT::kSTLmultiset; 4070 || proxy.GetCollectionType() == ROOT::kSTLmap || proxy.GetColle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:188658,cache,cached,188658,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,"{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGenCollectionProxy(*this);; 737 ; 738 switch(fSTL_type) {; 739 case ROOT::kSTLbitset: {; 740 return new TGenBitsetProxy(*this);; 741 }; 742 case ROOT::kSTLvector: {; 743 if ((*fValue).fKind == kBool_t) {; 744 return new TGenVectorBoolProxy(*this);; 745 } else {; 746 return new TGenVectorProxy(*this);; 747 }; 748 }; 749 case ROOT::kSTLlist:; 750 case ROOT::kSTLforwardlist:; 751 return new TGenListProxy(*this);; 752 case ROOT::kSTLmap:; 753 case ROOT::kSTLunorderedmap:; 754 case ROOT::kSTLmultimap:; 755 case ROOT::kSTLunorderedmultimap:; 756 return new TGenMapProxy(*this);; 757 case ROOT::kSTLset:; 758 case ROOT::kSTLunorderedset:; 759 case ROOT::kSTLmultiset:; 760 case ROOT::kSTLunorderedmultiset:; 761 return new TGenSetProxy(*this);; 762 default:; 763 return new TGenCollectionProxy(*this);; 764 }; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Proxy initializer; 769 ; 770TGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const; 771{; 772 TGenCollectionPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:22409,load,load,22409,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in \(\gamma\)-ray spectra we have to fit together tens, hundreds of peaks simultaneously that represent sometimes thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel \(i\) is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; the error of \(k\)-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; algorithm with higher powers w=1,2,3…; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; we have implemented the nonsymmetrical semiempirical peak shape function.; it contains the symmetrical Gaussian as well as nonsymmetrical terms.; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where \(T,S\) are relative amplitudes and \(B\) is a slop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:36747,optimiz,optimize,36747,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['optimiz'],['optimize']
Performance,"{kFALSE};  True if directory is writable. ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:43459,cache,cache,43459,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,['cache'],"['cache', 'cached']"
Performance,"{}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:25537,cache,cache,25537,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,3,['cache'],['cache']
Performance,"| (kGetLeaf & fFriendLockStatus)); 6221 return nullptr;; 6222 ; 6223 std::string path(name);; 6224 const auto sep = path.find_last_of('/');; 6225 if (sep != std::string::npos); 6226 return GetLeafImpl(path.substr(0, sep).c_str(), name+sep+1);; 6227 ; 6228 return GetLeafImpl(nullptr, name);; 6229}; 6230 ; 6231////////////////////////////////////////////////////////////////////////////////; 6232/// Return maximum of column with name columname.; 6233/// if the Tree has an associated TEventList or TEntryList, the maximum; 6234/// is computed for the entries in this list.; 6235 ; 6236Double_t TTree::GetMaximum(const char* columname); 6237{; 6238 TLeaf* leaf = this->GetLeaf(columname);; 6239 if (!leaf) {; 6240 return 0;; 6241 }; 6242 ; 6243 // create cache if wanted; 6244 if (fCacheDoAutoInit); 6245 SetCacheSizeAux();; 6246 ; 6247 TBranch* branch = leaf->GetBranch();; 6248 Double_t cmax = -DBL_MAX;; 6249 for (Long64_t i = 0; i < fEntries; ++i) {; 6250 Long64_t entryNumber = this->GetEntryNumber(i);; 6251 if (entryNumber < 0) break;; 6252 branch->GetEntry(entryNumber);; 6253 for (Int_t j = 0; j < leaf->GetLen(); ++j) {; 6254 Double_t val = leaf->GetValue(j);; 6255 if (val > cmax) {; 6256 cmax = val;; 6257 }; 6258 }; 6259 }; 6260 return cmax;; 6261}; 6262 ; 6263////////////////////////////////////////////////////////////////////////////////; 6264/// Static function which returns the tree file size limit in bytes.; 6265 ; 6266Long64_t TTree::GetMaxTreeSize(); 6267{; 6268 return fgMaxTreeSize;; 6269}; 6270 ; 6271////////////////////////////////////////////////////////////////////////////////; 6272/// Return minimum of column with name columname.; 6273/// if the Tree has an associated TEventList or TEntryList, the minimum; 6274/// is computed for the entries in this list.; 6275 ; 6276Double_t TTree::GetMinimum(const char* columname); 6277{; 6278 TLeaf* leaf = this->GetLeaf(columname);; 6279 if (!leaf) {; 6280 return 0;; 6281 }; 6282 ; 6283 // create cache if wanted; 6284 if (fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:244910,cache,cache,244910,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"| *sIt == '>' ||; 718 *sIt == ' ' || *sIt == '*' ||; 719 *sIt == ',' || *sIt == '&' ||; 720 *sIt == ':') {; 721 fileName += '_';; 722 }; 723 else {; 724 fileName += *sIt;; 725 }; 726 }; 727 if (classes.size() > 1) {; 728 Int_t chk = 0;; 729 std::vector<std::string>::const_iterator it = classes.begin();; 730 while ((++it) != classes.end()) {; 731 for (UInt_t cursor = 0; cursor != it->length(); ++cursor) {; 732 chk = chk * 3 + it->at(cursor);; 733 }; 734 }; 735 fileName += TString::Format(""_%u"", chk);; 736 }; 737 fileName += "".cxx"";; 738 if (gSystem->AccessPathName(fileName) != 0) {; 739 //file does not exist; 740 //(1) prepare file data; 741 // If STL, also request iterators' operators.; 742 // vector is special: we need to check whether; 743 // vector::iterator is a typedef to pointer or a; 744 // class.; 745 static const std::set<std::string> sSTLTypes {; 746 ""vector"",""list"",""forward_list"",""deque"",""map"",""unordered_map"",""multimap"",; 747 ""unordered_multimap"",""set"",""unordered_set"",""multiset"",""unordered_multiset"",; 748 ""queue"",""priority_queue"",""stack"",""iterator""};; 749 std::vector<std::string>::const_iterator it;; 750 std::string fileContent("""");; 751 for (it = headers.begin(); it != headers.end(); ++it) {; 752 fileContent += ""#include \"""" + *it + ""\""\n"";; 753 }; 754 for (it = unknown.begin(); it != unknown.end(); ++it) {; 755 TClass* cl = TClass::GetClass(it->c_str());; 756 if (cl && cl->GetDeclFileName()) {; 757 TString header = gSystem->BaseName(cl->GetDeclFileName());; 758 TString dir = gSystem->GetDirName(cl->GetDeclFileName());; 759 TString dirbase(gSystem->BaseName(dir));; 760 while (dirbase.Length() && dirbase != "".""; 761 && dirbase != ""include"" && dirbase != ""inc""; 762 && dirbase != ""prec_stl"") {; 763 gSystem->PrependPathName(dirbase, header);; 764 dir = gSystem->GetDirName(dir);; 765 }; 766 fileContent += TString(""#include \"""") + header + ""\""\n"";; 767 }; 768 }; 769 for (it = fwdDecls.begin(); it != fwdDecls.end(); ++it) {; 770 fileContent += ""class "" + *it + ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:26526,queue,queue,26526,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['queue'],['queue']
Performance,"|10,LINEAR"");; 151 TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; 152 ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; 153 TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; 154 ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; 155 nnOptions.Append("":"");; 156 nnOptions.Append(layoutString);; 157 nnOptions.Append("":"");; 158 nnOptions.Append(trainingStrategyString);; 159 factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; 160 }; 161 ; 162 ; 163 // Train MVAs using the set of training events; 164 factory->TrainAllMethods();; 165 ; 166 // Evaluate all MVAs using the set of test events; 167 factory->TestAllMethods();; 168 ; 169 // Evaluate and compare performance of all configured MVAs; 170 factory->EvaluateAllMethods();; 171 ; 172 // --------------------------------------------------------------; 173 ; 174 // Save the output; 175 outputFile->Close();; 176 ; 177 std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; 178 std::cout << ""==> TMVAMulticlass is done!"" << std::endl;; 179 ; 180 delete factory;; 181 delete dataloader;; 182 ; 183 // Launch the GUI for the root macros; 184 if (!gROOT->IsBatch()) TMVAMultiClassGui( outfileName );; 185 ; 186 ; 187}; 188 ; 189int main( int argc, char** argv ); 190{; 191 // Select methods (don't look at this code - not of interest); 192 TString methodList;; 193 for (int i=1; i<argc; i++) {; 194 TString regMethod(argv[i]);; 195 if(regMethod==""-b"" || regMethod==""--batch"") continue;; 196 if (!methodList.IsNull()) methodList += TString("","");; 197 methodList += regMethod;; 198 }; 199 TMVAMulticlass(methodList);; 200 return 0;; 201}; 202 ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:6863,perform,performance,6863,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['perform'],['performance']
Performance,"|; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooExpensiveObjectCache Class ReferenceRooFit » RooFit Core. ; Singleton class that serves as repository for objects that are expensive to calculate. ; Owners of such objects can registers these here with associated parameter values for which the object is valid, so that other instances can, at a later moment retrieve these precalculated objects. ; Definition at line 24 of file RooExpensiveObjectCache.h. Classes; class  ExpensiveObject;  . Public Member Functions;  RooExpensiveObjectCache ();  ;  RooExpensiveObjectCache (const RooExpensiveObjectCache &other);  ;  ~RooExpensiveObjectCache () override;  Destructor. ;  ; void clearAll ();  Clear all cache elements. ;  ; bool clearObj (Int_t uniqueID);  Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ;  ; bool empty () const;  ; const TObject * getObj (Int_t uniqueID);  Retrieve payload object of cache element with given unique ID. ;  ; void importCacheObjects (RooExpensiveObjectCache &other, const char *ownerName, bool verbose=false);  ; TClass * IsA () const override;  ; void print () const;  ; bool registerObject (const char *ownerName, const char *objectName, TObject &cacheObject, const RooArgSet &params);  Register object associated with given name and given associated parameters with given values in cache. ;  ; const TObject * retrieveObject (const char *name, TClass *tclass, const RooArgSet &params);  Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ;  ; bool setObj (Int_t uniqueID, TObject *obj);  Place new payload object in cache element with given unique ID. ;  ; Int_t size () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:1182,cache,cache,1182,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"|; Private Attributes |; Friends |; List of all members ; RooMinimizer Class ReferenceRooFit » RooFit Core. ; Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. ; By default the Minimizer is Minuit 2. RooMinimizer can minimize any RooAbsReal function with respect to its parameters. Usual choices for minimization are the object returned by RooAbsPdf::createNLL() or RooAbsReal::createChi2(). RooMinimizer has methods corresponding to MINUIT functions like hesse(), migrad(), minos() etc. In each of these function calls the state of the MINUIT engine is synchronized with the state of the RooFit variables: any change in variables, change in the constant status etc is forwarded to MINUIT prior to execution of the MINUIT call. Afterwards the RooFit objects are resynchronized with the output state of MINUIT: changes parameter values, errors are propagated. Various methods are available to control verbosity, profiling, automatic PDF optimization. ; Definition at line 48 of file RooMinimizer.h. Classes; struct  Config;  Config argument to RooMinimizer constructor. More...;  ; struct  FitResult;  ; class  FitterInterface;  . Public Types; enum  PrintLevel { ;   None = -1; , Reduced = 0; , Normal = 1; , ExtraForProblem = 2; , ;   Maximum = 3. };  ; enum  Strategy { Speed = 0; , Balance = 1; , Robustness = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:1288,optimiz,optimization,1288,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['optimiz'],['optimization']
Performance,"}""); hcorr.GetXaxis().SetBinLabel(3, ""c_{HDD}""); hcorr.GetXaxis().SetBinLabel(2, ""c_{Hl^{(3)}}""); hcorr.GetXaxis().SetBinLabel(1, ""c_{Hq^{(3)}}""); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz text""); ; c1.SaveAs(""rf712_lagrangianmorphfit.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x85555e0; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x915c650; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, deno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html:5082,cache,cache,5082,doc/master/rf712__lagrangianmorphfit_8py.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html,2,['cache'],['cache']
Performance,"});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2471. Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called rdfentry_ and rdfslot_. The rdfentry_ column is of type ULong64_t and it holds the current entry number while rdfslot_ is an unsigned int holding the index of the current data processing slot. For backwards compatibility reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; Certain actions, on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:62654,multi-thread,multi-thread,62654,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-thread']
Performance,"});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2640. Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called rdfentry_ and rdfslot_. The rdfentry_ column is of type ULong64_t and it holds the current entry number while rdfslot_ is an unsigned int holding the index of the current data processing slot. For backwards compatibility reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; Certain actions, on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:64076,multi-thread,multi-thread,64076,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-thread']
Performance,"})]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34883,load,loading,34883,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['loading']
Performance,"}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:27335,cache,cache,27335,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance,"},; {(char*)""__reshape__"", (PyCFunction)op_reshape, METH_O,; (char*)""cast pointer to 1D array type""},; {(char*)nullptr, nullptr, 0, nullptr}; }; CPyCppyy::op_reshapestatic PyObject * op_reshape(CPPInstance *self, PyObject *shape)Definition CPPInstance.cxx:330; CPyCppyy::op_dispatchstatic PyObject * op_dispatch(PyObject *self, PyObject *args, PyObject *)Definition CPPInstance.cxx:277; CPyCppyy::op_destructstatic PyObject * op_destruct(CPPInstance *self)Definition CPPInstance.cxx:266. Definition at line 405 of file CPPInstance.cxx. ◆ RefFloat_Type. PyTypeObject CPyCppyy::RefFloat_Type. Initial value:= { ; PyObject_HEAD_INIT( &PyType_Type ) 0 ,; (char*)""cppyy.Double"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,; Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |; Py_TPFLAGS_BASETYPE, ; (char*)""CPyCppyy float object for pass by reference"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0,; &PyFloat_Type, ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ; ; ; ; ; ; ; ; ; }. Custom ""builtins,"" detectable by type, for pass by ref and improved performance. ; Definition at line 27 of file CustomPyTypes.cxx. ◆ RefInt_Type. PyTypeObject CPyCppyy::RefInt_Type. Initial value:= { ; PyObject_HEAD_INIT( &PyType_Type ) 0 ,; (char*)""cppyy.Long"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,; Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |; Py_TPFLAGS_BASETYPE; ; ; ; , ; (char*)""CPyCppyy long object for pass by reference"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0,; &PyInt_Type, ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ; ; ; ; ; ; ; ; ; }. Definition at line 49 of file CustomPyTypes.cxx. ◆ SMALL_ARGS_N. const int CPyCppyy::SMALL_ARGS_N = 8. Definition at line 13 of file CallContext.h. ◆ TemplateProxy_Type. PyTypeObject CPyCppyy::TemplateProxy_Type. Definition at line 890 of file TemplateProxy.cxx. ◆ tpp_as_mapping. PyMappingMethods CPyCppyy::tpp_as_mapping. static . Initial value:= {; nullptr, (binaryfunc)tpp_subscript, nullptr; }. Definition at line 754 of file TemplateProxy.cxx. ◆ tpp_getset. PyGetSetDef CPyCppyy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:68385,perform,performance,68385,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['perform'],['performance']
Performance,"}; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:41108,cache,cache,41108,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,}; 5372 return nullptr;; 5373}; 5374 ; 5375////////////////////////////////////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:214172,cache,cache,214172,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char *pool); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char *cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char *vmname, const char *cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char *pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCondor.html:6675,perform,performance,6675,root/html526/TCondor.html,https://root.cern,https://root.cern/root/html526/TCondor.html,1,['perform'],['performance']
Performance,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfCPUParList of par files to be loaded for CPU benchmarks; TStringfCPUSelSelector to be used for CPU benchmarks; TProofBenchDataSet*fDSInstance to handle datasets operations; TStringfDataGenParList of par files to be loaded to generate data for benchmarks; TStringfDataGenSelSelector to be used for generate data for benchmarks; TStringfDataParList of par files to be loaded for data benchmarks; TStringfDataSelSelector to be used for data benchmarks; TStringfDataSetName of the dataset; Bool_tfDebugDebug switch; TNamed*fDescriptionStrings describing the cluster for this test (saved in the output file); TPBHistType*fHistTypeType of histograms for CPU runs; Int_tfNFilesWrkNumber of files generated files per worker; Int_tfNHistNumber of histograms to be created in default CPU runs; Int_tfNtriesNumber of times a measurement is repeated; Int_tfNumWrkMaxMax number of workers (required for dynamic setups); TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); Bool_tfReleaseCacheRelease cache for data reads between runs ; TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans; static TF1*fgFioFunction used for I/O rate fits; static TF1*fgFioVFunction used for I/O rate fits with non-constant Rcpu; static TF1*fgFp1Simple 1st degree polynomial; static TF1*fgFp1nNormalized 1st degree; static TF1*fgFp2Simple 2nd degree polynomial; static TF1*fgFp2nNormalized 2nd degree; static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:7259,load,loaded,7259,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,4,"['cache', 'load']","['cache', 'loaded']"
Performance,"~~{.cpp}; 1201df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1202df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1203~~~; 1204 ; 1205Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1206overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1207 ; 1208When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1209 ; 1210~~~{.cpp}; 1211// this throws an error (note the typo); 1212df.Define(""x"", ""0"").Filter(""x = 0"");; 1213~~~; 1214 ; 1215\anchor generic-actions; 1216### User-defined custom actions; 1217RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1218time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1219 ; 1220#### Implementing custom actions with Book(); 1221 ; 1222Through the Book() method, users can implement a custom action and have access to the same features; 1223that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1224event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1225 ; 1226~~~{.cpp}; 1227#include <ROOT/RDataFrame.hxx>; 1228#include <memory>; 1229 ; 1230class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1231 std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; 1232 std::vector<int> fPerThreadResults;; 1233 ; 1234public:; 1235 // We use a public type alias to advertise the type of the result of this action; 1236 using Result_t = int;; 1237 ; 1238 MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; 1239 ; 1240 // Called before the event loop to retrieve the address of the resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:71657,perform,perform,71657,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance,"~~{.cpp}; 1241df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1242df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1243~~~; 1244 ; 1245Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1246overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1247 ; 1248When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1249 ; 1250~~~{.cpp}; 1251// this throws an error (note the typo); 1252df.Define(""x"", ""0"").Filter(""x = 0"");; 1253~~~; 1254 ; 1255\anchor generic-actions; 1256### User-defined custom actions; 1257RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1258time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1259 ; 1260#### Implementing custom actions with Book(); 1261 ; 1262Through the Book() method, users can implement a custom action and have access to the same features; 1263that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1264event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1265 ; 1266~~~{.cpp}; 1267#include <ROOT/RDataFrame.hxx>; 1268#include <memory>; 1269 ; 1270class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1271 std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; 1272 std::vector<int> fPerThreadResults;; 1273 ; 1274public:; 1275 // We use a public type alias to advertise the type of the result of this action; 1276 using Result_t = int;; 1277 ; 1278 MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; 1279 ; 1280 // Called before the event loop to retrieve the address of the resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:73337,perform,perform,73337,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance," . ). Default constructor. ; Definition at line 61 of file TGeoParallelWorld.cxx. ◆ ~TGeoParallelWorld(). TGeoParallelWorld::~TGeoParallelWorld ; (; ). override . Destructor. ; Definition at line 76 of file TGeoParallelWorld.cxx. Member Function Documentation. ◆ AddNode(). void TGeoParallelWorld::AddNode ; (; const char * ; path). Add a node normally to this world. Overlapping nodes not allowed. ; Definition at line 92 of file TGeoParallelWorld.cxx. ◆ AddOverlap() [1/2]. void TGeoParallelWorld::AddOverlap ; (; const char * ; volname, . Bool_t ; activate = kTRUE . ). To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ; Better be done before misalignment ; Definition at line 120 of file TGeoParallelWorld.cxx. ◆ AddOverlap() [2/2]. void TGeoParallelWorld::AddOverlap ; (; TGeoVolume * ; vol, . Bool_t ; activate = kTRUE . ). To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ; Better be done before misalignment ; Definition at line 108 of file TGeoParallelWorld.cxx. ◆ BuildBVH(). void TGeoParallelWorld::BuildBVH ; (; ). Build the BVH acceleration structure. ; Definition at line 1315 of file TGeoParallelWorld.cxx. ◆ CheckBVH(). bool TGeoParallelWorld::CheckBVH ; (; void * ; bvh, . size_t ; expected_leaf_count . ); const. Check/validate the BVH acceleration structure. ; Definition at line 1261 of file TGeoParallelWorld.cxx. ◆ CheckOverlaps(). void TGeoParallelWorld::CheckOverlaps ; (; Double_t ; ovlp = 0.001). Check overlaps within a tolerance value. ; Definition at line 1245 of file TGeoParallelWorld.cxx. ◆ Class(). static TClass * TGeoParallelWorld::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoParallelWorld::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoParallelWorld::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:18791,optimiz,optimization,18791,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['optimiz'],['optimization']
Performance," . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawListOfPolyMarkers3D Class Reference. . Definition at line 281 of file TProofDraw.h. Classes; struct  Point4D_t;  . Public Member Functions;  TProofDrawListOfPolyMarkers3D ();  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; void Init (TTree *) override;  Init the tree. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawListOfPolyMarkers3D.html:1122,load,loaded,1122,doc/master/classTProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/doc/master/classTProofDrawListOfPolyMarkers3D.html,1,['load'],['loaded']
Performance," . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Types |; Private Attributes |; List of all members ; ROOT::Detail::RDF::RFilter< FilterF, PrevNodeRaw > Class Template Referencefinal. ; template<typename FilterF, typename PrevNodeRaw>; class ROOT::Detail::RDF::RFilter< FilterF, PrevNodeRaw >; Definition at line 57 of file RFilter.hxx. Public Member Functions;  RFilter (const RFilter &)=delete;  ;  RFilter (FilterF f, const ROOT::RDF::ColumnNames_t &columns, std::shared_ptr< PrevNode_t > pd, const RDFInternal::RColumnRegister &colRegister, std::string_view name="""", const std::string &variationName=""nominal"");  ;  ~RFilter ();  ; void AddFilterName (std::vector< std::string > &filters) final;  ; template<typename... ColTypes, std::size_t... S> ; bool CheckFilterHelper (unsigned int slot, Long64_t entry, TypeList< ColTypes... >, std::index_sequence< S... >);  ; bool CheckFilters (unsigned int slot, Long64_t entry) final;  ; void FinalizeSlot (unsigned int slot) final;  Clean-up operations to be performed at the end of a task. ;  ; std::shared_ptr< RDFGraphDrawing::GraphNode > GetGraph (std::unordered_map< void *, std::shared_ptr< RDFGraphDrawing::GraphNode > > &visitedMap) final;  ; template<typename ColType > ; auto GetValueChecked (unsigned int slot, std::size_t readerIdx, Long64_t entry) -> ColType &;  ; std::shared_ptr< RNodeBase > GetVariedFilter (const std::string &variationName) final;  Return a clone of this Filter that works with values in the variationName ""universe"". ;  ; void IncrChildrenCount () final;  ; void InitSlot (TTreeReader *r, unsigned int slot) final;  ; RFilter & operator= (const RFilter &)=delete;  ; void PartialReport (ROOT::RDF::RCutFlowReport &rep) const final;  ; void Report (ROOT::RDF::RCutFlowReport &rep) const final;  ; void StopProcessing () final;  ; void TriggerChildrenCount () final;  ;  Public Member Functions inherited from ROOT::Detail::RDF::RFilterBase;  RFilterBase (RLoopManager *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilter.html:1182,perform,performed,1182,doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilter.html,1,['perform'],['performed']
Performance," . Protected Types; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  . Protected Member Functions; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:9947,cache,cache,9947,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['cache'],['cache']
Performance," ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:1005,optimiz,optimized,1005,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance," ; Bool_t fIsGeomReading;  ; Bool_t fIsNodeSelectable;  switch ON/OFF volume activity (default OFF - all volumes active)) ;  ; Int_t * fKeyPNEId;  ; Bool_t fLoopVolumes;  flag that geometry is closed ;  ; TGeoVolume * fMasterVolume;  top physical node ;  ; TList * fMaterials;  ; TObjArray * fMatrices;  current painter ;  ; Bool_t fMatrixReflection;  flag for using GL matrix ;  ; Bool_t fMatrixTransform;  flag that the list of physical nodes has to be drawn ;  ; Int_t fMaxThreads;  ; Int_t fMaxVisNodes;  ; TList * fMedia;  ; Bool_t fMultiThread;  Max number of threads. ;  ; NavigatorsMap_t fNavigators;  ; Int_t fNLevel;  table of elements ;  ; Int_t fNNodes;  upper time limit for tracks drawing ;  ; TObjArray * fNodes;  ; Int_t fNpdg;  current track ;  ; Int_t fNPNEId;  ; Int_t fNsegments;  ; Int_t fNtracks;  ; TObjArray * fOpticalSurfaces;  ; TObjArray * fOverlaps;  ; TVirtualGeoPainter * fPainter;  flag that nodes are the selected objects in pad rather than volumes ;  ; TGeoVolume * fPaintVolume;  ; TGeoParallelWorld * fParallelWorld;  ; TString fParticleName;  path to current node ;  ; TString fPath;  ; Int_t fPdgId [1024];  ; TObjArray * fPdgNames;  ; Bool_t fPhiCut;  flag to notify that the manager is being destructed ;  ; Double_t fPhimax;  lowest range for phi cut ;  ; Double_t fPhimin;  ; TObjArray * fPhysicalNodes;  ; ConstPropMap_t fProperties;  ; Int_t fRaytraceMode;  Flag for multi-threading. ;  ; TObjArray * fRegions;  ; TObjArray * fShapes;  ; Int_t fSizePNEId;  array of physical node entries ;  ; TObjArray * fSkinSurfaces;  ; Bool_t fStreamVoxels;  flag volume lists loop ;  ; Bool_t fTimeCut;  ; Double_t fTmax;  lower time limit for tracks drawing ;  ; Double_t fTmin;  highest range for phi cut ;  ; TGeoNode * fTopNode;  top level volume in geometry ;  ; TGeoVolume * fTopVolume;  current volume ;  ; TObjArray * fTracks;  list of runtime volumes ;  ; TObjArray * fUniqueVolumes;  ; Bool_t fUsePWNav;  Raytrace mode: 0=normal, 1=pass through, 2=transparent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:65745,multi-thread,multi-threading,65745,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['multi-thread'],['multi-threading']
Performance," ; Int_t GetIndex (const TGeoNode *node) const;  get index number for a given daughter ;  ; TGeoMaterial * GetMaterial () const;  ; TGeoMedium * GetMedium () const;  ; Int_t GetNdaughters () const;  ; TGeoNode * GetNode (const char *name) const;  get the pointer to a daughter node ;  ; TGeoNode * GetNode (Int_t i) const;  ; Int_t GetNodeIndex (const TGeoNode *node, Int_t *check_list, Int_t ncheck) const;  Get the index of a daughter within check_list by providing the node pointer. ;  ; TObjArray * GetNodes ();  ; Int_t GetNtotal () const;  ; Int_t GetNumber () const;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get volume info for the browser. ;  ; Bool_t GetOptimalVoxels () const;  Returns true if cylindrical voxelization is optimal. ;  ; Option_t * GetOption () const override;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; Int_t GetRefCount () const;  ; TGeoShape * GetShape () const;  ; Char_t GetTransparency () const;  ; TGeoExtension * GetUserExtension () const;  ; TGeoVoxelFinder * GetVoxels () const;  Getter for optimization structure. ;  ; void Grab ();  ; void GrabFocus ();  Move perspective view focus to this volume. ;  ; TGeoExtension * GrabFWExtension () const;  Get a copy of the framework extension pointer. ;  ; TGeoExtension * GrabUserExtension () const;  Get a copy of the user extension pointer. ;  ; void Gsord (Int_t);  ; void InspectMaterial () const;  Inspect the material for this volume. ;  ; void InspectShape () const;  ; void InvisibleAll (Bool_t flag=kTRUE);  Make volume and each of it daughters (in)visible. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsAdded () const;  ; Bool_t IsAllInvisible () const;  Return TRUE if volume and all daughters are invisible. ;  ; Bool_t IsCylVoxels () const;  ; Bool_t IsFolder () const override;  Return TRUE if volume contains nodes. ;  ; Bool_t IsOverlappingCandidate () const;  ; Bool_t IsRaytracing () const;  Check if th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:6660,optimiz,optimization,6660,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['optimiz'],['optimization']
Performance, ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGraphDelaunay::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TGraphDelaunay.h. Member Data Documentation. ◆ fAllTri. Bool_t TGraphDelaunay::fAllTri. protected . ! True if FindAllTriangles() has been performed on fGraph2D ; Definition at line 64 of file TGraphDelaunay.h. ◆ fDist. Double_t* TGraphDelaunay::fDist. protected . ! Array used to order mass points by distance ; Definition at line 56 of file TGraphDelaunay.h. ◆ fGraph2D. TGraph2D* TGraphDelaunay::fGraph2D. protected . ! 2D graph containing the user data ; Definition at line 66 of file TGraphDelaunay.h. ◆ fHullPoints. Int_t* TGraphDelaunay::fHullPoints. protected . ! Hull points of size fNhull ; Definition at line 62 of file TGraphDelaunay.h. ◆ fInit. Bool_t TGraphDelaunay::fInit. protected . ! True if CreateTrianglesDataStructure() and FindHull() have been performed ; Definition at line 65 of file TGraphDelaunay.h. ◆ fMaxIter. Int_t TGraphDelaunay::fMaxIter. protected . ! Maximum number of iterations to find Delaunay triangles ; Definition at line 57 of file TGraphDelaunay.h. ◆ fMTried. Int_t* TGraphDelaunay::fMTried. protected . ! ; Definition at line 61 of file TGraphDelaunay.h. ◆ fNdt. Int_t TGraphDelaunay::fNdt. protected . ! Number of Delaunay triangles found ; Definition at line 39 of file TGraphDelaunay.h. ◆ fNhull. Int_t TGraphDelaunay::fNhull. protected . ! Number of points in the hull ; Definition at line 41 of file TGraphDelaunay.h. ◆ fNpoints. Int_t TGraphDelaunay::fNpoints. protected . ! Number of data points in fGraph2D ; Definition at line 40 of file TGraphDelaunay.h. ◆ fNTried. Int_t* TGraphDelaunay::fNTried. protected . ! Delaunay triangles storage of size fNdt ; Definition at line 60 of file TGraphDelaunay.h. ◆ fOrder. Int_t* TGraphDelaunay::fOrder. protected . ! Array used to order mass points by distance ; Defini,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphDelaunay.html:23722,perform,performed,23722,doc/master/classTGraphDelaunay.html,https://root.cern,https://root.cern/doc/master/classTGraphDelaunay.html,1,['perform'],['performed']
Performance," ; bool IsChain () const;  ; bool IsInvalid () const;  ; bool Notify () override;  Notify director and values of a change in tree. ;  ; void SetTree (const char *keyname, TDirectory *dir, TEntryList *entryList=nullptr);  Set (or update) the which tree to read from, passing the name of a tree in a directory. ;  ; void SetTree (const char *keyname, TEntryList *entryList=nullptr);  ; void SetTree (TTree *tree, TEntryList *entryList=nullptr);  Set (or update) the which tree to read from. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Entry setters; bool Next ();  Move to the next entry (or index of the TEntryList if that is set). ;  ; EEntryStatus SetEntry (Long64_t entry);  Set the next entry (or index of the TEntryList if that is set). ;  ; EEntryStatus SetLocalEntry (Long64_t entry);  Set the next local tree entry. ;  ; EEntryStatus SetEntriesRange (Long64_t beginEntry, Long64_t endEntry);  Set the range of entries to be loaded by Next(); end will not be loaded. ;  ; std::pair< Long64_t, Long64_t > GetEntriesRange () const;  Get the begin and end entry numbers. ;  ; void Restart ();  Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set). ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:10035,load,loaded,10035,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,2,['load'],['loaded']
Performance," ; epsabs, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). virtual . This function computes, to an attempted specified accuracy, the value of the integral. ; Parameters. [in]nNumber of dimensions [2,15] ; [in]a,bOne-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; , . Int_t ; maxpts,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100153,perform,performed,100153,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['perform'],['performed']
Performance," ; nentries, . const char * ; opt, . TList * ; inl, . Long64_t ; first, . TDSet * ; dset, . const char * ; selec, . TObject * ; elist . ). private . Create a TProofQueryResult instance for this query. ; Definition at line 3530 of file TProofServ.cxx. ◆ NextQuery(). TProofQueryResult * TProofServ::NextQuery ; (; ). private . Get the next query from the waiting list. ; The query is removed from the list. ; Definition at line 6867 of file TProofServ.cxx. ◆ OldAuthSetup(). Int_t TProofServ::OldAuthSetup ; (; TString & ; conf). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 3492 of file TProofServ.cxx. ◆ Print(). void TProofServ::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print status of slave server. ; Reimplemented from TObject.; Definition at line 2506 of file TProofServ.cxx. ◆ ProcessNext(). void TProofServ::ProcessNext ; (; TString * ; slb = 0). protectedvirtual . process the next query from the queue of submitted jobs. ; to be called on the top master only. ; Definition at line 4416 of file TProofServ.cxx. ◆ QueueQuery(). Int_t TProofServ::QueueQuery ; (; TProofQueryResult * ; pq). private . Add a query to the waiting list Returns the number of queries in the list. ; Definition at line 6856 of file TProofServ.cxx. ◆ ReceiveFile(). Int_t TProofServ::ReceiveFile ; (; const char * ; file, . Bool_t ; bin, . Long64_t ; size . ). Receive a file, either sent by a client or a master server. ; If bin is true it is a binary file, other wise it is an ASCII file and we need to check for Windows \r tokens. Returns -1 in case of error, 0 otherwise. ; Definition at line 2578 of file TProofServ.cxx. ◆ RedirectOutput(). void TProofServ::RedirectOutput ; (; const char * ; dir = 0, . const char * ; mode = ""w"" . ). private . Redirect stdout to a log file. ; This log file will be flushed to the client or master after each command. ; Definition at line 2518 of file TProofServ.cxx. ◆ RegisterDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:50359,queue,queue,50359,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['queue'],['queue']
Performance," ; params = nullptr, . Int_t * ; error = nullptr . ). virtual . Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine(). Returns the result of the macro (return value or value of the last expression), cast to a Long_t. ; Reimplemented in TEveMacro.; Definition at line 262 of file TMacro.cxx. ◆ GetLineWith(). TObjString * TMacro::GetLineWith ; (; const char * ; text); const. virtual . Search the first line containing text. ; Definition at line 297 of file TMacro.cxx. ◆ GetListOfLines(). TList * TMacro::GetListOfLines ; (; ); const. inline . Definition at line 51 of file TMacro.h. ◆ IsA(). TClass * TMacro::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 59 of file TMacro.h. ◆ Load(). Bool_t TMacro::Load ; (; ); const. virtual . Load the macro into the interpreter. ; Return true in case the loading was successful. ; Definition at line 244 of file TMacro.cxx. ◆ operator=(). TMacro & TMacro::operator= ; (; const TMacro & ; macro). Copy constructor. ; Definition at line 120 of file TMacro.cxx. ◆ Paint(). void TMacro::Paint ; (; Option_t * ; option = """"). overridevirtual . Execute this macro (called by TPad::Paint). ; Reimplemented from TObject.; Definition at line 311 of file TMacro.cxx. ◆ Print(). void TMacro::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print contents of this macro. ; Reimplemented from TObject.; Definition at line 319 of file TMacro.cxx. ◆ ReadFile(). Int_t TMacro::ReadFile ; (; const char * ; filename). virtual . Read lines in filename in this macro. ; Definition at line 329 of file TMacro.cxx. ◆ SavePrimitive(). void TMacro::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save macro source on stream out. ; Reimplemented from TObject.; Definition at line 382 of file TMacro.cxx. ◆ SaveSource()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:18536,load,loading,18536,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['load'],['loading']
Performance," ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t MakeSelector (const char *selfile);  Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:20843,cache,cache,20843,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['cache'],['cache']
Performance," ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for size points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors.html:31452,perform,perform,31452,doc/master/classTGraphAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors.html,1,['perform'],['perform']
Performance," ; static const char * DeclFileName ();  ; static Int_t GetErrno ();  Static function returning system error number. ;  ; static void ResetErrno ();  Static function resetting system error number. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; const char * GetLinkedLibraries () override;  Get list of shared libraries loaded at the start of the executable. ;  ;  Protected Member Functions inherited from TSystem; virtual Bool_t ConsistentWith (const char *path, void *dirptr=nullptr);  Check consistency of this helper with the one required by 'path' or 'dirptr'. ;  ; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ;  Protected Mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:30428,load,loaded,30428,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['load'],['loaded']
Performance," ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TFile * fFile;  currently open file fCurrent points to the currently open list ;  ; TObjArray * fFileNames;  ! points to the fFiles data member of the corresponding chain ;  ; TString fListFileName;  from this string names of all files can be found ;  ; TString fListName;  name of the list ;  ; Long64_t * fListOffset;  [fNFiles] numbers of entries in ind. lists ;  ; Int_t fNFiles;  total number of files ;  ;  Protected Attributes inherited from TEntryList; TObjArray * fBlocks;  blocks with indices of passing events (TEntryListBlocks) ;  ; TEntryList * fCurrent;  ! currently filled entry list ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntriesToProcess;  used on proof to set the number of entries to process in a packet ;  ; TString fFileName;  name of the file, where the tree is ;  ; Long64_t fLastIndexQueried;  ! used to optimize GetEntry() function from a loop ;  ; Long64_t fLastIndexReturned;  ! used to optimize GetEntry() function from a loop ;  ; TList * fLists;  a list of underlying entry lists for each tree of a chain ;  ; Long64_t fN;  number of entries in the list ;  ; Int_t fNBlocks;  number of TEntryListBlocks ;  ; bool fReapply;  If true, TTree::Draw will 'reapply' the original cut. ;  ; bool fShift;  ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ;  ; ULong_t fStringHash;  ! Hash value of a string of treename and filename ;  ; TString fTreeName;  name of the tree ;  ; Int_t fTreeNumber;  ! the index of the tree in the chain (used when the entry list is used as input (TTree::SetEntryList()) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static constexpr auto kBigNumber = std::numeric_limits<Long64_t>:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:17169,optimiz,optimize,17169,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,2,['optimiz'],['optimize']
Performance," ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Static Public Attributes; static constexpr value_type NoCatIdx = std::numeric_limits<value_type>::min();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; const RooMappedCategoryCache * getOrCreateCache () const;  ; void recomputeShape () override;  When the input category changes states, the cached state mappings are invalidated. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:35242,cache,cached,35242,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cached']
Performance," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1670,optimiz,optimizerName,1670,doc/master/structTMVA_1_1TTrainingSettings.html,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html,4,['optimiz'],"['optimizerName', 'optimizerParams']"
Performance," ; using RVecC = ROOT::VecOps::RVec< char >;  ; using RVecD = ROOT::VecOps::RVec< double >;  ; using RVecF = ROOT::VecOps::RVec< float >;  ; using RVecI = ROOT::VecOps::RVec< int >;  ; using RVecL = ROOT::VecOps::RVec< long int >;  ; using RVecLL = ROOT::VecOps::RVec< long long int >;  ; using RVecU = ROOT::VecOps::RVec< unsigned int >;  ; using RVecUL = ROOT::VecOps::RVec< unsigned long int >;  ; using RVecULL = ROOT::VecOps::RVec< unsigned long long int >;  ; typedef std::map< std::string, std::list< SchemaRuleMap_t > > SchemaRuleClassMap_t;  ; typedef std::map< std::string, std::string > SchemaRuleMap_t;  ; typedef std::list< std::pair< ROOT::Internal::TSchemaType, std::string > > SourceTypeList_t;  ; using TDataFrame = ROOT::RDataFrame;  ; using TSeqI = TSeq< int >;  ; using TSeqL = TSeq< long >;  ; using TSeqU = TSeq< unsigned int >;  ; using TSeqUL = TSeq< unsigned long >;  ; using UInt32_v = UInt_t;  ; using UInt_v = UInt_t;  ; using WebWindowConnectCallback_t = std::function< void(unsigned)>;  function signature for connect/disconnect call-backs argument is connection id ;  ; using WebWindowDataCallback_t = std::function< void(unsigned, const std::string &)>;  function signature for call-backs from the window clients first argument is connection id, second is received data ;  ; using WebWindowDeleteCallback_t = std::function< void(RWebWindow &)>;  function signature for callback when RWebWindow destroyed ;  ; using WebWindowShowCallback_t = std::function< bool(RWebWindow &, const RWebDisplayArgs &)>;  function signature for catching show calls of arbitrary RWebWindow if returns true, normal show procedure will not be invoked ;  ; using WebWindowWaitFunc_t = std::function< int(double)>;  function signature for waiting call-backs Such callback used when calling thread need to waits for some special data, but wants to run application event loop As argument, spent time in second will be provided Waiting will be performed until function returns non-zero value ;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:10655,perform,performed,10655,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['perform'],['performed']
Performance," ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:40705,load,loaded,40705,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['load'],['loaded']
Performance," ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:23219,load,loaded,23219,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,5,['load'],['loaded']
Performance," ; void DrawRectangleAux (Drawable_t wid, const GCValues_t &gcVals, Int_t x, Int_t y, UInt_t w, UInt_t h);  ; void DrawSegments (Drawable_t wid, GContext_t gc, Segment_t *segments, Int_t nSegments) override;  Draws multiple line segments. ;  ; void DrawSegmentsAux (Drawable_t wid, const GCValues_t &gcVals, const Segment_t *segments, Int_t nSegments);  ; void DrawString (Drawable_t wid, GContext_t gc, Int_t x, Int_t y, const char *s, Int_t len) override;  Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ;  ; void DrawStringAux (Drawable_t wid, const GCValues_t &gc, Int_t x, Int_t y, const char *s, Int_t len);  ; Bool_t EmptyRegion (Region_t reg) override;  Returns kTRUE if the region reg is empty. ;  ; Bool_t EqualRegion (Region_t rega, Region_t regb) override;  Returns kTRUE if the two regions have the same offset, size, and shape. ;  ; Int_t EventsPending () override;  Returns the number of events that have been received from the X server but have not been removed from the event queue. ;  ; UInt_t ExecCommand (TGWin32Command *code) override;  Executes the command ""code"" coming from the other threads (Win32) ;  ; void FillPolygon (Window_t wid, GContext_t gc, Point_t *polygon, Int_t nPoints) override;  Fills the region closed by the specified path. ;  ; void FillPolygonAux (Window_t wid, const GCValues_t &gcVals, const Point_t *polygon, Int_t nPoints);  ; void FillRectangle (Drawable_t wid, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ;  ; void FillRectangleAux (Drawable_t wid, const GCValues_t &gcVals, Int_t x, Int_t y, UInt_t w, UInt_t h);  ; Window_t FindRWindow (Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd) override;  Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd. ;  ; void FlushOpenGL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:9749,queue,queue,9749,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,2,['queue'],['queue']
Performance," Class(). static TClass * TBufferIO::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TBufferIO::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TBufferIO::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 120 of file TBufferIO.h. ◆ DeclFileName(). static const char * TBufferIO::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 120 of file TBufferIO.h. ◆ ForceWriteInfo(). void TBufferIO::ForceWriteInfo ; (; TVirtualStreamerInfo * ; info, . Bool_t ; force . ). overridevirtual . force writing the TStreamerInfo to the file ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 329 of file TBufferIO.cxx. ◆ ForceWriteInfoClones(). void TBufferIO::ForceWriteInfoClones ; (; TClonesArray * ; a). overridevirtual . Make sure TStreamerInfo is not optimized, otherwise it will not be possible to support schema evolution in read mode. ; In case the StreamerInfo has already been computed and optimized, one must disable the option BypassStreamer. ; Implements TBuffer.; Definition at line 341 of file TBufferIO.cxx. ◆ GetBufferDisplacement(). Int_t TBufferIO::GetBufferDisplacement ; (; ); const. inlineoverridevirtual . Implements TBuffer.; Definition at line 81 of file TBufferIO.h. ◆ GetGlobalReadParam(). Int_t TBufferIO::GetGlobalReadParam ; (; ). static . Get default read map size. ; Definition at line 572 of file TBufferIO.cxx. ◆ GetGlobalWriteParam(). Int_t TBufferIO::GetGlobalWriteParam ; (; ). static . Get default write map size. ; Definition at line 580 of file TBufferIO.cxx. ◆ GetLastProcessID(). TProcessID * TBufferIO::GetLastProcessID ; (; TRefTable * ; reftable); const. overridevirtual . Return the last TProcessID in the file. ; Implements TBuffer.; Definition at line 399 of file TBufferIO.cxx. ◆ GetMapCount(). Int_t TBufferIO::GetMapCount ; (; ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:32497,optimiz,optimized,32497,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['optimiz'],['optimized']
Performance," Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; CacheElem * getCache (const RooArgSet *nset) const;  ; int idxmax (const double &m) const;  ; int idxmin (const double &m) const;  ; Int_t ij (const Int_t &i, const Int_t &j) const;  ; void initialize ();  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFunc.html:50489,cache,cached,50489,doc/master/classRooMomentMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFunc.html,2,['cache'],"['cache', 'cached']"
Performance," Class_Version(). static constexpr Version_t TMVA::Factory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 227 of file Factory.h. ◆ DeclFileName(). static const char * TMVA::Factory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 227 of file Factory.h. ◆ DeleteAllMethods(). void TMVA::Factory::DeleteAllMethods ; (; void ; ). Delete methods. ; Definition at line 324 of file Factory.cxx. ◆ EvaluateAllMethods(). void TMVA::Factory::EvaluateAllMethods ; (; void ; ). Iterates over all MVAs that have been booked, and calls their evaluation methods. ; Definition at line 1376 of file Factory.cxx. ◆ EvaluateAllVariables(). void TMVA::Factory::EvaluateAllVariables ; (; DataLoader * ; loader, . TString ; options = """" . ). Iterates over all MVA input variables and evaluates them. ; Definition at line 1360 of file Factory.cxx. ◆ EvaluateImportance(). TH1F * TMVA::Factory::EvaluateImportance ; (; DataLoader * ; loader, . VIType ; vitype, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). Evaluate Variable Importance. ; Definition at line 2217 of file Factory.cxx. ◆ EvaluateImportanceAll(). TH1F * TMVA::Factory::EvaluateImportanceAll ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2246 of file Factory.cxx. ◆ EvaluateImportanceRandom(). TH1F * TMVA::Factory::EvaluateImportanceRandom ; (; DataLoader * ; loader, . UInt_t ; nseeds, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2473 of file Factory.cxx. ◆ EvaluateImportanceShort(). TH1F * TMVA::Factory::EvaluateImportanceShort ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2358 of file Factory.cxx. ◆ GetImportance(). TH1F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:24090,load,loader,24090,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance," Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; TClass * IsA () const override;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:4297,cache,cache,4297,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance," Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:2660,cache,cache,2660,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],['cache']
Performance," Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  An",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:6861,cache,cache,6861,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance," Create and fill a histogram with the efficiency N[1] / ( N[1] + N[0] ), where N(1/0) is the number of data points with effCat=1 and effCat=0 as function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t=std::numeric_limits< std::size_t >::max()) const =0;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static StorageType defaultStorageType =RooAbsData::Vector;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void copyGlobalObservables (const RooAbsData &other);  ; void copyImpl (const RooAbsData &other, const char *newname);  . Private Attributes; const RooFit::UniqueId< RooAbsData > _uniqueId;  ! ;  . Friends; class RooAbsOptTestStatistic;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:30756,cache,cached,30756,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance," GetErrno ();  Static function returning system error number. ;  ; static void ResetErrno ();  Static function resetting system error number. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TUnixSystem; const char * GetLinkedLibraries () override;  Get list of shared libraries loaded at the start of the executable. ;  ;  Protected Member Functions inherited from TSystem; virtual Bool_t ConsistentWith (const char *path, void *dirptr=nullptr);  Check consistency of this helper with the one required by 'path' or 'dirptr'. ;  ; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:32233,load,loaded,32233,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,1,['load'],['loaded']
Performance," GetUser(). const char * TProof::GetUser ; (; ); const. inline . Definition at line 906 of file TProof.h. ◆ GetWorkDir(). const char * TProof::GetWorkDir ; (; ); const. inline . Definition at line 908 of file TProof.h. ◆ GoAsynchronous(). void TProof::GoAsynchronous ; (; ). Send GOASYNC message to the master. ; Definition at line 6267 of file TProof.cxx. ◆ GoMoreParallel(). Int_t TProof::GoMoreParallel ; (; Int_t ; nWorkersToAdd). private . Add nWorkersToAdd workers to current list of workers. ; This function is works on the master only, and only when an analysis is ongoing. A message is sent back to the client when we go ""more"" parallel. Returns -1 on error, number of total (not added!) workers on success. ; Definition at line 7170 of file TProof.cxx. ◆ GoParallel(). Int_t TProof::GoParallel ; (; Int_t ; nodes, . Bool_t ; attach = kFALSE, . Bool_t ; random = kFALSE . ). private . Go in parallel mode with at most ""nodes"" slaves. ; Since the fSlaves list is sorted by slave performace the active list will contain first the most performant nodes. Returns the number of active slaves. If random is TRUE, and nodes is less than the number of available workers, a random selection is done. Returns -1 in case of error. ; Definition at line 7273 of file TProof.cxx. ◆ HandleInputMessage(). Int_t TProof::HandleInputMessage ; (; TSlave * ; sl, . TMessage * ; mess, . Bool_t ; deactonfail = kFALSE . ). private . Analyze the received message. ; Returns 0 on success (1 if this the last message from this socket), -1 if any failure occurs. ; Definition at line 3105 of file TProof.cxx. ◆ HandleLibIncPath(). void TProof::HandleLibIncPath ; (; const char * ; what, . Bool_t ; add, . const char * ; dirs . ). protected . Handle lib, inc search paths modification request. ; Definition at line 8998 of file TProof.cxx. ◆ HandleOutputOptions(). Int_t TProof::HandleOutputOptions ; (; TString & ; opt, . TString & ; target, . Int_t ; action . ). protected . Extract from opt information about output ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:108291,perform,performace,108291,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['perform'],"['performace', 'performant']"
Performance," GetUser(). const char * TProofServ::GetUser ; (; ); const. inline . Definition at line 241 of file TProofServ.h. ◆ GetVirtMemMax(). Long_t TProofServ::GetVirtMemMax ; (; ). static . VirtMemMax getter. ; Definition at line 6920 of file TProofServ.cxx. ◆ GetWorkDir(). const char * TProofServ::GetWorkDir ; (; ); const. inline . Definition at line 243 of file TProofServ.h. ◆ GetWorkers(). TProofServ::EQueryAction TProofServ::GetWorkers ; (; TList * ; workers, . Int_t & ; prioritychange, . Bool_t ; resume = kFALSE . ). virtual . Get list of workers to be used from now on. ; The list must be provided by the caller. ; Definition at line 5692 of file TProofServ.cxx. ◆ HandleArchive(). void TProofServ::HandleArchive ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle archive request. ; Definition at line 3597 of file TProofServ.cxx. ◆ HandleCache(). Int_t TProofServ::HandleCache ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here all cache and package requests. ; Definition at line 5280 of file TProofServ.cxx. ◆ HandleCheckFile(). void TProofServ::HandleCheckFile ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle file checking request. ; Definition at line 5129 of file TProofServ.cxx. ◆ HandleDataSets(). Int_t TProofServ::HandleDataSets ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here requests about datasets. ; Definition at line 6087 of file TProofServ.cxx. ◆ HandleException(). void TProofServ::HandleException ; (; Int_t ; sig). overridevirtual . Exception handler: we do not try to recover here, just exit. ; Reimplemented from TApplication.; Definition at line 6070 of file TProofServ.cxx. ◆ HandleFork(). void TProofServ::HandleFork ; (; TMessage * ; mess). protectedvirtual . Cloning itself via fork. Not implemented. ; Reimplemented in TProofServLite.; Definition at line 6654 of file TProofServ.cxx. ◆ HandleLibIncPath(). Int_t TProofServ::HandleLibIncPath ; (; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:44084,cache,cache,44084,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['cache'],['cache']
Performance," InitWindow (ULong_t window) override;  Creates a new window and return window number. ;  ; Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist) override;  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; void IntersectRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the intersection of two regions. ;  ; TClass * IsA () const override;  ; Bool_t IsCmdThread () const override;  ; Bool_t IsCocoaDraw () const;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist) override;  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; Int_t KeysymToKeycode (UInt_t keysym) override;  Converts the ""keysym"" to the appropriate keycode. ;  ; char ** ListFonts (const char *fontname, Int_t max, Int_t &count) override;  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; FontStruct_t LoadQueryFont (const char *font_name) override;  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t wid) override;  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID) override;  Makes context ctx current OpenGL context. ;  ; void MapRaised (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t wid) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:16959,load,loads,16959,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['load'],['loads']
Performance," Initializes the X system. ;  ; virtual Int_t InitWindow (ULongptr_t window);  Creates a new window and return window number. ;  ; virtual Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist);  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; virtual void IntersectRegion (Region_t rega, Region_t regb, Region_t result);  Computes the intersection of two regions. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsCmdThread () const;  ; virtual Bool_t IsDNDAware (Window_t win, Atom_t *typelist);  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; virtual Int_t KeysymToKeycode (UInt_t keysym);  Converts the ""keysym"" to the appropriate keycode. ;  ; virtual char ** ListFonts (const char *fontname, Int_t max, Int_t &count);  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; virtual FontStruct_t LoadQueryFont (const char *font_name);  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; virtual void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym);  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; virtual void LowerWindow (Window_t id);  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; virtual Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID);  Makes context ctx current OpenGL context. ;  ; virtual void MapGCFont (GContext_t, FontStruct_t);  Map the XftFont with the Graphics Context using it. ;  ; virtual void MapRaised (Window_t id);  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; virtual void MapSubwindows (Window_t id);  Maps all subw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:18471,load,loads,18471,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['load'],['loads']
Performance," MnUserParameterState;  class which holds the external user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand; More...;  ; class  MnUserTransformation;  class dealing with the transformation between user specified parameters (external) and internal parameters used for minimization More...;  ; class  MnVectorTransform;  ; class  ModularFunctionMinimizer;  Base common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters. More...;  ; class  MPIProcess;  ; class  MPITerminate;  ; class  NegativeG2LineSearch;  In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive. More...;  ; class  Numerical2PGradientCalculator;  class performing the numerical gradient calculation More...;  ; class  NumericalDerivator;  ; class  ParametricFunction;  Function which has parameters. More...;  ; class  PrefixStack;  ; class  ScanBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  ScanMinimizer;  Class implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. More...;  ; class  SimplexBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  SimplexMinimizer;  Class implementing the required methods for a minimization using Simplex. More...;  ; class  SimplexParameters;  class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process. More...;  ; class  SimplexSeedGenerator;  generate Simplex starting point (state) More...;  ; class  SinParameterTransformation;  class for the transformation for double-li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:10991,perform,performing,10991,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['perform'],['performing']
Performance," ROOT::Experimental::Detail::RCheckedMenuItem;  Menu item with check box. More...;  ; class  ROOT::Experimental::RColor;  The color class. More...;  ; class  ROOT::Experimental::RDisplayItem;  Base class for painting data for JS. More...;  ; class  ROOT::Experimental::RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  ROOT::Experimental::RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  ROOT::Experimental::RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  ROOT::Experimental::RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  ROOT::Experimental::RDrawableReply;  Base class for replies on RDrawableRequest. More...;  ; class  ROOT::Experimental::RDrawableRequest;  Base class for requests which can be submitted from the clients. More...;  ; class  ROOT::Experimental::RFrame;  Holds an area where drawing on user coordinate-system can be performed. More...;  ; class  ROOT::Experimental::RIndirectDisplayItem;  Extract (reference) only basic attributes from drawable, but not drawable itself. More...;  ; class  ROOT::Experimental::Internal::RIOSharedBase;  ; class  ROOT::Experimental::Detail::RMenuArgument;  Argument description for menu item which should invoke class method. More...;  ; class  ROOT::Experimental::Detail::RMenuItem;  Base class for menu items, shown on JS side. More...;  ; class  ROOT::Experimental::RMenuItems;  List of items for object context menu. More...;  ; class  ROOT::Experimental::ROnFrameDrawable;  Base class for drawable which can be drawn on frame or on pad. More...;  ; class  ROOT::Experimental::RPad;  Graphic container for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBase;  Base class for graphic containers for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBaseDisplayItem;  class RPadBaseDisplayItem More...;  ; class  ROOT::Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GpadROOT7.html:3124,perform,performed,3124,doc/master/group__GpadROOT7.html,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html,1,['perform'],['performed']
Performance," ReadMap (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadMapHelper (StreamHelper *i, Value *v, Bool_t vsn3, TBuffer &b);  ; void ReadObjects (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadPairFromMap (int nElements, TBuffer &b);  ; void ReadPrimitives (int nElements, TBuffer &b, const TClass *onfileClass);  ; void WriteMap (int nElements, TBuffer &b);  ; void WriteObjects (int nElements, TBuffer &b);  ; void WritePrimitives (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:9885,cache,cache,9885,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['cache'],['cache']
Performance," Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::string _binningName;  Name of binning to be used for cache histogram. ;  ; RooRealProxy func;  Proxy to functions whose running integral is calculated. ;  ; RooRealProxy x;  Integrated observable. ;  ;  Protected Attributes inherited from RooAbsCachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:57348,cache,cache,57348,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance," Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _allExtendable = false;  Flag indicating if all PDF components are extendable. ;  ; RooAICRegistry _codeReg = 10;  ! Registry of component analytical integration codes ;  ; std::vector< double > _coefCache;  ! Transient cache with transformed values of coefficients ;  ; Int_t _coefErrCount;  ! Coefficient error counter ;  ; RooListProxy _coefList;  List of coefficients. ;  ; bool _haveLastCoef = false;  Flag indicating if last PDFs coefficient was supplied in the constructor. ;  ; RooObjCacheManager _intCacheMgr;  ! Manager of cache with integrals ;  ; RooArgSet _ownedComps;  ! Owned components ;  ; RooListProxy _pdfList;  List of component PDFs. ;  ; RooObjCacheManager _projCacheMgr;  ! Manager of cache with coefficient projections and transformations ;  ; RooSetProxy _refCoefNorm;  ! Reference observable set for coefficient interpretation ;  ; TNamed * _refCoefRangeName = nullptr;  ! Reference range name for coefficient interpretation ;  ; RooArgList * _snormList {nullptr};  ! List of supplemental normalization factors ;  ;  Protected Attributes inherited from RooResolutionModel; RooFormulaVar * _basis = nullptr;  Basis function convolved with this resolution model. ;  ; Int_t _basisCode;  Identifier code for selected basis function. ;  ; bool _ownBasis;  Flag indicating ownership of _basis. ;  ; RooTemplateProxy< RooAbsRealLValue > x;  Dependent/convolution variable. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:71910,cache,cache,71910,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance," Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  Public Member Functions inherited from RooProjectedPdf;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:1546,cache,cache,1546,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['cache'],['cache']
Performance," Return p.d.f. ;  ; std::vector< double > scanPdf (RooRealVar &obs, RooAbsPdf &pdf, const RooDataHist &hist, const RooArgSet &slicePos, Int_t &N, Int_t &N2, Int_t &zeroBin, double shift) const;  Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos' N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins The return value is an array of doubles of length N2 with the sampled values. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual const char * payloadUniqueSuffix () const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:70616,cache,cache,70616,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchSTL.html:7261,cache,cached,7261,doc/master/classTBranchSTL.html,https://root.cern,https://root.cern/doc/master/classTBranchSTL.html,2,['cache'],"['cache', 'cached']"
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compressio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:7557,cache,cached,7557,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,2,['cache'],"['cache', 'cached']"
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:8042,cache,cached,8042,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,2,['cache'],"['cache', 'cached']"
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:12813,cache,cached,12813,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,2,['cache'],"['cache', 'cached']"
Performance," Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void setExtended (bool extended);  . Static Private Member Functions; static double analyticalIntegralWN (RooAbsReal const &caller, RooObjCacheManager &normIntMgr, RooArgList const &funcList, RooArgList const &coefList, Int_t code, const RooArgSet *normSet, const char *rangeName, bool hasWarnedBefore);  ; static std::list< double > * binBoundaries (RooArgList const &funcList, RooAbsRealLValue &, double, double);  ; static bool checkObservables (RooAbsReal const &caller, RooArgSet const *nset, RooArgList const &funcList, RooArgList const &coefList);  ; static double evaluate (RooAbsReal const &caller, RooArgList const &funcList, RooArgList const &coefList, bool doFloor, bool &hasWarnedBefore);  ; static Int_t getAnalyticalIntegralWN (RooAbsReal const &caller, RooObjCacheManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:66310,cache,cache,66310,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['cache'],['cache']
Performance," StreamerNVirtual(). void TVirtualStreamerInfo::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 216 of file TVirtualStreamerInfo.h. ◆ TagFile(). virtual void TVirtualStreamerInfo::TagFile ; (; TFile * ; fFile). pure virtual . Implemented in TStreamerInfo. ◆ Update(). virtual void TVirtualStreamerInfo::Update ; (; const TClass * ; oldClass, . TClass * ; newClass . ). pure virtual . Implemented in TStreamerInfo. Member Data Documentation. ◆ fgCanDelete. Bool_t TVirtualStreamerInfo::fgCanDelete = kTRUE. staticprotected . true if the StreamerInfo has been compiled (i.e. fully built, ready to use for streaming). ; Definition at line 52 of file TVirtualStreamerInfo.h. ◆ fgInfoFactory. TVirtualStreamerInfo * TVirtualStreamerInfo::fgInfoFactory = nullptr. staticprotected . Definition at line 55 of file TVirtualStreamerInfo.h. ◆ fgOptimize. Bool_t TVirtualStreamerInfo::fgOptimize = kTRUE. staticprotected . Definition at line 53 of file TVirtualStreamerInfo.h. ◆ fgStreamMemberWise. Bool_t TVirtualStreamerInfo::fgStreamMemberWise = kTRUE. staticprotected . Definition at line 54 of file TVirtualStreamerInfo.h. ◆ fIsBuilt. Bool_t TVirtualStreamerInfo::fIsBuilt. protected . true if the StreamerInfo has been optimized ; Definition at line 48 of file TVirtualStreamerInfo.h. ◆ fIsCompiled. std::atomic<Bool_t> TVirtualStreamerInfo::fIsCompiled. protected . true if the StreamerInfo has been 'built' (i.e. has all the StreamerElements it should have) ; Definition at line 49 of file TVirtualStreamerInfo.h. ◆ fOptimized. Bool_t TVirtualStreamerInfo::fOptimized. protected . Definition at line 47 of file TVirtualStreamerInfo.h. Libraries for TVirtualStreamerInfo:. [legend]; The documentation for this class was generated from the following files:; core/meta/inc/TVirtualStreamerInfo.h; core/meta/src/TVirtualStreamerInfo.cxx. TVirtualStreamerInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:35023,optimiz,optimized,35023,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['optimiz'],['optimized']
Performance," TEveCalo3D (TEveCaloData *d=nullptr, const char *n=""TEveCalo3D"", const char *t=""xx"");  Constructor. ;  ;  ~TEveCalo3D () override;  ; void ComputeBBox () override;  Fill bounding-box information of the base-class TAttBBox (virtual method). ;  ; Char_t GetFrameTransparency () const;  ; Float_t GetFrameWidth () const;  ; Bool_t GetRnrBarrelFrame () const;  ; Bool_t GetRnrEndCapFrame () const;  ; void GetRnrFrame (Bool_t &e, Bool_t &b) const;  ; TClass * IsA () const override;  ; void SetFrameTransparency (Char_t x);  ; void SetFrameWidth (Float_t w);  ; void SetRnrBarrelFrame (Bool_t r);  ; void SetRnrEndCapFrame (Bool_t r);  ; void SetRnrFrame (Bool_t e, Bool_t b);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveCaloViz;  TEveCaloViz (TEveCaloData *data=nullptr, const char *n=""TEveCaloViz"", const char *t="""");  ;  ~TEveCaloViz () override;  Destructor. ;  ; Bool_t AssertCellIdCache () const;  Assert cell id cache is ok. ;  ; TEveRGBAPalette * AssertPalette ();  Make sure the TEveRGBAPalette pointer is not null. ;  ; Bool_t CellInEtaPhiRng (TEveCaloData::CellData_t &) const;  Returns true if given cell is in the ceta phi range. ;  ; virtual void CellSelectionChanged ();  ; void DataChanged ();  Update setting and cache on data changed. ;  ; TEveElement * ForwardEdit () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; TEveElement * ForwardSelection () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; Bool_t GetAutoRange () const;  ; Float_t GetBackwardEndCapPos () const;  ; Float_t GetBarrelRadius () const;  ; TEveCaloData * GetData () const;  ; Color_t GetDataSliceColor (Int_t slice) const;  Get slice color from data. ;  ; Float_t GetDataSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Float_t GetEndCapPos () const;  ; Float_t GetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo3D.html:1526,cache,cache,1526,doc/master/classTEveCalo3D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo3D.html,1,['cache'],['cache']
Performance," Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; bool CreateMinimizer ();  internal function to create the minimizer for finding the contours ;  ; void ResetLimits ();  reset the cached limit values ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; RooArgSet * fBestFitParams;  snapshot of the model parameters with best fit value (managed internally) ;  ; double fConfidenceLevel;  Requested confidence level (eg. 0.95 for 95% CL) ;  ; std::shared_ptr< RooFunctor > fFunctor;  ! transient pointer to functor class used by the minimizer ;  ; RooAbsReal * fLikelihoodRatio;  likelihood ratio function used to make contours (managed internally) ;  ; std::map< std::string, double > fLowerLimits;  map with cached lower bound values ;  ; std::shared_ptr< ROOT::Math::IMultiGenFunction > fMinFunc;  ! transient pointer to the minimization function ;  ; std::shared_ptr< ROOT::Math::Minimizer > fMinimizer;  ! transient pointer to minimizer class used to find limits and contour ;  ; RooArgSet fParameters;  parameters of interest for this interval ;  ; std::map< std::string, double > fUpperLimits;  map with cached upper bound values ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html:14906,cache,cached,14906,doc/master/classRooStats_1_1LikelihoodInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html,2,['cache'],['cached']
Performance," TypeInfo_RefType(). int TCling::TypeInfo_RefType ; (; TypeInfo_t * ; tinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 9404 of file TCling.cxx. ◆ TypeInfo_Size(). int TCling::TypeInfo_Size ; (; TypeInfo_t * ; tinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 9412 of file TCling.cxx. ◆ TypeInfo_TrueName(). const char * TCling::TypeInfo_TrueName ; (; TypeInfo_t * ; tinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 9420 of file TCling.cxx. ◆ TypeName(). const char * TCling::TypeName ; (; const char * ; typeDesc). finalvirtual . Return the absolute type of typeDesc. ; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"". You need to use the result immediately before it is being overwritten. ; Implements TInterpreter.; Definition at line 5478 of file TCling.cxx. ◆ UnloadAllSharedLibraryMaps(). Int_t TCling::UnloadAllSharedLibraryMaps ; (; ). finalvirtual . Unload the library map entries coming from all the loaded shared libraries. ; Returns 0 if succesful ; Implements TInterpreter.; Definition at line 5998 of file TCling.cxx. ◆ UnloadFile(). int TCling::UnloadFile ; (; const char * ; path); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7648 of file TCling.cxx. ◆ UnloadLibraryMap(). Int_t TCling::UnloadLibraryMap ; (; const char * ; library). finalvirtual . Unload library map entries coming from the specified library. ; Returns -1 in case no entries for the specified library were found, 0 otherwise. ; Implements TInterpreter.; Definition at line 6016 of file TCling.cxx. ◆ UnRegisterTClassUpdate(). void TCling::UnRegisterTClassUpdate ; (; const TClass * ; oldcl). finalvirtual . If the dictionary is loaded, we can remove the class from the list (otherwise the class might be loaded twice). ; Implements TInterpreter.; Definition at line 2393 of file TCling.cxx. ◆ UpdateAllCanvases(). void TCling::UpdateAllCanvases ; (; ). static . Update all canvases",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:139582,load,loaded,139582,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:66721,cache,cache,66721,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,6,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:77334,cache,cache,77334,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsCachedPdf; using CacheElem = PdfCacheElem;  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:73138,cache,cache,73138,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:69571,cache,cache,69571,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,33,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:59581,cache,cache,59581,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,38,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class CacheElem;  ; class Grid2;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:59447,cache,cache,59447,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class CacheElem;  Current normalization set. ;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorph.html:72311,cache,cache,72311,doc/master/classRooMomentMorph.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorph.html,2,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class MorphCacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsCachedPdf; using CacheElem = PdfCacheElem;  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:76983,cache,cache,76983,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RICacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:59424,cache,cache,59424,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsAnaConvPdf;  ; class RooAddModel;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:72711,cache,cache,72711,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsTestStatistic;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:56773,cache,cache,56773,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAddGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:75086,cache,cache,75086,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:72676,cache,cache,72676,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,2,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooConvGenContext;  ; class RooNumConvPdf;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueCha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:60870,cache,cache,60870,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooHistConstraint;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  Oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:57118,cache,cache,57118,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; RooObjCacheManager _cacheMgr;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooJeffreysPrior.html:70194,cache,cache,70194,doc/master/classRooJeffreysPrior.html,https://root.cern,https://root.cern/doc/master/classRooJeffreysPrior.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache = false;  Flag to run object in passthrough (= non-caching mode) ;  . Friends; class PdfCacheElem;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:74542,cache,cache,74542,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache;  . Friends; class FuncCacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:58522,cache,cache,58522,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _doFast = false;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:70595,cache,cache,70595,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; double g (double x, double sigma) const;  . Private Attributes; bool _asymLeft = false;  ; bool _asymRight = false;  ; double _binWidth;  ; double * _dataPts = nullptr;  ; double * _dataWgts = nullptr;  ; double _hi;  ; double _lo;  ; double _lookupTable [_nPoints+1];  ; bool _mirrorLeft = false;  ; bool _mirrorRight = false;  ; Int_t _nEvents = 0;  ; double _rho;  ; double _sumWgt = 0.0;  ; Char_t _varName [128];  ; double * _weights = nullptr;  . Static Private Attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:72436,cache,cache,72436,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFraction (bool recursiveFraction);  . Private Attributes; std::unique_ptr< const RooArgSet > _copyOfLastNormSet = nullptr;  ! ;  ; RooFit::UniqueId< RooArgSet >::Value_t _idOfLast",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:73864,cache,cache,73864,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Friends; class RooAbsCachedReal;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:58897,cache,cache,58897,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Static Private Member Functions; static double analyticalIntegral (Int_t code, const char *rangeName, RooArgSet const &histObsList, RooArgSet const &pdfObsList, RooDataHist &dataHist, bool histFuncMode);  ; static bool forceAnalyticalInt (RooArgSet const &pdfObsList, RooAbsArg const &dep);  ; static Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName, RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:71801,cache,cache,71801,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void prepareFFTBinning (RooRealVar &convVar) const;  Try to improve the binning and inform user if possible. ;  . Friends; class FFTCacheElem;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:81945,cache,cache,81945,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  RooSimultaneous (const char *name, const char *title, InitializationOutput &&initInfo);  Private internal constructor. ;  . Static Private Member Functions; static std::unique_ptr< RooSimultaneous::InitializationOutput > initialize (std::string const &name, RooAbsCategoryLValue &inIndexCat, std::map< std::string, RooAbsPdf * > const &pdfMap);  . Private Attributes; std::unique_ptr< RooArgSet > _indexCatSet;  ! Index category wrapped in a RooArgSet if needed internally ;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:74207,cache,cache,74207,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:59582,cache,cache,59582,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static void doEvalImpl (RooAbsArg const *caller, RooFit::EvalContext &, RooAbsReal const &x, RooArgList const &coefs, int lowestOrder);  ; static void fillCoeffValues (std::vector< double > &wksp, RooListProxy const &coefList);  . Friends; class RooPolynomial;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyVar.html:56517,cache,cache,56517,doc/master/classRooPolyVar.html,https://root.cern,https://root.cern/doc/master/classRooPolyVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _cacheAllNDim;  ! Cache all integrals with given numeric dimension ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:59987,cache,cache,59987,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:64660,cache,cache,64660,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:57350,cache,cache,57350,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:77309,cache,cache,77309,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:63932,cache,cache,63932,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumFunc.html:50047,cache,cache,50047,doc/master/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/master/classRooRealSumFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:58779,cache,cache,58779,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _printScientific;  ; static Int_t _printSigDigits;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:70003,cache,cache,70003,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:73025,cache,cache,73025,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,17,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsRealLValue.h>. Inheritance diagram for RooAbsRealLValue:. This browser is no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:66942,cache,cache,66942,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBinWidthFunction.h>. Inheritance diagram for RooBinWidthFunction:. This browser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:59497,cache,cache,59497,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooConstVar.h>. Inheritance diagram for RooConstVar:. This browser is not able to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstVar.html:58640,cache,cache,58640,doc/master/classRooConstVar.html,https://root.cern,https://root.cern/doc/master/classRooConstVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFit/TestStatistics/RooRealL.h>. Inheritance diagram for RooFit::TestStatistics:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html:59313,cache,cache,59313,doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFormulaVar.h>. Inheritance diagram for RooFormulaVar:. This browser is not able",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:61496,cache,cache,61496,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLagrangianMorphFunc.h>. Inheritance diagram for RooLagrangianMorphFunc:. This b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:69616,cache,cache,69616,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLinearCombination.h>. Inheritance diagram for RooLinearCombination:. This brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinearCombination.html:58920,cache,cache,58920,doc/master/classRooLinearCombination.html,https://root.cern,https://root.cern/doc/master/classRooLinearCombination.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMultiBinomial.h>. Inheritance diagram for RooMultiBinomial:. This browser is no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiBinomial.html:59565,cache,cache,59565,doc/master/classRooMultiBinomial.html,https://root.cern,https://root.cern/doc/master/classRooMultiBinomial.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumCdf.h>. Inheritance diagram for RooNumCdf:. This browser is not able to show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:62808,cache,cache,62808,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSpHarmonic.h>. Inheritance diagram for RooSpHarmonic:. This browser is not able",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:60883,cache,cache,60883,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSpline.h>. Inheritance diagram for RooSpline:. This browser is not able to show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:60498,cache,cache,60498,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStepFunction.h>. Inheritance diagram for RooStepFunction:. This browser is not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStepFunction.html:59253,cache,cache,59253,doc/master/classRooStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooStepFunction.html,1,['cache'],['cache']
Performance," _varsNoWgt;  Vars without weight variable. ;  ; RooRealVar * _wgtVar = nullptr;  Pointer to weight variable (if set) ;  ;  Protected Attributes inherited from RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from RooDirItem; TDirectory * _dir {nullptr};  ! Associated directory ;  . Private Member Functions; void loadValuesFromSlices (RooCategory &indexCat, std::map< std::string, RooAbsData * > const &slices, const char *rangeName, RooFormulaVar const *cutVar, const char *cutSpec);  . Private Attributes; bool _doWeightErrorCheck {true};  ! When adding events with weights, check that weights can actually be stored. ;  ; unsigned short _errorMsgCount {0};  ! Counter to silence error messages when filling dataset. ;  ; std::unique_ptr< std::vector< double > > _sumW2Buffer;  ! Buffer for sumW2 in case a batch of values is requested. ;  . Friends; class RooProdGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsData; using CategorySpans = std::map< RooFit::Detail::DataKey, std::span< const RooAbsCategory::value_type > >;  ; enum  ErrorType { ;   Poisson; , SumW2; , None; , Auto; , ;   Expected. };  ; using RealSpans = std::map< RooFit::Detail::DataKey, std::span< const double > >;  ; enum  StorageType { Tree; , Vector; , Composite; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:34495,load,loadValuesFromSlices,34495,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['load'],['loadValuesFromSlices']
Performance," basic3d.C Show 3-D polylines and markers ;  canvas.C Example of primitives in a canvas ;  canvas2.C Example of canvas partitioning ;  compile.C This macro produces the flowchart of TFormula::Compile ;  crown.C Draw crowns ;  diamond.C Draw a diamond ;  earth.C This tutorial illustrates the special contour options ;  ellipse.C Draw ellipses ;  eval.C This macro produces the flowchart of TFormula::Eval ;  event.C Illustrate some basic primitives ;  feynman.C Draw Feynman diagrams ;  first.C Show some basic primitives ;  formula1.C Display interpreted functions ;  framework.C An example with basic graphics illustrating the Object Oriented User Interface of ROOT ;  gaxis.C Simple example illustrating how to draw TGaxis objects in various formats ;  gaxis2.C Example illustrating how to draw TGaxis with labels defined by a function ;  gaxis3.C Example illustrating how to modify individual labels of a TGaxis ;  graph_edit_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive graphical editing operations ;  gtime.CExample of a graph of data moving in time ;  latex.C This macro draws 5 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex2.C This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex3.C Example illustrating a TPaveText with Latex inside ;  latex4.C Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files ;  latex5.C This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files ;  mandelbrot.C Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set ;  manyaxis.C Show several TGaxis formats ;  markerwarning.C This script illustrates the danger of using asymmetric symbols ;  mass_spectrum.C This macro makes use of some basic graphics primitives such as line, arrow and text ;  palettes.C This macro draws all the high definition palettes available in ROOT ;  pav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:113832,perform,perform,113832,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['perform'],['perform']
Performance," fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:56532,optimiz,optimize,56532,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance," fill () override;  Forward fill request to appropriate subset. ;  ; void forceCacheUpdate () override;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='idx') in memory and return a pointer to the internal RooArgSet holding its coordinates. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Retrieve batches for all observables in this data store. ;  ; std::span< const double > getWeightBatch (std::size_t first, std::size_t len) const override;  Get the weights of the events in the range [first, first+len). ;  ; bool hasFilledCache () const override;  ; RooCategory * index ();  ; TClass * IsA () const override;  ; bool isWeighted () const override;  ; void loadValues (const RooAbsDataStore *tds, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) override;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  ; Int_t numEntries () const override;  ; void recalculateCache (const RooArgSet *, Int_t, Int_t, Int_t, bool) override;  Forward recalculate request to all subsets. ;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void resetBuffers () override;  ; void resetCache () override;  ; void setArgStatus (const RooArgSet &set, bool active) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  Forward fill request to appropriate subset. ;  ; double weight () const override;  ; virtual double weight () const=0;  ; double we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:3302,load,loadValues,3302,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['load'],['loadValues']
Performance," forceAnalyticalInt(). bool RooAddPdf::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Force RooRealIntegral to offer all observables for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 50 of file RooAddPdf.h. ◆ genContext(). RooAbsGenContext * RooAddPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ; Reimplemented from RooAbsPdf.; Definition at line 901 of file RooAddPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAddPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Determine which part (if any) of given integral can be performed analytically. ; If any analytical integration is possible, return integration scenario code; RooAddPdf queries each component PDF for its analytical integration capability of the requested set ('allVars'). It finds the largest common set of variables that can be integrated by all components. If such a set exists, it reconfirms that each component is capable of analytically integrating the common set, and combines the components individual integration codes into a single integration code valid for RooAddPdf. ; Reimplemented from RooAbsReal.; Definition at line 631 of file RooAddPdf.cxx. ◆ getCoefNormalization(). const RooArgSet & RooAddPdf::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; ns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:88133,perform,performed,88133,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['perform'],['performed']
Performance," kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TStreamerInfo ();  Status bits See TVirtualStreamerInfo::EStatusBits for the values. ;  ;  TStreamerInfo (TClass *cl);  Create a TStreamerInfo object. ;  ;  ~TStreamerInfo () override;  TStreamerInfo dtor. ;  ; void Build (Bool_t isTransient=kFALSE) override;  Build the I/O data structure for the current class version. ;  ; void BuildCheck (TFile *file=nullptr, Bool_t load=kTRUE) override;  Check if built and consistent with the class dictionary. ;  ; void BuildEmulated (TFile *file) override;  Create an Emulation TStreamerInfo object. ;  ; Bool_t BuildFor (const TClass *cl) override;  Check if we can build this for foreign class - do we have some rules to do that. ;  ; void BuildOld () override;  rebuild the TStreamerInfo structure ;  ; void CallShowMembers (const void *obj, TMemberInspector &insp, Bool_t isTransient) const override;  Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. ;  ; void Clear (Option_t *="""") override;  If opt contains 'built', reset this StreamerInfo as if Build or BuildOld was never called on it (useful to force their re-running). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Bool_t CompareContent (TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) override;  Return True if the current StreamerI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:3908,load,load,3908,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['load'],['load']
Performance, wgtErrLoArray(). double const * RooDataHist::wgtErrLoArray ; (; ); const. inline . Definition at line 217 of file RooDataHist.h. Friends And Related Symbol Documentation. ◆ RooDataHistSliceIter. friend class RooDataHistSliceIter. friend . Definition at line 227 of file RooDataHist.h. Member Data Documentation. ◆ _arrSize. Int_t RooDataHist::_arrSize {0}. protected . Definition at line 246 of file RooDataHist.h. ◆ _binbounds. std::vector<std::vector<double> > RooDataHist::_binbounds. mutableprotected . ! list of bin bounds per dimension ; Definition at line 260 of file RooDataHist.h. ◆ _binv. double* RooDataHist::_binv {nullptr}. protected . [_arrSize] Bin volume array ; Definition at line 253 of file RooDataHist.h. ◆ _cache_sum. double RooDataHist::_cache_sum {0.}. mutableprotected . ! Cache for sum of entries ; ; Definition at line 264 of file RooDataHist.h. ◆ _cache_sum_valid. Int_t RooDataHist::_cache_sum_valid {kInvalid}. mutableprotected . ! Is cache sum valid? Needs to be Int_t instead of CacheSumState_t for subclasses. ; Definition at line 263 of file RooDataHist.h. ◆ _curIndex. ULong64_t RooDataHist::_curIndex {std::numeric_limits<ULong64_t>::max()}. mutableprotected . Current index. ; Definition at line 255 of file RooDataHist.h. ◆ _errHi. double* RooDataHist::_errHi {nullptr}. mutableprotected . [_arrSize] High-side error on weight array ; Definition at line 251 of file RooDataHist.h. ◆ _errLo. double* RooDataHist::_errLo {nullptr}. mutableprotected . [_arrSize] Low-side error on weight array ; Definition at line 250 of file RooDataHist.h. ◆ _idxMult. std::vector<Int_t> RooDataHist::_idxMult. protected . Definition at line 247 of file RooDataHist.h. ◆ _interpolationBuffer. std::vector<double> RooDataHist::_interpolationBuffer. private . ! Buffer to contain values used for weight interpolation ; Definition at line 280 of file RooDataHist.h. ◆ _lvbins. std::vector<std::unique_ptr<const RooAbsBinning> > RooDataHist::_lvbins. protected . ! List of used binning,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:87102,cache,cache,87102,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cache']
Performance,"  kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TVirtualStreamerInfo ();  Default constructor. ;  ;  TVirtualStreamerInfo (TClass *);  Default constructor. ;  ; virtual ~TVirtualStreamerInfo ();  Destructor. ;  ; virtual void Build (Bool_t isTransient=kFALSE)=0;  ; virtual void BuildCheck (TFile *file=nullptr, Bool_t load=kTRUE)=0;  ; virtual void BuildEmulated (TFile *file)=0;  ; virtual Bool_t BuildFor (const TClass *cl)=0;  ; virtual void BuildOld ()=0;  ; virtual void CallShowMembers (const void *obj, TMemberInspector &insp, Bool_t isTransient) const =0;  ; virtual void Clear (Option_t *="""") override=0;  Set name and title to empty strings (""""). ;  ; virtual Bool_t CompareContent (TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file)=0;  ; virtual void Compile ()=0;  ; virtual void DeleteArray (void *p, Bool_t dtorOnly=kFALSE)=0;  ; virtual void Destructor (void *p, Bool_t dtorOnly=kFALSE)=0;  ; virtual void ForceWriteInfo (TFile *file, Bool_t force=kFALSE)=0;  ; virtual TClassStreamer * GenEmulatedClassStreamer (const char *class_name, Bool_t silent)=0;  ; virtual TVirtualCollectionProxy * GenEmulatedProxy (const char *class_name, Bool_t silent)=0;  ; virtual Int_t GenerateHeaderFile (const char *dirname, const TList *subClasses=nullptr, const TList *extrainfos=nullptr)=0;  ; virtual TVirtualStreamerInfo * GenerateInfoForPair (const std::string &firstname, const std::string &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:2875,load,load,2875,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['load'],['load']
Performance,"’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one function. Setting this option to On will add the newly fitted function to the existing list of functions for the histogram. Note that the fitted functions are saved with the histogram when it is written to a ROOT file. By default, the function is drawn on the pad displaying the histogram.; 5.6.3 Draw Options; ‘SAME’ sets On/Off function drawing on the same pad. When a fit is executed, the image of the function is drawn on the current pad.; ‘No drawing’ sets On/Off the option “0”- do not draw the fit results.; ‘Do not store/draw’ sets On/Off option “N”- do not store the function and do not draw it.; 5.6.4 Advances Options; The advance option button is enabled only after having performed the fit and provides additional drawing options that can be used after having done the fit. These new drawing tools, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:186516,perform,performed,186516,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"◆ GetClass(). const char * TPluginHandler::GetClass ; (; ); const. inline . Definition at line 212 of file TPluginManager.h. ◆ GetCtor(). const char * TPluginHandler::GetCtor ; (; ); const. inlineprivate . Definition at line 139 of file TPluginManager.h. ◆ GetOrigin(). const char * TPluginHandler::GetOrigin ; (; ); const. inlineprivate . Definition at line 140 of file TPluginManager.h. ◆ GetPlugin(). const char * TPluginHandler::GetPlugin ; (; ); const. inlineprivate . Definition at line 138 of file TPluginManager.h. ◆ GetRegexp(). const char * TPluginHandler::GetRegexp ; (; ); const. inlineprivate . Definition at line 137 of file TPluginManager.h. ◆ IsA(). TClass * TPluginHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 254 of file TPluginManager.h. ◆ LoadPlugin(). Int_t TPluginHandler::LoadPlugin ; (; ). Load the plugin library for this handler. ; Returns 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 293 of file TPluginManager.cxx. ◆ LoadPluginImpl(). void TPluginHandler::LoadPluginImpl ; (; ). private . Load the plugin library for this handler. ; Sets status to 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 274 of file TPluginManager.cxx. ◆ operator=(). TPluginHandler & TPluginHandler::operator= ; (; const TPluginHandler & ; ). privatedelete . ◆ Print(). void TPluginHandler::Print ; (; Option_t * ; opt = """"); const. overridevirtual . Print info about the plugin handler. ; If option is ""a"" print also the ctor's that will be used. ; Reimplemented from TObject.; Definition at line 341 of file TPluginManager.cxx. ◆ SetupCallEnv(). void TPluginHandler::SetupCallEnv ; (; ). private . Setup ctor or static method call environment. ; Definition at line 198 of file TPluginManager.cxx. ◆ Streamer(). void TPluginHandler::Streamer ; (; TBuffer & ; R__b). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginHandler.html:17153,load,loading,17153,doc/master/classTPluginHandler.html,https://root.cern,https://root.cern/doc/master/classTPluginHandler.html,1,['load'],['loading']
Performance,"◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::RooCachedReal ; (; const RooCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 87 of file RooCachedReal.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedReal.; Definition at line 165 of file RooCachedReal.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ; If this p.d.f is operated in automatic mode, return the parameters of the external input p.d.f ; Implements RooAbsCachedReal.; Definition at line 178 of file RooCachedReal.cxx. ◆ cacheSource(). bool RooCachedReal::cacheSource ; (; ); const. inline . Definition at line 42 of file RooCachedReal.h. ◆ Class(). static TClass * RooCachedReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCachedReal::Class_Name ; (; ). static . ReturnsName of this class . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:65276,cache,cache,65276,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"◆ SetBaggedSampleFraction(). void TMVA::MethodBDT::SetBaggedSampleFraction ; (; Double_t ; f). inline . Definition at line 143 of file MethodBDT.h. ◆ SetMaxDepth(). void TMVA::MethodBDT::SetMaxDepth ; (; Int_t ; d). inline . Definition at line 134 of file MethodBDT.h. ◆ SetMinNodeSize() [1/2]. void TMVA::MethodBDT::SetMinNodeSize ; (; Double_t ; sizeInPercent). Definition at line 660 of file MethodBDT.cxx. ◆ SetMinNodeSize() [2/2]. void TMVA::MethodBDT::SetMinNodeSize ; (; TString ; sizeInPercent). Definition at line 674 of file MethodBDT.cxx. ◆ SetNodePurityLimit(). void TMVA::MethodBDT::SetNodePurityLimit ; (; Double_t ; l). inline . Definition at line 140 of file MethodBDT.h. ◆ SetNTrees(). void TMVA::MethodBDT::SetNTrees ; (; Int_t ; d). inline . Definition at line 138 of file MethodBDT.h. ◆ SetShrinkage(). void TMVA::MethodBDT::SetShrinkage ; (; Double_t ; s). inline . Definition at line 141 of file MethodBDT.h. ◆ SetTuneParameters(). void TMVA::MethodBDT::SetTuneParameters ; (; std::map< TString, Double_t > ; tuneParameters). virtual . Set the tuning parameters according to the argument. ; Reimplemented from TMVA::MethodBase.; Definition at line 1121 of file MethodBDT.cxx. ◆ SetUseNvars(). void TMVA::MethodBDT::SetUseNvars ; (; Int_t ; n). inline . Definition at line 142 of file MethodBDT.h. ◆ Streamer(). virtual void TMVA::MethodBDT::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodBDT::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 305 of file MethodBDT.h. ◆ TestTreeQuality(). Double_t TMVA::MethodBDT::TestTreeQuality ; (; DecisionTree * ; dt). Test the tree quality.. in terms of Misclassification. ; Definition at line 1696 of file MethodBDT.cxx. ◆ Train(). void TMVA::MethodBDT::Train ; (; void ; ). virtual . BDT training. ; Implements TMVA::MethodBase.; Definition at line 1142 of file MethodBDT.cxx. ◆ UpdateTargets(). void TMVA::MethodBDT::UpdateTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:58297,tune,tuneParameters,58297,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:56462,optimiz,optimize,56462,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance,"������ bin = 1 + Int_t(a +; 0.5);�� ������������ ; ������� PosX[i] =; d->GetBinCenter(bin);; ������� PosY[i] =; d->GetBinContent(bin);; �� }; �� TPolyMarker * pm =; (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; �� if (pm) {; �����; h->GetListOfFunctions()->Remove(pm);; ����� delete pm;; �� }; �� pm = new; TPolyMarker(nfound, PosX, PosY);; ��; h->GetListOfFunctions()->Add(pm);; �� pm->SetMarkerStyle(23);; ��; pm->SetMarkerColor(kRed);; �� pm->SetMarkerSize(1);��. }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Double_t* positionInit, const Bool_t* fixPosition, const Double_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:36289,optimiz,optimization,36289,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,2,['optimiz'],['optimization']
Performance,"������ bin = 1 + Int_t(a +; 0.5);�� ������������ ; ������� PosX[i] =; d->GetBinCenter(bin);; ������� PosY[i] =; d->GetBinContent(bin);; �� }; �� TPolyMarker * pm =; (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; �� if (pm) {; �����; h->GetListOfFunctions()->Remove(pm);; ����� delete pm;; �� }; �� pm = new; TPolyMarker(nfound, PosX, PosY);; ��; h->GetListOfFunctions()->Add(pm);; �� pm->SetMarkerStyle(23);; ��; pm->SetMarkerColor(kRed);; �� pm->SetMarkerSize(1);��. }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:35243,optimiz,optimization,35243,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,4,['optimiz'],['optimization']
Safety," """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:11345,timeout,timeout,11345,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,1,['timeout'],['timeout']
Safety," """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:11201,timeout,timeout,11201,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,1,['timeout'],['timeout']
Safety," """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; 209 Int_t header = GetOffsetHeaderSize();; 210 Int_t len = 0;; 211 for (Int_t idx = 0, offset = base; idx < events; idx++) {; 212 retval[idx] = offset;; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:5633,avoid,avoid,5633,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['avoid'],['avoid']
Safety," """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:16925,timeout,timeout,16925,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['timeout'],['timeout']
Safety," """", Option_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:11323,abort,abort,11323,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,1,['abort'],['abort']
Safety," """", Option_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:11179,abort,abort,11179,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,1,['abort'],['abort']
Safety," ""; 441 ""encounter problems.""; 442 << Endl;; 443 }; 444 ; 445 if (fArchitectureString == ""OPENCL"") {; 446 Log() << kERROR << ""The OPENCL architecture has not been implemented yet. ""; 447 ""Please use Architecture=CPU or Architecture=CPU for the ""; 448 ""time being. See the TMVA Users' Guide for instructions ""; 449 ""if you encounter problems.""; 450 << Endl;; 451 Log() << kFATAL << ""The OPENCL architecture has not been implemented yet. ""; 452 ""Please use Architecture=CPU or Architecture=CPU for the ""; 453 ""time being. See the TMVA Users' Guide for instructions ""; 454 ""if you encounter problems.""; 455 << Endl;; 456 }; 457 ; 458 if (fArchitectureString == ""GPU"") {; 459#ifndef DNNCUDA // Included only if DNNCUDA flag is _not_ set.; 460 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 461 ""you have CUDA installed and it was successfully ""; 462 ""detected by CMAKE.""; 463 << Endl;; 464 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 465 ""you have CUDA installed and it was successfully ""; 466 ""detected by CMAKE.""; 467 << Endl;; 468#endif // DNNCUDA; 469 }; 470 ; 471 if (fArchitectureString == ""CPU"") {; 472#ifndef DNNCPU // Included only if DNNCPU flag is _not_ set.; 473 Log() << kERROR << ""Multi-core CPU backend not enabled. Please make sure ""; 474 ""you have a BLAS implementation and it was successfully ""; 475 ""detected by CMake as well that the imt CMake flag is set.""; 476 << Endl;; 477 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 478 ""you have a BLAS implementation and it was successfully ""; 479 ""detected by CMake as well that the imt CMake flag is set.""; 480 << Endl;; 481#endif // DNNCPU; 482 }; 483 ; 484 //; 485 // Set network structure.; 486 //; 487 ; 488 fLayout = TMVA::MethodDNN::ParseLayoutString (fLayoutString);; 489 size_t inputSize = GetNVariables ();; 490 size_t outputSize = 1;; 491 if (fAnalysisType == Types::kRegression && GetNTargets() != 0) {; 492 outputSize = GetNTargets();; 493 } else if (fAnaly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:15899,detect,detected,15899,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety," ""; 454 ""if you encounter problems.""; 455 << Endl;; 456 }; 457 ; 458 if (fArchitectureString == ""GPU"") {; 459#ifndef DNNCUDA // Included only if DNNCUDA flag is _not_ set.; 460 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 461 ""you have CUDA installed and it was successfully ""; 462 ""detected by CMAKE.""; 463 << Endl;; 464 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 465 ""you have CUDA installed and it was successfully ""; 466 ""detected by CMAKE.""; 467 << Endl;; 468#endif // DNNCUDA; 469 }; 470 ; 471 if (fArchitectureString == ""CPU"") {; 472#ifndef DNNCPU // Included only if DNNCPU flag is _not_ set.; 473 Log() << kERROR << ""Multi-core CPU backend not enabled. Please make sure ""; 474 ""you have a BLAS implementation and it was successfully ""; 475 ""detected by CMake as well that the imt CMake flag is set.""; 476 << Endl;; 477 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 478 ""you have a BLAS implementation and it was successfully ""; 479 ""detected by CMake as well that the imt CMake flag is set.""; 480 << Endl;; 481#endif // DNNCPU; 482 }; 483 ; 484 //; 485 // Set network structure.; 486 //; 487 ; 488 fLayout = TMVA::MethodDNN::ParseLayoutString (fLayoutString);; 489 size_t inputSize = GetNVariables ();; 490 size_t outputSize = 1;; 491 if (fAnalysisType == Types::kRegression && GetNTargets() != 0) {; 492 outputSize = GetNTargets();; 493 } else if (fAnalysisType == Types::kMulticlass && DataInfo().GetNClasses() >= 2) {; 494 outputSize = DataInfo().GetNClasses();; 495 }; 496 ; 497 fNet.SetBatchSize(1);; 498 fNet.SetInputWidth(inputSize);; 499 ; 500 auto itLayout = std::begin (fLayout);; 501 auto itLayoutEnd = std::end (fLayout)-1;; 502 for ( ; itLayout != itLayoutEnd; ++itLayout) {; 503 fNet.AddLayer((*itLayout).first, (*itLayout).second);; 504 }; 505 fNet.AddLayer(outputSize, EActivationFunction::kIdentity);; 506 ; 507 //; 508 // Loss function and output.; 509 //; 510 ; 511 fOutputFunction = EOutputFunctio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:16445,detect,detected,16445,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety," ""ObjectsTable"". In this there are following columns: . Name Description . ""key:id"" key identifier to which belong object . ""obj:id"" object identifier . ""Class"" object class name . ""Version"" object class version . Data in each ""ObjectsTable"" row uniquely identify, in which table and which column object is stored.; In normal situation all class data should be sorted column-wise. Up to now following member are supported:; Basic data types. Here is everything clear. Column SQL type will be as much as possible close to the original type of value.; Fixed array of basic data types. In this case n columns like fArr[0], fArr[1] and so on will be created. If there is multidimensional array, names will be fArr2[1][2][1] and so on; Parent class. In this case version of parent class is stored and data of parent class will be stored with the same obj:id in correspondent table. There is a special case, when parent store nothing (this is for instance TQObject). In that case just -1 is written to avoid any extra checks if table exist or not.; Object as data member. In that case object is saved in normal way to data base and column will contain id of this object.; Pointer on object. Same as before. In case if object was already stored, just its id will be placed in the column. For NULL pointer 0 is used.; TString. Now column with limited width like VARCAHR(255) in MySQL is used. Later this will be improved to support maximum possible strings; Anything else. Data will be converted to raw format and saved in streamer table. Each row supplied with obj:id and row:id, where row:id indicates data, corresponding to this particular data member, and column will contain this raw:id. All conversion to SQL statements are done with help of TSQLStructure class. This is special hierarchical structure wich internally is very similar to XML structures. TBufferSQL2 creates these structures, when object data is streamed by ROOT and only afterwards all SQL statements will be produced and applied all tog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:2251,avoid,avoid,2251,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['avoid'],['avoid']
Safety," ""cannot create socket (entry %i)"",; 15023 portsTotal);; 15024 continue;; 15025 }; 15026 ; 15027#if defined(_WIN32); 15028 /* Windows SO_REUSEADDR lets many procs binds to a; 15029 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15030 * if someone already has the socket -- DTL */; 15031 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15032 * Windows might need a few seconds before; 15033 * the same port can be used again in the; 15034 * same process, so a short Sleep may be; 15035 * required between mg_stop and mg_start.; 15036 */; 15037 if (setsockopt(so.sock,; 15038 SOL_SOCKET,; 15039 SO_EXCLUSIVEADDRUSE,; 15040 (SOCK_OPT_TYPE)&on,; 15041 sizeof(on)); 15042 != 0) {; 15043 ; 15044 /* Set reuse option, but don't abort on errors. */; 15045 mg_cry_ctx_internal(; 15046 phys_ctx,; 15047 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15048 portsTotal);; 15049 }; 15050#else; 15051 if (setsockopt(so.sock,; 15052 SOL_SOCKET,; 15053 SO_REUSEADDR,; 15054 (SOCK_OPT_TYPE)&on,; 15055 sizeof(on)); 15056 != 0) {; 15057 ; 15058 /* Set reuse option, but don't abort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:445624,abort,abort,445624,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety," ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 sizeof(on)); 15043 != 0) {; 15044 ; 15045 /* Set reuse option, but don't abort on errors. */; 15046 mg_cry_ctx_internal(; 15047 phys_ctx,; 15048 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15049 portsTotal);; 15050 }; 15051#else; 15052 if (setsockopt(so.sock,; 15053 SOL_SOCKET,; 15054 SO_REUSEADDR,; 15055 (SOCK_OPT_TYPE)&on,; 15056 sizeof(on)); 15057 != 0) {; 15058 ; 15059 /* Set reuse option, but don't abort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:445657,abort,abort,445657,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety," && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1] = 0;; 4480 ; 4481 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4482 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:133150,redund,redundant,133150,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety," && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:133182,redund,redundant,133182,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety," & ; ). privatedelete . ◆ TGeoHelix() [2/3]. TGeoHelix::TGeoHelix ; (; ). Dummy constructor. ; Definition at line 61 of file TGeoHelix.cxx. ◆ TGeoHelix() [3/3]. TGeoHelix::TGeoHelix ; (; Double_t ; curvature, . Double_t ; step, . Int_t ; charge = 1 . ). Normal constructor. ; Definition at line 82 of file TGeoHelix.cxx. ◆ ~TGeoHelix(). TGeoHelix::~TGeoHelix ; (; ). override . Destructor. ; Definition at line 104 of file TGeoHelix.cxx. Member Function Documentation. ◆ Class(). static TClass * TGeoHelix::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoHelix::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoHelix::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file TGeoHelix.h. ◆ ComputeSafeStep(). Double_t TGeoHelix::ComputeSafeStep ; (; Double_t ; epsil = 1E-6); const. Compute safe linear step that can be made such that the error between linear-helix extrapolation is less than EPSIL. ; Definition at line 114 of file TGeoHelix.cxx. ◆ DeclFileName(). static const char * TGeoHelix::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 73 of file TGeoHelix.h. ◆ GetCurrentDirection(). const Double_t * TGeoHelix::GetCurrentDirection ; (; ); const. inline . Definition at line 51 of file TGeoHelix.h. ◆ GetCurrentPoint(). const Double_t * TGeoHelix::GetCurrentPoint ; (; ); const. inline . Definition at line 50 of file TGeoHelix.h. ◆ GetStep(). Double_t TGeoHelix::GetStep ; (; ); const. inline . Definition at line 53 of file TGeoHelix.h. ◆ GetTotalCurvature(). Double_t TGeoHelix::GetTotalCurvature ; (; ); const. Compute helix total curvature. ; Definition at line 169 of file TGeoHelix.cxx. ◆ GetXYcurvature(). Double_t TGeoHelix::GetXYcurvature ; (; ); const. inline . Definition at line 52 of file TGeoHelix.h. ◆ InitDirection() [1/2]. void TGeoHelix::InitDire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:15014,safe,safe,15014,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['safe'],['safe']
Safety," ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:57791,detect,detection,57791,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoCone.h>. Inheritance diagram for TGeoCone:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoCone() [1/5]. TGeoCone::TGeoCone ; (; const TGeoCone & ; ). protecteddelete . ◆ TGeoCone() [2/5]. TGeoCone::TGeoCone ; (; ). ◆ TGeoCone() [3/5]. TGeoCone::TGeoCone ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ TGeoCone() [4/5]. TGeoCone::TGeoCone ; (; const char * ; name, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ TGeoCone() [5/5]. TGeoCone::TGeoCone ; (; Double_t * ; params). ◆ ~TGeoCone(). TGeoCone::~TGeoCone ; (; ). override . Member Function Documentation. ◆ Capacity() [1/2]. Double_t TGeoCone::Capacity ; (; ); const. overridevirtual . Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:22958,detect,detection,22958,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoCone.h>. Inheritance diagram for TGeoConeSeg:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoConeSeg() [1/4]. TGeoConeSeg::TGeoConeSeg ; (; ). ◆ TGeoConeSeg() [2/4]. TGeoConeSeg::TGeoConeSeg ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoConeSeg() [3/4]. TGeoConeSeg::TGeoConeSeg ; (; const char * ; name, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoConeSeg() [4/4]. TGeoConeSeg::TGeoConeSeg ; (; Double_t * ; params). ◆ ~TGeoConeSeg(). TGeoConeSeg::~TGeoConeSeg ; (; ). override . Member Function Documentation. ◆ AfterStreamer(). void TGeoConeSeg::AfterStreamer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:25333,detect,detection,25333,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoPara.h>. Inheritance diagram for TGeoPara:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoPara() [1/5]. TGeoPara::TGeoPara ; (; const TGeoPara & ; ). protecteddelete . ◆ TGeoPara() [2/5]. TGeoPara::TGeoPara ; (; ). ◆ TGeoPara() [3/5]. TGeoPara::TGeoPara ; (; Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . Double_t ; alpha, . Double_t ; theta, . Double_t ; phi . ). ◆ TGeoPara() [4/5]. TGeoPara::TGeoPara ; (; const char * ; name, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . Double_t ; alpha, . Double_t ; theta, . Double_t ; phi . ). ◆ TGeoPara() [5/5]. TGeoPara::TGeoPara ; (; Double_t * ; param). ◆ ~TGeoPara(). TGeoPara::~TGeoPara ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoPara::Capacity ; (; ); const. overridevir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:22109,detect,detection,22109,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoPcon.h>. Inheritance diagram for TGeoPcon:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoPcon() [1/6]. TGeoPcon::TGeoPcon ; (; const TGeoPcon & ; ). protecteddelete . Cosine of dphi. . ◆ TGeoPcon() [2/6]. TGeoPcon::TGeoPcon ; (; ). ◆ TGeoPcon() [3/6]. TGeoPcon::TGeoPcon ; (; const char * ; name). inline . Definition at line 45 of file TGeoPcon.h. ◆ TGeoPcon() [4/6]. TGeoPcon::TGeoPcon ; (; Double_t ; phi, . Double_t ; dphi, . Int_t ; nz . ). ◆ TGeoPcon() [5/6]. TGeoPcon::TGeoPcon ; (; const char * ; name, . Double_t ; phi, . Double_t ; dphi, . Int_t ; nz . ). ◆ TGeoPcon() [6/6]. TGeoPcon::TGeoPcon ; (; Double_t * ; params). ◆ ~TGeoPcon(). TGeoPcon::~TGeoPcon ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoPcon::Capacity ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:22976,detect,detection,22976,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoPgon.h>. Inheritance diagram for TGeoPgon:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoPgon() [1/5]. TGeoPgon::TGeoPgon ; (; const TGeoPgon & ; ). protecteddelete . ◆ TGeoPgon() [2/5]. TGeoPgon::TGeoPgon ; (; ). ◆ TGeoPgon() [3/5]. TGeoPgon::TGeoPgon ; (; Double_t ; phi, . Double_t ; dphi, . Int_t ; nedges, . Int_t ; nz . ). ◆ TGeoPgon() [4/5]. TGeoPgon::TGeoPgon ; (; const char * ; name, . Double_t ; phi, . Double_t ; dphi, . Int_t ; nedges, . Int_t ; nz . ). ◆ TGeoPgon() [5/5]. TGeoPgon::TGeoPgon ; (; Double_t * ; params). ◆ ~TGeoPgon(). TGeoPgon::~TGeoPgon ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoPgon::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ Class(). static TClass * TGeoPgon::Class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:25522,detect,detection,25522,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoSphere.h>. Inheritance diagram for TGeoSphere:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoSphere() [1/5]. TGeoSphere::TGeoSphere ; (; const TGeoSphere & ; ). protecteddelete . ◆ TGeoSphere() [2/5]. TGeoSphere::TGeoSphere ; (; ). ◆ TGeoSphere() [3/5]. TGeoSphere::TGeoSphere ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; theta1 = 0, . Double_t ; theta2 = 180, . Double_t ; phi1 = 0, . Double_t ; phi2 = 360 . ). ◆ TGeoSphere() [4/5]. TGeoSphere::TGeoSphere ; (; const char * ; name, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; theta1 = 0, . Double_t ; theta2 = 180, . Double_t ; phi1 = 0, . Double_t ; phi2 = 360 . ). ◆ TGeoSphere() [5/5]. TGeoSphere::TGeoSphere ; (; Double_t * ; param, . Int_t ; nparam = 6 . ). ◆ ~TGeoSphere(). TGeoSphere::~TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:22583,detect,detection,22583,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTorus.h>. Inheritance diagram for TGeoTorus:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTorus() [1/5]. TGeoTorus::TGeoTorus ; (; const TGeoTorus & ; ). protecteddelete . ◆ TGeoTorus() [2/5]. TGeoTorus::TGeoTorus ; (; ). ◆ TGeoTorus() [3/5]. TGeoTorus::TGeoTorus ; (; Double_t ; r, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; phi1 = 0, . Double_t ; dphi = 360 . ). ◆ TGeoTorus() [4/5]. TGeoTorus::TGeoTorus ; (; const char * ; name, . Double_t ; r, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; phi1 = 0, . Double_t ; dphi = 360 . ). ◆ TGeoTorus() [5/5]. TGeoTorus::TGeoTorus ; (; Double_t * ; params). ◆ ~TGeoTorus(). TGeoTorus::~TGeoTorus ; (; ). inlineoverride . Definition at line 45 of file TGeoTorus.h. Member Function Documentation. ◆ Capacity(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:22405,detect,detection,22405,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTrd1.h>. Inheritance diagram for TGeoTrd1:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTrd1() [1/5]. TGeoTrd1::TGeoTrd1 ; (; const TGeoTrd1 & ; ). protecteddelete . ◆ TGeoTrd1() [2/5]. TGeoTrd1::TGeoTrd1 ; (; ). ◆ TGeoTrd1() [3/5]. TGeoTrd1::TGeoTrd1 ; (; Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy, . Double_t ; dz . ). ◆ TGeoTrd1() [4/5]. TGeoTrd1::TGeoTrd1 ; (; const char * ; name, . Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy, . Double_t ; dz . ). ◆ TGeoTrd1() [5/5]. TGeoTrd1::TGeoTrd1 ; (; Double_t * ; params). ◆ ~TGeoTrd1(). TGeoTrd1::~TGeoTrd1 ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoTrd1::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Class(). static TClass * TGeoTrd1::Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:21945,detect,detection,21945,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTrd2.h>. Inheritance diagram for TGeoTrd2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTrd2() [1/5]. TGeoTrd2::TGeoTrd2 ; (; const TGeoTrd2 & ; ). protecteddelete . ◆ TGeoTrd2() [2/5]. TGeoTrd2::TGeoTrd2 ; (; ). ◆ TGeoTrd2() [3/5]. TGeoTrd2::TGeoTrd2 ; (; Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy1, . Double_t ; dy2, . Double_t ; dz . ). ◆ TGeoTrd2() [4/5]. TGeoTrd2::TGeoTrd2 ; (; const char * ; name, . Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy1, . Double_t ; dy2, . Double_t ; dz . ). ◆ TGeoTrd2() [5/5]. TGeoTrd2::TGeoTrd2 ; (; Double_t * ; params). ◆ ~TGeoTrd2(). TGeoTrd2::~TGeoTrd2 ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoTrd2::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:22024,detect,detection,22024,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTube.h>. Inheritance diagram for TGeoTube:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTube() [1/5]. TGeoTube::TGeoTube ; (; const TGeoTube & ; ). protecteddelete . ◆ TGeoTube() [2/5]. TGeoTube::TGeoTube ; (; ). ◆ TGeoTube() [3/5]. TGeoTube::TGeoTube ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). ◆ TGeoTube() [4/5]. TGeoTube::TGeoTube ; (; const char * ; name, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). ◆ TGeoTube() [5/5]. TGeoTube::TGeoTube ; (; Double_t * ; params). ◆ ~TGeoTube(). TGeoTube::~TGeoTube ; (; ). override . Member Function Documentation. ◆ Capacity() [1/2]. Double_t TGeoTube::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Capacity() [2/2]. static Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:22456,detect,detection,22456,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTube.h>. Inheritance diagram for TGeoTubeSeg:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTubeSeg() [1/4]. TGeoTubeSeg::TGeoTubeSeg ; (; ). ◆ TGeoTubeSeg() [2/4]. TGeoTubeSeg::TGeoTubeSeg ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoTubeSeg() [3/4]. TGeoTubeSeg::TGeoTubeSeg ; (; const char * ; name, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoTubeSeg() [4/4]. TGeoTubeSeg::TGeoTubeSeg ; (; Double_t * ; params). ◆ ~TGeoTubeSeg(). TGeoTubeSeg::~TGeoTubeSeg ; (; ). override . Member Function Documentation. ◆ AfterStreamer(). void TGeoTubeSeg::AfterStreamer ; (; ). overridevirtual . Reimplemented from TGeoShape. ◆ Capacity() [1/2]. Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:24401,detect,detection,24401,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoXtru.h>. Inheritance diagram for TGeoXtru:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoXtru() [1/4]. TGeoXtru::TGeoXtru ; (; const TGeoXtru & ; ). protecteddelete . mutex for thread data . ◆ TGeoXtru() [2/4]. TGeoXtru::TGeoXtru ; (; ). ◆ TGeoXtru() [3/4]. TGeoXtru::TGeoXtru ; (; Int_t ; nz). ◆ TGeoXtru() [4/4]. TGeoXtru::TGeoXtru ; (; Double_t * ; param). ◆ ~TGeoXtru(). TGeoXtru::~TGeoXtru ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoXtru::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Class(). static TClass * TGeoXtru::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoXtru::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:23002,detect,detection,23002,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['detect'],['detection']
Safety," (; ); const. overridevirtual . Return the line style. ; Reimplemented from TAttLine. ◆ GetLineWidth(). Width_t TGWin32VirtualXProxy::GetLineWidth ; (; ); const. overridevirtual . Return the line width. ; Reimplemented from TAttLine. ◆ GetMarkerColor(). Color_t TGWin32VirtualXProxy::GetMarkerColor ; (; ); const. overridevirtual . Return the marker color. ; Reimplemented from TAttMarker. ◆ GetMarkerSize(). Size_t TGWin32VirtualXProxy::GetMarkerSize ; (; ); const. overridevirtual . Return the marker size. ; Reimplemented from TAttMarker. ◆ GetMarkerStyle(). Style_t TGWin32VirtualXProxy::GetMarkerStyle ; (; ); const. overridevirtual . Return the marker style. ; Reimplemented from TAttMarker. ◆ GetNativeEvent(). Handle_t TGWin32VirtualXProxy::GetNativeEvent ; (; ); const. overridevirtual . Returns the current native event handle. ; Reimplemented from TVirtualX. ◆ GetParent(). Window_t TGWin32VirtualXProxy::GetParent ; (; Window_t ; id); const. overridevirtual . might be thread unsafe (?) ; Reimplemented from TVirtualX.; Definition at line 274 of file TGWin32VirtualXProxy.cxx. ◆ GetPasteBuffer(). void TGWin32VirtualXProxy::GetPasteBuffer ; (; Window_t ; id, . Atom_t ; atom, . TString & ; text, . Int_t & ; nchar, . Bool_t ; del . ). overridevirtual . Gets contents of the paste buffer ""atom"" into the string ""text"". ; (nchar = number of characters) If ""del"" is true deletes the paste buffer afterwards. ; Reimplemented from TVirtualX. ◆ GetPixel(). ULong_t TGWin32VirtualXProxy::GetPixel ; (; Color_t ; cindex). overridevirtual . Returns pixel value associated to specified ROOT color number ""cindex"". ; Reimplemented from TVirtualX. ◆ GetPlanes(). void TGWin32VirtualXProxy::GetPlanes ; (; Int_t & ; nplanes). overridevirtual . Returns the maximum number of planes. ; Reimplemented from TVirtualX. ◆ GetPrimarySelectionOwner(). Window_t TGWin32VirtualXProxy::GetPrimarySelectionOwner ; (; ). overridevirtual . Returns the window id of the current owner of the primary selection. ; That ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:82641,unsafe,unsafe,82641,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['unsafe'],['unsafe']
Safety," (; const Double_t * ; point, . const Double_t * ; dir, . Double_t * ; norm . ). overridevirtual . Reimplemented from TGeoBBox. ◆ ComputeNormal_v(). void TGeoCtub::ComputeNormal_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; norms, . Int_t ; vecsize . ). overridevirtual . Reimplemented from TGeoBBox. ◆ Contains(). Bool_t TGeoCtub::Contains ; (; const Double_t * ; point); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Contains_v(). void TGeoCtub::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DeclFileName(). static const char * TGeoCtub::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file TGeoTube.h. ◆ DistFromInside(). Double_t TGeoCtub::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoCtub::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoCtub::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoCtub::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoCtub::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:30620,safe,safe,30620,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety," (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Static Public Attributes; static constexpr auto kBigNumber = TTree::kMaxEntries;  ;  Static Public Attributes inherited from TTree; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Member Functions; void InvalidateCurrentTree ();  Set the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:43309,detect,detection,43309,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['detect'],['detection']
Safety," (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStreamerElement* element;; 690 while ((element = (TStreamerElement*) next())) {; 691 if (element->TestBit(TStreamerElement::kRepeat) && element->IsaPointer()) {; 692 TStreamerElement *other = (TStreamerElement*) infoalloc->GetElements()->FindObject(element->GetName());; 693 if (other) {; 694 other->SetBit(TStreamerElement::kDoNotDelete);; 695 }; 696 }; 697 }; 698 infoalloc->GetElements()->Compress();; 699 }; 700 {; 701 TIter next(fElements);; 702 TStreamerElement* element;; 703 while ((element = (TStreamerElement*) next())) {; 704 if (element->TestBit(TStreamerElement::kCache)) {; 705 element->SetOffset(infoalloc->GetOffset(element->GetName()));; 706 }; 707 }; 708 }; 709 ; 710 TStreamerElement *el = new TStreamerArtificial(""@@alloc"","""", 0, TStreamerInfo::kCacheNew, allocClass->GetName());; 711 R__TObjArray_InsertAt( fElements, el, 0 );; 712 ; 713 el = new TStreamerArtificial(""@@dealloc"","""", 0, TStreamerInfo::kCacheDelete, allocClass->GetName());; 714 fElements->Add( el );; 715 }; 716 }; 717 ; 718 //; 719 // Make a more compact version.; 720 //; 721 Compile();; 722 fIsBuilt = kTRUE;; 723}; 724 ; 725////////////////////////////////////////////////////////////////////////////////; 726/// Check if built and consistent with the class dictionary.; 727/// This method is called by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:25054,avoid,avoid,25054,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety," (also known as ""variable binning""). More...;  ; class  RAxisLabels;  A RAxisGrow that has a label assigned to each bin and a bin width of 1. More...;  ; class  RBitsetField;  The generic field an std::bitset<N>. More...;  ; class  RCanvas;  A window's topmost RPad. More...;  ; class  RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  RCanvasPainter;  ; class  RCardinalityField;  An artificial field that transforms an RNTuple column that contains the offset of collections into collection sizes. More...;  ; class  RChangeAttrRequest;  ; class  RClassField;  The field for a class with dictionary. More...;  ; class  RClusterDescriptor;  Meta-data for a set of ntuple clusters. More...;  ; class  RClusterGroupDescriptor;  Clusters are bundled in cluster groups. More...;  ; class  RClusterIndex;  Addresses a column element or field item relative to a particular cluster, instead of a global NTupleSize_t index. More...;  ; struct  RClusterSize;  Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t. More...;  ; class  RCollectionField;  The collection field is only used for writing; when reading, untyped collections are projected to an std::vector. More...;  ; class  RColor;  The color class. More...;  ; class  RColumnDescriptor;  Meta-data stored for every column of an ntuple. More...;  ; class  RColumnGroupDescriptor;  Meta-data for a sets of columns; non-trivial column groups are used for sharded clusters. More...;  ; class  RColumnModel;  Holds the static meta-data of an RNTuple column. More...;  ; class  RColumnSwitch;  Holds the index and the tag of a kSwitch column. More...;  ; class  RDirectory;  Key/value store of objects. More...;  ; class  RDirectoryTypeMismatch;  Objects of this class are thrown to signal that the value known under the given name . More...;  ; class  RDirectoryUnknownKey;  Objects of this class are thrown to signal that no key with that name exists. More...;  ; class  RDisplayHistStat;  Obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:3667,avoid,avoid,3667,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['avoid'],['avoid']
Safety," (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVDUnfold.html:10711,detect,detector,10711,root/html602/TSVDUnfold.html,https://root.cern,https://root.cern/root/html602/TSVDUnfold.html,2,['detect'],['detector']
Safety," (default: """", example: http://root.cern.ch/viewcvs).; Root.Html.ViewCVS:; Stem of the CERN XWho system (default: http://consult.cern.ch/xwho/people?); Root.Html.XWho:; If set to Doc++, allow method documentation in front of method even for methods in the source file (default: """"); Root.Html.DescriptionStyle:; Search path for the source and header files with their default settings:; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; URL stem for ROOT documentation pages (default is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1259965,detect,detecting,1259965,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detecting']
Safety," (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:12811,timeout,timeout,12811,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety," (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:187111,timeout,timeout,187111,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:187143,timeout,timeout,187143,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," (other._specGeneratorConfig) {; 268 _specGeneratorConfig = std::make_unique<RooNumGenConfig>(*other._specGeneratorConfig);; 269 }; 270}; 271 ; 272 ; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11171,recover,recover,11171,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['recover'],['recover']
Safety," (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D,E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:942355,avoid,avoid,942355,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," ) Log() << kWARNING << ""Negative background efficiency found and set to 0. This is probably due to many events with negative weights in a certain cut-region."" << Endl;; 1042 fNegEffWarning = kTRUE;; 1043 }; 1044}; 1045 ; 1046////////////////////////////////////////////////////////////////////////////////; 1047/// compute signal and background efficiencies from event counting; 1048/// for given cut sample; 1049 ; 1050void TMVA::MethodCuts::GetEffsfromSelection( Double_t* cutMin, Double_t* cutMax,; 1051 Double_t& effS, Double_t& effB); 1052{; 1053 Float_t nTotS = 0, nTotB = 0;; 1054 Float_t nSelS = 0, nSelB = 0;; 1055 ; 1056 Volume* volume = new Volume( cutMin, cutMax, GetNvar() );; 1057 ; 1058 // search for all events lying in the volume, and add up their weights; 1059 nSelS = fBinaryTreeS->SearchVolume( volume );; 1060 nSelB = fBinaryTreeB->SearchVolume( volume );; 1061 ; 1062 delete volume;; 1063 ; 1064 // total number of ""events"" (sum of weights) as reference to compute efficiency; 1065 nTotS = fBinaryTreeS->GetSumOfWeights();; 1066 nTotB = fBinaryTreeB->GetSumOfWeights();; 1067 ; 1068 // sanity check; 1069 if (nTotS == 0 && nTotB == 0) {; 1070 Log() << kFATAL << ""<GetEffsfromSelection> fatal error in zero total number of events:""; 1071 << "" nTotS, nTotB: "" << nTotS << "" "" << nTotB << "" ***"" << Endl;; 1072 }; 1073 ; 1074 // efficiencies; 1075 if (nTotS == 0 ) {; 1076 effS = 0;; 1077 effB = nSelB/nTotB;; 1078 Log() << kWARNING << ""<ComputeEstimator> zero number of signal events"" << Endl;; 1079 }; 1080 else if (nTotB == 0) {; 1081 effB = 0;; 1082 effS = nSelS/nTotS;; 1083 Log() << kWARNING << ""<ComputeEstimator> zero number of background events"" << Endl;; 1084 }; 1085 else {; 1086 effS = nSelS/nTotS;; 1087 effB = nSelB/nTotB;; 1088 }; 1089 ; 1090 // quick fix to prevent from efficiencies < 0; 1091 if( effS < 0.0 ) {; 1092 effS = 0.0;; 1093 if( !fNegEffWarning ) Log() << kWARNING << ""Negative signal efficiency found and set to 0. This is probably due to many events w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:40021,sanity check,sanity check,40021,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety," ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. ◆ WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 608 of file TBufferSQL.cxx. ◆ WriteFastArray() [13/15]. void TBufferSQL::WriteFastArray ; (; const UShort_t * ; us, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 527 of file TBufferSQL.cxx. ◆ WriteFastArray() [14/15]. Int_t TBufferSQL::WriteFastArray ; (; void ** ; startp, . const TClass * ; cl, . Long64_t ; n = 1, . bool ; isPreAlloc = false, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 717 of file TBufferSQL.cxx. ◆ WriteFastAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:55569,abort,aborts,55569,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void RefreshCB(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:25148,redund,redundand,25148,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['redund'],['redundand']
Safety," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is move",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:8539,redund,redundand,8539,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,3,['redund'],['redundand']
Safety," * RooTemplateProxy< T >::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). template<class T > . static constexpr Version_t RooTemplateProxy< T >::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 448 of file RooTemplateProxy.h. ◆ DeclFileName(). template<class T > . static const char * RooTemplateProxy< T >::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 448 of file RooTemplateProxy.h. ◆ IsA(). template<class T > . TClass * RooTemplateProxy< T >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooArgProxy.; Definition at line 448 of file RooTemplateProxy.h. ◆ lvptr() [1/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const LValue_t * ; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 407 of file RooTemplateProxy.h. ◆ lvptr() [2/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const RooAbsArg * ; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:23479,safe,safe,23479,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['safe'],['safe']
Safety," * TUnixSystem::HostName ; (; ). overridevirtual . Return the system's host name. ; Reimplemented from TSystem.; Definition at line 762 of file TUnixSystem.cxx. ◆ IgnoreSignal(). void TUnixSystem::IgnoreSignal ; (; ESignals ; sig, . Bool_t ; ignore = kTRUE . ). overridevirtual . If ignore is true ignore the specified signal, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 895 of file TUnixSystem.cxx. ◆ Init(). Bool_t TUnixSystem::Init ; (; ). overridevirtual . Initialize Unix system interface. ; Reimplemented from TSystem.; Definition at line 595 of file TUnixSystem.cxx. ◆ IsA(). TClass * TUnixSystem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSystem.; Definition at line 219 of file TUnixSystem.h. ◆ IsPathLocal(). Bool_t TUnixSystem::IsPathLocal ; (; const char * ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 1643 of file TUnixSystem.cxx. ◆ Link(). int TUnixSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1686 of file TUnixSystem.cxx. ◆ ListLibraries(). void TUnixSystem::ListLibraries ; (; const char * ; regexp = """"). overridevirtual . List all loaded shared libraries. ; Reimplemented from TSystem.; Definition at line 2848 of file TUnixSystem.cxx. ◆ ListSymbols(). void TUnixSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). overridevirtual . List symbols in a shared library. ; Reimplemented from TSystem.; Definition at line 2840 of file TUnixSystem.cxx. ◆ Load(). int TUnixSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:57841,avoid,avoid,57841,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['avoid'],['avoid']
Safety," */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 6466 ; 6467static int; 6468mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6469{; 6470 int64_t con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:187304,timeout,timeout,187304,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 6467 ; 6468static int; 6469mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6470{; 6471 int64_t con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:187336,timeout,timeout,187336,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," *a, const TMatrixDSparse *b) const;  multiply two sparse matrices ;  ; TMatrixDSparse * MultiplyMSparseMSparseTranspVector (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixTBase< Double_t > *v) const;  calculate a sparse matrix product M1*V*M2T where the diagonal matrix V is given by a vector ;  ; TMatrixDSparse * MultiplyMSparseTranspMSparse (const TMatrixDSparse *a, const TMatrixDSparse *b) const;  multiply a transposed Sparse matrix with another Sparse matrix ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; const TUnfoldBinning * fConstInputBins;  binning scheme for the input (detector level) ;  ; const TUnfoldBinning * fConstOutputBins;  binning scheme for the output (truth level) ;  ; TUnfoldBinning * fOwnedInputBins;  pointer to input binning scheme if owned by this class ;  ; TUnfoldBinning * fOwnedOutputBins;  pointer to output binning scheme if owned by this class ;  ; TUnfoldBinning * fRegularisationConditions;  binning scheme for the regularisation conditions ;  ;  Protected Attributes inherited from TUnfoldSys; TMatrixD * fAoutside;  Input: underflow/overflow bins. ;  ; TMap * fBgrErrScaleIn;  Input: background sources correlated error. ;  ; TMap * fBgrErrUncorrInSq;  Input: uncorr error squared from bgr sources. ;  ; TMap * fBgrIn;  Input: size of background sources. ;  ; TMatrixD * fDAinColRelSq;  Input: normalized column err.sq. (inp.matr.) ;  ; TMatrixDSparse * fDAinRelSq;  Input: normalized errors from input matrix. ;  ; TMap * fDeltaCorrAx;  Result: syst.shift from fSysIn on fAx. ;  ; TMap * fDeltaCorrX;  Result: syst.shift from fSysIn on fX. ;  ; TMatrixDSparse * fDeltaSysTau;  Result: systematic shift from tau. ;  ; Double_t fDtau;  Input: error on tau. ;  ; TMatrixDSparse * fEmatUncorrAx;  Result: syst.error from fDA2 on fAx. ;  ; TMatrixDSpa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:37007,detect,detector,37007,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['detect'],['detector']
Safety," *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:40765,detect,detection,40765,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['detect'],['detection']
Safety," *tree, const char *alias, bool warn); 1399{; 1400 if (!tree) {; 1401 return nullptr;; 1402 }; 1403 if (!fFriends) {; 1404 fFriends = new TList();; 1405 }; 1406 TFriendElement *fe = new TFriendElement(this, tree, alias);; 1407 R__ASSERT(fe); // this assert is for historical reasons. Don't remove it unless you understand all the consequences.; 1408 TTree *t = fe->GetTree();; 1409 if (warn && (t->GetEntries() < fEntries)) {; 1410 Warning(""AddFriend"", ""FriendElement '%s' in file '%s' has less entries %lld than its parent tree: %lld"",; 1411 tree->GetName(), fe->GetFile() ? fe->GetFile()->GetName() : ""(memory resident)"", t->GetEntries(),; 1412 fEntries);; 1413 }; 1414 if (CheckReshuffling(*this, *t)); 1415 fFriends->Add(fe);; 1416 else; 1417 tree->RemoveExternalFriend(fe);; 1418 return fe;; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// AutoSave tree header every fAutoSave bytes.; 1423///; 1424/// When large Trees are produced, it is safe to activate the AutoSave; 1425/// procedure. Some branches may have buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:52256,safe,safe,52256,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['safe'],['safe']
Safety," * ; b). overridevirtual . Browse pad. ; Reimplemented from TObject.; Definition at line 523 of file TPad.cxx. ◆ BuildLegend(). TLegend * TPad::BuildLegend ; (; Double_t ; x1 = 0.3, . Double_t ; y1 = 0.21, . Double_t ; x2 = 0.3, . Double_t ; y2 = 0.21, . const char * ; title = """", . Option_t * ; option = """" . ). overridevirtual . Build a legend from the graphical objects in the pad. ; A simple method to build automatically a TLegend from the primitives in a TPad.; Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding TPave and TFrame derived classes.; ReturnsThe built TLegend; Parameters. [in]x1,y1,x2,y2The TLegend coordinates ; [in]titleThe legend title. By default it is "" "" ; [in]optionThe TLegend option. The caller program owns the returned TLegend.; If the pad contains some TMultiGraph or THStack the individual graphs or histograms in them are added to the TLegend. Automatic placement of the legend; If x1 is equal to x2 and y1 is equal to y2 the legend will be automatically placed to avoid overlapping with the existing primitives already displayed. x1 is considered as the width of the legend and y1 the height. By default the legend is automatically placed with width = x1= x2 = 0.3 and height = y1= y2 = 0.21. ; Implements TVirtualPad.; Definition at line 555 of file TPad.cxx. ◆ cd(). TVirtualPad * TPad::cd ; (; Int_t ; subpadnumber = 0). overridevirtual . Set Current pad. ; When a canvas/pad is divided via TPad::Divide, one can directly set the current path to one of the subdivisions. See TPad::Divide for the convention to number sub-pads.; Returns the new current pad, or 0 in case of failure.; For example: c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad points to the current pad. One can use gPad to set attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:59346,avoid,avoid,59346,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety," * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67028,recover,recovered,67028,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,2,"['recover', 'safe']","['recovered', 'safely']"
Safety," * ; elem, . Int_t ; comp_type . ). finalvirtual . Function is called from TStreamerInfo WriteBuffer and ReadBuffer functions and add/verify next element of json structure This calls allows separate data, correspondent to one class member, from another. ; Implements TBuffer.; Definition at line 2092 of file TBufferJSON.cxx. ◆ SetTypenameTag(). void TBufferJSON::SetTypenameTag ; (; const char * ; tag = ""_typename""). Configures _typename tag in JSON structures By default ""_typename"" field in JSON structures used to store class information One can specify alternative tag like ""$typename"" or ""xy"", but such JSON can not be correctly used in JSROOT If empty string is provided, class information will not be stored. ; Definition at line 578 of file TBufferJSON.cxx. ◆ SetTypeversionTag(). void TBufferJSON::SetTypeversionTag ; (; const char * ; tag = nullptr). Configures _typeversion tag in JSON One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version Such tag can be used to correctly recover objects from JSON If empty string is provided (default), class version will not be stored. ; Definition at line 592 of file TBufferJSON.cxx. ◆ SkipObjectAny(). void TBufferJSON::SkipObjectAny ; (; ). finalvirtual . Skip any kind of object from buffer. ; Implements TBuffer.; Definition at line 2508 of file TBufferJSON.cxx. ◆ Stack(). TJSONStackObj * TBufferJSON::Stack ; (; ). inlineprotected . Definition at line 257 of file TBufferJSON.h. ◆ StoreObject(). TString TBufferJSON::StoreObject ; (; const void * ; obj, . const TClass * ; cl . ). Store provided object as JSON structure Allows to configure different TBufferJSON properties before converting object into JSON Actual object class must be specified here Method can be safely called once - after that TBufferJSON instance must be destroyed Code should look like: ; auto obj = new UserClass(); TBufferJSON buf; buf.SetCompact(TBufferJSON::kNoSpaces); // change any other settings in TBufferJSO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:86095,recover,recover,86095,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['recover'],['recover']
Safety," * ; norm . ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ Contains(). virtual Bool_t TGeoBoolNode::Contains ; (; const Double_t * ; point); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ CreateThreadData(). void TGeoBoolNode::CreateThreadData ; (; Int_t ; nthreads). Create thread data for n threads max. ; Definition at line 100 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoBoolNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). virtual Int_t TGeoBoolNode::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromInside(). virtual Double_t TGeoBoolNode::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromOutside(). virtual Double_t TGeoBoolNode::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetBooleanOperator(). virtual EGeoBoolType TGeoBoolNode::GetBooleanOperator ; (; ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetLeftMatrix(). TGeoMatrix * TGeoBoolNode::GetLeftMatrix ; (; ); const. inline . Definition at line 76 of file TGeoBoolNode.h. ◆ GetLeftShape(). TGeoShape * TGeoBoolNode::GetLeftShape ; (; ); const. inline . Definition at line 78 of file TGeoBoolNode.h. ◆ GetNpoints(). virtual Int_t TGeoBoolNode::GetNpoints ; (; ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetRightMatrix(). TGeoMatrix ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:17147,safe,safe,17147,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['safe'],['safe']
Safety," * ; pt, . const Double_t * ; dir, . Double_t ; t . ); const. ◆ DDaxis(). Double_t TGeoTorus::DDaxis ; (; const Double_t * ; pt, . const Double_t * ; dir, . Double_t ; t . ); const. ◆ DDDaxis(). Double_t TGeoTorus::DDDaxis ; (; const Double_t * ; pt, . const Double_t * ; dir, . Double_t ; t . ); const. ◆ DeclFileName(). static const char * TGeoTorus::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoTorus.h. ◆ DistancetoPrimitive(). Int_t TGeoTorus::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoTorus::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoTorus::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoTorus::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoTorus::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoTorus::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:25750,safe,safe,25750,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['safe'],['safe']
Safety," + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(), this->end());; 1160 }; 1161 }; 1162 ; 1163 explicit RVecN(size_t Size, const T &Value) : Detail::VecOps::RVecImpl<T>(N) { this->assign(Size, Value); }; 1164 ; 1165 explicit RVecN(size_t Size) : Detail::VecOps::RVecImpl<T>(N); 1166 {; 1167 if (Size > N); 1168 this->grow(Size);; 1169 this->fSize = Size;; 1170 ROOT::Internal::VecOps::UninitializedValueConstruct(t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:39573,avoid,avoid,39573,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety," , kGeoTrd2 = (1ULL << ( 24 )); , kGeoComb = (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  . #include <TGeoArb8.h>. Inheritance diagram for TGeoArb8:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EGeoArb8Type. enum TGeoArb8::EGeoArb8Type. protected . EnumeratorkArb8Trap ; kArb8Tra . Definition at line 19 of file TGeoArb8.h. Constructor & Destructor Documentation. ◆ TGeoArb8() [1/4]. TGeoArb8::TGeoArb8 ; (; const TGeoArb8 & ; ). protecteddelete . ◆ TGeoArb8() [2/4]. TGeoArb8::TGeoArb8 ; (; ). ◆ TGeoArb8() [3/4]. TGeoArb8::TGeoArb8 ; (; Double_t ; dz, . Double_t * ; vertices = nullptr . ). ◆ TGeoArb8() [4/4]. TGeoArb8::TGeoArb8 ; (; const char * ; name, . Double_t ; dz, . Double_t * ; vertices = nullptr . ). ◆ ~TGeoArb8(). TGeoArb8::~TGeoArb8 ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoArb8::Capacity ; (; ); const. overridevirtual . Implements TGeoShape. ◆ Class(). static TClass * T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:24983,detect,detection,24983,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['detect'],['detection']
Safety," , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSlave;  TSlave ();  Default constructor used by derived classes. ;  ; virtual void FlushSocket ();  ; void Init (TSocket *s, Int_t stype);  Init a PROOF slave object using the connection opened via s. ;  ; virtual void Interrupt (Int_t type);  Send interrupt OOB byte to master or slave servers. ;  ; virtual Int_t Ping ();  Ping the remote master or slave servers. ;  ; virtual TObjString * SendCoordinator (Int_t kind, const char *msg=0, Int_t int2=0);  Send message to intermediate coordinator. ;  ; virtual Int_t SendGroupPriority (const char *, Int_t);  ; virtual void SetAlias (const char *alias);  Set an alias for this session. ;  ; void SetSocket (TSocket *s);  ; virtual void SetStatus (Int_t st);  ; virtual void StopProcess (Bool_t abort, Int_t timeout);  Sent stop/abort request to PROOF server. ;  ;  Protected Member Functions inherited from TObject; void MakeZombie ();  ;  Protected Attributes inherited from TSlave; TString fArchComp;  ; Long64_t fBytesRead;  ; Float_t fCpuTime;  ; TString fGroup;  ; TString fImage;  ; TFileHandler * fInput;  ; TString fMsd;  ; TString fName;  ; TString fOrdinal;  ; Int_t fParallel;  ; Int_t fPerfIdx;  ; Int_t fPort;  ; TProof * fProof;  ; TString fProofWorkDir;  ; Int_t fProtocol;  ; Float_t fRealTime;  ; TString fROOTVers;  ; TString fSessionTag;  ; ESlaveType fSlaveType;  ; TSocket * fSocket;  ; Int_t fStatus;  ; TString fUser;  ; TString fWorkDir;  . #include <TSlaveLite.h>. Inheritance diagram for TSlaveLite:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSlaveLite(). TSlaveLite::TSlaveLite ; (; const char * ; ord, . Int_t ; perf, . const char * ; image, . TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlaveLite.html:12934,abort,abort,12934,doc/master/classTSlaveLite.html,https://root.cern,https://root.cern/doc/master/classTSlaveLite.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety," - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = kAscii, const char* rfile = 0); Send a fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:14600,timeout,timeout,14600,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,21,['timeout'],['timeout']
Safety," - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); Set cell element i of cell to value. If the cell element i does; not exist, it is created. void OutputGrow(Bool_t finished = false); Overridden function of PDEFoam to avoid native foam output.; Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t CreateCanvas = kTRUE, Bool_t colors = kTRUE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - CreateCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. Example:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoam.html:20868,avoid,avoid,20868,root/html530/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoam.html,2,['avoid'],['avoid']
Safety," - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); Set cell element i of cell to value. If the cell element i does; not exist, it is created. void OutputGrow(Bool_t finished = false); Overridden function of PDEFoam to avoid native foam output.; Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t createCanvas = kTRUE, Bool_t colors = kTRUE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - createCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. Example:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoam.html:20881,avoid,avoid,20881,root/html534/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoam.html,3,['avoid'],['avoid']
Safety," -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 }; 135}; 136 ; 137////////////////////////////////////////////////////////////////////////////////; 138/// Delete an I/O buffer object.; 139 ; 140TBuffer::~TBuffer(); 141{; 142 if (TestBit(kIsOwner)) {; 143 //printf(""Deleting fBuffer=%lx\n"", fBuffer);; 144 delete [] fBuffer;; 145 }; 146 fBuffer = nullptr;; 147 fParent = nullptr;; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Automatically calculate a new size and expand the buffer to fit at least size_needed.; 152/// The goals is to minimize the number of memory allocation and the memory allocation; 153/// which avoiding too much memory wastage.; 154///; 155/// If the size_needed is larger than the current size, the policy; 156/// is to expand to double the current size or the size_needed which ever is largest.; 157 ; 158void TBuffer::AutoExpand(Int_t size_needed); 159{; 160 if (size_needed < 0) {; 161 Fatal(""AutoExpand"",""Request to expand to a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", size_needed, kMaxBufferSize);; 162 }; 163 if (size_needed > fBufSize) {; 164 Long64_t doubling = 2LLU * fBufSize;; 165 if (doubling > kMaxBufferSize); 166 doubling = kMaxBufferSize;; 167 if (size_needed > doubling) {; 168 Expand(size_needed);; 169 } else {; 170 Expand(doubling);; 171 }; 172 }; 173}; 174 ; 175////////////////////////////////////////////////////////////////////////////////; 176/// Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; 177/// new buffer is expected to have the same size as the previous buffer.; 17",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:5114,avoid,avoiding,5114,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoiding']
Safety," . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 5. Fitting. Distributions; Some analyses want to check theory predictions that exist as a function definition. Others want to use a distribution from a histogram in another step of the analysis. But histograms have bin steps by nature instead of being smooth, and they have bumps / fluctuations due to limited statistics (i.e. ""not enough data"").; So what's needed is a function whose line is ""as close as possible"" to the histogram counts. I.e. we need a function (that predicts the shape of the histogram) and that we can vary a bit (""free parameters""). Then we search for the best set of parameters, such that the function resembles the histogram.; That's fitting.; Fitting in Practice; As often with ROOT, you can use a GUI element (the fit panel, available through the menu in ""Tools"", ""Fit Panel"", or on the prompt (TH1::Fit()). Let's use the fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We wan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:1934,predict,predictions,1934,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['predict'],['predictions']
Safety," . Conversion method to create VecGeom solid corresponding to TGeoShape. ; Definition at line 104 of file TGeoVGShape.cxx. ◆ DistancetoPrimitive(). Int_t TGeoVGShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). inlineoverridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox.; Definition at line 52 of file TGeoVGShape.h. ◆ DistFromInside(). Double_t TGeoVGShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 448 of file TGeoVGShape.cxx. ◆ DistFromOutside(). Double_t TGeoVGShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 458 of file TGeoVGShape.cxx. ◆ Divide(). TGeoVolume * TGeoVGShape::Divide ; (; TGeoVolume * ; , . const char * ; , . Int_t ; , . Int_t ; , . Double_t ; , . Double_t ;  . ). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoVGShape.h. ◆ Draw(). void TGeoVGShape::Draw ; (; Option_t * ; option = """"). inlineoverridevirtual . Draw this shape. ; Reimplemented from TGeoShape.; Definition at line 58 of file TGeoVGShape.h. ◆ GetAxisName(). const char * TGeoVGShape::GetAxisName ; (; Int_t ; iaxis); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 59 of file TGeoVGShape.h. ◆ GetAxisRange(). Double_t TGeoVGShape::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 60 of file TGeoVGShape.h. ◆ GetBoundingCylinder(). void TGeoVGShape::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:25972,safe,safe,25972,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['safe'],['safe']
Safety," . Definition at line 192 of file TTreeFormula.h. ◆ GetMethodCall(). TMethodCall * TTreeFormula::GetMethodCall ; (; Int_t ; code); const. Return methodcall corresponding to code. ; function called by TLeafObject::GetValue with the value of fLookupType computed in TTreeFormula::DefinedVariable ; Definition at line 4476 of file TTreeFormula.cxx. ◆ GetMultiplicity(). virtual Int_t TTreeFormula::GetMultiplicity ; (; ); const. inlinevirtual . Definition at line 194 of file TTreeFormula.h. ◆ GetNcodes(). virtual Int_t TTreeFormula::GetNcodes ; (; ); const. inlinevirtual . Definition at line 196 of file TTreeFormula.h. ◆ GetNdata(). Int_t TTreeFormula::GetNdata ; (; ). virtual . Return number of available instances in the formula. ; Definition at line 4485 of file TTreeFormula.cxx. ◆ GetRealInstance(). Int_t TTreeFormula::GetRealInstance ; (; Int_t ; instance, . Int_t ; codeindex . ). protected . Now let calculate what physical instance we really need. ; Some redundant code is used to speed up the cases where they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so we can skip the modulo when virt_dim is 0. ; Definition at line 3362 of file TTreeFormula.cxx. ◆ GetTree(). virtual TTree * TTreeFormula::GetTree ; (; ); const. inlinevirtual . Definition at line 213 of file TTreeFormula.h. ◆ GetValueFromMethod(). Double_t TTreeFormula::GetValueFromMethod ; (; Int_t ; i, . TLeaf * ; leaf . ); const. protectedvirtual . Return result of a leafobject method. ; Definition at line 4493 of file TTreeFormula.cxx. ◆ GetValuePointerFromMethod(). void * TTreeFormula::GetValuePointerFromMethod ; (; Int_t ; i, . TLeaf * ; leaf . ); const. protectedvirtual . Return result of a leafobject method. ; Definition at line 4554 of file TTreeFormula.cxx. ◆ Init(). void TTreeFormula::Init ; (; const char * ; name, . const char * ; formula . ). protected . Initialization called from the constructors. ; Definition at line 178 of file TTreeFormula.cxx. ◆ IsA(). TClass * TTreeForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:41972,redund,redundant,41972,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['redund'],['redundant']
Safety," . Int_t & ; iz . ); const. ◆ Divide(). TGeoVolume * TGeoPcon::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Dphi(). Double_t & TGeoPcon::Dphi ; (; ). inline . Definition at line 94 of file TGeoPcon.h. ◆ GetAxisName(). const char * TGeoPcon::GetAxisName ; (; Int_t ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoPcon::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoPcon::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetBuffer3D(). const TBuffer3D & TGeoPcon::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetByteCount(). Int_t TGeoPcon::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon.; Definition at line 75 of file TGeoPcon.h. ◆ GetDphi(). Double_t TGeoPcon::GetDphi ; (; ); const. inline . Definition at line 77 of file TGeoPcon.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoPcon::GetMakeRuntimeShape ; (; TGeoShape * ; , . TGeoMatrix * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon.; Definition at line 86 of file TGeoPcon.h. ◆ GetMeshNumbers(). void TGeoPcon::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetNmeshVertices(). Int_t TGeoPcon::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetNsegments(). virtual Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:28258,avoid,avoid,28258,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['avoid'],['avoid']
Safety," . const ColumnNames_t & ; branches, . const RColumnRegister & ; colRegister, . TTree * ; tree, . RDataSource * ; ds . ). Book the jitting of a Filter call. ; Definition at line 658 of file RDFInterfaceUtils.cxx. ◆ BookVariationJit(). std::shared_ptr< RJittedVariation > ROOT::Internal::RDF::BookVariationJit ; (; const std::vector< std::string > & ; colNames, . std::string_view ; variationName, . const std::vector< std::string > & ; variationTags, . std::string_view ; expression, . RLoopManager & ; lm, . RDataSource * ; ds, . const RColumnRegister & ; colRegister, . const ColumnNames_t & ; branches, . std::shared_ptr< RNodeBase > * ; upcastNodeOnHeap, . bool ; isSingleColumn . ). Book the jitting of a Vary call. ; Definition at line 782 of file RDFInterfaceUtils.cxx. ◆ CacheLineStep(). template<typename T > . constexpr std::size_t ROOT::Internal::RDF::CacheLineStep ; (; ). constexpr . Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line. ; Useful to avoid false sharing. ; Definition at line 222 of file Utils.hxx. ◆ ChangeEmptyEntryRange(). void ROOT::Internal::RDF::ChangeEmptyEntryRange ; (; const ROOT::RDF::RNode & ; node, . std::pair< ULong64_t, ULong64_t > && ; newRange . ). Definition at line 13 of file RInterface.cxx. ◆ ChangeSpec(). void ROOT::Internal::RDF::ChangeSpec ; (; const ROOT::RDF::RNode & ; node, . ROOT::RDF::Experimental::RDatasetSpec && ; spec . ). Changes the input dataset specification of an RDataFrame. ; Parameters. nodeAny node of the computation graph. ; specThe new specification. . Definition at line 26 of file RInterface.cxx. ◆ CheckForDefinition(). void ROOT::Internal::RDF::CheckForDefinition ; (; const std::string & ; where, . std::string_view ; definedColView, . const RColumnRegister & ; colRegister, . const ColumnNames_t & ; treeColumns, . const ColumnNames_t & ; dataSourceColumns . ). Throw if column definedColView is not already there. ; Definition at line 513 of file RDFInterfaceUtils.cxx. ◆ CheckForDup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:22883,avoid,avoid,22883,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['avoid'],['avoid']
Safety," . std::size_t ; nVariations, . std::string_view ; variationName . ). inline . Register systematic variations for for multiple existing columns using custom variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]nVariationsnumber of variations returned by the expression. The corresponding tags will be ""0"", ""1"", etc. ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". colName is used if none is provided. NoteThis overload ensures that the ambiguity between C++20 string, vector<string> construction from init list is avoided.; See alsoThis Vary() overload for more information. ; Definition at line 1043 of file RInterface.hxx. ◆ Vary() [7/11]. template<typename Proxied , typename DataSource = void> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::initializer_list< std::string > ; colNames, . std::string_view ; expression, . std::size_t ; nVariations, . std::string_view ; variationName . ). inline . Register systematic variations for multiple existing columns using auto-generated variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona string containing valid C++ code that evaluates to an RVec containing the varied values for the specified column. ; [in]nVariationsnumber of variations returned by the expression. The corresponding tags will be ""0"", ""1"", etc. ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:146743,avoid,avoided,146743,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['avoid'],['avoided']
Safety," / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of acti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:11167,avoid,avoid,11167,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,1,['avoid'],['avoid']
Safety," /* Wait until process is terminated (don't leave zombies) */; 11260 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11261 ;; 11262 } else {; 11263 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11264 }; 11265 /* Dec reference counter */; 11266 refs = mg_atomic_dec(&proc->references);; 11267 if (refs == 0) {; 11268 /* no more references - free data */; 11269 mg_free(data);; 11270 }; 11271 ; 11272 return 0;; 11273}; 11274 ; 11275 ; 11276/* Local (static) function assumes all arguments are valid. */; 11277static void; 11278handle_cgi_request(struct mg_connection *conn,; 11279 const char *prog,; 11280 unsigned char cgi_config_idx); 11281{; 11282 char *buf;; 11283 size_t buflen;; 11284 int headers_len, data_len, i, truncated;; 11285 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11286 const char *status, *status_text, *connection_state;; 11287 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11288 struct mg_request_info ri;; 11289 struct cgi_environment blk;; 11290 FILE *in = NULL, *out = NULL, *err = NULL;; 11291 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11292 pid_t pid = (pid_t)-1;; 11293 struct process_control_data *proc = NULL;; 11294 ; 11295#if defined(USE_TIMERS); 11296 double cgi_timeout;; 11297 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11298 /* Get timeout in seconds */; 11299 cgi_timeout =; 11300 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11301 } else {; 11302 cgi_timeout =; 11303 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11304 }; 11305 ; 11306#endif; 11307 ; 11308 buf = NULL;; 11309 buflen = conn->phys_ctx->max_request_size;; 11310 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11311 if (i != 0) {; 11312 blk.buf = NULL;; 11313 blk.var = NULL;; 11314 goto done;; 11315 }; 11316 ; 11317 /* CGI must be executed in its own directory. 'dir' must point to the; 11318 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:326602,timeout,timeout,326602,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," /* Wait until process is terminated (don't leave zombies) */; 11261 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11262 ;; 11263 } else {; 11264 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11265 }; 11266 /* Dec reference counter */; 11267 refs = mg_atomic_dec(&proc->references);; 11268 if (refs == 0) {; 11269 /* no more references - free data */; 11270 mg_free(data);; 11271 }; 11272 ; 11273 return 0;; 11274}; 11275 ; 11276 ; 11277/* Local (static) function assumes all arguments are valid. */; 11278static void; 11279handle_cgi_request(struct mg_connection *conn,; 11280 const char *prog,; 11281 unsigned char cgi_config_idx); 11282{; 11283 char *buf;; 11284 size_t buflen;; 11285 int headers_len, data_len, i, truncated;; 11286 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11287 const char *status, *status_text, *connection_state;; 11288 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11289 struct mg_request_info ri;; 11290 struct cgi_environment blk;; 11291 FILE *in = NULL, *out = NULL, *err = NULL;; 11292 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11293 pid_t pid = (pid_t)-1;; 11294 struct process_control_data *proc = NULL;; 11295 ; 11296#if defined(USE_TIMERS); 11297 double cgi_timeout;; 11298 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11299 /* Get timeout in seconds */; 11300 cgi_timeout =; 11301 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11302 } else {; 11303 cgi_timeout =; 11304 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11305 }; 11306 ; 11307#endif; 11308 ; 11309 buf = NULL;; 11310 buflen = conn->phys_ctx->max_request_size;; 11311 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11312 if (i != 0) {; 11313 blk.buf = NULL;; 11314 blk.var = NULL;; 11315 goto done;; 11316 }; 11317 ; 11318 /* CGI must be executed in its own directory. 'dir' must point to the; 11319 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:326635,timeout,timeout,326635,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); 18.4.2.3 Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat’ CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:936748,detect,detector,936748,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety," 0) {; 19283 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19284 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19285 * successful poll, and POLLIN is defined as; 19286 * (POLLRDNORM | POLLRDBAND); 19287 * Therefore, we're checking pfd[i].revents & POLLIN, not; 19288 * pfd[i].revents == POLLIN. */; 19289 if (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 19290 && (pfd[i].revents & POLLIN)) {; 19291 accept_new_connection(&ctx->listening_sockets[i], ctx);; 19292 }; 19293 }; 19294 }; 19295 }; 19296 ; 19297 /* Here stop_flag is 1 - Initiate shutdown. */; 19298 DEBUG_TRACE(""%s"", ""stopping workers"");; 19299 ; 19300 /* Stop signal received: somebody called mg_stop. Quit. */; 19301 close_all_listening_sockets(ctx);; 19302 ; 19303 /* Wakeup workers that are waiting for connections to handle. */; 19304#if defined(ALTERNATIVE_QUEUE); 19305 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 19306 event_signal(ctx->client_wait_events[i]);; 19307 }; 19308#else; 19309 (void)pthread_mutex_lock(&ctx->thread_mutex);; 19310 pthread_cond_broadcast(&ctx->sq_full);; 19311 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 19312#endif; 19313 ; 19314 /* Join all worker threads to avoid leaking threads. */; 19315 workerthreadcount = ctx->cfg_worker_threads;; 19316 for (i = 0; i < workerthreadcount; i++) {; 19317 if (ctx->worker_threadids[i] != 0) {; 19318 mg_join_thread(ctx->worker_threadids[i]);; 19319 }; 19320 }; 19321 ; 19322#if defined(USE_LUA); 19323 /* Free Lua state of lua background task */; 19324 if (ctx->lua_background_state) {; 19325 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19326 ctx->lua_bg_log_available = 0;; 19327 ; 19328 /* call ""stop()"" in Lua */; 19329 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19330 lua_getglobal(lstate, ""stop"");; 19331 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19332 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19333 if (ret != 0) {; 19334 struct mg_connection fc;; 19335 lua_cry(fake_connection(&fc, ctx),; 19336 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:576157,avoid,avoid,576157,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety," 0) {; 19284 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19285 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19286 * successful poll, and POLLIN is defined as; 19287 * (POLLRDNORM | POLLRDBAND); 19288 * Therefore, we're checking pfd[i].revents & POLLIN, not; 19289 * pfd[i].revents == POLLIN. */; 19290 if (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 19291 && (pfd[i].revents & POLLIN)) {; 19292 accept_new_connection(&ctx->listening_sockets[i], ctx);; 19293 }; 19294 }; 19295 }; 19296 }; 19297 ; 19298 /* Here stop_flag is 1 - Initiate shutdown. */; 19299 DEBUG_TRACE(""%s"", ""stopping workers"");; 19300 ; 19301 /* Stop signal received: somebody called mg_stop. Quit. */; 19302 close_all_listening_sockets(ctx);; 19303 ; 19304 /* Wakeup workers that are waiting for connections to handle. */; 19305#if defined(ALTERNATIVE_QUEUE); 19306 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 19307 event_signal(ctx->client_wait_events[i]);; 19308 }; 19309#else; 19310 (void)pthread_mutex_lock(&ctx->thread_mutex);; 19311 pthread_cond_broadcast(&ctx->sq_full);; 19312 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 19313#endif; 19314 ; 19315 /* Join all worker threads to avoid leaking threads. */; 19316 workerthreadcount = ctx->cfg_worker_threads;; 19317 for (i = 0; i < workerthreadcount; i++) {; 19318 if (ctx->worker_threadids[i] != 0) {; 19319 mg_join_thread(ctx->worker_threadids[i]);; 19320 }; 19321 }; 19322 ; 19323#if defined(USE_LUA); 19324 /* Free Lua state of lua background task */; 19325 if (ctx->lua_background_state) {; 19326 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19327 ctx->lua_bg_log_available = 0;; 19328 ; 19329 /* call ""stop()"" in Lua */; 19330 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19331 lua_getglobal(lstate, ""stop"");; 19332 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19333 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19334 if (ret != 0) {; 19335 struct mg_connection fc;; 19336 lua_cry(fake_connection(&fc, ctx),; 19337 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:576190,avoid,avoid,576190,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety," 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Print(""t""); ; # Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt""); ; # Draw composite tree graphically; # -------------------------------------------------------------; ; # Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot""); ; # Make graphic output file with one of the GraphViz tools; # (freely available from www.graphviz.org); #; # 'Top-to-bottom graph'; # unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; #; # 'Spring-model graph'; # unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x788d230 RooAddPdf::model = 0.602695/1 [Auto,Clean] ; 0x73f4730/V- RooAddPdf::bkg = 0.20539/1 [Auto,Clean] ; 0x793f3e0/V- RooChebychev::bkg1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7539e30/V- RooRealVar::a0 = 0.5; 0x7496810/V- RooRealVar::a1 = 0; 0x7353b80/V- RooRealVar::bkg1frac = 0.2; 0x792d390/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7429310/V- RooRealVar::alpha = -1; 0x2ee1ac0/V- RooRealVar::bkgfrac = 0.5; 0x4d76f30/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7444460/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x3bcf160/V- RooRealVar::sigma1 = 0.5; 0x736e030/V- RooRealVar::sig1frac = 0.8; 0x7422370/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x2ee16d0/V- RooRealVar::sigma2 = 1; DateFebruary 2018 ; AuthorsC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8py.html:2840,safe,safe,2840,doc/master/rf206__treevistools_8py.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html,1,['safe'],['safe']
Safety," 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(), this->end());; 1160 }; 1161 }; 1162 ; 1163 explicit RVecN(size_t Size, const T &Value) : Detail::VecOps::RVecImpl<T>(N) { this->assign(Size, Value); }; 1164 ; 1165 explicit RVecN(size_t Size) : Detail::VecOps::RVecImpl<T>(N); 1166 {; 1167 if (Size > N); 1168 this->grow(Size);; 1169 this->fSize = Size;; 1170 ROOT::Internal::VecOps::UninitializedValueConstruct(this->begin(), this->end());; 1171 }; 1172 ; 1173 template <typename ItTy,; 1174 typename = typename std::enable_if<std::is_convertible<; 1175 typename std::iterator_traits<ItTy>::iterator_category, std::input_ite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:39823,safe,safe,39823,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['safe'],['safe']
Safety," 1314 ; 1315////////////////////////////////////////////////////////////////////////////////; 1316/// Merge TH2Polys; 1317/// Given the special nature of the TH2Poly, the merge is implemented in; 1318/// terms of subsequent TH2Poly::Add calls.; 1319Long64_t TH2Poly::Merge(TCollection *coll); 1320{; 1321 for (auto h2pAsObj : *coll) {; 1322 if (!Add((TH1*)h2pAsObj, 1.)) {; 1323 Warning(""Merge"", ""An issue was encountered during the merge operation."");; 1324 return 0L;; 1325 }; 1326 }; 1327 return GetEntries();; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Save primitive as a C++ statement(s) on output stream out; 1332 ; 1333void TH2Poly::SavePrimitive(std::ostream &out, Option_t *option); 1334{; 1335 out <<"" ""<<std::endl;; 1336 out <<"" ""<< ClassName() <<"" *"";; 1337 ; 1338 //histogram pointer has by default the histogram name.; 1339 //however, in case histogram has no directory, it is safer to add a; 1340 //incremental suffix; 1341 static Int_t hcounter = 0;; 1342 TString histName = GetName();; 1343 if (!fDirectory && !histName.Contains(""Graph"")) {; 1344 hcounter++;; 1345 histName += ""__"";; 1346 histName += hcounter;; 1347 }; 1348 ; 1349 TString hname = gInterpreter->MapCppName(histName.Data());; 1350 ; 1351 //Construct the class initialization; 1352 out << hname << "" = new "" << ClassName() << ""(\"""" << hname << ""\"", \""""; 1353 << GetTitle() << ""\"", "" << fCellX << "", "" << fXaxis.GetXmin(); 1354 << "", "" << fXaxis.GetXmax(); 1355 << "", "" << fCellY << "", "" << fYaxis.GetXmin() << "", ""; 1356 << fYaxis.GetXmax() << "");"" << std::endl;; 1357 ; 1358 // Save Bins; 1359 TIter next(fBins);; 1360 TObject *obj;; 1361 TH2PolyBin *th2pBin;; 1362 ; 1363 while((obj = next())){; 1364 th2pBin = (TH2PolyBin*) obj;; 1365 th2pBin->GetPolygon()->SavePrimitive(out, TString::Format(""th2poly%s"",hname.Data()));; 1366 }; 1367 ; 1368 // save bin contents; 1369 out<<"" ""<<std::endl;; 1370 Int_t bin;; 1371 for (bin=1;bin<=GetNumberOfBins();bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:46287,safe,safer,46287,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['safe'],['safer']
Safety," 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:7005,avoid,avoid,7005,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['avoid'],['avoid']
Safety," 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:56706,predict,predict,56706,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['predict'],['predict']
Safety," 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)pids->UncheckedAt(pidf);; 1957 if (pid) {; 1958 pid->CheckInit();; 1959 return pid;; 1960 }; 1961 ; 1962 //check if fProcessIDs[uid] is set in file; 1963 //if not set, read the process uid from file; 1964 char pidname[32];; 1965 snprintf(pidname,32,""ProcessID%d"",pidf);; 1966 pid = (TProcessID *)Get(pidname);; 1967 if (gDebug > 0) {; 1968 printf(""ReadProcessID, name=%s, file=%s, pid=%zx\n"",pidname,GetName(),(size_t)pid);; 1969 }; 1970 if (!pid) {; 1971 //file->Error(""ReadProcessID"",""Cannot find %s in file %s"",pidname,file->GetName());; 1972 return pid;; 1973 }; 1974 ; 1975 //check that a similar pid is not already registered in fgPIDs; 1976 TObjArray *pidslist = TProcessID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:71659,recover,recover,71659,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['recover'],"['recover', 'recovered']"
Safety," 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error oc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:8016,abort,abort,8016,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['abort'],['abort']
Safety," 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0.0 || sum2 == 0.0) {; 2242 Error(""Chi2TestX"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:89659,avoid,avoid,89659,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety," 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 337 void AddAllocationCount(UInt_t count) { fAllocationCount += count; }; 338 virtual Long64_t AutoSave(Option_t* option = """");; 339 ; 340 /// Add a new branch, and infer the data type from the type of `obj` being passed.; 341 ///; 342 /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; 343 /// possible, unless e.g. type conversions are needed.; 344 ///; 345 /// \param[in] name Name of the branch to be created.; 346 /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; 347 /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:15678,safe,safe,15678,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['safe'],['safe']
Safety," 3474 ; 3475 ; 3476#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3477 ; 3478 ; 3479const char *; 3480mg_version(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static const char *; 3540get_proto_name(const struct mg_connection *conn); 3541{; 3542#if defined(__clang__); 3543#pragma cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:104224,safe,safe,104224,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety," 3475 ; 3476 ; 3477#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3478 ; 3479 ; 3480const char *; 3481mg_version(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:104256,safe,safe,104256,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety," 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 5025 if (!CheckModuleValid(modGen, llvmResourceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203960,detect,detectedUmbrella,203960,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety," 67 of file TGeoShape.h. ◆ DeclFileName(). static const char * TGeoShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 171 of file TGeoShape.h. ◆ DistancetoPrimitive(). Int_t TGeoShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridepure virtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TObject.; Implemented in TGeoTessellated, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ DistFromInside(). virtual Double_t TGeoShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromInside_v(). virtual void TGeoShape::DistFromInside_v ; (; const Double_t * ; , . const Double_t * ; , . Double_t * ; , . Int_t ; , . Double_t * ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 105 of file TGeoShape.h. ◆ DistFromOutside(). virtual Double_t TGeoShape::DistFromOutside ; (; const Double_t * ; point, . const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:32412,safe,safe,32412,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety," 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file.C will be compiled; 134/// and dynamically loaded. The corresponding binary file and shared; 135/// library will be deleted at the end of the function.; 136/// If filename is of the form file.C+, the file file.C will ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4702,abort,abort,4702,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['abort'],['abort']
Safety," 90\anchor cheatsheet; 91## Cheat sheet; 92These are the operations which can be performed with RDataFrame.; 93 ; 94### Transformations; 95Transformations are a way to manipulate the data.; 96 ; 97| **Transformation** | **Description** |; 98|------------------|--------------------|; 99| Alias() | Introduce an alias for a particular column name. |; 100| Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; 101| DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; 102| DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 103| DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; 104| Filter() | Filter rows based on user-defined conditions. |; 105| Range() | Filter rows based on entry number (single-thread only). |; 106| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 107| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 108| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 109| Vary() | Register systematic variations for an exis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:5487,safe,safe,5487,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety," 96 of file TGeoArb8.h. Public Member Functions;  TGeoTrap ();  ;  TGeoTrap (const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);  ;  TGeoTrap (Double_t dz, Double_t theta, Double_t phi);  ;  TGeoTrap (Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);  ;  ~TGeoTrap () override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha1 () const;  ; Double_t GetAlpha2 () const;  ; Double_t GetBl1 () const;  ; Double_t GetBl2 () const;  ; Double_t GetH1 () const;  ; Double_t GetH2 () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Double_t GetPhi () const;  ; Double_t GetTheta () const;  ; Double_t GetTl1 () const;  ; Double_t GetTl2 () const;  ; TClass * IsA () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimension",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:933,safe,safe,933,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,3,['safe'],['safe']
Safety," : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.261 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyTorch for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyTorch ] :␛[0m; : ; : PyTorch is a scientific computing package supporting; : automatic differentiation. This method wraps the training; : and predictions steps of the PyTorch Python package for; : TMVA, so that dataloading, preprocessing and evaluation; : can be done within the TMVA system. To use this PyTorch; : interface, you need to generatea model with PyTorch first.; : Then, this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Print Training Model Architecture; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; : Elapsed time for training with 1600 events: 23.1 sec ; PyTorch : [dataset] : Evaluation of PyTorch on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.434 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.class.C␛[0m; Factory : Training",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:28416,predict,predictions,28416,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predictions']
Safety," ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TGeoTrap, and TGeoGtra.; Definition at line 93 of file TGeoArb8.h. ◆ IsCylType(). Bool_t TGeoArb8::IsCylType ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Definition at line 73 of file TGeoArb8.h. ◆ IsSamePoint(). static Bool_t TGeoArb8::IsSamePoint ; (; const Double_t * ; p1, . const Double_t * ; p2 . ). inlinestatic . Definition at line 74 of file TGeoArb8.h. ◆ IsTwisted(). Bool_t TGeoArb8::IsTwisted ; (; ); const. inline . Definition at line 80 of file TGeoArb8.h. ◆ operator=(). TGeoArb8 & TGeoArb8::operator= ; (; const TGeoArb8 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoArb8::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ Safety_v(). void TGeoArb8::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SafetyToFace(). Double_t TGeoArb8::SafetyToFace ; (; const Double_t * ; point, . Int_t ; iseg, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoArb8::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SetDimensions(). void TGeoArb8::SetDimensions ; (; Double_t * ; param). overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SetDz(). void TGeoArb8::SetDz ; (; Double_t ; dz). inline . Definition at line 88 of file TGeoArb8.h. ◆ SetPlaneVertices(). void TGeoArb8::SetPlaneVertices ; (; Double_t ; zpl, . Double_t * ; vertices . ); const. ◆ SetPoints() [1/2]. void TGeoArb8::SetPoints ; (; Double_t * ; points); const. overridevirtual . Implements TGeoShap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:31830,safe,safe,31830,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety, ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 198 of file TGDNDManager.h. Member Data Documentation. ◆ fAcceptedAction. Atom_t TGDNDManager::fAcceptedAction. protected . Definition at line 94 of file TGDNDManager.h. ◆ fDNDNoDropCursor. Cursor_t TGDNDManager::fDNDNoDropCursor. protected . no drop cursor type ; Definition at line 111 of file TGDNDManager.h. ◆ fDraggerTypes. Atom_t * TGDNDManager::fDraggerTypes. protected . lists of DND types ; Definition at line 92 of file TGDNDManager.h. ◆ fDragging. Bool_t TGDNDManager::fDragging. protected . kTRUE while dragging ; Definition at line 96 of file TGDNDManager.h. ◆ fDragWin. TGDragWindow* TGDNDManager::fDragWin. protected . drag window ; Definition at line 107 of file TGDNDManager.h. ◆ fDropAccepted. Bool_t TGDNDManager::fDropAccepted. protected . kTRUE if drop accepted ; Definition at line 97 of file TGDNDManager.h. ◆ fDropTimeout. TTimer* TGDNDManager::fDropTimeout. protected . drop timeout ; Definition at line 106 of file TGDNDManager.h. ◆ fDropType. Atom_t TGDNDManager::fDropType. protected . drop type ; Definition at line 93 of file TGDNDManager.h. ◆ fgDNDActionAsk. Atom_t TGDNDManager::fgDNDActionAsk = kNone. staticprotected . Definition at line 119 of file TGDNDManager.h. ◆ fgDNDActionCopy. Atom_t TGDNDManager::fgDNDActionCopy = kNone. staticprotected . Definition at line 118 of file TGDNDManager.h. ◆ fgDNDActionDescrip. Atom_t TGDNDManager::fgDNDActionDescrip = kNone. staticprotected . Definition at line 120 of file TGDNDManager.h. ◆ fgDNDActionLink. Atom_t TGDNDManager::fgDNDActionLink = kNone. staticprotected . Definition at line 118 of file TGDNDManager.h. ◆ fgDNDActionList. Atom_t TGDNDManager::fgDNDActionList = kNone. staticprotected . Definition at line 120 of file TGDNDManager.h. ◆ fgDNDActionMove. Atom_t TGDNDManager::fgDNDActionMove = kNone. staticprotected . Definition at line 118 of file TGDNDManager.h. ◆ fgDNDActionPrivate. Atom_t TGDNDManager::fgDNDActionPrivate = kNon,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:26019,timeout,timeout,26019,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['timeout'],['timeout']
Safety," ; (; std::string const & ; type). Choose the minimizer algorithm. ; Passing an empty string selects the default minimizer type returned by ROOT::Math::MinimizerOptions::DefaultMinimizerType(). ; Definition at line 246 of file RooMinimizer.cxx. ◆ setOffsetting(). void RooMinimizer::setOffsetting ; (; bool ; flag). Enable internal likelihood offsetting for enhanced numeric precision. ; Definition at line 234 of file RooMinimizer.cxx. ◆ setPrintEvalErrors(). void RooMinimizer::setPrintEvalErrors ; (; int ; numEvalErrors). inline . Definition at line 152 of file RooMinimizer.h. ◆ setPrintLevel(). void RooMinimizer::setPrintLevel ; (; int ; newLevel). Change the MINUIT internal printing level. ; Definition at line 472 of file RooMinimizer.cxx. ◆ setProfile(). void RooMinimizer::setProfile ; (; bool ; flag = true). inline . Definition at line 170 of file RooMinimizer.h. ◆ setRecoverFromNaNStrength(). void RooMinimizer::setRecoverFromNaNStrength ; (; double ; strength). Try to recover from invalid function values. ; When invalid function values are encountered, a penalty term is returned to the minimiser to make it back off. This sets the strength of this penalty. NoteA strength of zero is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24). Positive values lead to a gradient pointing away from the undefined regions. Use ~10 to force the minimiser away from invalid function values. ; Definition at line 802 of file RooMinimizer.cxx. ◆ setStrategy(). void RooMinimizer::setStrategy ; (; int ; istrat). Change MINUIT strategy to istrat. ; Accepted codes are 0,1,2 and represent MINUIT strategies for dealing most efficiently with fast FCNs (0), expensive FCNs (2) and 'intermediate' FCNs (1) ; Definition at line 189 of file RooMinimizer.cxx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:28630,recover,recover,28630,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['recover'],['recover']
Safety," ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has been placed in the system timer list (using TurnOn()).; 228/// If a TTimer subclass is placed on another list, override TurnOff() to; 229/// remove the timer from the correct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:7105,timeout,timeout,7105,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,2,['timeout'],['timeout']
Safety," ; 293 INLINE_TEMPLATE_ARGS Int_t ReadTextObject(TBuffer &buf, void *addr, const TConfiguration *config); 294 {; 295 void *x = (void *)(((char *)addr) + config->fOffset);; 296 buf.ReadFastArray(x, config->fCompInfo->fClass, config->fCompInfo->fLength, config->fCompInfo->fStreamer);; 297 return 0;; 298 }; 299 ; 300 INLINE_TEMPLATE_ARGS Int_t ReadTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 301 {; 302 void *x = (void *)(((char *)addr) + config->fOffset);; 303 buf.StreamObject(x, TObject::Class(), TObject::Class());; 304 return 0;; 305 }; 306 ; 307 INLINE_TEMPLATE_ARGS Int_t ReadTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 308 {; 309 void *x = (void *)(((char *)addr) + config->fOffset);; 310 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 311 ((TBufferText *)&buf)->ReadBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 312 return 0;; 313 }; 314 ; 315 INLINE_TEMPLATE_ARGS Int_t ReadTextStreamer(TBuffer &buf, void *addr, const TConfiguration *config); 316 {; 317 void *x = (void *)(((char *)addr) + config->fOffset);; 318 TMemberStreamer *pstreamer = config->fCompInfo->fStreamer;; 319 ; 320 UInt_t start, count;; 321 /* Version_t v = */ buf.ReadVersion(&start, &count, config->fCompInfo->fClass);; 322 (*pstreamer)(buf, x, config->fCompInfo->fLength);; 323 buf.CheckByteCount(start, count, config->fCompInfo->fElem->GetFullName());; 324 return 0;; 325 }; 326 ; 327 INLINE_TEMPLATE_ARGS Int_t ReadTextTObjectBase(TBuffer &buf, void *addr, const TConfiguration *config); 328 {; 329 // action required to call custom code for TObject as base class; 330 void *x = (void *)(((char *)addr) + config->fOffset);; 331 buf.ReadClassBuffer(TObject::Class(), x, TObject::Class());; 332 return 0;; 333 }; 334 ; 335 INLINE_TEMPLATE_ARGS Int_t ReadTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 336 {; 337 void *x = (void *)(((char *)addr) + config->fOffset);; 338 buf.StreamObject(x, TNamed::Class(), TNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:11642,avoid,avoid,11642,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety," ; 4283////////////////////////////////////////////////////////////////////////////////; 4284/// Activate/deactivate usage of parallel world navigation. Can only be done if; 4285/// there is a parallel world. Activating navigation will automatically close; 4286/// the parallel geometry.; 4287 ; 4288void TGeoManager::SetUseParallelWorldNav(Bool_t flag); 4289{; 4290 if (!fParallelWorld) {; 4291 Error(""SetUseParallelWorldNav"", ""No parallel world geometry defined. Use CreateParallelWorld."");; 4292 return;; 4293 }; 4294 if (!flag) {; 4295 fUsePWNav = flag;; 4296 return;; 4297 }; 4298 if (!fClosed) {; 4299 Error(""SetUseParallelWorldNav"", ""The geometry must be closed first"");; 4300 return;; 4301 }; 4302 // Closing the parallel world geometry is mandatory; 4303 if (fParallelWorld->CloseGeometry()); 4304 fUsePWNav = kTRUE;; 4305}; 4306 ; 4307Bool_t TGeoManager::LockDefaultUnits(Bool_t new_value); 4308{; 4309 Bool_t val = gGeometryLocked;; 4310 gGeometryLocked = new_value;; 4311 return val;; 4312}; 4313 ; 4314TGeoManager::EDefaultUnits TGeoManager::GetDefaultUnits(); 4315{; 4316 return fgDefaultUnits;; 4317}; 4318 ; 4319void TGeoManager::SetDefaultUnits(EDefaultUnits new_value); 4320{; 4321 if (fgDefaultUnits == new_value) {; 4322 gGeometryLocked = true;; 4323 return;; 4324 } else if (gGeometryLocked) {; 4325 ::Fatal(""TGeoManager"", ""The system of units may only be changed once, \n""; 4326 ""BEFORE any elements and materials are created! \n""; 4327 ""Alternatively unlock the default units at own risk."");; 4328 } else if (new_value == kG4Units) {; 4329 ::Info(""TGeoManager"", ""Changing system of units to Geant4 units (mm, ns, MeV)."");; 4330 } else if (new_value == kRootUnits) {; 4331 ::Info(""TGeoManager"", ""Changing system of units to ROOT units (cm, s, GeV)."");; 4332 }; 4333 fgDefaultUnits = new_value;; 4334}; 4335 ; 4336void TGeoManager::SetExportPrecision(UInt_t prec); 4337{; 4338 fgExportPrecision = prec;; 4339}; 4340 ; 4341UInt_t TGeoManager::GetExportPrecision(); 4342{; 4343 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:157415,risk,risk,157415,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['risk'],['risk']
Safety," ;  . Protected Member Functions;  TGeoParallelWorld (const TGeoParallelWorld &)=delete;  switch between different algorithm implementations ;  ; TGeoParallelWorld & operator= (const TGeoParallelWorld &)=delete;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; AccelerationMode fAccMode = AccelerationMode::kVoxelFinder;  to keep the vector of primitive axis aligned bounding boxes ;  ; void * fBoundingBoxes = nullptr;  stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ;  ; void * fBVH = nullptr;  array of physical nodes ;  ; TGeoManager * fGeoManager;  ; Bool_t fIsClosed;  ; TGeoPhysicalNode * fLastState;  helper volume ;  ; TObjArray * fPaths;  ; TObjArray * fPhysical;  Last PN touched. ;  ; std::vector< unsigned int > fSafetyCandidateStore {};  A regular 3D cache layer for fast point-based safety lookups. ;  ; TGeoVoxelGrid< SafetyVoxelInfo > * fSafetyVoxelCache;  BVH helper structure for safety and navigation. ;  ; Bool_t fUseOverlaps;  ; TGeoVolume * fVolume;  Closed flag. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; TGeoPhysicalNode * FindNextBoundaryBVH (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world in a trivial loop version (for debugging) ;  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:14208,safe,safety,14208,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety," ;  ; static Bool_t IsCrossingSemiplane (const Double_t *point, const Double_t *dir, Double_t cphi, Double_t sphi, Double_t &snext, Double_t &rxy);  Compute distance from POINT to semiplane defined by PHI angle along DIR. ;  ; static Bool_t IsInPhiRange (const Double_t *point, Double_t phi1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:20292,safe,safety,20292,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,27,['safe'],['safety']
Safety, ;  ; void StreamerNVi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:2693,safe,safe,2693,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['safe'],['safe']
Safety," = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:2356,safe,safe,2356,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,3,['safe'],['safe']
Safety," = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); virtual voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual voidShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:17609,abort,abort,17609,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['abort'],['abort']
Safety," = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:26316,recover,recovery,26316,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['recover'],['recovery']
Safety," = fBuffer;; 916 if (fObjlen > fNbytes-fKeylen) {; 917 fBuffer = bufferRead;; 918 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 919 } else {; 920 fBuffer = bufferRef.Buffer();; 921 ReadFile(); //Read object structure from file; 922 }; 923 fBuffer = storeBuffer;; 924 ; 925 // get version of key; 926 bufferRef.SetBufferOffset(sizeof(fNbytes));; 927 Version_t kvers = bufferRef.ReadVersion();; 928 ; 929 bufferRef.SetBufferOffset(fKeylen);; 930 TObject *tobj = 0;; 931 // Create an instance of this class; 932 ; 933 char *pobj = (char*)cl->New();; 934 if (!pobj) {; 935 Error(""ReadObjWithBuffer"", ""Cannot create new object of class %s"", fClassName.Data());; 936 return 0;; 937 }; 938 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 939 if (baseOffset==-1) {; 940 // cl does not inherit from TObject.; 941 // Since this is not possible yet, the only reason we could reach this code; 942 // is because something is screw up in the ROOT code.; 943 Fatal(""ReadObjWithBuffer"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 944 fClassName.Data());; 945 }; 946 tobj = (TObject*)(pobj+baseOffset);; 947 ; 948 if (kvers > 1); 949 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 950 ; 951 if (fObjlen > fNbytes-fKeylen) {; 952 char *objbuf = bufferRef.Buffer() + fKeylen;; 953 UChar_t *bufcur = (UChar_t *)&bufferRead[fKeylen];; 954 Int_t nin, nout = 0, nbuf;; 955 Int_t noutot = 0;; 956 while (1) {; 957 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 958 if (hc!=0) break;; 959 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 960 if (!nout) break;; 961 noutot += nout;; 962 if (noutot >= fObjlen) break;; 963 bufcur += nin;; 964 objbuf += nout;; 965 }; 966 if (nout) {; 967 tobj->Streamer(bufferRef); //does not work with example 2 above; 968 } else {; 969 // Even-though we have a TObject, if the class is emulated the virtual; 970 // table may not be 'right', so let's go via the TClass.; 971 cl->Destructor(pobj);; 972 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:33571,detect,detection,33571,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['detect'],['detection']
Safety," = kVoid_t;; 342 return;; 343 }; 344 }; 345 ; 346 if ( intype.substr(0,6) == ""string"" || intype.substr(0,11) == ""std::string"" ) {; 347 fCase = kBIT_ISSTRING;; 348 fType = TClass::GetClass(""string"");; 349 fCtor = fType->GetNew();; 350 fDtor = fType->GetDestructor();; 351 fDelete = fType->GetDelete();; 352 if (isPointer) {; 353 fCase |= kIsPointer;; 354 fSize = sizeof(void*);; 355 } else {; 356 fSize = sizeof(std::string);; 357 }; 358 }; 359 else {; 360 // In the case where we have an emulated class,; 361 // if the class is nested (in a class or a namespace),; 362 // calling G__TypeInfo ti(inside.c_str());; 363 // might fail because CINT does not known the nesting; 364 // scope, so let's first look for an emulated class:; 365 ; 366 fType = TClass::GetClass(intype.c_str(),kTRUE,silent, hint_pair_offset, hint_pair_size);; 367 ; 368 if (fType) {; 369 if (isPointer) {; 370 fCase |= kIsPointer;; 371 fSize = sizeof(void*);; 372 if (fType == TString::Class()) {; 373 fCase |= kBIT_ISTSTRING;; 374 }; 375 }; 376 fCase |= kIsClass;; 377 fCtor = fType->GetNew();; 378 fDtor = fType->GetDestructor();; 379 fDelete = fType->GetDelete();; 380 } else {; 381 R__LOCKGUARD(gInterpreterMutex);; 382 ; 383 // Try to avoid autoparsing.; 384 ; 385 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 386 assert(typeTable && ""The type of the list of type has changed"");; 387 ; 388 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );; 389 if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {; 390 fKind = (EDataType)fundType->GetType();; 391 // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );; 392 ; 393 fCase |= kIsFundamental;; 394 if (isPointer) {; 395 fCase |= kIsPointer;; 396 fSize = sizeof(void*);; 397 } else {; 398 fSize = fundType->Size();; 399 }; 400 } else if (TEnum::GetEnum( intype.c_str(), TEnum::kNone) ) {; 401 // This is a known enum.; 402 fCase = kIsEnum;; 403 fSize = sizeof(Int_t);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:11235,avoid,avoid,11235,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['avoid'],['avoid']
Safety," = true . ); const. Function for evaluating the loss, based on the activations stored in the last layer. ; Definition at line 1263 of file DeepNet.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; Tensor_t & ; input, . const Matrix_t & ; groundTruth, . const Matrix_t & ; weights, . bool ; inTraining = false, . bool ; includeRegularization = true . ). Function for evaluating the loss, based on the propagation of the given input. ; Definition at line 1279 of file DeepNet.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . EOutputFunction ; f . ); const. Prediction based on activations stored in the last layer. ; Definition at line 1303 of file DeepNet.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . Tensor_t & ; input, . EOutputFunction ; f . ). Prediction for the given inputs, based on what network learned. ; Definition at line 1311 of file DeepNet.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Print. Print the Deep Net Info. ; Definition at line 1321 of file DeepNet.h. ◆ RegularizationTerm(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::RegularizationTerm. Function for computing the regularizaton term to be added to the loss function . Definition at line 1289 of file DeepNet.h. ◆ ResetTraining(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::ResetTraining. Function that reset some training flags after looping all the events but not the weights. ; Definition at line 886 of file DeepNet.h. ◆ SetBatchDepth(). template<typename Archite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:24888,predict,predictions,24888,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,1,['predict'],['predictions']
Safety," > . auto ROOT::Internal::GetTheRightOp ; (; T(F::*)(T *, double *) ; opPtr); -> decltype(opPtr); . Definition at line 219 of file TF1.h. ◆ gVersionCheck(). static TVersionCheck ROOT::Internal::gVersionCheck ; (; ROOT_VERSION_CODE ; ). static . ◆ hasBeginEnd() [1/2]. template<typename > . constexpr bool ROOT::Internal::hasBeginEnd ; (;  ; ...). constexpr . Definition at line 72 of file RRangeCast.hxx. ◆ hasBeginEnd() [2/2]. template<typename T > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7345 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:35990,safe,safe,35990,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety," > . auto ROOT::Internal::GetTheRightOp ; (; T(F::*)(T *, double *) ; opPtr); -> decltype(opPtr); . Definition at line 219 of file TF1.h. ◆ gVersionCheck(). static TVersionCheck ROOT::Internal::gVersionCheck ; (; ROOT_VERSION_CODE ; ). static . ◆ hasBeginEnd() [1/2]. template<typename > . constexpr bool ROOT::Internal::hasBeginEnd ; (;  ; ...). constexpr . Definition at line 72 of file RRangeCast.hxx. ◆ hasBeginEnd() [2/2]. template<typename T > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7412 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:36571,safe,safe,36571,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety," And Related Symbol Documentation. ◆ RWebWindow. friend class RWebWindow. friend . Definition at line 38 of file RWebWindowsManager.hxx. Member Data Documentation. ◆ fAddr. std::string ROOT::RWebWindowsManager::fAddr. private . ! HTTP address of the server ; Definition at line 42 of file RWebWindowsManager.hxx. ◆ fAssgnExec. std::unique_ptr<TExec> ROOT::RWebWindowsManager::fAssgnExec. private . ! special exec to assign thread id via ProcessEvents ; Definition at line 51 of file RWebWindowsManager.hxx. ◆ fExternalProcessEvents. bool ROOT::RWebWindowsManager::fExternalProcessEvents {false}. private . ! indicate that there are external process events engine ; Definition at line 50 of file RWebWindowsManager.hxx. ◆ fIdCnt. unsigned ROOT::RWebWindowsManager::fIdCnt {0}. private . ! counter for identifiers ; Definition at line 46 of file RWebWindowsManager.hxx. ◆ fLaunchTmout. float ROOT::RWebWindowsManager::fLaunchTmout {30.}. private . ! timeout in seconds to start browser process, default 30s ; Definition at line 49 of file RWebWindowsManager.hxx. ◆ fMutex. std::recursive_mutex ROOT::RWebWindowsManager::fMutex. private . ! main mutex, used for window creations ; Definition at line 45 of file RWebWindowsManager.hxx. ◆ fServer. std::unique_ptr<THttpServer> ROOT::RWebWindowsManager::fServer. private . ! central communication with the all used displays ; Definition at line 41 of file RWebWindowsManager.hxx. ◆ fSessionKey. std::string ROOT::RWebWindowsManager::fSessionKey. private . ! secret session key used on client to code connections keys ; Definition at line 43 of file RWebWindowsManager.hxx. ◆ fShowCallback. WebWindowShowCallback_t ROOT::RWebWindowsManager::fShowCallback. private . ! function called for each RWebWindow::Show call ; Definition at line 52 of file RWebWindowsManager.hxx. ◆ fUseHttpThrd. bool ROOT::RWebWindowsManager::fUseHttpThrd {false}. private . ! use special thread for THttpServer ; Definition at line 47 of file RWebWindowsManager.hxx. ◆ fUseSenderThr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:20291,timeout,timeout,20291,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety," Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const; Decides fast if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:14638,safe,safe,14638,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['safe'],['safe']
Safety," Bool_t Init();; 347 virtual void SetProgname(const char *name);; 348 virtual void SetDisplay();; 349 void SetErrorStr(const char *errstr);; 350 const char *GetErrorStr() const { return GetLastErrorString(); }; 351 virtual const char *GetError();; 352 virtual Int_t GetCryptoRandom(void *buf, Int_t len);; 353 void RemoveOnExit(TObject *obj);; 354 virtual const char *HostName();; 355 virtual void NotifyApplicationCreated();; 356 ; 357 static Int_t GetErrno();; 358 static void ResetErrno();; 359 void Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);; 360 void GetBeepDefaults(Int_t &freq, Int_t &duration) const { freq = fBeepFreq; duration = fBeepDuration; }; 361 ; 362 //---- EventLoop; 363 virtual void Run();; 364 virtual Bool_t ProcessEvents();; 365 virtual void DispatchOneEvent(Bool_t pendingOnly = kFALSE);; 366 virtual void ExitLoop();; 367 Bool_t InControl() const { return fInControl; }; 368 virtual void InnerLoop();; 369 virtual Int_t Select(TList *active, Long_t timeout);; 370 virtual Int_t Select(TFileHandler *fh, Long_t timeout);; 371 ; 372 //---- Handling of system events; 373 virtual void AddSignalHandler(TSignalHandler *sh);; 374 virtual TSignalHandler *RemoveSignalHandler(TSignalHandler *sh);; 375 virtual void ResetSignal(ESignals sig, Bool_t reset = kTRUE);; 376 virtual void ResetSignals();; 377 virtual void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE);; 378 virtual void IgnoreInterrupt(Bool_t ignore = kTRUE);; 379 virtual TSeqCollection *GetListOfSignalHandlers() const { return fSignalHandler; }; 380 virtual void AddFileHandler(TFileHandler *fh);; 381 virtual TFileHandler *RemoveFileHandler(TFileHandler *fh);; 382 virtual TSeqCollection *GetListOfFileHandlers() const { return fFileHandler; }; 383 virtual void AddStdExceptionHandler(TStdExceptionHandler *eh);; 384 virtual TStdExceptionHandler *RemoveStdExceptionHandler(TStdExceptionHandler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:15423,timeout,timeout,15423,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['timeout'],['timeout']
Safety," Bool_t add(const RooAbsArg& var, Bool_t silent); Add element to non-owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is specified to own its elements. Eventual error messages; can be suppressed with the silent flag. Bool_t addOwned(RooAbsArg& var, Bool_t silent); Add element to an owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg* addClone(const RooAbsArg& var, Bool_t silent); Add clone of specified element to an owning set. If sucessful, the; set will own the clone, not the original. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg& operator[](const char* name) const; Array operator. Named element must exist in set, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. Bool_t checkForDup(const RooAbsArg& arg, Bool_t silent) const; Check if element with var's name is already in set. Double_t getRealValue(const char* name, Double_t defVal = 0, Bool_t verbose = kFALSE) const; Get value of a RooAbsReal stored in set with given name. If none is found, value of defVal is returned.; No error messages are printed unless the verbose flag is set. Bool_t setRealValue(const char* name, Double_t newVal = 0, Bool_t verbose = kFALSE); Set value of a RooAbsRealLValye stored in set with given name to newVal; No error messages are printed unless the verbose flag is set. const char* getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; Get state name of a RooAbsCategory stored in set with given name. If none is found, value of defVal is returned.; No error messages ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:18186,abort,abort,18186,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,1,['abort'],['abort']
Safety," Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHalfSpace.html:8289,safe,safe,8289,root/html602/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html,2,['safe'],['safe']
Safety," C++ type_info, we must be in the case of; 1669 // a template of Double32_t. This is actually a correct case.; 1670 } else {; 1671 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1672 actualClass->GetName(), branchname, claim->GetName());; 1673 }; 1674 }; 1675 }; 1676 if (!actualClass) {; 1677 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1678 branchname, ptrClass->GetName());; 1679 actualClass = ptrClass;; 1680 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1681 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1682 return nullptr;; 1683 }; 1684 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1685 Error(""Branch"", writeStlWithoutProxyMsg,; 1686 actualClass->GetName(), branchname, actualClass->GetName());; 1687 return nullptr;; 1688 }; 1689 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Same as TTree::Branch but automatic detection of the class name.; 1694/// \see TTree::Branch for other details.; 1695 ; 1696TBranch* TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); 1697{; 1698 if (!ptrClass) {; 1699 if (datatype == kOther_t || datatype == kNoType_t) {; 1700 Error(""Branch"", ""The pointer specified for %s is not of a class or type known to ROOT"", branchname);; 1701 } else {; 1702 TString varname; varname.Form(""%s/%c"",branchname,DataTypeToChar(datatype));; 1703 retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:65390,detect,detection,65390,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['detect'],['detection']
Safety," Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:16476,safe,safe,16476,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['safe'],['safe']
Safety," ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:14057,safe,safe,14057,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,3,['safe'],['safe']
Safety," Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:13270,timeout,timeout,13270,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,3,['timeout'],['timeout']
Safety," Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSubString.html:2560,detect,detecting,2560,root/html534/TSubString.html,https://root.cern,https://root.cern/root/html534/TSubString.html,1,['detect'],['detecting']
Safety, Definition at line 191 of file RuleFitParams.h. ◆ fNTCoeff. Double_t* TMVA::RuleFitParams::fNTCoeff. protected . GD path: rule coefficients. ; Definition at line 243 of file RuleFitParams.h. ◆ fNTCoefRad. Double_t TMVA::RuleFitParams::fNTCoefRad. protected . GD path: 'radius' of all rulecoeffs. ; Definition at line 241 of file RuleFitParams.h. ◆ fNTErrorRate. Double_t TMVA::RuleFitParams::fNTErrorRate. protected . GD path: error rate (or performance) ; Definition at line 239 of file RuleFitParams.h. ◆ fNTLinCoeff. Double_t* TMVA::RuleFitParams::fNTLinCoeff. protected . GD path: linear coefficients. ; Definition at line 244 of file RuleFitParams.h. ◆ fNTNuval. Double_t TMVA::RuleFitParams::fNTNuval. protected . GD path: value of nu. ; Definition at line 240 of file RuleFitParams.h. ◆ fNTOffset. Double_t TMVA::RuleFitParams::fNTOffset. protected . GD path: model offset. ; Definition at line 242 of file RuleFitParams.h. ◆ fNTRisk. Double_t TMVA::RuleFitParams::fNTRisk. protected . GD path: risk. ; Definition at line 238 of file RuleFitParams.h. ◆ fPathIdx1. UInt_t TMVA::RuleFitParams::fPathIdx1. protected . first event index for path search ; Definition at line 197 of file RuleFitParams.h. ◆ fPathIdx2. UInt_t TMVA::RuleFitParams::fPathIdx2. protected . last event index for path search ; Definition at line 198 of file RuleFitParams.h. ◆ fPerfIdx1. UInt_t TMVA::RuleFitParams::fPerfIdx1. protected . first event index for performance evaluation ; Definition at line 199 of file RuleFitParams.h. ◆ fPerfIdx2. UInt_t TMVA::RuleFitParams::fPerfIdx2. protected . last event index for performance evaluation ; Definition at line 200 of file RuleFitParams.h. ◆ fRuleEnsemble. RuleEnsemble* TMVA::RuleFitParams::fRuleEnsemble. protected . rule ensemble ; Definition at line 189 of file RuleFitParams.h. ◆ fRuleFit. RuleFit* TMVA::RuleFitParams::fRuleFit. protected . rule fit ; Definition at line 188 of file RuleFitParams.h. ◆ fsigave. Double_t TMVA::RuleFitParams::fsigave. protected . Si,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:25910,risk,risk,25910,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety," Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 5. Fitting. Distributions; Some analyses want to check theory predictions that exist as a function definition. Others want to use a distribution from a histogram in another step of the analysis. But histograms have bin steps by nature instead of being smooth, and they have bumps / fluctuations due to limited statistics (i.e. ""not enough data"").; So what's needed is a function whose line is ""as close as possible"" to the histogram counts. I.e. we need a function (that predicts the shape of the histogram) and that we can vary a bit (""free parameters""). Then we search for the best set of parameters, such that the function resembles the histogram.; That's fitting.; Fitting in Practice; As often with ROOT, you can use a GUI element (the fit panel, available through the menu in ""Tools"", ""Fit Panel"", or on the prompt (TH1::Fit()). Let's use the fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We want to fit a Gaussian distribution - and hat's already selected by default. Se just press ""Fit"". Looks good, right?; Fit Parameters; As mentioned before, fitting means finding the optimal set of parameters. In the menu, select ""Options"", ""Fit Parameters"" (and resize the statistics box to make its content readable). You will see the values that the minimizer has found optimal, for instance it chose 1.2 as the mean of the Gaussian and 1.04",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:2343,predict,predicts,2343,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['predict'],['predicts']
Safety," Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:15107,safe,safe,15107,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,6,['safe'],['safe']
Safety," Double_t xmin, Double_t xmax ); 111{; 112 return 2*(x - xmin)/(xmax - xmin) - 1.0;; 113}; 114 ; 115////////////////////////////////////////////////////////////////////////////////; 116/// compute ""separation"" defined as; 117/// \f[; 118/// <s2> = \frac{1}{2} \int_{-\infty}^{+\infty} \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; 119/// \f]; 120 ; 121Double_t TMVA::Tools::GetSeparation( TH1* S, TH1* B ) const; 122{; 123 Double_t separation = 0;; 124 ; 125 // sanity checks; 126 // signal and background histograms must have same number of bins and; 127 // same limits; 128 if ((S->GetNbinsX() != B->GetNbinsX()) || (S->GetNbinsX() <= 0)) {; 129 Log() << kFATAL << ""<GetSeparation> signal and background""; 130 << "" histograms have different number of bins: ""; 131 << S->GetNbinsX() << "" : "" << B->GetNbinsX() << Endl;; 132 }; 133 ; 134 if (S->GetXaxis()->GetXmin() != B->GetXaxis()->GetXmin() ||; 135 S->GetXaxis()->GetXmax() != B->GetXaxis()->GetXmax() ||; 136 S->GetXaxis()->GetXmax() <= S->GetXaxis()->GetXmin()) {; 137 Log() << kINFO << S->GetXaxis()->GetXmin() << "" "" << B->GetXaxis()->GetXmin(); 138 << "" "" << S->GetXaxis()->GetXmax() << "" "" << B->GetXaxis()->GetXmax(); 139 << "" "" << S->GetXaxis()->GetXmax() << "" "" << S->GetXaxis()->GetXmin() << Endl;; 140 Log() << kFATAL << ""<GetSeparation> signal and background""; 141 << "" histograms have different or invalid dimensions:"" << Endl;; 142 }; 143 ; 144 Int_t nstep = S->GetNbinsX();; 145 Double_t intBin = (S->GetXaxis()->GetXmax() - S->GetXaxis()->GetXmin())/nstep;; 146 Double_t nS = S->GetSumOfWeights()*intBin;; 147 Double_t nB = B->GetSumOfWeights()*intBin;; 148 ; 149 if (nS > 0 && nB > 0) {; 150 for (Int_t bin=0; bin<nstep; bin++) {; 151 Double_t s = S->GetBinContent( bin+1 )/Double_t(nS);; 152 Double_t b = B->GetBinContent( bin+1 )/Double_t(nB);; 153 // separation; 154 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 155 }; 156 separation *= (0.5*intBin);; 157 }; 158 else {; 159 Log() << kWARNING << ""<GetSeparation> histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:3955,sanity check,sanity checks,3955,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity checks']
Safety," Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:15358,safe,safe,15358,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,3,['safe'],['safe']
Safety," Double_t* w, Bool_t userw, Double_t* rw, Bool_t& ok); Fit value at x[i] *-*-*-*-*-*-*-*-*-. Based on R function lowest: Translated to C++ by C. Stratowa; (R source file: lowess.c by R Development Core Team (C) 1999-2001). -. TGraph * SmoothSuper(TGraph* grin, Option_t* option = """", Double_t bass = 0, Double_t span = 0, Bool_t isPeriodic = kFALSE, Double_t* w = 0); Smooth data with Super smoother*-*-*-. Smooth the (x, y) values by Friedman's ``super smoother''. Arguments:; grin: graph for smoothing. span: the fraction of the observations in the span of the running lines; smoother, or 0 to choose this by leave-one-out cross-validation.; bass: controls the smoothness of the fitted curve.; Values of up to 10 indicate increasing smoothness.; isPeriodic: if TRUE, the x values are assumed to be in [0, 1]; and of period 1.; w: case weights. Details:; supsmu is a running lines smoother which chooses between three spans for; the lines. The running lines smoothers are symmetric, with k/2 data points; each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; 0.05 * n, where n is the number of data points. If span is specified,; a single smoother with span span * n is used. The best of the three smoothers is chosen by cross-validation for each; prediction. The best spans are then smoothed by a running lines smoother; and the final prediction chosen by linear interpolation. The FORTRAN code says: ``For small samples (n < 40) or if there are; substantial serial correlations between observations close in x - value,; then a prespecified fixed span smoother (span > 0) should be used.; Reasonable span values are 0.2 to 0.4.''. References:; Friedman, J. H. (1984) SMART User's Guide.; Laboratory for Computational Statistics,; Stanford University Technical Report No. 1. Friedman, J. H. (1984) A variable span scatterplot smoother.; Laboratory for Computational Statistics,; Stanford University Technical Report No. 5. void BDRsupsmu(Int_t n, Double_t* x, Double_t* y, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:11212,predict,predicted,11212,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,6,['predict'],['predicted']
Safety," Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Tra; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Trap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:17810,safe,safe,17810,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety," Double_t ; r1, . Double_t ; r2, . Double_t & ; b, . Double_t & ; delta . ). static . ◆ Divide(). TGeoVolume * TGeoCone::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetAxisName(). const char * TGeoCone::GetAxisName ; (; Int_t ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoCone::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetBoundingCylinder(). void TGeoCone::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetBuffer3D(). const TBuffer3D & TGeoCone::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetByteCount(). Int_t TGeoCone::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 69 of file TGeoCone.h. ◆ GetDz(). virtual Double_t TGeoCone::GetDz ; (; ); const. inlinevirtual . Definition at line 71 of file TGeoCone.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoCone::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetMeshNumbers(). void TGeoCone::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetNmeshVertices(). Int_t TGeoCone::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetPointsOnSegments(). Bool_t TGeoCone::GetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:28988,avoid,avoid,28988,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['avoid'],['avoid']
Safety," Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:14466,safe,safe,14466,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,3,['safe'],['safe']
Safety," Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn the following way:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:68848,avoid,avoid,68848,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,1,['avoid'],['avoid']
Safety," FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:11075,avoid,avoid,11075,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['avoid'],['avoid']
Safety," For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in those cases first call ExpandPathName().; 1294/// Attention, bizarre convention of return value!!; 1295 ; 1296Bool_t TSystem::AccessPathName(const char *, EAccessMode); 1297{; 1298 return kFALSE;; 1299}; 1300 ; 1301////////////////////////////////////////////////////////////////////////////////; 1302/// Returns TRUE if the url in 'path' points to the local file system.; 1303/// This is used to avoid going through the NIC card for local operations.; 1304 ; 1305Bool_t TSystem::IsPathLocal(const char *path); 1306{; 1307 Bool_t localPath = kTRUE;; 1308 ; 1309 TUrl url(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(gSystem->HostName()));; 1315 if (!strcmp(a.GetHostName(), b.GetHostName()) ||; 1316 !strcmp(a.GetHostAddress(), b.GetHostAddress())) {; 1317 // Host OK; 1318 localPath = kTRUE;; 1319 // Check the user if specified; 1320 if (strlen(url.GetUser()) > 0) {; 1321 UserGroup_t *u = gSystem->GetUserInfo();; 1322 if (u) {; 1323 if (strcmp(u->fUser, url.GetUser())); 1324 // Requested a different user; 1325 localPath = kFALSE;; 1326 delete u;; 1327 }; 1328 }; 1329 }; 1330 }; 1331 // Done; 1332 return localPath;; 1333}; 1334 ; 1335////////////////////////////////////////////////////////////////////////////////; 1336/// Copy a file. If overwrit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:40527,avoid,avoid,40527,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSAViewer.html:27678,timeout,timeout,27678,root/html534/TGLSAViewer.html,https://root.cern,https://root.cern/root/html534/TGLSAViewer.html,2,['timeout'],['timeout']
Safety," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLSAViewer.html:29963,timeout,timeout,29963,root/html604/TGLSAViewer.html,https://root.cern,https://root.cern/root/html604/TGLSAViewer.html,2,['timeout'],['timeout']
Safety," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSAViewer.html:29832,timeout,timeout,29832,root/html602/TGLSAViewer.html,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html,2,['timeout'],['timeout']
Safety," Geometry classes. ; Bridge class for using a VecGeom solid as TGeoShape. ; Definition at line 30 of file TGeoVGShape.h. Public Member Functions;  TGeoVGShape ();  ;  ~TGeoVGShape () override;  Destructor. ;  ; Double_t Capacity () const override;  Returns analytic capacity of the solid. ;  ; void ComputeBBox () override;  Compute bounding box. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Normal computation. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside this shape. ;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; TGeoVolume * Divide (TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t) override;  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; const char * GetName () const override;  Get the shape n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:1250,safe,safe,1250,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,2,['safe'],['safe']
Safety," GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; TString.h; TSysEvtHandler.h; TTime.h; TObjectMother of all ROOT objects.Definition TObject.h:41; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TSysEvtHandlerAbstract base class for handling system events.Definition TSysEvtHandler.h:28; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; TTimer::~TTimervirtual ~TTimer()Definition TTimer.h:71; TTimer::SetTimerIDvoid SetTimerID(UInt_t id=0)Definition TTimer.h:92; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::SetCommandvoid SetCommand(const char *command)Set the interpreter command to be executed at time out.Definition TTimer.cxx:176; TTimer::fCommandTString fCommandDefinition TTimer.h:61; TTimer::SetInterruptSyscallsvoid SetInterruptSyscalls(Bool_t set=kTRUE)When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted...Definition TTimer.cxx:199; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::GetCommandconst char * GetCommand() constDefinition TTimer.h:74; TTimer::fTimeTTime fTimeDefinition TTimer.h:54; TTimer::GetObjectTObject * GetObject()Definition TTimer.h:75; TTimer::Resetvoid Reset()Reset the timer.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:5716,timeout,timeout,5716,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,1,['timeout'],['timeout']
Safety," Histogram default constructor. ; Definition at line 615 of file TH1.cxx. ◆ TH1() [3/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . Double_t ; xlow, . Double_t ; xup . ). protected . Constructor for fix bin size histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xlowlow edge of first bin ; [in]xupupper edge of last bin (not included in last bin) . Definition at line 697 of file TH1.cxx. ◆ TH1() [4/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Float_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type float. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbins+1 . Definition at line 719 of file TH1.cxx. ◆ TH1() [5/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Double_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbins+1 . Definition at line 741 of file TH1.cxx. ◆ ~TH1(). TH1::~TH1 ; (; ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:73014,avoid,avoid,73014,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['avoid'],['avoid']
Safety," IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:447232,recover,recover,447232,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recover']
Safety," Inherited Members; Includes; Libraries. Function documentation; QString SetFileName(const QString& fileName); Set the file pattern. QString GetNewFileName(const QString& fileNamePrototype); Find the filename for the given ""fileNamePrototype"". QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". QWidget * winid(Window_t id); returns the top level QWidget for the ROOT widget. Window_t wid(TQtClientWidget* widget). Window_t rootwid(QPaintDevice* dev). QWidget * wid(Window_t id); method to restore (dynamic cast) the QWidget object pointer (if any) from ROOT windows ""id"". void PrintEvent(Event_t& ); Dump trhe ROOT Event_t structure to debug the code. int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. QString RootFileFormat(const char* selector); { return RootFileFormat(QString(selector)); }. QString RootFileFormat(const QString& selector); Define whether the input string contains any pattern; that matches the ROOT image formats; those Qt library can not provide. QString QtFileFormat(const char* selector); { return QtFileFormat(QString(selector)); }. QString QtFileFormat(const QString& selector); returns Qt file format. if no suitable format found and the selector is empty; the default PNG format is returned. a special treatment of the ""gif"" format.; If ""gif"" is not provided with the local Qt installation; replace ""gif"" format with ""png"" one. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:28011,safe,safely,28011,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,2,['safe'],['safely']
Safety," Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 virtual Bool_t Cp(const char *dst, Bool_t progressbar = kTRUE,UInt_t buffersize = 1000000);; 211 virtual TKey* CreateKey(TDirectory* mother, const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:9005,avoid,avoid,9005,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['avoid'],['avoid']
Safety," Int_t TGeoParaboloid::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoParaboloid::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoParaboloid::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoParaboloid::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoParaboloid::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToParaboloid(). Double_t TGeoParaboloid::DistToParaboloid ; (; const Double_t * ; point, . const Double_t * ; dir, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoParaboloid::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoParaboloid::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoParaboloid::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:25506,safe,safe,25506,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['safe'],['safe']
Safety," Int_t TotalConts = conts->GetSize();; ; printf(""TotalConts = %d\n"", TotalConts);; ; for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; printf(""Contour %d has %d Graphs\n"", i, contLevel->GetSize());; nGraphs += contLevel->GetSize();; }; ; nGraphs = 0;; ; TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);; ; hr->Draw();; Double_t xval0, yval0, zval0;; TLatex l;; l.SetTextSize(0.03);; char val[20];; ; for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) zval0 = contours[2-i];; else zval0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", zval0);; ; // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, xval0, yval0);; if (zval0<0) curv->SetLineColor(kRed);; if (zval0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());; ; // Draw clones of the graphs to avoid deletions in case the 1st; // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");; ; sprintf(val,""%g"",zval0);; l.DrawLatex(xval0,yval0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }; ; ; Double_t SawTooth(Double_t x, Double_t WaveLen){; ; // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //; ; Double_t y;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ContourList_8C.html:4462,avoid,avoid,4462,doc/master/ContourList_8C.html,https://root.cern,https://root.cern/doc/master/ContourList_8C.html,2,['avoid'],['avoid']
Safety," Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoArb8& operator=(const TGeoGtra& ). TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoGtra.html:19310,safe,safe,19310,root/html604/TGeoGtra.html,https://root.cern,https://root.cern/root/html604/TGeoGtra.html,2,['safe'],['safe']
Safety," Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoArb8& operator=(const TGeoGtra& ). TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:19310,safe,safe,19310,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety," Int_t len);  ; Long64_t DavixReadBuffers (Davix_fd *fd, char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  ; Int_t DavixStat (struct stat *st) const;  ; Long64_t DavixWriteBuffer (Davix_fd *fd, const char *buf, Int_t len);  ; Double_t eventStart ();  ; void eventStop (Double_t t, Long64_t len, bool read=true);  set TFile state info ;  ; void Init (Bool_t init);  Initialize a TFile object. ;  . Private Attributes; TDavixFileInternal * d_ptr;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:30482,timeout,timeout,30482,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['timeout'],['timeout']
Safety," Int_t loglevel, const char *alias=0);  Start the PROOF environment. ;  ; TProofQueryResult * MakeQueryResult (Long64_t nent, const char *opt, Long64_t fst, TDSet *dset, const char *selec);  Create a TProofQueryResult instance for this query. ;  ; Int_t PollForNewWorkers () override;  Simulate dynamic addition, for test purposes. ;  ; void SetQueryRunning (TProofQueryResult *pq);  Set query in running state. ;  ; Int_t SetupWorkers (Int_t opt=0, TList *wrks=0);  Start up PROOF workers. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ;  ; Int_t Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; Int_t Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; TSlave * CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir);  Create a new TSlave of type TSlave::kSlave. ;  ; TSlave * CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1);  Create a new TSlave of type TSlave::kMaster. ;  ; TList * GetEnabledPackages () const;  ; TList * GetListOfActiveSlaves () const;  ; TVirtualProofPlayer * GetPlayer () const;  ; TPluginHandler * GetProgressDialog () const;  ; Int_t GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0);  Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ;  ; void HandleLibIncPath (const char *what, Bool_t add, const char *dirs);  Handle lib, inc search paths modification request. ;  ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:36429,timeout,timeout,36429,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['timeout'],['timeout']
Safety," Int_t, const T &... params);  Emit a signal with a varying number of arguments. ;  ; TList * GetListOfClassSignals () const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void SetMenuHidingTimeout (Long_t timeout);  Set global timeout for menu-hiding in mili-seconds. ;  ;  Static Public Member Functions inherited from TGLViewer; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGLColorSet & GetDefaultColorSet ();  Returns reference to the default color-set. ;  ; static Bool_t IsUsingDefaultColorSetForNewViewers ();  Returns the value of the static flag that determines if new viewers should use the default color-set. ;  ; static void SetAxisLabelScale (Float_t als);  Sets static scaling facor that allows simple guide axies to have label values scaled relative to actual scene dimensions. ;  ; static void UseDefaultColorSetForNewViewers (Bool_t x);  Sets static flag that determines if new viewers should use the default color-set. ;  ;  Static Public Member Functions inherited from TVirtualViewer3D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:28794,timeout,timeout,28794,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,2,['timeout'],['timeout']
Safety," Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheSystem.html:11366,timeout,timeout,11366,root/html528/TDCacheSystem.html,https://root.cern,https://root.cern/root/html528/TDCacheSystem.html,4,['timeout'],['timeout']
Safety," Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char*); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheSystem.html:11316,timeout,timeout,11316,root/html526/TDCacheSystem.html,https://root.cern,https://root.cern/root/html526/TDCacheSystem.html,1,['timeout'],['timeout']
Safety," Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:82052,unsafe,unsafe,82052,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['unsafe'],['unsafe']
Safety," L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps; The relevant equations are (1), (2) for the unfolding; and (14) for the L-curve curvature definition. Related literature on unfolding:; The program package RUN and the web-page by V.Blobel; http://www.desy.de/~blobel/unfold.html; Talk by V. Blobel, Terascale Statistics school; https://indico.desy.de/contributionDisplay.py?contribId=23&confId=1149; References quoted in Blobel's talk:; Per Chistian Hansen, Rank-Deficient and D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:1684,detect,detector,1684,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['detect'],['detector']
Safety," Layer_t * GetLayerAt (size_t i) const;  ; std::vector< Layer_t * > & GetLayers ();  ; const std::vector< Layer_t * > & GetLayers () const;  ; ELossFunction GetLossFunction () const;  ; size_t GetOutputWidth () const;  ; ERegularization GetRegularization () const;  ; Scalar_t GetWeightDecay () const;  ; void Initialize ();  DAE functions. ;  ; bool IsTraining () const;  ; Scalar_t Loss (const Matrix_t &groundTruth, const Matrix_t &weights, bool includeRegularization=true) const;  Function for evaluating the loss, based on the activations stored in the last layer. ;  ; Scalar_t Loss (Tensor_t &input, const Matrix_t &groundTruth, const Matrix_t &weights, bool inTraining=false, bool includeRegularization=true);  Function for evaluating the loss, based on the propagation of the given input. ;  ; void Prediction (Matrix_t &predictions, EOutputFunction f) const;  Prediction based on activations stored in the last layer. ;  ; void Prediction (Matrix_t &predictions, Tensor_t &input, EOutputFunction f);  Prediction for the given inputs, based on what network learned. ;  ; void Print () const;  Print the Deep Net Info. ;  ; Scalar_t RegularizationTerm () const;  Function for computing the regularizaton term to be added to the loss function .  ; void ResetTraining ();  Function that reset some training flags after looping all the events but not the weights. ;  ; void SetBatchDepth (size_t batchDepth);  ; void SetBatchHeight (size_t batchHeight);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetBatchWidth (size_t batchWidth);  ; void SetDropoutProbabilities (const std::vector< Double_t > &probabilities);  ; void SetInitialization (EInitialization I);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetLossFunction (ELossFunction J);  ; void SetRegularization (ERegularization R);  ; void SetWeightDecay (Scalar_t weightDecay);  ; void Update (Scalar_t learningRate);  Function t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:6619,predict,predictions,6619,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,1,['predict'],['predictions']
Safety," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoChecker.html:1147,safe,safety,1147,root/html528/TGeoChecker.html,https://root.cern,https://root.cern/root/html528/TGeoChecker.html,6,['safe'],['safety']
Safety," Matches. TGeoPhysicalNode.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 17/02/04; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoPhysicalNode; 13\ingroup Geometry_classes; 14 ; 15Physical nodes are the actual 'touchable' objects in the geometry, representing; 16a path of positioned volumes starting with the top node:; 17 path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; 18 ; 19The number of physical nodes is given by the total number of possible of; 20branches in the geometry hierarchy. In case of detector geometries and; 21specially for calorimeters this number can be of the order 1e6-1e9, therefore; 22it is impossible to create all physical nodes as objects in memory. In TGeo,; 23physical nodes are represented by the class TGeoPhysicalNode and can be created; 24on demand for alignment purposes:; 25 ; 26~~~ {.cpp}; 27 TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); 28~~~; 29 ; 30Once created, a physical node can be misaligned, meaning that its position; 31or even shape can be changed:; 32 ; 33~~~ {.cpp}; 34 pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); 35~~~; 36*/; 37 ; 38/** \class TGeoPNEntry; 39\ingroup Geometry_classes; 40 ; 41The knowledge of the path to the objects that need to be misaligned is; 42essential since there is no other way of identifying them. One can however; 43create 'symbolic links' to any complex path to make it more representable; 44for the object it designates:; 45 ; 46~~~ {.cpp}; 47 TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; 48 pne->SetPhysicalNode(pn); 49~~~; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:1046,detect,detector,1046,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['detect'],['detector']
Safety," NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THStack.html:11771,avoid,avoid,11771,root/html534/THStack.html,https://root.cern,https://root.cern/root/html534/THStack.html,1,['avoid'],['avoid']
Safety," NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:09; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THStack.html:12496,avoid,avoid,12496,root/html602/THStack.html,https://root.cern,https://root.cern/root/html602/THStack.html,1,['avoid'],['avoid']
Safety," NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; cout << ""[ERROR] Bad file"" << endl;; return;; }; ; Double_t x[3], y[3];; for (int i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; ; det_avg_merge->AddBin(3, x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealistic_8C.html:1458,detect,detector,1458,doc/master/tprofile2polyRealistic_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html,1,['detect'],['detector']
Safety," One can get a picture on which are the most ""burned"" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced.; All histos are saved in the file statistics.root ; Definition at line 503 of file TGeoChecker.cxx. ◆ CheckOverlaps(). void TGeoChecker::CheckOverlaps ; (; const TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ). Check illegal overlaps for volume VOL within a limit OVLP. ; Definition at line 1427 of file TGeoChecker.cxx. ◆ CheckOverlapsBySampling(). void TGeoChecker::CheckOverlapsBySampling ; (; TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Int_t ; npoints = 1000000 . ); const. Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. ◆ CheckPoint(). void TGeoChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21081,safe,safety,21081,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety," Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a function of the protocol field in 'name'. ;  ; static void IncrementFileCounter ();  ; static TFile * Open (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create / open a file. ;  ; static TFile * Open (TFileOpenHandle *handle);  Waits for the completion of an asynchronous open request. ;  ; static Bool_t SetCacheFileDir (std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE);  Sets the directory where to locally stage/cache remote files. ;  ; static void SetFileBytesRead (Long64_t bytes=0);  ; static void SetFileBytesWritten (Long64_t bytes=0);  ; static void SetFileReadCalls (Int_t readcalls=0);  ; static Bool_t SetOnlyStaged (Bool_t onlystaged);  Sets only staged flag. ;  ; static UInt_t SetOpenTimeout (UInt_t timeout);  Sets open timeout time (in ms). Returns previous timeout value. ;  ; static void SetReadaheadSize (Int_t bufsize=256000);  ; static void SetReadStreamerInfo (Bool_t readinfo=kTRUE);  Specify if the streamerinfos must be read at file opening. ;  ; static Bool_t ShrinkCacheFileDir (Long64_t shrinkSize, Long_t cleanupInteval=0);  Try to shrink the cache to the desired size. ;  ;  Static Public Member Functions inherited from TDirectoryFile; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:29712,timeout,timeout,29712,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,15,['timeout'],['timeout']
Safety," PATH now fixed ROOT-7715; Fix builtin_xrootd option that was not working for XROOTD version 4.2.2.; Option gnuinstall also sets RPATH in librries and executables in installation directory; Various fixes for MacOS X 10.11 ROOT-7680. Core. Fix thread safety of the creation of TMethodCall from a TFunction.; Fix dictionary generation of STL collection involving one of ROOT’s core classes when the user header contains only a forward declaration of the class [ROOT-7695]. Bugs. [ROOT-7680] - Can’t build v6-02-12 on MacOS X 10.11; [ROOT-7695] - Segmentation violation in rootcint; [ROOT-7709] - PyROOT not functional with system-default Python version on MacOS X 10.11; [ROOT-7715] - Building ROOT with CMake not in my PATH fails. Release 6.04/08; Build. Add –disable-search-usrlocal to configure/make to be able to avoid conflict with incompatible installation (e.g. homebrew).; Add /opt/X11 to configure/make search for include files and libraries.; Updates PCRE to 8.37 (current upstream version) which can detect PPC64LE machine.; Fail cmake configuration if the specified CMAKE_BUILD_TYPE is unknown; Fix RPATH for MacOSX (El Capitan) to avoid building with -Drpath=ON. The default uses rpath=@loader_path/../lib. Core. Add missing protection when creating new StreamerInfo.; Add accessor functions and functionality needed by CMS event display.; Do not delete resource when replaceing default TApplication. Interpreter. Prevent crash in expressions which contain use undefined identifier ROOT-7737; Disable unnecessary code during dictionary generation that triggered problem due to the lack of support for template parameter packs ROOT-7708; Add suport in the type and name normalization routine for template parameter packs ROOT-7708. IO. For backward compatibility with ROOT5, allow to define IO constructors with the signature MyClass::MyClass(void&) where void is a forward declared type.; In TBuffer shrink buffers when requested. Histograms. Fix interval calculation in Divide for the Pois",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:32836,detect,detect,32836,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['detect'],['detect']
Safety," POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Implements TGeoBoolNode.; Definition at line 1398 of file TGeoBoolNode.cxx. ◆ Contains(). Bool_t TGeoIntersection::Contains ; (; const Double_t * ; point); const. overridevirtual . Find if a intersection of two shapes contains a given point. ; Implements TGeoBoolNode.; Definition at line 1449 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoIntersection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 166 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoIntersection::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1464 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoIntersection::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1472 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoIntersection::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1505 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoIntersection::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 156 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoInters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:16758,safe,safe,16758,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safe']
Safety," Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:970996,safe,safety,970996,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," Private Attributes |; List of all members ; TGeoNavigator Class ReferenceThe Geometry Package » Geometry classes. ; Class providing navigation API for TGeo geometries. ; Several instances are allowed for a single geometry. A default navigator is provided for any geometry but one may add several others for parallel navigation:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; Int_t inav = gGeoManager->AddNavigator(navig);; gGeoManager->SetCurrentNavigator(inav);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; int; .... and then switch back to the default navigator:; gGeoManager->SetCurrentNavigator(0);. Definition at line 32 of file TGeoNavigator.h. Public Member Functions;  TGeoNavigator ();  global mode is caching enabled for parallel world safety calls ;  ;  TGeoNavigator (TGeoManager *geom);  Constructor. ;  ;  ~TGeoNavigator () override;  Destructor. ;  ; void BuildCache (Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE);  Builds the cache for physical nodes and global matrices. ;  ; Bool_t cd (const char *path="""");  Browse the tree of nodes starting from top node according to pathname. ;  ; void CdDown (Int_t index);  Make a daughter of current node current. ;  ; void CdDown (TGeoNode *node);  Make a daughter of current node current. ;  ; void CdNext ();  Do a cd to the node found next by FindNextBoundary. ;  ; void CdNode (Int_t nodeid);  Change current path to point to the node having this id. ;  ; void CdTop ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:1293,safe,safety,1293,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety," Public Member Functions;  TGeoArb8 ();  ;  TGeoArb8 (const char *name, Double_t dz, Double_t *vertices=nullptr);  ;  TGeoArb8 (Double_t dz, Double_t *vertices=nullptr);  ;  ~TGeoArb8 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; void ComputeTwist ();  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToPlane (const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:1142,safe,safe,1142,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety," Public Member Functions;  TGeoPara ();  ;  TGeoPara (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi);  ;  TGeoPara (Double_t *param);  ;  TGeoPara (Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi);  ;  ~TGeoPara () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha () const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:1218,safe,safe,1218,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety," Public Member Functions;  TGeoTrd1 ();  ;  TGeoTrd1 (const char *name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz);  ;  TGeoTrd1 (Double_t *params);  ;  TGeoTrd1 (Double_t dx1, Double_t dx2, Double_t dy, Double_t dz);  ;  ~TGeoTrd1 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; Double_t GetDx2 () const;  ; Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:1157,safe,safe,1157,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety," Public Member Functions;  TGeoTrd2 ();  ;  TGeoTrd2 (const char *name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz);  ;  TGeoTrd2 (Double_t *params);  ;  TGeoTrd2 (Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz);  ;  ~TGeoTrd2 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:1187,safe,safe,1187,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety," PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Why? . I don't understand. You wish to maintain backwards compatibility. This implies maintaining the insanity that is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:9553,avoid,avoiding,9553,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['avoid'],['avoiding']
Safety," RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::SaveGraph ; (; NodeType ; node, . const std::string & ; outputFile . ). Create a graphviz representation of the dataframe computation graph, write it to the specified file. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. ; [in]outputFilefile where to save the representation. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 139 of file RDFHelpers.hxx. ◆ splitInEqualRanges(). void ROOT::RDF::splitInEqualRanges ; (; std::vector< std::pair< ULong64_t, ULong64_t > > & ; ranges, . int ; nRecords, . unsigned int ; nSlots . ). Definition at line 519 of file RArrowDS.cxx. ROOTRDF. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:14:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1RDF.html:16283,safe,safe,16283,doc/v632/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1RDF.html,1,['safe'],['safe']
Safety," ROOT::Math::GaussLegendreIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::GaussLegendreIntegrator ; (; int ; num = 10, . double ; eps = 1e-12 . ). Basic constructor of GaussLegendreIntegrator. ; @param num Number of desired points to calculate the integration. @param eps Desired relative error. ; Definition at line 23 of file GaussLegendreIntegrator.cxx. ◆ ~GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::~GaussLegendreIntegrator ; (; ). override . Default Destructor. ; Definition at line 34 of file GaussLegendreIntegrator.cxx. Member Function Documentation. ◆ CalcGaussLegendreSamplingPoints(). void ROOT::Math::GaussLegendreIntegrator::CalcGaussLegendreSamplingPoints ; (; ). private . Type: unsafe but fast interface filling the arrays x and w (static method) ; Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: W(x)=1 -1<x<1 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Definition at line 98 of file GaussLegendreIntegrator.cxx. ◆ DoIntegral(). double ROOT::Math::GaussLegendreIntegrator::DoIntegral ; (; double ; a, . double ; b, . const IGenFunction * ; func . ). overrideprivatevirtual . Integration surrogate method. ; Return integral of passed function in interval [a,b] Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints ; Reimplemented from ROOT::Math::GaussIntegrator.; Definition at line 60 of file GaussLegendreIntegrator.cxx. ◆ GetNumberPoints(). int ROOT::Math::GaussLegendreIntegrator::GetNumberPoints ; (; ); const. inline . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html:5423,unsafe,unsafe,5423,doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety," ReadBasicType<BitsMarker>(TBuffer &buf, void *addr, const TConfiguration *config); 236 {; 237 UInt_t *x = (UInt_t*)( ((char*)addr) + config->fOffset );; 238 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 239 // Idea: This code really belongs inside TBuffer[File]; 240 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance was actually allocated.; 241 buf >> *x;; 242 *x |= isonheap | TObject::kNotDeleted; // by definition de-serialized object are not yet deleted.; 243 ; 244 if ((*x & kIsReferenced) != 0) {; 245 HandleReferencedTObject(buf,addr,config);; 246 }; 247 return 0;; 248 }; 249 ; 250 template <typename T>; 251 INLINE_TEMPLATE_ARGS Int_t WriteBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 252 {; 253 T *x = (T *)(((char *)addr) + config->fOffset);; 254 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 255 buf << *x;; 256 return 0;; 257 }; 258 ; 259 INLINE_TEMPLATE_ARGS Int_t WriteTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLINE_TEMPLATE_ARGS Int_t WriteTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 268 {; 269 void *x = (void *)(((char *)addr) + config->fOffset);; 270 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 271 buf.StreamObject(x, TObject::Class(), TObject::Class());; 272 return 0;; 273 }; 274 ; 275 INLINE_TEMPLATE_ARGS Int_t WriteTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 276 {; 277 void *x = (void *)(((char *)addr) + config->fOffset);; 278 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 279 ((TBufferText *)&buf)->WriteBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 280 return 0;; 281 }; 282 ; 283 INLINE_TEMPLATE_A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:9332,avoid,avoid,9332,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:32609,avoid,avoid,32609,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,6,['avoid'],['avoid']
Safety," RooAbsArg& var7, const RooAbsArg& var8, const char* name = """"); Constructor for set containing 8 initial objects. RooArgList(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const RooAbsArg& var5, const RooAbsArg& var6, const RooAbsArg& var7, const RooAbsArg& var8, const RooAbsArg& var9, const char* name = """"); Constructor for set containing 9 initial objects. RooArgList(const TCollection& tcoll, const char* name = """"); Constructor from a root TCollection. Elements in the collection that; do not inherit from RooAbsArg will be skipped. A warning message; will be printed for every skipped item. RooArgList(const RooArgList& other, const char* name = """"); Copy constructor. Note that a copy of a list is always non-owning,; even the source list is owning. To create an owning copy of; a list (owning or not), use the snaphot() method. ~RooArgList(); Destructor. RooAbsArg& operator[](Int_t idx) const; Array operator. Element in slot 'idx' must already exist, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. void writeToStream(ostream& os, Bool_t compact); Write the contents of the argset in ASCII form to given stream. All elements will be printed on a single line separated by a single; white space. The contents of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. A single line is read, and all elements are assumed to be separated; by white space. The value of each argument is read by the arguments; readFromStream function. TObject* clone(const char* newname) const; { return new RooArgList(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgList(newname); }. RooArgList& operator=(const RooArgList& other); { RooAbsCollection::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgList.html:15054,abort,abort,15054,root/html528/RooArgList.html,https://root.cern,https://root.cern/root/html528/RooArgList.html,6,['abort'],['abort']
Safety," RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAddition, RooFormulaVar, RooProduct, RooRealSumFunc, RooRealSumPdf, ParamHistFunc, PiecewiseInterpolation, RooMomentMorphFunc, RooParametricStepFunction, RooParamHistFunc, RooStepFunction, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooHistFunc, RooHistPdf, RooLinearCombination, RooProdPdf, RooRangeBoolean, RooRealIntegral, and RooWrapperPdf.; Definition at line 3571 of file RooAbsReal.cxx. ◆ plotSanityChecks(). bool RooAbsReal::plotSanityChecks ; (; RooPlot * ; frame); const. protected . Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ; Definition at line 2860 of file RooAbsReal.cxx. ◆ preferredObservableScanOrder(). void RooAbsReal::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. virtual . Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ; The observables to be ordered are offered in argument 'obs' and should be copied in their preferred order into argument 'orderedObs', This default implementation indicates no preference and copies the original order of 'obs' into 'orderedObs' ; Reimplemented in RooIntegralMorph, and RooCachedPdf.; Definition at line 3694 of file RooAbsReal.cxx. ◆ printEvalErrors(). void RooAbsReal::printEvalErrors ; (; std::ostream & ; os = std::cout, . Int_t ; maxPerNode = 10000000 . ). static . Print all outstanding logged evaluation error on the given ostream. ; If maxPerNode is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:140376,sanity check,sanity check,140376,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAddition, RooFormulaVar, RooProduct, RooRealSumFunc, RooRealSumPdf, ParamHistFunc, PiecewiseInterpolation, RooMomentMorphFunc, RooParametricStepFunction, RooParamHistFunc, RooStepFunction, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooHistFunc, RooHistPdf, RooLinearCombination, RooProdPdf, RooRangeBoolean, RooRealIntegral, and RooWrapperPdf.; Definition at line 3651 of file RooAbsReal.cxx. ◆ plotSanityChecks(). bool RooAbsReal::plotSanityChecks ; (; RooPlot * ; frame); const. protected . Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ; Definition at line 2945 of file RooAbsReal.cxx. ◆ plotSliceOn(). RooPlot * RooAbsReal::plotSliceOn ; (; RooPlot * ; frame, . const RooArgSet & ; sliceSet, . Option_t * ; drawOptions = ""L"", . double ; scaleFactor = 1.0, . ScaleType ; stype = Relative, . const RooAbsData * ; projData = nullptr . ); const. virtual . Deprecated:OBSOLETE – RETAINED FOR BACKWARD COMPATIBILITY. Use plotOn() with Slice() instead ; Definition at line 2253 of file RooAbsReal.cxx. ◆ preferredObservableScanOrder(). void RooAbsReal::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. virtual . Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ; The observables to be ordered are offered in argument 'obs' and should be copied in their preferred order into argument 'orderedObs', This default implementation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:141803,sanity check,sanity check,141803,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~IBaseParam(). virtual ROOT::Math::IBaseParam::~IBaseParam ; (; ). inlinevirtual . Virtual Destructor (no operations) ; Definition at line 59 of file IParamFunction.h. Member Function Documentation. ◆ NPar(). virtual unsigned int ROOT::Math::IBaseParam::NPar ; (; ); const. pure virtual . Return the number of Parameters. ; Implemented in ROOT::Math::ParamFunction< IParamGradFunction >, ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::MultiDimParamGradFunctionAdapter, ROOT::Math::WrappedParamFunction< FuncPtr >, ROOT::Math::WrappedParamFunctionGen< FuncPtr >, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile. ◆ ParameterName(). virtual std::string ROOT::Math::IBaseParam::ParameterName ; (; unsigned int ; i); const. inlinevirtual . Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ; Reimplemented in ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile.; Definition at line 86 of file IParamFunction.h. ◆ Parameters(). virtual const double * ROOT::Math::IBaseParam::Parameters ; (; ); const. pure virtual . Access the parameter values. ; Implemented in ROOT::Math::ParamFunction< IParamGradFunction >, ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::MultiDimParamGradFunctionAdapter, ROOT::Math::WrappedParamFunction< FuncPtr >, ROOT::Math::WrappedParamFunctionGen< FuncPtr >, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile. ◆ SetParameters(). virtual void ROOT::Math::IBaseParam::SetParameters ; (; const double * ; p). pure virtual . Set the parameter values. ; Parameters. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html:2401,avoid,avoid,2401,doc/master/classROOT_1_1Math_1_1IBaseParam.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html,1,['avoid'],['avoid']
Safety," Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html:8620,avoid,avoid,8620,root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['avoid'],['avoid']
Safety," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeAssembly. class TGeoVolumeAssembly: public TGeoVolume. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:1117,avoid,avoid,1117,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,3,['avoid'],['avoid']
Safety," Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0)) {; 5978 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 5979 leaf->SetTitle(GetTitle());; 5980 fNleaves = 1;; 5981 fLeaves.Add(leaf);; 5982 fTree->GetListOfLeaves()->Add(leaf);; 5983 }; 5984 ; 5985 // SetReadLeavesPtr();; 5986 }; 5987 else {; 5988 TDirectory* dirsav = fDirectory;; 5989 fDirectory = nullptr; // to avoid recursive calls; 5990 {; 5991 // Save class version.; 5992 Int_t classVersion = fClassVersion;; 5993 // Record only positive 'version number'; 5994 if (fClassVersion < 0) {; 5995 fClassVersion = -fClassVersion;; 5996 }; 5997 // TODO: Should we clear the kDeleteObject bit before writing?; 5998 // If we did we would have to remember the old value and; 5999 // put it back, we wouldn't want to forget that we owned; 6000 // something just because we got written to disk.; 6001 R__b.WriteClassBuffer(TBranchElement::Class(), this);; 6002 // Restore class version.; 6003 fClassVersion = classVersion;; 6004 }; 6005 //; 6006 // Mark all streamer infos used by this branch element; 6007 // to be written to our output file.; 6008 //; 6009 {; 6010 R__b.ForceWriteInfo(GetInfoImp(), true);; 6011 }; 6012 //; 6013 // If we are a clones array master branch, or an; 6014 // STL container master branch, we must also mark; 6015 // the str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:224368,avoid,avoid,224368,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['avoid'],['avoid']
Safety," TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void FindMomentumLimits (TEveElement *el, Bool_t recurse=kTRUE);  Loop over track elements of argument el and find highest pT and p. ;  ; Double_t RoundMomentumLimit (Double_t x);  Round the momentum limit up to a nice value. ;  ; void SanitizeMinMaxCuts ();  Set Min/Max cuts so that they are within detected limits. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t fLimP;  ; Double_t fLimPt;  ; Double_t fMaxP;  ; Double_t fMaxPt;  ; Double_t fMinP;  ; Double_t fMinPt;  ; TEveTrackPropagator * fPropagator;  ; Bool_t fRecurse;  ; Bool_t fRnrLine;  ; Bool_t fRnrPoints;  ;  Protected Attributes inherited from TEveElementList; TClass * fChildClass;  ; Color_t fColor;  ;  Protected Attributes inherited from TEveElement; Bool_t fCanEditMainColor;  ; Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackList.html:35241,detect,detected,35241,doc/master/classTEveTrackList.html,https://root.cern,https://root.cern/doc/master/classTEveTrackList.html,1,['detect'],['detected']
Safety," TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 394 virtual TBranch *Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 395 template <class T> TBranch *Branch(const char* name, const char* classname, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 396 {; 397 // See BranchImpRed for details. Here we __ignore; 398 return BranchImpRef(name, classname, TClass::GetClass<T>(), obj, bufsize, splitlevel);; 399 }; 400 template <class T> TBranch *Branch(const char* name, const char* classname, T** addobj, Int_t bufsize = 32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:19622,avoid,avoid,19622,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['avoid'],['avoid']
Safety," TBufferXML::XmlWriteBasic ; (; ULong_t ; value). protected . Converts ULong_t to string and add xml node to buffer. ; Definition at line 2940 of file TBufferXML.cxx. ◆ XmlWriteBasic() [13/13]. XMLNodePointer_t TBufferXML::XmlWriteBasic ; (; UShort_t ; value). protected . Converts UShort_t to string and add xml node to buffer. ; Definition at line 2920 of file TBufferXML.cxx. ◆ XmlWriteBlock(). void TBufferXML::XmlWriteBlock ; (; XMLNodePointer_t ; node). protected . Write binary data block from buffer to xml. ; This data can be produced only by direct call of TBuffer::WriteBuf() functions. ; Definition at line 390 of file TBufferXML.cxx. ◆ XmlWriteFastArray(). template<typename T > . R__ALWAYS_INLINE void TBufferXML::XmlWriteFastArray ; (; const T * ; arr, . Long64_t ; n . ). protected . Write array without size attribute Also treat situation, when instead of one single array chain of several elements should be produced. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Definition at line 2161 of file TBufferXML.cxx. ◆ XmlWriteObject(). XMLNodePointer_t TBufferXML::XmlWriteObject ; (; const void * ; obj, . const TClass * ; objClass, . Bool_t ; cacheReuse . ). protected . Write object to buffer If object was written before, only pointer will be stored Return pointer to top xml node, representing object. ; Definition at line 756 of file TBufferXML.cxx. ◆ XmlWriteValue(). XMLNodePointer_t TBufferXML::XmlWriteValue ; (; const char * ; value, . const char * ; name . ). protected . Create xml node with specified name and adds it to stack node. ; Definition at line 2959 of file TBufferXML.cxx. Friends And Related Symbol Documentation. ◆ TKeyXML. friend class TKeyXML. friend . Definition at line 35 of file TBufferXML.h. Member Data Documentation. ◆ fCanUseCompact. Bool_t TBufferXML::fCanUseCompact {kFALSE}. protected . ! F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:103920,abort,aborts,103920,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['abort'],['aborts']
Safety," TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name and version are taken from special objects table. void IncrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and indent new level in data structure.; This call indicates, that TStreamerInfo functions starts streaming; object data of correspondent class. void DecrementLevel(TVirtualStreamerInfo* ); Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:24127,avoid,avoid,24127,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,5,['avoid'],['avoid']
Safety," TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLINE_TEMPLATE_ARGS Int_t WriteTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 268 {; 269 void *x = (void *)(((char *)addr) + config->fOffset);; 270 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 271 buf.StreamObject(x, TObject::Class(), TObject::Class());; 272 return 0;; 273 }; 274 ; 275 INLINE_TEMPLATE_ARGS Int_t WriteTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 276 {; 277 void *x = (void *)(((char *)addr) + config->fOffset);; 278 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 279 ((TBufferText *)&buf)->WriteBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 280 return 0;; 281 }; 282 ; 283 INLINE_TEMPLATE_ARGS Int_t WriteTextStreamer(TBuffer &buf, void *addr, const TConfiguration *config); 284 {; 285 void *x = (void *)(((char *)addr) + config->fOffset);; 286 TMemberStreamer *pstreamer = config->fCompInfo->fStreamer;; 287 UInt_t pos = buf.WriteVersion(config->fInfo->IsA(), kTRUE);; 288 (*pstreamer)(buf, x, config->fCompInfo->fLength);; 289 buf.SetByteCount(pos, kTRUE);; 290 return 0;; 291 }; 292 ; 293 INLINE_TEMPLATE_ARGS Int_t ReadTextObject(TBuffer &buf, void *addr, const TConfiguration *config); 294 {; 295 void *x = (void *)(((char *)addr) + config->fOffset);; 296 buf.ReadFastArray(x, config->fCompInfo->fClass, config->fCompInfo->fLength, config->fCompInfo->fStreamer);; 297 return 0;; 298 }; 299 ; 300 INLINE_TEMPLATE_ARGS Int_t ReadTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 301 {; 302 void *x = (void *)(((char *)addr) + config->fOffset);; 303 buf.StreamObject(x, TObject::Class(), TObject::Class());; 304 return 0;; 305 }; 306 ; 307 INLINE_TEMPLATE_ARGS Int_t ReadTextBaseClass(TBuffer &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:10290,avoid,avoid,10290,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety," TEveTrackList(const char* name, TEveTrackPropagator* prop = 0); Constructor. If track-propagator argument is 0, a new default; one is created. ~TEveTrackList(); Destructor. void SetPropagator(TEveTrackPropagator* prop); Set default propagator for tracks.; This is not enforced onto the tracks themselves but this is the; propagator that is shown in the TEveTrackListEditor. void MakeTracks(Bool_t recurse = kTRUE); Regenerate the visual representations of tracks.; The momentum limits are rescanned during the same traversal. void FindMomentumLimits(Bool_t recurse = kTRUE); Loop over children and find highest pT and p of contained TEveTracks.; These are stored in members fLimPt and fLimP. void FindMomentumLimits(TEveElement* el, Bool_t recurse = kTRUE); Loop over track elements of argument el and find highest pT and p.; These are stored in members fLimPt and fLimP. Double_t RoundMomentumLimit(Double_t x); Round the momentum limit up to a nice value. void SanitizeMinMaxCuts(); Set Min/Max cuts so that they are within detected limits. void SetRnrLine(Bool_t rnr); Set rendering of track as line for the list and the elements. void SetRnrLine(Bool_t rnr, TEveElement* el); Set rendering of track as line for children of el. void SetRnrPoints(Bool_t r); Set rendering of track as points for the list and the elements. void SetRnrPoints(Bool_t r, TEveElement* el); Set rendering of track as points for children of el. void SetMainColor(Color_t c); Set main (line) color for the list and the elements. void SetLineColor(Color_t c, TEveElement* el); Set line color for children of el. void SetLineWidth(Width_t w); Set line width for the list and the elements. void SetLineWidth(Width_t w, TEveElement* el); Set line width for children of el. void SetLineStyle(Style_t s); Set line style for the list and the elements. void SetLineStyle(Style_t s, TEveElement* el); Set line style for children of el. void SetMarkerStyle(Style_t s); Set marker style for the list and the elements. void SetMarkerSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackList.html:24105,detect,detected,24105,root/html530/TEveTrackList.html,https://root.cern,https://root.cern/root/html530/TEveTrackList.html,5,['detect'],['detected']
Safety," TGLSAViewer::GetFrame ; (; ); const. Return the main-frame. ; Definition at line 325 of file TGLSAViewer.cxx. ◆ GetLeftVerticalFrame(). TGCompositeFrame * TGLSAViewer::GetLeftVerticalFrame ; (; ); const. inline . Definition at line 122 of file TGLSAViewer.h. ◆ GetName(). const char * TGLSAViewer::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 104 of file TGLSAViewer.h. ◆ HandleMenuBarHiding(). void TGLSAViewer::HandleMenuBarHiding ; (; Event_t * ; ev). Maybe switch menu-bar / menu-button. ; Definition at line 583 of file TGLSAViewer.cxx. ◆ IsA(). TClass * TGLSAViewer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 132 of file TGLSAViewer.h. ◆ MenuHidingTimeout(). void TGLSAViewer::MenuHidingTimeout ; (; ). Action for menu-hiding timeout. ; Definition at line 638 of file TGLSAViewer.cxx. ◆ operator=(). TGLSAViewer & TGLSAViewer::operator= ; (; const TGLSAViewer & ; ). private . ◆ ProcessFrameMessage(). Bool_t TGLSAViewer::ProcessFrameMessage ; (; Long_t ; msg, . Long_t ; parm1, . Long_t ;  . ). Process GUI message capture by the main GUI frame (TGLSAFrame). ; Definition at line 663 of file TGLSAViewer.cxx. ◆ ResetMenuHidingTimer(). void TGLSAViewer::ResetMenuHidingTimer ; (; Bool_t ; show_menu). private . Reset the timer for menu-bar hiding. ; Definition at line 620 of file TGLSAViewer.cxx. ◆ SelectionChanged(). void TGLSAViewer::SelectionChanged ; (; ). overridevirtual . Update GUI components for embedded viewer selection change. ; Override from TGLViewer. ; Reimplemented from TGLViewer.; Definition at line 481 of file TGLSAViewer.cxx. ◆ SetMenuHidingTimeout(). void TGLSAViewer::SetMenuHidingTimeout ; (; Long_t ; timeout). static . Set global timeout for menu-hiding in mili-seconds. ; Static function. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:45465,timeout,timeout,45465,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['timeout'],['timeout']
Safety," TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::fH2Double_t fH2Definition TGeoArb8.h:105; TGeoTrap::GetAlpha1Double_t GetAlpha1() constDefinition TGeoArb8.h:135; TGeoTrap::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTrap::GetBl2Double_t GetBl2() constDefinition TGeoArb8.h:137; TGeoTrap::GetTl2Double_t GetTl2() constDefinition TGeoArb8.h:138; TGeoTrap::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::GetH1Double_t GetH1() constDefinition TGeoArb8.h:132; TGeoTrap::fThetaDouble_t fThetaDefinition TGeoArb8.h:99; TGeoTrap::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTrap::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::fAlpha1Double_t fAlpha1Definition TGeoArb8.h:104; TGeoTrap::GetH2Double_t GetH2() constDefinition TGeoArb8.h:136; TGeoTrap::GetBl1Double_t GetBl1() constDefinition TGeoArb8.h:133; TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomincTGeoArb8.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:19964,safe,safe,19964,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:2079,safe,safe,2079,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,3,['safe'],['safe']
Safety," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShapeAssembly.html:1716,safe,safe,1716,root/html528/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html,1,['safe'],['safe']
Safety," TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:2201,safe,safety,2201,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety," TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h:55; TGeoNavigator::GetPWSafetyDouble_t GetPWSafety(Double_t cpoint[3], Double_t saf_max)Wrapper for getting the safety from the parallel world.Definition TGeoNavigator.cxx:1656; TGeoNavigator::ResetAllvoid ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNavigator::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoNavigator.h:145; TGeoNavigator::fIsOutsideBool_t fIsOutsideflag that next geometric step will exit current volumeDefinition TGeoNavigator.h:68; TGeoNavigator::CdDownvoid CdDown(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:33479,safe,safety,33479,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety," TGeoTube(Double_t *params);; 34 // destructor; 35 ~TGeoTube() override;; 36 // methods; 37 ; 38 Double_t Capacity() const override;; 39 static Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz);; 40 void ComputeBBox() override;; 41 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 42 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 43 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 44 Double_t dz);; 45 Bool_t Contains(const Double_t *point) const override;; 46 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 47 static Double_t; 48 DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 49 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 50 Double_t *safe = nullptr) const override;; 51 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 52 Double_t *step) const override;; 53 static Double_t; 54 DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 static void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);; 60 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 61 TGeoVolume *; 62 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 63 const char *GetAxisName(Int_t iaxis) const override;; 64 Double_t GetAxisR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:2177,safe,safe,2177,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety," THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistImplBase that abstracts out the histogram's PRECISION ;  ►CTSchemaRuleSet;  CTMatches;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:12054,avoid,avoids,12054,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['avoid'],['avoids']
Safety," TMVA::MethodRSNNS::fModel. protected . Definition at line 116 of file MethodRSNNS.h. ◆ fMvaCounter. UInt_t TMVA::MethodRSNNS::fMvaCounter. protected . Definition at line 84 of file MethodRSNNS.h. ◆ fNetType. TString TMVA::MethodRSNNS::fNetType. protected . Definition at line 88 of file MethodRSNNS.h. ◆ fProbResultForTestSig. std::vector<Float_t> TMVA::MethodRSNNS::fProbResultForTestSig. protected . Definition at line 86 of file MethodRSNNS.h. ◆ fProbResultForTrainSig. std::vector<Float_t> TMVA::MethodRSNNS::fProbResultForTrainSig. protected . Definition at line 85 of file MethodRSNNS.h. ◆ fPruneFunc. TString TMVA::MethodRSNNS::fPruneFunc. protected . Definition at line 106 of file MethodRSNNS.h. ◆ fPruneFuncParams. TString TMVA::MethodRSNNS::fPruneFuncParams. protected . Definition at line 107 of file MethodRSNNS.h. ◆ fShufflePatterns. Bool_t TMVA::MethodRSNNS::fShufflePatterns. protected . Definition at line 103 of file MethodRSNNS.h. ◆ fSize. TString TMVA::MethodRSNNS::fSize. protected . Definition at line 90 of file MethodRSNNS.h. ◆ fUpdateFunc. TString TMVA::MethodRSNNS::fUpdateFunc. protected . Definition at line 99 of file MethodRSNNS.h. ◆ fUpdateFuncParams. TString TMVA::MethodRSNNS::fUpdateFuncParams. protected . Definition at line 100 of file MethodRSNNS.h. ◆ IsModuleLoaded. Bool_t MethodRSNNS::IsModuleLoaded = ROOT::R::TRInterface::Instance().Require(""RSNNS""). staticprotected . Definition at line 112 of file MethodRSNNS.h. ◆ mlp. ROOT::R::TRFunctionImport TMVA::MethodRSNNS::mlp. protected . Definition at line 114 of file MethodRSNNS.h. ◆ predict. ROOT::R::TRFunctionImport TMVA::MethodRSNNS::predict. protected . Definition at line 113 of file MethodRSNNS.h. Libraries for TMVA::MethodRSNNS:. [legend]; The documentation for this class was generated from the following files:; tmva/rmva/inc/TMVA/MethodRSNNS.h; tmva/rmva/src/MethodRSNNS.cxx. TMVAMethodRSNNS. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html:35532,predict,predict,35532,doc/master/classTMVA_1_1MethodRSNNS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html,2,['predict'],['predict']
Safety," TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPacketizer.html:11070,avoid,avoid,11070,root/html604/TPacketizer.html,https://root.cern,https://root.cern/root/html604/TPacketizer.html,1,['avoid'],['avoid']
Safety," TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE; LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING; RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A; FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF; SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH; DAMAGES. END OF TERMS AND CONDITIONS; ; How to Apply These Terms to Your New Libraries. If you develop a new library, and you want it to be of the greatest; possible use to the public, we recommend making it free software that; everyone can redistribute and change. You can do so by permitting; redistribution under these terms (or, alternatively, under the terms of the; ordinary General Public License). To apply these terms, attach the following notices to the library. It is; safest to attach them to the start of each source file to most effectively; convey the exclusion of warranty; and each file should have at least the; ""copyright"" line and a pointer to where the full notice is found. <one line to give the library's name and a brief idea of what it does>; Copyright (C) <year> <name of author>. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Lesser General Public; License as published by the Free Software Foundation; either; version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public; License along with this library; if not, write to the Free Software; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. Also add information on how to contact you by electronic and paper mail. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:27075,safe,safest,27075,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['safe'],['safest']
Safety," TObject destructor. Each TProcessID has a table (TObjArray *fObjects) that keeps track of all referenced objects. If a referenced object has a fUniqueID, a pointer to this unique object may be found using fObjects->At(fUniqueID). In the same way, when a TRef::GetObject is called, GetObject uses its own fUniqueID to find the pointer to the referenced object. See TProcessID::GetObjectWithID and PutObjectWithID.; 11.4.4.2 Object Number; When an object is referenced, a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. The fUniqueID is the serial object number in the current session. One can retrieve the current fgNumber value by calling the static function TProcessID::GetObjectCount at any time or can set this number by TProcessID::SetObjectCount. To avoid a growing table of fObjects in TProcessID, in case, for example, one processes many events in a loop, it might be necessary to reset the object number at the end of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build). The value of ObjectNumbermay be saved at the beginning of one event and reset to this original value at the end of the event. These actions may be nested.; saveNumber = TProcessID::GetObjectCount();; ...; TProcessID::SetObjectCount(savedNumber);; 11.4.5 Action on Demand; The normal behavior of a TRef has been described above. In addition, TRef supports “Actions on Demand”. It may happen that the referenced object is not yet in the memory, on a separate file or not yet computed. In this case, TRef is able to execute automatically an action:. Call to a compiled function (static function of member function); Call to an interpreted function; Execution of a Cling script. 11.4.5.1 How to Select This Option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName points to something; Wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:485035,avoid,avoid,485035,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, TProofDrawGraph, TProofDrawPolyMarker3D, TProofDrawListOfGraphs, and TProofDrawListOfPolyMarkers3D.; Definition at line 93 of file TProofDraw.h. ◆ Notify(). Bool_t TProofDraw::Notify ; (; ). overridevirtual . Called when a new tree is loaded. ; Reimplemented from TObject.; Definition at line 152 of file TProofDraw.cxx. ◆ Process(). Bool_t TProofDraw::Process ; (; Long64_t ; entry). overridevirtual . Executed for each entry. ; Reimplemented from TSelector.; Definition at line 244 of file TProofDraw.cxx. ◆ ProcessSingle(). Bool_t TProofDraw::ProcessSingle ; (; Long64_t ; entry, . Int_t ; i . ). protectedvirtual . Processes a single variable from an entry. ; Definition at line 217 of file TProofDraw.cxx. ◆ SetCanvas(). void TProofDraw::SetCanvas ; (; const char * ; objname). protected . Move to a canvas named <name>_canvas; create the canvas if not existing. ; Used to avoid screwing up existing plots when non default names are used for the final objects ; Definition at line 310 of file TProofDraw.cxx. ◆ SetDrawAtt(). void TProofDraw::SetDrawAtt ; (; TObject * ; o). protected . Set the drawing attributes from the input list. ; Definition at line 326 of file TProofDraw.cxx. ◆ SetError(). void TProofDraw::SetError ; (; const char * ; sub, . const char * ; mesg . ). protected . Sets the error status. ; Definition at line 383 of file TProofDraw.cxx. ◆ SlaveBegin(). void TProofDraw::SlaveBegin ; (; TTree * ; ). overridevirtual . Executed by each slave before processing. ; Reimplemented from TSelector.; Reimplemented in TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, TProofDrawGraph, TProofDrawPolyMarker3D, TProofDrawListOfGraphs, and TProofDrawListOfPolyMarkers3D.; Definition at line 196 of file TProofDraw.cxx. ◆ SlaveTerminate(). void TProofDraw::SlaveTerminate ; (; void ; ). overridevirtual . Executed by each slave after the processing has finished, before return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDraw.html:18064,avoid,avoid,18064,doc/master/classTProofDraw.html,https://root.cern,https://root.cern/doc/master/classTProofDraw.html,1,['avoid'],['avoid']
Safety," TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:17660,safe,safe,17660,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety," TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ;  CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ;  CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ;  CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ;  CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:218719,detect,detector,218719,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['detect'],['detector']
Safety," TXSocket&operator=(const TXSocket& xs); virtual voidTObject::Paint(Option_t* option = """"); Bool_tPing(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidRemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0, Long64_t l64 = 0, Int_t int3 = 0, const char* opt = 0); Int_tSendInterrupt(Int_t type); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); voidSendUrgent(Int_t type, Int_t int1, Int_t int2); voidSetAWait(Bool_t w = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClientID(Int_t); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:6440,timeout,timeout,6440,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,2,['timeout'],['timeout']
Safety," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:11323,avoid,avoids,11323,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoids']
Safety," This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self reference; 392 const_cast<TObject*>(obj)->Streamer(*buffer);; 393 ; 394 // read new object from buffer; 395 buffer->SetReadMode();; 396 buffer->ResetMap();; 397 buffer->SetBufferOffset(0);; 398 buffer->MapObject(newobj); //register obj in map to handle self reference; 399 newobj->Streamer(*buffer);; 400 newobj->ResetBit(kIsReferenced);; 401 newobj->ResetBit(kCanDelete);; 402 ; 403 delete buffer;; 404 if (autoadd) {; 405 ROOT::DirAutoAdd_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:13167,detect,detection,13167,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['detect'],['detection']
Safety," Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TGeoVolume Class ReferenceThe Geometry Package » Shapes. ; TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes. ; Volumes are the basic objects used in building the geometrical hierarchy. They represent unpositioned objects but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. In order to create a volume, one has to put together a shape and a medium which are already defined. Volumes have to be named by users at creation time. Every different name may represent a an unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two cases : when a generic shape is provided to the volume constructor or when a division operation is applied. Each volume in the geometry stores an unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; Volumes are objects that can be visualized, therefore having visibility, colour, line and fill attributes that can be defined or modified any time after the volume creation. It is advisable however to define these properties just after the first creation of a volume namespace, since in case of volume families any new member created by the modeler inherits these properties.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itsel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:1175,avoid,avoid,1175,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['avoid'],['avoid']
Safety," UUID version 1, this is represented by Coordinated Universal Time (UTC/GMT) as a count of 100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar).; The version number is multiplexed in the 4 most significant bits of the 'fTimeHiAndVersion' field. There are two defined versions: MSB <---; Version 4-Bit Code Description; ------------------------------------------------------------; | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value; ------------------------------------------------------------; a#define a(i)Definition RSha256.hxx:99; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. Clock Sequence; The clock sequence value must be changed whenever:; The UUID generator detects that the local value of UTC has gone backward; this may be due to re-syncing of the system clock.; While a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.; The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly. Clock Adjustment; UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:3082,detect,detects,3082,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['detect'],['detects']
Safety," Write array of UInt_t to buffer. void WriteFastArray(const Long_t *l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t *l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t *l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t *l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t *f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t *d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void *obj, const type_info &typeinfo, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(void *obj, const char *className, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void *obj, const TClass *cl, const TClass* /* onfileClass */ ); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:38520,avoid,avoid,38520,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['avoid'],['avoid']
Safety," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:40451,avoid,avoid,40451,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,6,['avoid'],['avoid']
Safety," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:35877,avoid,avoid,35877,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['avoid'],['avoid']
Safety," [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:15103,safe,safe,15103,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,6,['safe'],['safe']
Safety," \]. The distribution of the control variable \(x\) obtained by histogramming the weighted events reproduces, on average, the true distribution \({\hbox{ {M}}}_{\rm n}(x)\); The class TSPlot allows to reconstruct the true distribution \({\hbox{ {M}}}_{\rm n}(x)\); of a control variable \(x\) for each of the \({\rm N}_{\rm s}\) species from the sole knowledge of the PDFs of the discriminating variables \({\rm f}_i(y)\). The plots obtained thanks to the TSPlot class are called \(\hbox {$_s$}{\cal P}lots\). Some properties and checks; Beside reproducing the true distribution, \(\hbox {$_s$}{\cal P}lots\) bear remarkable properties:. Each \(x\) - distribution is properly normalized:. \[; \sum_{e=1}^{N} {_s{\cal P}}_{\rm n}(y_e)~=~N_{\rm n} ~. \tag{4}; \]. For any event:. \[; \sum_{l=1}^{{\rm N}_{\rm s}} {_s{\cal P}}_l(y_e) ~=~1 ~. \tag{5}; \]. That is to say that, summing up the \({\rm N}_{\rm s}\) \(\hbox {$_s$}{\cal P}lots\), one recovers the data sample distribution in \(x\), and summing up the number of events entering in a \(\hbox{$_s$}{\cal P}lot\) for a given species, one recovers the yield of the species, as provided by the fit. The property 4 is implemented in the TSPlot class as a check. the sum of the statistical uncertainties per bin. \[; \sigma[N_{\rm n}\ _s\tilde{\rm M}_{\rm n}(x) {\delta x}]~=~\sqrt{\sum_{e \subset {\delta x}} ({_s{\cal P}}_{\rm n})^2} ~. \tag{6}; \]. reproduces the statistical uncertainty on the yield \(N_{\rm n}\), as provided by the fit: \(\sigma[N_{\rm n}]\equiv\sqrt{\hbox{ V}_{{\rm n}{\rm n}}}\) . Because of that and since the determination of the yields is optimal when obtained using a Likelihood fit, one can conclude that the \(\hbox{$_s$}{\cal P}lot\) technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields \(N_i\) of the various species.The fit relies on discriminating variables \(y\) uncorrelated with a c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:5055,recover,recovers,5055,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,2,['recover'],['recovers']
Safety," \param[in] ww is the window size in pixels along X; 386/// (if ww < 0 the menubar is not shown); 387/// \param[in] wh is the window size in pixels along Y; 388 ; 389void TCanvas::Constructor(const char *name, const char *title, Int_t ww, Int_t wh); 390{; 391 if (gThreadXAR) {; 392 void *arr[6];; 393 arr[1] = this; arr[2] = (void*)name; arr[3] = (void*)title; arr[4] =&ww; arr[5] = &wh;; 394 if ((*gThreadXAR)(""CANV"", 6, arr, nullptr)) return;; 395 }; 396 ; 397 Init();; 398 SetBit(kMenuBar,true);; 399 if (ww < 0) {; 400 ww = -ww;; 401 SetBit(kMenuBar,false);; 402 }; 403 if (wh <= 0) {; 404 Error(""Constructor"", ""Invalid canvas height: %d"",wh);; 405 return;; 406 }; 407 fCw = ww;; 408 fCh = wh;; 409 fCanvasID = -1;; 410 TCanvas *old = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(name);; 411 if (old && old->IsOnHeap()) {; 412 Warning(""Constructor"",""Deleting canvas with same name: %s"",name);; 413 delete old;; 414 }; 415 if (gROOT->IsBatch()) { //We are in Batch mode; 416 fWindowTopX = fWindowTopY = 0;; 417 fWindowWidth = ww;; 418 fWindowHeight = wh;; 419 fCw = ww;; 420 fCh = wh;; 421 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 422 if (!fCanvasImp) return;; 423 fBatch = kTRUE;; 424 } else {; 425 Float_t cx = gStyle->GetScreenFactor();; 426 auto factory = gROOT->IsWebDisplay() ? gBatchGuiFactory : gGuiFactory;; 427 fCanvasImp = factory->CreateCanvasImp(this, name, UInt_t(cx*ww), UInt_t(cx*wh));; 428 if (!fCanvasImp) return;; 429 ; 430 if (!gROOT->IsBatch() && fCanvasID == -1); 431 fCanvasID = fCanvasImp->InitWindow();; 432 ; 433 fCanvasImp->ShowMenuBar(TestBit(kMenuBar));; 434 fBatch = kFALSE;; 435 }; 436 ; 437 CreatePainter();; 438 ; 439 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 440 SetTitle(title); // requires fCanvasImp set; 441 Build();; 442 ; 443 // Popup canvas; 444 fCanvasImp->Show();; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new canvas.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:13684,avoid,avoid,13684,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety," __LINE__; } /** \endcond */; 352 ; 353#define ClassDefInlineOverride(name,id) \; 354 _ClassDefInline_(name,id,,override) \; 355 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 356 ; 357#define ClassDefInlineNV(name,id) \; 358 _ClassDefInline_(name,id,,) \; 359 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 360 ; 361//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 362 ; 363#define R__UseDummy(name) \; 364 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 365 ; 366#define ClassImpUnique(name,key) \; 367 namespace ROOT { \; 368 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 369 namespace { \; 370 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 371 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 372 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 373 } \; 374 }; 375 ; 376/// \deprecated; 377#define ClassImp(name) ClassImpUnique(name,default); 378 ; 379/// Macro for Namespace; 380#define NamespaceImpUnique(name,key) \; 381 namespace name { \; 382 namespace ROOTDict { \; 383 /** \cond HIDDEN_SYMBOLS */ \; 384 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 385 namespace { \; 386 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 387 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 388 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 389 } \; 390 } \; 391 }; 392 ; 393#define NamespaceImp(name) NamespaceImpUnique(name,default); 394 ; 395//---- ClassDefT macros for templates with one template argument ---------------; 396// ClassDefT corresponds to ClassDef; 397// ClassDefT2 goes in the same header as ClassDefT but must be; 398// outside the class scope; 399// ClassImpT corresponds to ClassImp; 400 ; 401 ; 402/// This ClassDefT is strictly redundant and is kept only for; 403/// backward compatibility.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h_source.html:17177,redund,redundant,17177,doc/v632/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h_source.html,1,['redund'],['redundant']
Safety," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h_source.html:17598,redund,redundant,17598,doc/master/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html,1,['redund'],['redundant']
Safety," `TResultProxy` (they are executed one after the other in the; // same order as they were registered). We now request that the partial result is drawn and the TBrowser's TPad is; // updated every 50 events.; h.OnPartialResult(50, [&browserPad](TH1D &hist) {; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; hist.Draw();; browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4573,safe,safety,4573,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,1,['safe'],['safety']
Safety," a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16708,safe,safe,16708,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety," a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:9001,avoid,avoid,9001,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,1,['avoid'],['avoid']
Safety," a subtraction of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this subtraction. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode;  TGeoBoolNode ();  Default constructor. ;  ;  TGeoBoolNode (const char *expr1, const char *expr2);  Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches. ;  ;  TGeoBoolNode (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr);  Constructor providing left and right shapes and matrices (in the Boolean operation). ;  ;  ~TGeoBoolNode () override;  Destructor. ;  ; void ClearThreadData () const;  ; void CreateThreadData (Int_t nthreads);  Create thread data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:2147,safe,safety,2147,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safety']
Safety," actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:21329,safe,safe,21329,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,1,['safe'],['safe']
Safety," add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:11757,timeout,timeout,11757,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety," against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002171,safe,safety,1002171,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; List of all members ; TKey Class ReferenceInput/Output Library. ; Book space in a file, create I/O buffers, to fill them, (un)compress them. ; The TKey class includes functions to book space in a file, to create I/O buffers, to fill these buffers, to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must be created. The key structure contains all the information to uniquely identify a persistent object in a file. . Data Member Explanation . fNbytes Number of bytes for the compressed object and key. . fObjlen Length of uncompressed object. . fDatime Date/Time when the object was written. . fKeylen Number of bytes for the key structure. . fCycle Cycle number of the object. . fSeekKey Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. . fSeekPdir Pointer to the directory supporting this object. . fClassName Object class name. . fName Name of the object. . fTitle Title of the object. . In the 16 highest bits of fSeekPdir is encoded a pid offset. This offset is to be added to the pid index stored in the TRef object and the referenced TObject.; The TKey class is used by ROOT to:; Write an object in the current directory; Write a new ntuple buffer. The structure of a file is shown in TFile::TFile. The structure of a directory is shown in TDirectoryFile::TDirectoryFile. The TKey class is used by the TBasket class. See also TTree. ; Definition at line 28 of file TKey.h. Public Member Functions;  TKey ();  TKey default constructor. ;  ;  TKey (const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory *motherDir);  Create a TKey object with the specified name, title for the given class. ;  ;  TKey (const TObject *obj, const char *name, Int_t bufsize, TDirectory *m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:1091,redund,redundant,1091,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['redund'],['redundant']
Safety," and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClonesArray.html:3320,avoid,avoid,3320,root/html530/TClonesArray.html,https://root.cern,https://root.cern/root/html530/TClonesArray.html,1,['avoid'],['avoid']
Safety," and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:3320,avoid,avoid,3320,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,1,['avoid'],['avoid']
Safety," and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must include the header file Math/Vector3D.h. The following typedef’s, defined in the header file Math/Vector3Dfwd.h, are available for the different instantiations of the template class ROOT::Math::DisplacementVector3D:. ROOT::Math::XYZVector vector based on x,y,z coordinates (Cartesian) in double precision; ROOT::Math::XYZVectorF vector based on x,y,z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar) in double precision; ROOT::Math::Polar3DVectorF vector based on r,theta,phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiVector vector based on rho,z,phi coordinates (cylindrical) in double precision; ROOT::Math::RhoZPhiVectorF vector based on rho,z,phi coordinates (cylindrical) in float precision; ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:727810,avoid,avoid,727810,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:14810,safe,safe,14810,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,3,['safe'],['safe']
Safety," are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, control distribution, etc) by their name, then: . Use the method GetGlobalBinNumber() to locate a bin in a distribution, then: . Use the TH1::Fill() method and the bin number to fill the appropriate bin in one of the histograms booked above. . Unfolding: Specify the response matrix and the binning schemes when constructing a TUnfoldDensity object. Tell TUnfoldDensity about the data, bakcground, systematic error histograms using the corresponding methods of class TUnfoldDensity. Then run the unfolding. Use the GetXXX() methods to retreive the unfolding results into properly bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:2308,detect,detector,2308,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety," are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:2332,avoid,avoiding,2332,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['avoid'],['avoiding']
Safety," are waiting for more input either because the collected; 4542/// input contains unbalanced braces or last seen token was a `\` (backslash-newline); 4543 ; 4544Int_t TCling::GetMore() const; 4545{; 4546 return fMetaProcessor->awaitingMoreInput();; 4547}; 4548 ; 4549////////////////////////////////////////////////////////////////////////////////; 4550/// Generate a TClass for the given class.; 4551/// Since the caller has already check the ClassInfo, let it give use the; 4552/// result (via the value of emulation) rather than recalculate it.; 4553 ; 4554TClass *TCling::GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent /* = kFALSE */); 4555{; 4556// For now the following line would lead to the (unwanted) instantiation; 4557// of class template. This could/would need to be resurrected only if; 4558// we re-introduce so sort of automatic instantiation. However this would; 4559// have to include carefull look at the template parameter to avoid; 4560// creating instance we can not really use (if the parameter are only forward; 4561// declaration or do not have all the necessary interfaces).; 4562 ; 4563 // TClingClassInfo tci(fInterpreter, classname);; 4564 // if (1 || !tci.IsValid()) {; 4565 ; 4566 Version_t version = 1;; 4567 if (TClassEdit::IsSTLCont(classname)) {; 4568 version = TClass::GetClass(""TVirtualStreamerInfo"")->GetClassVersion();; 4569 }; 4570 R__LOCKGUARD(gInterpreterMutex);; 4571 TClass *cl = new TClass(classname, version, silent);; 4572 if (!emulation) {; 4573 // Set the class version if the class is versioned.; 4574 // Note that we cannot just call CLASS::Class_Version() as we might not have; 4575 // an execution engine (when invoked from rootcling).; 4576 ; 4577 // Do not call cl->GetClassVersion(), it has side effects!; 4578 Version_t oldvers = cl->fClassVersion;; 4579 if (oldvers == version && cl->GetClassInfo()) {; 4580 // We have a version and it might need an update.; 4581 TClingClassInfo* cli = (TClingClassInfo*)cl->GetClassInfo(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:177379,avoid,avoid,177379,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety," argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. ROOT::Internal::TExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. The signature of the reduce function should be (const std::vector<T>) -> T; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. (Note: Please be aware that chunking is only available when the policy is kMultiThread, ignoring this argument in other cases) This may be useful to avoid the overhead introduced when running really short tasks. In this case, the reduction function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; Examples:; root[] ROOT::Internal::TExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int>; &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::Internal::TExecutor; pool(ROOT::EExecutionPolicy::kMultiProcess); auto hist = pool.MapReduce(CreateAndFillHists, 10,; PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::Internal::TExecutorThis class implements the interface to execute the same task multiple times, sequentially or in paral...Definition TExecutor.hxx:37; ROOT::Internal::TExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc, unsigned nChunks) -> InvokeResult_t< F >Execute a function nTimes (M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:2474,avoid,avoid,2474,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['avoid'],['avoid']
Safety," at line 984 of file TF1.cxx. ◆ AddParameter(). virtual void TF1::AddParameter ; (; const TString & ; name, . Double_t ; value . ). inlinevirtual . Definition at line 435 of file TF1.h. ◆ AddToGlobalList(). Bool_t TF1::AddToGlobalList ; (; Bool_t ; on = kTRUE). virtual . Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the function was already in the list false if not) ; Definition at line 847 of file TF1.cxx. ◆ Browse(). void TF1::Browse ; (; TBrowser * ; b). overridevirtual . Browse. ; Reimplemented from TObject.; Definition at line 993 of file TF1.cxx. ◆ CalcGaussLegendreSamplingPoints(). void TF1::CalcGaussLegendreSamplingPoints ; (; Int_t ; num, . Double_t * ; x, . Double_t * ; w, . Double_t ; eps = 3.0e-11 . ). static . Type safe interface (static method) The number of sampling points are taken from the TGraph. ; Type: unsafe but fast interface filling the arrays x and w (static method); Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: ; \[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \]. num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Definition at line 3826 of file TF1.cxx. ◆ CentralMoment(). Double_t TF1::CentralMoment ; (; Double_t ; n, . Double_t ; a, . Double_t ; b, . const Double_t * ; params = nullptr, . Double_t ; epsilon = 0.000001 . ). virtual . Return nth central moment of function between a and b (i.e the n-th moment around the mean value) ; See TF1::Integral() for parameter definitions; AuthorGene Van Buren gene@.nosp@m.bnl..nosp@m.gov ; Definition at line 3739 of file TF1.cxx. ◆ Class(). static TClass * TF1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:58487,unsafe,unsafe,58487,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['unsafe'],['unsafe']
Safety," automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72835,recover,recovered,72835,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety," b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrap.html:3012,safe,safe,3012,root/html530/TGeoTrap.html,https://root.cern,https://root.cern/root/html530/TGeoTrap.html,1,['safe'],['safe']
Safety," b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGtra.html:2991,safe,safe,2991,root/html530/TGeoGtra.html,https://root.cern,https://root.cern/root/html530/TGeoGtra.html,1,['safe'],['safe']
Safety," bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. Int_t SendCanvases(); Send any created canvas to client. Int_t BrowseDirectory(const char* dirname); Browse directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:15160,abort,abort,15160,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,10,['abort'],"['abort', 'aborts']"
Safety," bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. Int_t SendCanvases(); Send any created canvas to client. Int_t BrowseDirectory(const char* dirname); Browse directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:16255,abort,abort,16255,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,4,['abort'],"['abort', 'aborts']"
Safety," bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Generate a data sample of 1000 events in x from model; data = model.generate({x}, 1000); ; # Create workspace, import data and model; # -----------------------------------------------------------------------------; ; # Create a empty workspace; w = ROOT.RooWorkspace(""w"", ""workspace""); ; # Import model and all its components into the workspace; w.Import(model); ; # Import data into the workspace; w.Import(data); ; # Print workspace contents; w.Print(); ; # Save workspace in file; # -------------------------------------------; ; # Save the workspace into a ROOT file; w.writeToFile(""rf502_workspace_py.root""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8py.html:2404,safe,safe,2404,doc/master/rf502__wspacewrite_8py.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8py.html,1,['safe'],['safe']
Safety," bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:28676,avoid,avoid,28676,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['avoid'],['avoid']
Safety," bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 614 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:28680,avoid,avoid,28680,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['avoid'],['avoid']
Safety," boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8620,recover,recover,8620,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,1,['recover'],['recover']
Safety," boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; According the step value, two use cases are possible:. step = TGeoShape::kBig(default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:986301,safe,safety,986301,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:132360,safe,safety,132360,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety," boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a strai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:51703,safe,safety,51703,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['safe'],['safety']
Safety," buffer size of the cache. ; The buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 360 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 376 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 437 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 840 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 831 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:35772,detect,detection,35772,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['detect'],['detection']
Safety," buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:53361,recover,recovered,53361,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recovered']
Safety," bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t maxCacheSize = 10, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:13659,timeout,timeout,13659,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['timeout'],['timeout']
Safety," bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:53453,recover,recovered,53453,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recovered']
Safety," bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualProofPlayer.html:9623,abort,abort,9623,root/html528/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:39614,risk,risk,39614,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['risk'],['risk']
Safety," called on the top master only. Int_t RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:27827,abort,abort,27827,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['abort'],['abort']
Safety," can access a file using the specified access mode.; NB: for the time being mode is ignored for XROOTD (just checks existence; of the file or directory).; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 41574 2011-10-25 13:42:03Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetSystem.html:22933,avoid,avoid,22933,root/html532/TXNetSystem.html,https://root.cern,https://root.cern/root/html532/TXNetSystem.html,1,['avoid'],['avoid']
Safety," can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4232,recover,recovery,4232,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety," canvas to file; 4956/// }// end loop; 4957/// c1.Print(""file.ps]""); // No actual print, just close.; 4958/// ~~~; 4959/// As before, the same macro is valid for PDF files.; 4960///; 4961/// It is possible to print a canvas into an animated GIF file by specifying the; 4962/// file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; 4963/// between the subimages' display. If NN is omitted the delay between; 4964/// subimages is zero. Each picture is added in the animation thanks to a loop; 4965/// similar to the following one:; 4966/// ~~~ {.cpp}; 4967/// for (int i=0; i<10; ++i) {; 4968/// // fill canvas for context i; 4969/// // ...; 4970///; 4971/// c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; 4972/// }// end loop; 4973/// ~~~; 4974/// The delay between each frame must be specified in each Print() statement.; 4975/// If the file ""myfile.gif"" already exists, the new frame are appended at; 4976/// the end of the file. To avoid this, delete it first with `gSystem->Unlink(myfile.gif);`; 4977/// If you want the gif file to repeat or loop forever, check TASImage::WriteImage documentation; 4978 ; 4979void TPad::Print(const char *filename, Option_t *option); 4980{; 4981 if (!GetCanvas()); 4982 return;; 4983 ; 4984 TString psname, fs1 = filename;; 4985 ; 4986 // ""["" and ""]"" are special characters for ExpandPathName. When they are at the end; 4987 // of the file name (see help) they must be removed before doing ExpandPathName.; 4988 if (fs1.EndsWith(""["")) {; 4989 fs1.Replace((fs1.Length()-1),1,"" "");; 4990 gSystem->ExpandPathName(fs1);; 4991 fs1.Replace((fs1.Length()-1),1,""["");; 4992 } else if (fs1.EndsWith(""]"")) {; 4993 fs1.Replace((fs1.Length()-1),1,"" "");; 4994 gSystem->ExpandPathName(fs1);; 4995 fs1.Replace((fs1.Length()-1),1,""]"");; 4996 } else {; 4997 gSystem->ExpandPathName(fs1);; 4998 }; 4999 ; 5000 // Set the default option as ""Postscript"" (Should be a data member of TPad); 5001 const char *opt_default = ""ps"";; 5002 ; 5003 TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:160172,avoid,avoid,160172,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety," case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having rece",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34588,timeout,timeout,34588,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['timeout'],['timeout']
Safety," cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1117010,safe,safe,1117010,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety," char *value);  add attribute to node ;  ; void * AddChild (void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false);  add child node ;  ; Bool_t AddComment (void *node, const char *comment);  ; Bool_t AddRawLine (void *node, const char *raw);  XML helpers. ;  ; std::vector< TMatrixDSym * > * CalcCovarianceMatrices (const std::vector< const Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr);  ; std::vector< TMatrixDSym * > * CalcCovarianceMatrices (const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr);  compute covariance matrices ;  ; Bool_t CheckForSilentOption (const TString &) const;  check for ""silence"" option in configuration option string ;  ; Bool_t CheckForVerboseOption (const TString &) const;  check if verbosity ""V"" set in option ;  ; Bool_t CheckSplines (const TH1 *, const TSpline *);  check quality of splining by comparing splines and histograms in each bin ;  ; const TString & Color (const TString &);  human readable color strings ;  ; void ComputeStat (const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE);  sanity check ;  ; Double_t ComputeVariance (Double_t sumx2, Double_t sumx, Int_t nx);  compute variance from given sums ;  ; Bool_t ContainsRegularExpression (const TString &s);  check if regular expression helper function to search for ""$!%^&()'<>?= "" in a string ;  ; void FormattedOutput (const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"");  formatted output of simple table ;  ; void FormattedOutput (const TMatrixD &, const std::vector< TString > &, MsgLogger &logger);  formatted output of matrix (with labels) ;  ; void FormattedOutput (const TMatrixD &, const std::vector< TString > &vert, const std::vector< TString > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:2304,sanity check,sanity check,2304,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['sanity check'],['sanity check']
Safety," char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:14836,safe,safe,14836,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,3,['safe'],['safe']
Safety," char* objname, TString& itemname); TRootSnifferScanRec&operator=(const TRootSnifferScanRec&); Bool_tScanOnlyFields() const; voidSetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Bool_tSetResult(void* obj, TClass* cl, TDataMember* member = 0); voidSetRootClass(TClass* cl); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootSnifferScanRec(); TRootSnifferScanRec(const TRootSnifferScanRec&). Data Members; protected:. Bool_tfHasMore! indicates that potentially there are more items can be found; TStringfItemName! name of current item; TListfItemsNames! list of created items names, need to avoid duplication; Int_tfLevel! current level of hierarchy; UInt_tfMask! defines operation kind; Bool_tfNodeStarted! indicate if node was started; Int_tfNumChilds! number of childs; Int_tfNumFields! number of fields; TRootSnifferScanRec*fParent! pointer on parent record; Int_tfRestriction! restriction 0 - default, 1 - read-only, 2 - full access; const char*fSearchPath! current path searched; TRootSnifferStore*fStore! object to store results; static TRootSnifferScanRec::(anonymous)kActions; static TRootSnifferScanRec::(anonymous)kCheckChilds; static TRootSnifferScanRec::(anonymous)kExpand; static TRootSnifferScanRec::(anonymous)kOnlyFields; static TRootSnifferScanRec::(anonymous)kScan; static TRootSnifferScanRec::(anonymous)kSearch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSnifferScanRec.html:1687,avoid,avoid,1687,root/html604/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html604/TRootSnifferScanRec.html,1,['avoid'],['avoid']
Safety," char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:16912,abort,abort,16912,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['abort'],['abort']
Safety," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoBBox::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoBBox::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tTGeoBBox::DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoPolyShape.html:1823,safe,safe,1823,root/html528/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html528/TEveGeoPolyShape.html,2,['safe'],['safe']
Safety," cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. Bool_t LoadText(const char* ) const; {return kFALSE;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void(*)() ) const; {;}. void SetAllocunlockfunc(void(*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. int SetClassAutoparsing(int ); {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:30240,avoid,avoids,30240,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['avoid'],['avoids']
Safety," classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:283009,safe,safe,283009,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety," classes, those classes should be; 7415 // cross-checked in testHashRecursiveRemove.cxx; 7416 static const char *handVerified[] = {; 7417 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7418 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432////////////////////////////////////////////////////////////////////////////////; 7433/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7434/// classes in the class hierarchy that overload TObject::Hash do call; 7435/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7436/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7437 ; 7438Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7439{; 7440 return clRef.HasConsistentHashMember();; 7441}; 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:285760,safe,safe,285760,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety," collcl = LoadClassDefault(collname.c_str(), silent);; 3163 if (collcl) {; 3164 auto p = collcl->GetCollectionProxy();; 3165 if (p); 3166 cl = p->GetValueClass();; 3167 if (cl); 3168 return cl;; 3169 }; 3170 }; 3171 }; 3172 } else if (TClassEdit::IsSTLCont( normalizedName.c_str() )) {; 3173 ; 3174 return gInterpreter->GenerateTClass(normalizedName.c_str(), kTRUE, silent);; 3175 }; 3176 ; 3177 // Check the interpreter only after autoparsing the template if any.; 3178 if (!ispairbase) {; 3179 std::string::size_type posLess = normalizedName.find('<');; 3180 if (posLess != std::string::npos) {; 3181 gCling->AutoParse(normalizedName.substr(0, posLess).c_str());; 3182 }; 3183 }; 3184 ; 3185 //last attempt. Look in CINT list of all (compiled+interpreted) classes; 3186 if (gDebug>0){; 3187 printf(""TClass::GetClass: Header Parsing - The representation of %s was not found in the type system. A lookup in the interpreter is about to be tried: this can cause parsing. This can be avoided selecting %s in the linkdef/selection file.\n"",normalizedName.c_str(), normalizedName.c_str());; 3188 }; 3189 if (normalizedName.length()) {; 3190 auto cci = gInterpreter->CheckClassInfo(normalizedName.c_str(), kTRUE /* autoload */,; 3191 kTRUE /*Only class, structs and ns*/);; 3192 ; 3193 // We could have an interpreted class with an inline ClassDef, in this case we do not; 3194 // want to create an 'interpreted' TClass but we want the one triggered via the call to; 3195 // the Dictionary member. If we go ahead and generate the 'interpreted' version it will; 3196 // replace if/when there is a call to IsA on an object of this type.; 3197 ; 3198 if (cci == TInterpreter::kWithClassDefInline) {; 3199 auto ci = gInterpreter->ClassInfo_Factory(normalizedName.c_str());; 3200 auto funcDecl = gInterpreter->GetFunctionWithPrototype(ci, ""Dictionary"", """", false, ROOT::kExactMatch);; 3201 auto method = gInterpreter->MethodInfo_Factory(funcDecl);; 3202 typedef void (*tcling_callfunc_Wrapper_t)(void *, int, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:121169,avoid,avoided,121169,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoided']
Safety," collcl = LoadClassDefault(collname.c_str(), silent);; 3230 if (collcl) {; 3231 auto p = collcl->GetCollectionProxy();; 3232 if (p); 3233 cl = p->GetValueClass();; 3234 if (cl); 3235 return cl;; 3236 }; 3237 }; 3238 }; 3239 } else if (TClassEdit::IsSTLCont( normalizedName.c_str() )) {; 3240 ; 3241 return gInterpreter->GenerateTClass(normalizedName.c_str(), kTRUE, silent);; 3242 }; 3243 ; 3244 // Check the interpreter only after autoparsing the template if any.; 3245 if (!ispairbase) {; 3246 std::string::size_type posLess = normalizedName.find('<');; 3247 if (posLess != std::string::npos) {; 3248 gCling->AutoParse(normalizedName.substr(0, posLess).c_str());; 3249 }; 3250 }; 3251 ; 3252 //last attempt. Look in CINT list of all (compiled+interpreted) classes; 3253 if (gDebug>0){; 3254 printf(""TClass::GetClass: Header Parsing - The representation of %s was not found in the type system. A lookup in the interpreter is about to be tried: this can cause parsing. This can be avoided selecting %s in the linkdef/selection file.\n"",normalizedName.c_str(), normalizedName.c_str());; 3255 }; 3256 if (normalizedName.length()) {; 3257 auto cci = gInterpreter->CheckClassInfo(normalizedName.c_str(), kTRUE /* autoload */,; 3258 kTRUE /*Only class, structs and ns*/);; 3259 ; 3260 // We could have an interpreted class with an inline ClassDef, in this case we do not; 3261 // want to create an 'interpreted' TClass but we want the one triggered via the call to; 3262 // the Dictionary member. If we go ahead and generate the 'interpreted' version it will; 3263 // replace if/when there is a call to IsA on an object of this type.; 3264 ; 3265 if (cci == TInterpreter::kWithClassDefInline) {; 3266 auto ci = gInterpreter->ClassInfo_Factory(normalizedName.c_str());; 3267 auto funcDecl = gInterpreter->GetFunctionWithPrototype(ci, ""Dictionary"", """", false, ROOT::kExactMatch);; 3268 auto method = gInterpreter->MethodInfo_Factory(funcDecl);; 3269 typedef void (*tcling_callfunc_Wrapper_t)(void *, int, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:123920,avoid,avoided,123920,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoided']
Safety," composite p.d.fs.Definition RooAbsReal.cxx:1438; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::ScaleTypeScaleTypeDefinition RooAbsReal.h:276; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276; RooAbsReal::Relative@ RelativeDefinition RooAbsReal.h:276; RooAbsReal::Raw@ RawDefinition RooAbsReal.h:276; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:157088,sanity check,sanity check,157088,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:2875,safe,safe,2875,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,['safe'],['safe']
Safety," const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:947; RooAbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220683,sanity check,sanity check,220683,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:20359,safe,safe,20359,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,2,['safe'],['safe']
Safety," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTube.html:22113,safe,safe,22113,root/html604/TGeoTube.html,https://root.cern,https://root.cern/root/html604/TGeoTube.html,2,['safe'],['safe']
Safety," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTube.html:22113,safe,safe,22113,root/html602/TGeoTube.html,https://root.cern,https://root.cern/root/html602/TGeoTube.html,2,['safe'],['safe']
Safety," const TString & ; name, . const TString & ; options, . const TString & ; suffix = """", . PDF * ; defaultPDF = nullptr, . Bool_t ; norm = kTRUE . ). explicit . Definition at line 193 of file PDF.cxx. ◆ ~PDF(). TMVA::PDF::~PDF ; (; ). virtual . Definition at line 246 of file PDF.cxx. Member Function Documentation. ◆ AddXMLTo(). void TMVA::PDF::AddXMLTo ; (; void * ; parent). XML file writing. ; Definition at line 919 of file PDF.cxx. ◆ BuildKDEPDF(). void TMVA::PDF::BuildKDEPDF ; (; ). private . creates high-binned reference histogram to be used instead of the PDF for speed reasons ; Definition at line 387 of file PDF.cxx. ◆ BuildPDF(). void TMVA::PDF::BuildPDF ; (; const TH1 * ; theHist). Definition at line 260 of file PDF.cxx. ◆ BuildSplinePDF(). void TMVA::PDF::BuildSplinePDF ; (; ). private . build the PDF from the original histograms ; Definition at line 321 of file PDF.cxx. ◆ CheckHist(). void TMVA::PDF::CheckHist ; (; ); const. private . sanity check: compare PDF with original histogram ; Definition at line 553 of file PDF.cxx. ◆ Class(). static TClass * TMVA::PDF::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::PDF::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::PDF::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 211 of file PDF.h. ◆ DeclareOptions(). void TMVA::PDF::DeclareOptions ; (; ). define the options (their key words) that can be set in the option string ; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:20995,sanity check,sanity check,20995,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,1,['sanity check'],['sanity check']
Safety," const char * UnixHomedirectory (const char *user, char *path, char *mydir);  Returns the user's home directory. ;  ; static const char * UnixHomedirectory (const char *user=nullptr);  Returns the user's home directory. ;  ; static void UnixIgnoreSignal (ESignals sig, Bool_t ignore);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; static int UnixMakedir (const char *name);  Make a Unix file system directory. ;  ; static Long64_t UnixNow ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; static void * UnixOpendir (const char *name);  Open a directory. ;  ; static int UnixRecv (int sock, void *buf, int len, int flag);  Receive exactly length bytes into buffer. ;  ; static void UnixResetSignal (ESignals sig);  Restore old signal handler for specified signal. ;  ; static void UnixResetSignals ();  Restore old signal handlers. ;  ; static int UnixSelect (Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout);  Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ;  ; static int UnixSend (int sock, const void *buf, int len, int flag);  Send exactly length bytes from buffer. ;  ; static int UnixSetitimer (Long_t ms);  Set interval timer to time-out in ms milliseconds. ;  ; static void UnixSigAlarmInterruptsSyscalls (Bool_t set);  When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; static void UnixSignal (ESignals sig, SigHandler_t h);  Set a signal handler for a signal. ;  ; static const char * UnixSigname (ESignals sig);  Return the signal name associated with a signal. ;  ; static int UnixTcpConnect (const char *hostname, int port, int tcpwindowsize);  Open a TCP/IP connection to server and connect to a service (i.e. ;  ; static int UnixTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize);  Open a socket, bind to it and start listening fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:34780,timeout,timeout,34780,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,4,['timeout'],['timeout']
Safety," const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); Create a PROOF slave object. Called via the TProof ctor. void Init(const char* host, Int_t stype); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void ParseBuffer(); Parse fBuffer after a connection attempt. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSlave.html:10665,abort,abort,10665,root/html602/TXSlave.html,https://root.cern,https://root.cern/root/html602/TXSlave.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety," const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPgon&operator=(const TGeoPgon&); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:9047,safe,safe,9047,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,2,['safe'],['safe']
Safety," const char* title, Int_t nbinsx, Double_t xlow, Double_t xup); Normal constructor for fix bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); Creates histogram basic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:40947,avoid,avoid,40947,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['avoid'],['avoid']
Safety," const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTorus.html:2249,safe,safe,2249,root/html532/TGeoTorus.html,https://root.cern,https://root.cern/root/html532/TGeoTorus.html,1,['safe'],['safe']
Safety," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:7157,unsafe,unsafe,7157,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['unsafe'],['unsafe']
Safety," const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:22675,abort,abort,22675,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,6,['abort'],['abort']
Safety," const; TGeoArb8::InsidePolygonstatic Bool_t InsidePolygon(Double_t x, Double_t y, Double_t *pts); TGeoArb8::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoArb8::fDzDouble_t fDzDefinition TGeoArb8.h:26; TGeoArb8::operator=TGeoArb8 & operator=(const TGeoArb8 &)=delete; TGeoArb8::GetBoundingCylindervoid GetBoundingCylinder(Double_t *param) const override; TGeoArb8::EGeoArb8TypeEGeoArb8TypeDefinition TGeoArb8.h:19; TGeoArb8::kArb8Trap@ kArb8TrapDefinition TGeoArb8.h:22; TGeoArb8::kArb8Tra@ kArb8TraDefinition TGeoArb8.h:23; TGeoArb8::fTwistDouble_t * fTwistDefinition TGeoArb8.h:27; TGeoArb8::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoArb8::GetPlaneNormalstatic void GetPlaneNormal(Double_t *p1, Double_t *p2, Double_t *p3, Double_t *norm); TGeoArb8::CapacityDouble_t Capacity() const override; TGeoArb8::SafetyToFaceDouble_t SafetyToFace(const Double_t *point, Int_t iseg, Bool_t in) const; TGeoArb8::Sizeof3Dvoid Sizeof3D() const override; TGeoArb8::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::IsTwistedBool_t IsTwisted() constDefinition TGeoArb8.h:80; TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoArb8::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoArb8::InspectShapevoid InspectShape() const override; TGeoArb8::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoArb8::TGeoArb8TGeoArb8(); TGeoArb8::GetTwistDouble_t GetTwist(Int_t iseg) const; TGeoArb8::TGeoArb8TGeoArb8(Double_t dz, Double_t *vertices=nullptr); TGeoArb8::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:13380,safe,safe,13380,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety," const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidAddNode(TStructNode* node, ULong_t size); voidCountMembers(TClass* cl, TStructNode* parent, void* pointer); voidPrepare(); voidReset(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TListfColorsList with properties used to color nodes; TStructViewerGUI*fGUIPointer to GUI class; TObjArrayfLevelArrayArray with pointers to nodes on each level; TExMapfLevelMembersCountContains number of objects on each level; TExMapfLevelSizeContains total size in bytes of a level; void*fPointerMain pointer to represented object; TClass*fPointerClassTClass of a main pointer; TExMapfPointersMap of pointer to avoid circulation; TStructNode*fTopNodeMaster node for fPointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructViewer(void* ptr = NULL, const char* clname = NULL); Default constructor. An argument ""ptr"" is a main pointer of type ""clname"", which should be shown in the viewer. ~TStructViewer(); Destructor. Clean all object after closing the viewer. void AddNode(TStructNode* node, ULong_t size); Find list with nodes on specified level and add node to this list and increment list of sizes and list of members. void CountMembers(TClass* cl, TStructNode* parent, void* pointer); Count allocated memory, increase member counters, find child nodes. void Draw(Option_t* option = """"); Draw object if there is valid pointer. TCanvas* GetCanvas(); Returns canvas used to keep TGeoV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructViewer.html:7232,avoid,avoid,7232,root/html530/TStructViewer.html,https://root.cern,https://root.cern/root/html530/TStructViewer.html,3,['avoid'],['avoid']
Safety," const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); TSlaveLite(const TSlaveLite&); TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. static TSlave::ESlaveStatusTSlave::kActive; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TSlave::ESlaveStatusTSlave::kInactive; static TSlave::ESlaveStatusTSlave::kInvalid; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TSlave::ESlaveTypeTSlave::kMaster; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlaveLite.html:6690,abort,abort,6690,root/html602/TSlaveLite.html,https://root.cern,https://root.cern/root/html602/TSlaveLite.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," constructor: start a remote session at 'url' accepting callbacks; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:14497,timeout,timeout,14497,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,7,['timeout'],['timeout']
Safety," crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988253,safe,safety,988253,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ;  CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ;  CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ;  CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ;  CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions ;  CTUnuranSamplerTUnuranSampler class class implementing the ROOT::Math::DistSampler interface using the UNU.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:202617,detect,detector,202617,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,8,['detect'],['detector']
Safety," destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 ///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:18033,safe,safe,18033,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety," dictionary parsing is done and these headers cannot be selected anymore. ;  ; static llvm::cl::SubCommand gBareClingSubcommand (""bare-cling"", ""Call directly cling and exit."");  ; static bool GenerateAllDict (TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance, const std::string &currentDirectory);  Generates a PCH from the given ModuleGenerator and CompilerInstance. ;  ; int GenerateFullDict (std::ostream &dictStream, cling::Interpreter &interp, RScanner &scan, const ROOT::TMetaUtils::RConstructorTypes &ctorTypes, bool isSplit, bool isGenreflex, bool isSelXML, bool writeEmptyRootPCM);  ; static std::string GenerateFwdDeclString (const RScanner &scan, const cling::Interpreter &interp);  Generate the fwd declarations of the selected entities. ;  ; void GenerateLinkdef (llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser);  ; void GenerateNecessaryIncludes (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:10343,detect,detectedUmbrella,10343,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['detect'],['detectedUmbrella']
Safety," difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias; bias_default[j] = sum_i A[i][j]; x0[j] = scaleBias*bias[j]; The scale factor can be used to; (a) completely suppress the bias by setting it to zero; (b) compensate differences in the normalisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:5553,avoid,avoid,5553,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,3,['avoid'],['avoid']
Safety," directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the scaled shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the scaled shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to surface of the scaled shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Fills a static 3D buffer and returns a reference. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  in case shape has some negative parameters, these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:2306,safe,safe,2306,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety," dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide the shape along one axis. ;  ; void GetBoundingCylinder (Double_t *) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; virtual Double_t * GetNorm ();  ; virtual Double_t * GetPoint ();  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  computes the closest distance from given point to this shape, according to option. ;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  Set half-space parameters as stored in an array. ;  ; void SetPoints (Double_t *) const override;  ; void SetPoints (Float_t *) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:4062,safe,safe,4062,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,2,['safe'],['safe']
Safety," distinct subset of entries, and their partial results are merged before returning the final values to the user. There are no guarantees on the order in which threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46281,safe,safety,46281,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safety']
Safety," do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16453,safe,safe,16453,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety," double relTol=-1, unsigned int calls=0);  constructor of GSL MCIntegrator. ;  ;  ~GSLMCIntegrator () override;  destructor ;  ; double ChiSqr ();  returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm ;  ; double Error () const override;  return the estimate of the absolute Error of the last Integral calculation ;  ; std::unique_ptr< ROOT::Math::IOptions > ExtraOptions () const;  get the specific options (for Vegas or Miser) in term of string- name. ;  ; MCIntegration::Type GetType () const;  return the type (need to be called GetType to avoid a conflict with typedef) ;  ; const char * GetTypeName () const;  return the name ;  ; double Integral (const double *a, const double *b) override;  evaluate the integral using the previously defined function ;  ; double Integral (const GSLMonteFuncPointer &f, unsigned int dim, double *a, double *b, void *p=nullptr);  evaluate the Integral of a function f over the defined hypercube (a,b) ;  ; int NEval () const override;  return number of function evaluations in calculating the integral (This is an fixed by the user) ;  ; ROOT::Math::IntegratorMultiDimOptions Options () const override;  get the option used for the integration ;  ; double Result () const override;  return the type of the integration used ;  ; void SetAbsTolerance (double absTolerance) override;  set the desired absolute Error ;  ; void SetExtraOptions (const ROOT::Math::IOptions &opt);  Set the extra options for Vegas and Miser. ;  ; void SetFunction (const IMultiGenFunction &f) override;  method to set the a generic integration function ;  ; void SetFunction (GSLMonteFuncPointer f, unsigned int dim, void *p=nullptr);  ; void SetGenerator (GSLRandomEngine &r);  set random number generator ;  ; void SetMode (MCIntegration::Mode mode);  set integration mode for VEGAS method The possible MODE are : MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling MCIntegration::kSTRATIFIED : VEGAS will use strat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html:1341,avoid,avoid,1341,doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,1,['avoid'],['avoid']
Safety," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:11327,predict,predictions,11327,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,4,['predict'],['predictions']
Safety," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__VavilovAccurateCdf.html:3599,avoid,avoid,3599,root/html602/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__VavilovAccurateCdf.html:2840,avoid,avoid,2840,root/html534/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html:3599,avoid,avoid,3599,root/html604/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:7726,detect,detect,7726,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,7,['detect'],['detect']
Safety," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:9777,detect,detect,9777,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['detect'],['detect']
Safety," dump2(); Debug stuff, should go... RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t weight, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:28080,safe,safe,28080,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,1,['safe'],['safe']
Safety," dump2(); Debug stuff, should go... RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t wgt, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:27273,safe,safe,27273,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['safe'],['safe']
Safety," each packet; TStatus*fSelStatus! status of query in progress; TSelector*fSelector! the latest selector; TClass*fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*fStopTimerTimer associated with a stop request; TMutex*fStopTimerMtxTo protect the stop timer; Long64_tfTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fAutoBinsMap of min/max values by name for slaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPlayer(TProof* proof = 0); Default ctor. ~TProofPlayer(); Destructor. void SetProcessing(Bool_t on = kTRUE); Set processing bit according to 'on'. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop the process after this event. If timeout is positive, start; a timer firing after timeout seconds to hard-stop time-expensive; events. void SetDispatchTimer(Bool_t on = kTRUE); Enable/disable the timer to dispatch pening events while processing. void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); Enable/disable the timer to stop/abort processing.; The 'timeout' is in seconds. void AddQueryResult(TQueryResult* q); Add query result to the list, making sure that there are no; duplicates. void RemoveQueryResult(const char* ref); Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:15524,timeout,timeout,15524,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,['timeout'],['timeout']
Safety," embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes.; 18.4.2 Creating and Positioning Volumes; 18.4.2.1 Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user’s task to provide different names for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; 18.4.2.2 Example of Volume Creation; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:935137,avoid,avoid,935137,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; 139| Stats() | Return a TStatistic object filled with the input columns. |; 140| StdDev() | Return the unbiased standard deviation of the processed column values. |; 141| Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; 142| Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |; 143 ; 144| **Instant action** | **Description** |; 145|---------------------|-----------------|; 146| Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; 147| ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 148| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 149 ; 150 ; 151### Queries; 152 ; 153These operations do not modify the dataframe or book computations but simply return info",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:10529,safe,safety,10529,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safety']
Safety," entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; 143| Stats() | Return a TStatistic object filled with the input columns. |; 144| StdDev() | Return the unbiased standard deviation of the processed column values. |; 145| Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; 146| Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |; 147 ; 148| **Instant action** | **Description** |; 149|---------------------|-----------------|; 150| Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; 151| ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 152| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 153 ; 154 ; 155### Queries; 156 ; 157These operations do not modify the dataframe or book computations but simply return info",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:10971,safe,safety,10971,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safety']
Safety," entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 everytime a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, eg the default name for a TList is ""TList"". Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *l = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; l->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; l->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; l->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(l,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:42710,avoid,avoid,42710,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['avoid'],['avoid']
Safety," epsilon) ||; 293 (i == j && (*d)(i,i) < 0)) {; 294 //d->Print();; 295 Log() << kWARNING << ""<GetSQRootMatrix> error in matrix diagonalization; printed S and B"" << Endl;; 296 }; 297 }; 298 }; 299 ; 300 // make exactly diagonal; 301 for (i=0; i<n; i++) for (j=0; j<n; j++) if (j != i) (*d)(i,j) = 0;; 302 ; 303 // compute the square-root C' of covariance matrix: C = C'*C'; 304 for (i=0; i<n; i++) (*d)(i,i) = TMath::Sqrt((*d)(i,i));; 305 ; 306 TMatrixD* sqrtMat = new TMatrixD( n, n );; 307 sqrtMat->Mult( (*s), (*d) );; 308 (*sqrtMat) *= (*si);; 309 ; 310 // invert square-root matrices; 311 sqrtMat->Invert();; 312 ; 313 delete eigen;; 314 delete s;; 315 delete si;; 316 delete d;; 317 ; 318 return sqrtMat;; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// turns covariance into correlation matrix; 323 ; 324const TMatrixD* TMVA::Tools::GetCorrelationMatrix( const TMatrixD* covMat ); 325{; 326 ; 327 if (covMat == 0) return 0;; 328 // sanity check; 329 Int_t nvar = covMat->GetNrows();; 330 if (nvar != covMat->GetNcols()); 331 Log() << kFATAL << ""<GetCorrelationMatrix> input matrix not quadratic"" << Endl;; 332 ; 333 Log() << kWARNING;; 334 TMatrixD* corrMat = new TMatrixD( nvar, nvar );; 335 for (Int_t ivar=0; ivar<nvar; ivar++) {; 336 for (Int_t jvar=0; jvar<nvar; jvar++) {; 337 if (ivar != jvar) {; 338 Double_t d = (*covMat)(ivar, ivar)*(*covMat)(jvar, jvar);; 339 if (d > 1E-20) {; 340 (*corrMat)(ivar, jvar) = (*covMat)(ivar, jvar)/TMath::Sqrt(d);; 341 } else {; 342 Log() << ""<GetCorrelationMatrix> zero variances for variables ""; 343 << ""("" << ivar << "", "" << jvar << "")"" << Endl;; 344 (*corrMat)(ivar, jvar) = 0;; 345 }; 346 if (TMath::Abs( (*corrMat)(ivar,jvar)) > 1){; 347 Log() << kWARNING; 348 << "" Element corr(""<<ivar<<"",""<<ivar<<"")="" << (*corrMat)(ivar,jvar); 349 << "" sigma2=""<<d; 350 << "" cov(""<<ivar<<"",""<<ivar<<"")="" <<(*covMat)(ivar, ivar); 351 << "" cov(""<<jvar<<"",""<<jvar<<"")="" <<(*covMat)(jvar, jvar); 352 << Endl;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:11190,sanity check,sanity check,11190,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety," experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create “symbolic links” to any complex path to make it more representable for the object it designates:; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); Such a symbolic link hides the complexity of the path to the align object and replaces it with a more meaningful name. In addition, TGeoPNEntry objects are faster to search by name and they may optionally store an additional user matrix.; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *unique_n,; const char*path); // Retrieving an existing al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1014044,detect,detector,1014044,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety," fInfo->SetBit(TStreamerInfo::kBuildRunning);; 247 fInfo->SetBit(TStreamerInfo::kBuildOldUsed);; 248 }; 249 ~TPreventRecursiveBuildGuard() {; 250 fInfo->ResetBit(TStreamerInfo::kBuildOldUsed);; 251 fInfo->ResetBit(TStreamerInfo::kBuildRunning);; 252 }; 253 TStreamerInfo* fInfo;; 254 };; 255 ; 256}; 257 ; 258////////////////////////////////////////////////////////////////////////////////; 259/// Build the I/O data structure for the current class version.; 260///; 261/// A list of TStreamerElement derived classes is built by scanning; 262/// one by one the list of data members of the analyzed class.; 263void TStreamerInfo::Build(Bool_t isTransient); 264{; 265 // Did another thread already do the work?; 266 if (fIsCompiled) return;; 267 ; 268 R__LOCKGUARD(gInterpreterMutex);; 269 ; 270 // Did another thread already do the work while we were waiting ..; 271 if (fIsCompiled) return;; 272 ; 273 // Has Build already been run?; 274 if (fIsBuilt) return;; 275 ; 276 // Are we recursing on ourself?; 277 if (TestBit(TStreamerInfo::kBuildRunning)) return;; 278 ; 279 // This is used to avoid unwanted recursive call to Build or BuildOld.; 280 TPreventRecursiveBuildGuard buildGuard(this);; 281 ; 282 if (fClass->GetCollectionProxy()) {; 283 TVirtualCollectionProxy *proxy = fClass->GetCollectionProxy();; 284 TString title;; 285 if (proxy->GetValueClass()) {; 286 title.Form(""<%s%s> Used to call the proper TStreamerInfo case"",proxy->GetValueClass()->GetName(),proxy->HasPointers() ? ""*"" : """");; 287 } else {; 288 title .Form(""<%s%s> Used to call the proper TStreamerInfo case"",TDataType::GetTypeName(proxy->GetType()),proxy->HasPointers() ? ""*"" : """");; 289 }; 290 TStreamerElement* element = new TStreamerSTL(""This"", title.Data(), 0, fClass->GetName(), *proxy, 0);; 291 fElements->Add(element);; 292 Compile();; 293 fCheckSum = fClass->GetCheckSum();; 294 fIsBuilt = kTRUE;; 295 return;; 296 }; 297 ; 298 // Warn on read/write of RVec (see 6.24 release notes); 299 if (strncmp(GetName(), ""ROOT::V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:8271,avoid,avoid,8271,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety," fNTried = nullptr;; 136 fMTried = nullptr;; 137 fHullPoints = nullptr;; 138 fOrder = nullptr;; 139 fDist = nullptr;; 140 fXN = nullptr;; 141 fYN = nullptr;; 142}; 143 ; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Return the z value corresponding to the (x,y) point in fGraph2D; 147 ; 148Double_t TGraphDelaunay::ComputeZ(Double_t x, Double_t y); 149{; 150 // Initialise the Delaunay algorithm if needed.; 151 // CreateTrianglesDataStructure computes fXoffset, fYoffset,; 152 // fXScaleFactor and fYScaleFactor;; 153 // needed in this function.; 154 if (!fInit) {; 155 CreateTrianglesDataStructure();; 156 FindHull();; 157 fInit = kTRUE;; 158 }; 159 ; 160 // Find the z value corresponding to the point (x,y).; 161 Double_t xx, yy;; 162 xx = (x+fXoffset)*fXScaleFactor;; 163 yy = (y+fYoffset)*fYScaleFactor;; 164 Double_t zz = Interpolate(xx, yy);; 165 ; 166 // Wrong zeros may appear when points sit on a regular grid.; 167 // The following line try to avoid this problem.; 168 if (zz==0) zz = Interpolate(xx+0.0001, yy);; 169 ; 170 return zz;; 171}; 172 ; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Function used internally only. It creates the data structures needed to; 176/// compute the Delaunay triangles.; 177 ; 178void TGraphDelaunay::CreateTrianglesDataStructure(); 179{; 180 // Offset fX and fY so they average zero, and scale so the average; 181 // of the X and Y ranges is one. The normalized version of fX and fY used; 182 // in Interpolate.; 183 Double_t xmax = fGraph2D->GetXmax();; 184 Double_t ymax = fGraph2D->GetYmax();; 185 Double_t xmin = fGraph2D->GetXmin();; 186 Double_t ymin = fGraph2D->GetYmin();; 187 fXoffset = -(xmax+xmin)/2.;; 188 fYoffset = -(ymax+ymin)/2.;; 189 fXScaleFactor = 1./(xmax-xmin);; 190 fYScaleFactor = 1./(ymax-ymin);; 191 fXNmax = (xmax+fXoffset)*fXScaleFactor;; 192 fXNmin = (xmin+fXoffset)*fXScaleFactor;; 193 fYNmax = (ymax+fYoffset)*fYScale",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:5238,avoid,avoid,5238,doc/master/TGraphDelaunay_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html,1,['avoid'],['avoid']
Safety," faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis. TGeoPara class. The shape has the center in the origin and it is defined by:. dX, dY, dZ: half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at -dZ, while the upper at +dZ.; alpha: angle between the segment defined by the centers of the X-parallel edges and Y axis [-90,90] in degrees; theta: theta angle of the segment defined by the centers of the Z faces;; phi: phi angle of the same segment. TGeoPara(dX,dY,dZ,alpha,theta,phi);; A box is a particular parallelepiped having the parameters: (dX,dY,dZ,0.,0.,0.).; 18.3.2.3 Trapezoids; In general, we will call trapezoidal shapes having 8 vertices and up to 6 trapezoid faces. Besides that, two of the opposite faces are parallel to XY plane and are positioned at dZ. Since general trapezoids are seldom used in detector geometry descriptions, there are several primitives implemented in the modeller for particular cases.; Trd1 is a trapezoid with only X varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:; TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);. TGeoTrd1 class. Trd2 is a trapezoid with both X and Y varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y at these planes:; TGeoTrd2(Double_t dx1,Double_t dx2,Double_t dy1,Double_t dy2, Double_t dz);. TGeoTrd2 class. 18.3.2.4 General Trapezoid - TGeoTrap Class; A general trapezoid is one for which the faces perpendicular to z are trapezes but their centers are not necessary at the same x, y coordinates. TGeoTrap Class. It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, H1 the half length in y at low z, LB1 the half length in x at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:901361,detect,detector,901361,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety," feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; \[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]; They form parallelepiped \(P\) (\(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument.; 5.12 Neural Networks; 5.12.1 Introduction; Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:230545,predict,predictions,230545,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['predict'],['predictions']
Safety," fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:2406,avoid,avoiding,2406,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,6,['avoid'],['avoiding']
Safety," file name finishes with ""("", the file is not closed; if the Postscript or PDF file name finishes with "")"" and the file has been opened with ""("", the file is closed. Example: {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); //write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); canvas is added to ""c1.ps"" and ps file is closed; }; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; In the previous example replacing ""ps"" by ""pdf"" will create a multi-pages PDF file.; Note that the following sequence writes the canvas to ""c1.ps"" and closes the ps file.: TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop one needs to detect the special cases of first and last page and then munge the argument to Print() accordingly.; The ""["" and ""]"" can be used instead of ""("" and "")"".; Example: c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close.; As before, the same macro is valid for PDF files.; It is possible to print a canvas into an animated GIF file by specifying the file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay between the subimages' display. If NN is omitted the delay between subimages is zero. Each picture is added in the animation thanks to a loop similar to the following one: for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop; The delay between each frame must be specified in each Print() statement. If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:105287,detect,detect,105287,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['detect'],['detect']
Safety," file will not be compressed. . 1 minimal compression level but fast. . ... .... . 9 maximal compression level but slower and might use more memory. . (For the currently supported algorithms, the maximum level is 9) If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::RCompressionSetting::EAlgorithm associates each algorithm with a number. There is a utility function to help to set the value of compress. For example, ROOT::CompressionSettings(ROOT::kLZMA, 1) will build an integer which will set the compression to use the LZMA algorithm and compression level 1. These are defined in the header file Compression.h. Note that the compression settings may be changed at any time. The new compression settings will only apply to branches created or attached after the setting is changed and other objects written after the setting is changed. In case the file does not exist or is not a valid ROOT file, it is made a Zombie. One can detect this situation with a code like: TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; f#define f(i)Definition RSha256.hxx:104; If you open a file instead with TFile::Open(""file.root"") use rather the following code as a nullptr is returned. TFile* f = TFile::Open(""file.root"");; if (!f) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When opening the file, the system checks the validity of this directory. If something wrong is detected, an automatic Recovery is performed. In this case, the file is scanned sequentially reading all logical blocks and attempting to rebuild a correct directory (see TFile::Recover). One can disable the automatic recovery procedure when reading one or more files by setting the en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:51431,detect,detect,51431,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['detect'],['detect']
Safety," files from other locations which can be configured with AddServerLocation() method or directly via: WebGui.ServerLocations: location1:/file/path/to/location1;location2:/file/path/to/location2 . Definition at line 430 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 619 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 250 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float ROOT::RWebWindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; Definition at line 66 of file RWebWindowsManager.hxx. ◆ GetServer(). THttpServer * ROOT::RWebWindowsManager::GetServer ; (; ); const. inline . Returns THttpServer instance. ; Definition at line 89 of file RWebWindowsManager.hxx. ◆ GetServerAddr(). std::string ROOT::RWebWindowsManager::GetServerAddr ; (; ); const. inline . Returns http address of the server, empty string when not available. ; Definition at line 92 of file RWebWindowsManager.hxx. ◆ GetServerLocations(). std::map< std::string, std::string > RWebWindowsManager::GetServerLocations ; (; ). static . Returns server locations as <std::string, std::string> Key is location name (with slash at the end) and value is file path. ; Definition at line 209 of file RWebWindowsManager.cxx. ◆ GetUrl(). std::string RWebWindowsManager::GetUrl ; (; RWebWindow & ; win, . bool ; remote = false, . std::string * ; produced_key = nullptr . ). private . Provide URL address to access specified window from inside or from r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:12981,timeout,timeout,12981,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety," find_library() after integrating with ROOT.; [#15751] - [RF] Using a conditional RooProdPdf in a multi-channel fit spawns too many integrals with new CPU evaluation backend; [#15791] - JS ROOT does not draw tprofile2d correctly with “TEXT” draw option; [#15799] - pyunittests-pyroot-pyz-ttree-setbranchaddress segfaults with Python 3.13; [ROOT-7412] - Strange results looking for nested types; [ROOT-8439] - PyROOT does not treat exceptions properly in overloaded methods; [ROOT-9307] - TPad::GetListOfPrimitives() double deletion error in TList::Clear(). Release 6.32.04; Published on August 14, 2024; Items addressed in this release. [#7223] - [RF] RDataFrame to RooDataSet/RooDataHist conversion; [#7782] - [RF] Allow to set nbins for RooPlot (or disallow); [#9838] - [RF] RooCurve::Average() overestimating average values of standard precision curves on small; [#11565] - [RF] Crash in RooStats::ToyMCSample::GenerateToyData; [#13387] - Please recover SrvAuthenticate from libSrvAuth library; [#14541] - [ROOT-6193] Editor for palette axis cannot set title properties; [#15104] - new PyROOT/cppyy fails to pickle enums; [#15161] - Attribute (getitem) differences for PyROOT objects in ROOT master; [#15234] - cppyy - wrong object type when iterating over a polymorphic container; [#15269] - Iterators in pyROOT working differently in ROOT master compared to 6.30/02; [#15315] - PyROOT Example with inheriting from ROOT.Math.IMultiGenFunction doesn’t work after recent cppyy upgrade; [#15425] - TTreeProcessorMP processes events multiple times when there are more threads than entries; [#15755] - [RF][HS3] Higgs discovery workspaces roundtrip; [#15874] - [Hist] Backwards compatibility broken for THnSparseL in 6.32; [#15887] - Broken plot .C macros for default Name() argument in plotOn(); [#15977] - [gui] Event StatusBar does not work well when TMarker outside of zoom region; [#15986] - Problems with TUri compilation; [#16031] - VecOps binary functions not using the right types; [#16038] - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:44565,recover,recover,44565,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['recover'],['recover']
Safety," fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111280,detect,detector,111280,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety," float number with negative exponent; [ROOT-8331] - Error in the member function Multiply(const Double_t *vin, Double_t* vout, Double_t w) in TEveTrans of Eve package; [ROOT-8489] - Toy generation using RooCBShape with conditional PDF; [ROOT-8497] - Wrong likelihood is computed for RooProdPdf containing a RooFFTConvPdf; [ROOT-8535] - Non unique UUID; [ROOT-8885] - Cannot create a branch of long, unsigned long, std::size_t types; [ROOT-9062] - $HOME is not automatically extended in TCling; [ROOT-9240] - Compiled program with libNew.so crash; [ROOT-9324] - [cling] segfault when calling cout both from jitted and compiled code; [ROOT-9483] - TMVAGui::mvaeffs crashes when compiled stand-alone; [ROOT-9497] - TCling::Calc() must not abort; [ROOT-9563] - [TreeProcMT] Trees in subdirectories are not supported (and their usage lead to a crash); [ROOT-9583] - TF1::Random; [ROOT-9674] - [DF] Wrong branch type inference in some cases; [ROOT-9731] - [DF] Cannot read columns holding TVector3 pointers; [ROOT-9975] - [DF] Cannot access certain sub-branches; [ROOT-9977] - [DF] SaveGraph produces an empty graph; [ROOT-10023] - [TTreeReader] Unable to read TBranchObject; [ROOT-10152] - [DF] Cannot analyze friend trees in subdirectories with MT; [ROOT-10215] - RDataFrame can’t Snapshot an std::array; [ROOT-10464] - TBB Deprecation Warning; [ROOT-10468] - Crash when users rootlogon contains std::cout in embedded python; [ROOT-10499] - TROOT::ProcessLine(""cout ..."") crashes when called from compiled code; [ROOT-10623] - Functions TF2::Moment2, TF2::CentralMoment2, and similar for TF3 work only for Formula based object; [ROOT-10639] - [DF] Handle errors in opening Snapshot output files; [ROOT-10663] - ROOT dictionary for ATLAS persistent class can’t load correctly; [ROOT-10692] - CMake should use system default C++ standard; [ROOT-10702] - [TTree] Wrong data could be silently written if data-member of object has same name as another branch; [ROOT-10703] - TCling fails to catch compiled exc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:32626,abort,abort,32626,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['abort'],['abort']
Safety," for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 79}; 80 ; 81 ; 82////////////////////////////////////////////////////////////////////////////////; 83/// Constructor for fix bin size 3-D histograms.; 84/// Creates the main histogram structure.; 85///; 86/// \param[in] name name of histogram (avoid blanks); 87/// \param[in] title histogram title.; 88/// If title is of the form `stringt;stringx;stringy;stringz`,; 89/// the histogram title is set to `stringt`,; 90/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 91/// \param[in] nbinsx number of bins along the X axis; 92/// \param[in] xlow low edge of the X axis first bin; 93/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 94/// \param[in] nbinsy number of bins along the Y axis; 95/// \param[in] ylow low edge of the Y axis first bin; 96/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 97/// \param[in] nbinsz number of bins along the Z axis; 98/// \param[in] zlow low edge of the Z axis first bin; 99/// \param[in] zup upper edge of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:3892,avoid,avoid,3892,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety," force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLocal.html:11648,abort,abort,11648,root/html534/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLocal.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8C.html:6219,safe,safe,6219,doc/master/rf201__composite_8C.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html,1,['safe'],['safe']
Safety," from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddHitB ; (; ). Add a new hit to the list of hits in detector B. ; Definition at line 134 of file JetEvent.cxx. ◆ AddJet(). Jet * JetEvent::AddJet ; (; ). Add a new Jet to the list of tracks for this event. ; Definition at line 102 of file JetEvent.cxx. ◆ AddTrack(). Track * JetEvent::AddTrack ; (; ). Add a new track to the list of tracks for this event. ; Definition at line 113 of file JetEvent.cxx. ◆ Build(). void JetEvent::Build ; (; Int_t ; jetm = 3, . Int_t ; trackm = 10, . Int_t ; hitam = 100, . Int_t ; hitbm = 10 . ). Build one event. ; Definition at line 46 of file JetEvent.cxx. ◆ Clear(). void JetEvent::Clear ; (; Option_t * ; option = """"). overridevirtual . Reimplemented from TObject.; Definition at line 143 of file JetEvent.cxx. ◆ GetJets(). TClonesArray * JetEvent::GetJets ; (; ); const. inline . Definition at line 96 of file JetEvent.h. ◆ GetNhitA(). Int_t JetEvent::GetNhit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classJetEvent.html:11367,detect,detector,11367,doc/master/classJetEvent.html,https://root.cern,https://root.cern/doc/master/classJetEvent.html,1,['detect'],['detector']
Safety," from the TH1 object passed as argument; 203 ; 204TGraphErrors::TGraphErrors(const TH1 *h); 205 : TGraph(h); 206{; 207 if (!CtorAllocate()) return;; 208 ; 209 for (Int_t i = 0; i < fNpoints; i++) {; 210 fEX[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 211 fEY[i] = h->GetBinError(i + 1);; 212 }; 213}; 214 ; 215 ; 216////////////////////////////////////////////////////////////////////////////////; 217/// GraphErrors constructor reading input from `filename`.; 218///; 219/// `filename` is assumed to contain at least 2 columns of numbers; 220///; 221/// Convention for format (default=`""%lg %lg %lg %lg""`); 222///; 223/// - format = `%lg %lg` read only 2 first columns into X,Y; 224/// - format = `%lg %lg %lg` read only 3 first columns into X,Y and EY; 225/// - format = `%lg %lg %lg %lg` read only 4 first columns into X,Y,EX,EY.; 226///; 227/// For files separated by a specific delimiter different from ' ' and `\\t` (e.g. `;` in csv files); 228/// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `option` argument,; 229/// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters (`' ', '\\t', ',', ';'`); 230/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 231///; 232/// Note in that case, the instantiation is about 2 times slower.; 233/// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.; 234 ; 235TGraphErrors::TGraphErrors(const char *filename, const char *format, Option_t *option); 236 : TGraph(100); 237{; 238 if (!CtorAllocate()) return;; 239 Double_t x, y, ex, ey;; 240 TString fname = filename;; 241 gSystem->ExpandPathName(fname);; 242 std::ifstream infile(fname.Data());; 243 if (!infile.good()) {; 244 MakeZombie();; 245 Error(""TGraphErrors"", ""Cannot open file: %s, TGraphErrors is Zombie"", filename);; 246 fNpoints = 0;; 247 return;; 248 }; 249 std::string line;; 250 Int_t np = 0;; 251 ; 252 if (strcmp(option, """") == 0) { // No delimiters specified (standard construc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:7502,avoid,avoid,7502,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['avoid'],['avoid']
Safety," full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for ROOT::RBrowserTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RBrowserTimer(). ROOT::RBrowserTimer::RBrowserTimer ; (; Long_t ; milliSec, . Bool_t ; mode, . RBrowser & ; br . ). inline . !< browser processing postponed requests ; constructor ; Definition at line 52 of file RBrowser.cxx. Member Function Documentation. ◆ Timeout(). void ROOT::RBrowserTimer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process postponed requests in main ROOT thread ; Reimplemented from TTimer.; Definition at line 56 of file RBrowser.cxx. Member Data Documentation. ◆ fBrowser. RBrowser& ROOT::RBrowserTimer::fBrowser. Definition at line 49 of file RBrowser.cxx. gui/browserv7/src/RBrowser.cxx. ROOTRBrowserTimer. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html:17684,timeout,timeout,17684,doc/v632/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html,1,['timeout'],['timeout']
Safety," function stores the name into a static array. ;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerLoop.html:3401,detect,detected,3401,doc/master/classTStreamerLoop.html,https://root.cern,https://root.cern/doc/master/classTStreamerLoop.html,1,['detect'],['detected']
Safety," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35464,recover,recovered,35464,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety," geometry (here ALICE). ;  ; file  geomAlice_itsv.C;  Script drawing a detector geometry (here ITSV from Alice). ;  ; file  geomAtlas.C;  Script drawing a detector geometry (here ATLAS). ;  ; file  geomBrahms.C;  Script drawing a detector geometry (here BRAHMS). ;  ; file  geomD0.C;  Script drawing a detector geometry (here D0). ;  ; file  geometry.C;  Example of the old geometry package (now obsolete) ;  ; file  lego.C;  Drawing a figure, made of lego block, using ROOT geometry class. ;  ; file  mp3player.C;  Drawing a mp3 type music player, using ROOT geometry class. ;  ; file  na49.C;  This file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package. ;  ; file  robot.C;  Drawing a famous Korean robot, TaekwonV, using ROOT geometry class. ;  ; file  rootgeom.C;  Definition of a simple geometry (the 4 ROOT characters) ;  ; file  runplugin.C;  Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ;  ; file  shapes.C;  The old geometry shapes (see script geodemo.C) ;  ; file  shapesAnim.C;  Macro illustrating how to animate a geometry picture using a Timer. ;  ; file  south_gate.C;  Drawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class. ;  ; file  station1.C;  Drawing a space sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:1624,detect,detector,1624,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,1,['detect'],['detector']
Safety," gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16770,risk,risk,16770,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety," h3.SetMaximum(1.35); # Set up plot for markers and errors; h3.Sumw2(); h3.SetStats(0); h3.Divide(h2); ; # Adjust y-axis settings; y = h3.GetYaxis(); y.SetTitle(""ratio h1/h2 ""); y.SetNdivisions(505); y.SetTitleSize(20); y.SetTitleFont(43); y.SetTitleOffset(1.55); y.SetLabelFont(43); y.SetLabelSize(15); ; # Adjust x-axis settings; x = h3.GetXaxis(); x.SetTitleSize(20); x.SetTitleFont(43); x.SetTitleOffset(4.0); x.SetLabelFont(43); x.SetLabelSize(15); ; return h3; ; ; def createCanvasPads():; c = TCanvas(""c"", ""canvas"", 800, 800); # Upper histogram plot is pad1; pad1 = TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0); pad1.SetBottomMargin(0) # joins upper and lower plot; pad1.SetGridx(); pad1.Draw(); # Lower ratio plot is pad2; c.cd() # returns to main canvas before defining pad2; pad2 = TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3); pad2.SetTopMargin(0) # joins upper and lower plot; pad2.SetBottomMargin(0.2); pad2.SetGridx(); pad2.Draw(); ; return c, pad1, pad2; ; ; def ratioplot():; # create required parts; h1 = createH1(); h2 = createH2(); h3 = createRatio(h1, h2); c, pad1, pad2 = createCanvasPads(); ; # draw everything; pad1.cd(); h1.Draw(); h2.Draw(""same""); # to avoid clipping the bottom zero, redraw a small axis; h1.GetYaxis().SetLabelSize(0.0); axis = TGaxis(-5, 20, -5, 220, 20, 220, 510, """"); axis.SetLabelFont(43); axis.SetLabelSize(15); axis.Draw(); pad2.cd(); h3.Draw(""ep""); ; # To hold window open when running from command line; # text = raw_input(); ; ; if __name__ == ""__main__"":; ratioplot(); TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; ratioplotDefinition ratioplot.py:1; AuthorMichael Moran ; Definition in file ratioplot.py. tutorialspyrootratioplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot_8py.html:2237,avoid,avoid,2237,doc/master/ratioplot_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot_8py.html,1,['avoid'],['avoid']
Safety," handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method abo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922760,safe,safe,922760,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety," has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:11622,recover,recovers,11622,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['recover'],['recovers']
Safety," histogram with options.Definition TH1.cxx:3066; The ""SQL I/O"" package is currently under development. Any bug reports and suggestions are welcome. Author: S.Linev, GSI Darmstadt, S.Lin.nosp@m.ev@g.nosp@m.si.de ; Definition at line 30 of file TSQLFile.h. Public Types; enum  EIndexesKinds { kIndexesNone = 0; , kIndexesBasic = 1; , kIndexesClass = 2; , kIndexesAll = 3; };  ; enum  ETransactionKinds { kTransactionsOff = 0; , kTransactionsAuto = 1; , kTransactionsUser = 2; };  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:8687,timeout,timeout,8687,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['timeout'],['timeout']
Safety," how to make a branch with a variable length array; how to read selective branches; how to fill a histogram from a branch; how to use TTree::Draw to show a 3D plot. A C structure (struct) is used to build a ROOT tree. In general we discourage the use of C structures, we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example struct holds simple variables and arrays. It maps to a Geant3 common block /gctrak/.This is the definition of the common block/structure:; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; When using Geant3, the common block is filled by Geant3 routines at each step and only the TTree::Fill method needs to be called. In this example we emulate the Geant3 step routine with the helixStep function. We also emulate the filling of the particle values. The calls to the Branch methods are the same as if Geant3 were used.; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:561200,safe,safety,561200,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHalfSpace.html:12007,safe,safe,12007,root/html528/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html528/TGeoHalfSpace.html,3,['safe'],['safe']
Safety," if (rc < 0); 1463 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmin, xmax);; 1464 } else {; 1465 fBuffer = nullptr;; 1466 Int_t keep = fBufferSize; fBufferSize = 0;; 1467 if (xmin < fXaxis.GetXmin()) ExtendAxis(xmin, &fXaxis);; 1468 if (xmax >= fXaxis.GetXmax()) ExtendAxis(xmax, &fXaxis);; 1469 fBuffer = buffer;; 1470 fBufferSize = keep;; 1471 }; 1472 }; 1473 ; 1474 // call DoFillN which will not put entries in the buffer as FillN does; 1475 // set fBuffer to zero to avoid re-emptying the buffer from functions called; 1476 // by DoFillN (e.g Sumw2); 1477 buffer = fBuffer; fBuffer = nullptr;; 1478 DoFillN(nbentries,&buffer[2],&buffer[1],2);; 1479 fBuffer = buffer;; 1480 ; 1481 // if action == 1 - delete the buffer; 1482 if (action > 0) {; 1483 delete [] fBuffer;; 1484 fBuffer = nullptr;; 1485 fBufferSize = 0;; 1486 } else {; 1487 // if number of entries is consistent with buffer - set it negative to avoid; 1488 // refilling the histogram every time BufferEmpty(0) is called; 1489 // In case it is not consistent, by setting fBuffer[0]=0 is like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:58203,avoid,avoid,58203,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety," if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:15884,safe,safe,15884,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety," in debug mode or optimized. ; The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library . Definition at line 4077 of file TSystem.cxx. ◆ SetBuildDir(). void TSystem::SetBuildDir ; (; const char * ; build_dir, . Bool_t ; isflat = kFALSE . ). virtual . Set the location where ACLiC will create libraries and use as a scratch area. ; If unset, libraries will be created at the same location than the script.; Parameters. build_dirthe name of the build directory ; isflatIf false (default), then the libraries are actually stored in sub-directories of 'build_dir' including the full pathname of the script. If the script is located at /full/path/name/macro.C the library will be located at build_dir+/full/path/name/macro_C.so If 'isflat' is true, then no subdirectory is created and the library is created directly in the directory 'build_dir'. Note that in this mode there is a risk than 2 script of the same in different source directory will over-write each other. . NoteThis build_dir can also be controlled via ACLiC.BuildDir in your .rootrc. ; Definition at line 4043 of file TSystem.cxx. ◆ SetDisplay(). void TSystem::SetDisplay ; (; ). virtual . Set DISPLAY environment variable based on utmp entry. Only for UNIX. ; Reimplemented in TUnixSystem.; Definition at line 235 of file TSystem.cxx. ◆ SetDynamicPath(). void TSystem::SetDynamicPath ; (; const char * ; pathname). virtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1806 of file TSystem.cxx. ◆ Setenv(). void TSystem::Setenv ; (; const char * ; name, . const char * ; value . ). virtual . Set environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:83688,risk,risk,83688,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['risk'],['risk']
Safety," incremental changes to a RNTupleModel More...;  ; class  RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  RNTupleWriteOptionsManip;  ; class  ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  RPageRef;  Reference to a page stored in the page pool. More...;  ; class  RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  RPageStorage;  Common functionality of an ntuple storage for both reading and writing. More...;  ; class  RProjectedFields; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:8165,safe,safe,8165,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['safe'],['safe']
Safety," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:128554,recover,recover,128554,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,1,['recover'],['recover']
Safety," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:122953,recover,recover,122953,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['recover'],['recover']
Safety," int flag) overrideTUnixSystemvirtual; RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideTUnixSystemvirtual; RemoveFileHandler(TFileHandler *fh) overrideTUnixSystemvirtual; RemoveOnExit(TObject *obj)TSystem; RemoveSignalHandler(TSignalHandler *sh) overrideTUnixSystemvirtual; RemoveStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; RemoveTimer(TTimer *ti) overrideTUnixSystemvirtual; Rename(const char *from, const char *to) overrideTUnixSystemvirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno()TSystemstatic; ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideTUnixSystemvirtual; ResetSignals() overrideTUnixSystemvirtual; ResetTimer(TTimer *ti) overrideTUnixSystemvirtual; Run()TSystemvirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; Select(TList *active, Long_t timeout) overrideTUnixSystemvirtual; Select(TFileHandler *fh, Long_t timeout) overrideTUnixSystemvirtual; SendBuf(int sock, const void *buffer, int length) overrideTUnixSystemvirtual; SendRaw(int sock, const void *buffer, int length, int flag) overrideTUnixSystemvirtual; SetAclicMode(EAclicMode mode)TSystemvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)TSystemvirtual; SetDisplay() overrideTUnixSystemvirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetDynamicPath(const char *lib) overrideTUnixSystemvirtual; Setenv(const char *name, const char *value) overrideTUnixSystemvirtual; SetErrorStr(const char *errstr)TSystem; SetFlagsDebug(const char *)TSystemvirtual; SetFlagsOpt(const char *)TSystemvirtual; SetFPEMask(Int_t mask=kDefaultMask) overrideTUnixSystemvirtual; SetIncludePath(const char *includePath)TSystemvirtual; SetLinkdefSuffix(const char *suffix)TSystemvirtual; SetLinkedLibs(const char *linkedLibs)TSystemvirtual; SetMakeE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem-members.html:15011,timeout,timeout,15011,doc/master/classTUnixSystem-members.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem-members.html,1,['timeout'],['timeout']
Safety," int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheSystem.html:11496,timeout,timeout,11496,root/html530/TDCacheSystem.html,https://root.cern,https://root.cern/root/html530/TDCacheSystem.html,10,['timeout'],['timeout']
Safety," integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:143571,safe,safe,143571,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,2,['safe'],['safe']
Safety," internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(whic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1109760,timeout,timeouts,1109760,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['timeout'],['timeouts']
Safety," interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:82597,avoid,avoid,82597,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety," intersection of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this intersection. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode;  TGeoBoolNode ();  Default constructor. ;  ;  TGeoBoolNode (const char *expr1, const char *expr2);  Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches. ;  ;  TGeoBoolNode (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr);  Constructor providing left and right shapes and matrices (in the Boolean operation). ;  ;  ~TGeoBoolNode () override;  Destructor. ;  ; void ClearThreadData () const;  ; void CreateThreadData (Int_t nthreads);  Create thread data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:2156,safe,safety,2156,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safety']
Safety," into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:14391,safe,safe,14391,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,6,['safe'],['safe']
Safety," is exactly the same scripts used by the continuous integration system (Jenkins).; For slc and centos systems using the gcc compiler; The instructions are a single line to source an existing script in AFS/CVMFS. In the following example OS is 'slc6', the compiler is 'gcc49', and build type is 'release'.; # on AFS:; source /afs/cern.ch/sw/lcg/app/releases/ROOT-externals/ROOT-latest/x86_64-slc6-gcc49-opt/setup.sh ; # on CVMFS; source /cvmfs/sft.cern.ch/lcg/views/ROOT-latest/x86_64-slc6-gcc49-opt/setup.csh. For all the other compilers (icc, clang,...) and systems; In this case we can use the script that is used by jenkins. The script expects 4 arguments:. LABEL is system OS and version. E.g. 'slc6', 'centos7', 'fedora14', 'mac1012', etc.; COMPILER is the compiler and version. E.g. 'icc16', 'clang37', 'native' (for the native compiler), etc.; BUILDTYPE is the type of the build. E.g. Release, Debug; EXTERNALS is the label for the set of versions of the externals. Typically 'ROOT-date', but 'ROOT-latest' is a safe bet. . git clone http://root.cern.ch/git/rootspi.git ; source rootspi/jenkins/jk-setup.sh slc6 icc14 Release ROOT-latest. Debugging an existing nightly build; Often when a build has failed in the nightlies we are required to debug it. The following are the instructions to get the correct environment for starting the debug session. As input you need to know the node name and the working directory in the build node (and the password of the sftnight account). You can get this information from the logs in Jenkins or CDash.; $ ssh sftnight@<node-name>; $ cd <work-directory>; $ source setup.sh; $ cd build; $ ctest -V -R <failing test>; or; $ make <failing target>. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-setup-root-externals-afscvmfs.html:3117,safe,safe,3117,d/how-setup-root-externals-afscvmfs.html,https://root.cern,https://root.cern/d/how-setup-root-externals-afscvmfs.html,1,['safe'],['safe']
Safety," is given – this number should be at least 2; Xvtx: array [nxy] of X coordinates of vertices; Yvtx: array [nxy] of Y coordinates of vertices; z: array [nz] of z plane positions; scale: array [nz] of scale factors; x0: array [nz] of x offsets; y0: array [nz] of y offsets. All XTRU shapes are correctly rendered in wire mode but can encounter difficulty when rendered as a solid with hidden surfaces. These exceptions occur if the outline shape is not a convex polygon. Both the X3D and OpenGL renderers expect polygons to be convex. The OpenGL spec specifies that points defining a polygon using the GL_POLYGON primitive may be rendered as the convex hull of that set.; Solid rendering under X3D can also give unexpected artifacts if the combination of x-y-z offsets and scales for the segments are chosen in such a manner that they represent a concave shape when sliced along a plane parallel to the z axis.; Choosing sets of point that represent a malformed polygon is not supported, but testing for such a condition is not implemented and thus it is left to the user to avoid this mistake. Definition at line 22 of file TXTRU.h. Public Member Functions;  TXTRU ();  TXTRU shape - default constructor. ;  ;  TXTRU (const char *name, const char *title, const char *material, Int_t nyx, Int_t nz);  TXTRU shape - normal constructor. ;  ;  TXTRU (const TXTRU &xtru);  TXTRU copy constructor. ;  ;  ~TXTRU () override;  TXTRU destructor deallocates arrays. ;  ; void Copy (TObject &xtru) const override;  TXTRU Copy method. ;  ; virtual void DefineSection (Int_t secNum, Float_t z, Float_t scale=1., Float_t x0=0., Float_t y0=0.);  Set z section iz information expand size of array if necessary. ;  ; virtual void DefineVertex (Int_t pointNum, Float_t x, Float_t y);  Set vertex point ipt to (x,y) expand size of array if necessary. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute the distance from point px,py to a TXTRU by calculating the closest approach to each corner. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:2110,avoid,avoid,2110,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,1,['avoid'],['avoid']
Safety," is now using a new just-in-time compilation engine called OrcJIT, a development based on MCJIT. It enables interpretation of inline assembly and exceptions; it will hopefully in the near future also support interpreting thread local storage (but doesn’t at the moment).; Thanks to the new JIT, cling also comes with debug symbols for interpreted code; you can enable them with “.debug”.; Function evaluation; Function calls through TMethodCall etc have been accelerated.; llvm / clang; llvm / clang were updated to r227800. This includes everything from the clang 3.6 release.; Dictionary Generation; Detect usage of #pragma once for inlined headers.; Turn on verbosity of genreflex if the VERBOSE environment variable is defined.; Optimise forward declarations in rootmap files in order to make their interpretation faster.; Propagate attributes specified in xml selection files to selected classes even when selected through typedefs.; Optimise selection procedure caching selected declarations in the selection rules, therewith avoiding to query the AST twice.; Include in the PCH all the STL and C headers to guarantee portability of binaries from SLC6 to CC7.; I/O Libraries; I/O New functionalities. Support for forward_list and I/O of unordered stl containers.; Support for std::complex. I/O Behavior change. The I/O now properly skip the content of base class onfile that have been removed from the in-memory class layout.; The scheduling the I/O customization rules within a StreamerInfo is now as soon as possible, i.e. after all sources have been read. One significant consequence is that now when an object is stored in a split branch the rule is associtated with the branch of the last of the rule’s sources rather than the last of the object’s data member.; Properly support TStreamerInfo written by ROOT v4.00.; Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile bei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:7701,avoid,avoiding,7701,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoiding']
Safety," kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualProofPlayer.html:13077,abort,abort,13077,root/html534/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html534/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:7729,safe,safe,7729,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,4,['safe'],['safe']
Safety," kDescending; ETupleOrdering::kUnexpected@ kUnexpected; TCling__LibraryLoadingFailedbool TCling__LibraryLoadingFailed(const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved)Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by er...Definition TCling.cxx:351; gIgnoredPCMNamesstatic const std::unordered_set< std::string > gIgnoredPCMNamesList of dicts that have the PCM information already in the PCH.Definition TCling.cxx:1939; s_IsLibraryLoadedstatic Bool_t s_IsLibraryLoaded(const char *libname, cling::Interpreter *fInterpreter)Definition TCling.cxx:3129; TCling__GetClassSharedLibsconst char * TCling__GetClassSharedLibs(const char *className, bool skipCore)Definition TCling.cxx:633; loadGlobalModuleIndexstatic GlobalModuleIndex * loadGlobalModuleIndex(cling::Interpreter &interp)Definition TCling.cxx:1080; TClingLookupHelper__ExistingTypeCheckbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname, std::string &result)Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing.Definition TCling.cxx:903; HasASTFileOnDiskstatic bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName=nullptr)Checks if there is an ASTFile on disk for the given module M.Definition TCling.cxx:1065; TCling__UnlockCompilationDuringUserCodeExecutionvoid TCling__UnlockCompilationDuringUserCodeExecution(void *)Unlock the interpreter.Definition TCling.cxx:379; AlternateTuplestatic std::string AlternateTuple(const char *classname, const cling::LookupHelper &lh, Bool_t silent)Definition TCling.cxx:3947; R__InitStreamerInfoFactorystatic bool R__InitStreamerInfoFactory()Helper to initialize TVirtualStreamerInfo's factor early.Definition TCling.cxx:1664; TCling__AutoParseCallbackint TCling__AutoParseCallback(const char *className)Definition TCling.cxx:628; TCling__DEBUG__DCtoRecordDeclclang::RecordDecl * TCling__DEBUG__DCtoRecordDecl(cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:378938,avoid,avoid,378938,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety," kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooListProxy.html:10731,safe,safeDeleteList,10731,root/html534/RooListProxy.html,https://root.cern,https://root.cern/root/html534/RooListProxy.html,1,['safe'],['safeDeleteList']
Safety," kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooListProxy.html:10714,safe,safeDeleteList,10714,root/html602/RooListProxy.html,https://root.cern,https://root.cern/root/html602/RooListProxy.html,2,['safe'],['safeDeleteList']
Safety," kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoTube;  TGeoTube (const TGeoTube &)=delete;  ; TGeoTube & operator= (const TGeoTube &)=delete;  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoHype.h>. Inheritance diagram for TGeoHype:. This browser is not able to show SVG: try Firefox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:25629,detect,detection,25629,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['detect'],['detection']
Safety," kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoTube;  TGeoTube (const TGeoTube &)=delete;  ; TGeoTube & operator= (const TGeoTube &)=delete;  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoTube; Double_t fDz;  ; Double_t fRmax;  ; Double_t fRmin;  ;  Prot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:24330,detect,detection,24330,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['detect'],['detection']
Safety," kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TChain; void InvalidateCurrentTree ();  Set the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:51502,detect,detection,51502,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['detect'],['detection']
Safety," kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:11524,timeout,timeout,11524,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,8,['timeout'],['timeout']
Safety," kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Long64_t ); This method is called before processing entry. It is the u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9552,abort,abort,9552,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,1,['abort'],['abort']
Safety," len, struct mg_response_info *ri);  ; static int parse_match_net (const struct vec *vec, const union usa *sa, int no_strict);  ; static int parse_port_string (const struct vec *vec, struct socket *so, int *ip_version);  ; static int parse_range_header (const char *header, int64_t *a, int64_t *b);  ; static int prepare_cgi_environment (struct mg_connection *conn, const char *prog, struct cgi_environment *env, unsigned char cgi_config_idx);  ; static int print_dav_dir_entry (struct de *de, void *data);  ; static int print_dir_entry (struct de *de);  ; static int print_props (struct mg_connection *conn, const char *uri, const char *name, struct mg_file_stat *filep);  ; static void process_new_connection (struct mg_connection *conn);  ; static void produce_socket (struct mg_context *ctx, const struct socket *sp);  ; static int pull_all (FILE *fp, struct mg_connection *conn, char *buf, int len);  ; static int pull_inner (FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout);  ; static int push_all (struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len);  ; static int push_inner (struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout);  ; static int put_dir (struct mg_connection *conn, const char *path);  ; static void put_file (struct mg_connection *conn, const char *path);  ; static int read_auth_file (struct mg_file *filep, struct read_auth_file_struct *workdata, int depth);  ; static int read_message (FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread);  ; static void redirect_to_https_port (struct mg_connection *conn, int port);  ; static int refresh_trust (struct mg_connection *conn);  ; static void release_handler_ref (struct mg_connection *conn, struct mg_handler_info *handler_info);  ; static void remove_bad_file (const struct mg_connection *conn, const char *path);  ; static int remove_directory (struct mg_connection *conn, const char *dir);  ; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:27074,timeout,timeout,27074,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety," line 6880 of file TProofServ.cxx. ◆ CreateServer(). Int_t TProofServ::CreateServer ; (; ). virtual . Finalize the server setup. ; If master, create the TProof instance to talk to the worker or submaster nodes. Return 0 on success, -1 on error ; Reimplemented in TProofServLite.; Definition at line 790 of file TProofServ.cxx. ◆ DeclFileName(). static const char * TProofServ::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 344 of file TProofServ.h. ◆ DeletePlayer(). void TProofServ::DeletePlayer ; (; ). protectedvirtual . Delete player instance. ; Definition at line 5907 of file TProofServ.cxx. ◆ DisableTimeout(). virtual void TProofServ::DisableTimeout ; (; ). inlinevirtual . Definition at line 316 of file TProofServ.h. ◆ EnableTimeout(). virtual void TProofServ::EnableTimeout ; (; ). inlinevirtual . Definition at line 317 of file TProofServ.h. ◆ ErrorHandler(). void TProofServ::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). static . The PROOF error handler function. ; It prints the message on fgErrorHandlerFile and if abort is set it aborts the application. ; Definition at line 5755 of file TProofServ.cxx. ◆ FilterLocalroot(). void TProofServ::FilterLocalroot ; (; TString & ; path, . const char * ; dsrv = ""root://dum/"" . ). static . If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings, if any. ; The final path via the server is dsrv+path. ; Definition at line 6966 of file TProofServ.cxx. ◆ FlushLogFile(). void TProofServ::FlushLogFile ; (; ). Reposition the read pointer in the log file to the very end. ; This allows to ""hide"" useful debug messages during normal operations while preserving the possibility to have them in case of problems. ; Definition at line 6013 of file TProofServ.cxx. ◆ Fork(). Int_t TProofServ::Fork ; (; ). protectedvirtual . Fork a child. ; If successful, return 0 in the child process and the child pid in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:35420,abort,abort,35420,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['abort'],['abort']
Safety," line 975 of file TSocket.cxx. ◆ RecvRaw(). Int_t TSocket::RecvRaw ; (; void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Receive a raw buffer of specified length bytes. ; Using option kPeek one can peek at incoming data. Returns number of received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34261,timeout,timeout,34261,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['timeout'],['timeout']
Safety," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34514,recover,recover,34514,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recover']
Safety," master. Reference Guide ; .  . Loading...; Searching...; No Matches. SparseData.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:1070,avoid,avoid,1070,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['avoid'],['avoid']
Safety," means left-handed helix. ; Definition at line 195 of file TGeoHelix.cxx. ◆ SetField(). void TGeoHelix::SetField ; (; Double_t ; bx, . Double_t ; by, . Double_t ; bz, . Bool_t ; is_normalized = kTRUE . ). Initialize particle direction (tangent on the helix in initial point) ; Definition at line 211 of file TGeoHelix.cxx. ◆ SetHelixStep(). void TGeoHelix::SetHelixStep ; (; Double_t ; hstep). Set Z step of the helix on a complete turn. Positive or null. ; Definition at line 227 of file TGeoHelix.cxx. ◆ SetXYcurvature(). void TGeoHelix::SetXYcurvature ; (; Double_t ; curvature). Set XY curvature: c = 1/Rxy. ; Definition at line 178 of file TGeoHelix.cxx. ◆ Step(). void TGeoHelix::Step ; (; Double_t ; step). Make a step from current point along the helix and compute new point, direction and angle To reach a plane/ shape boundary, one has to: . Compute the safety to the plane/boundary; Define / update a helix according local field and particle state (position, direction, charge); Compute the magnetic safety (maximum distance for which the field can be considered constant); Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; Repeat from 1. until the step to be made is small enough.; Add to the total step the distance along a straight line from the last point to the plane/shape boundary . Definition at line 260 of file TGeoHelix.cxx. ◆ StepToPlane(). Double_t TGeoHelix::StepToPlane ; (; Double_t * ; point, . Double_t * ; norm . ). Propagate initial point up to a given Z position in MARS. ; Definition at line 293 of file TGeoHelix.cxx. ◆ Streamer(). void TGeoHelix::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoHelix::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TGeoHelix.h. ◆ UpdateHelix(). void TGeoHelix::UpdateHelix ; (; ). Update the local helix matrix. ; Definition at line 352 of file TGeoHeli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:18358,safe,safety,18358,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,2,['safe'],['safety']
Safety," members ; TRobustEstimator Class ReferenceMath » Legacy Physics Classes. ; NoteDespite being in the group of Legacy statistics classes, TRobustEstimator is still useful and no drop-in replacement exists for it.; Minimum Covariance Determinant Estimator - a Fast Algorithm invented by Peter J.Rousseeuw and Katrien Van Dreissen ""A Fast Algorithm for the Minimum covariance Determinant Estimator"" Technometrics, August 1999, Vol.41, NO.3; What are robust estimators? ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recognise them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected."" R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz ""Data Analysis Techniques for High-Energy Physics"", 2nd edition; What does this algorithm do? It computes a highly robust estimator of multivariate location and scatter. Then, it takes those estimates to compute robust distances of all the data vectors. Those with large robust distances are considered outliers. Robust distances can then be plotted for better visualization of the data.; How does this algorithm do it? The MCD objective is to find h observations(out of n) whose classical covariance matrix has the lowest determinant. The MCD estimator of location is then the average of those h points and the MCD estimate of scatter is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2 so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers. The algorithm also allows for exact fit situations - that is, when h or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:1314,detect,detected,1314,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['detect'],['detected']
Safety," method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSlave.html:11254,recover,recovered,11254,root/html604/TXSlave.html,https://root.cern,https://root.cern/root/html604/TXSlave.html,1,['recover'],['recovered']
Safety," method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSlave.html:11254,recover,recovered,11254,root/html602/TXSlave.html,https://root.cern,https://root.cern/root/html602/TXSlave.html,1,['recover'],['recovered']
Safety," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RRangeCast_8hxx_source.html:2763,avoid,avoid,2763,doc/master/RRangeCast_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html,4,['avoid'],['avoid']
Safety," mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:22179,avoid,avoid,22179,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety," moved into Doxygen. Still some work and polish has to be done but the reference guide in this new format is now online and can be seen from the ROOT home page.; Core Libraries; Dictionary generation; Fixed the dictionary generation in the case of class inside a namespace marked inlined.; Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates.; Fix ROOT-7760 : fully allow the usage of the dylib extension on OSx.; Fix ROOT-7723 : allow IOCtors to have as argument a ref to a type called void.; We added a dictionary for map as part of the default STL dictionary.; We added support for template parameter packs in class name involved in the I/O.; Thread safety and thread awareness; We added the function TMethodCall::GetCallFunc to allow direct access to the function wrapper.; We reduced thread serialization in TClass::GetCheckSum, TClass::GetBaseClassOffset and TClass::Property; TObjArray::Delete was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock); We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:3596,avoid,avoid,3596,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['avoid'],['avoid']
Safety," namespace  TDS;  ; namespace  TreeUtils;  Namespace hosting functions and classes to retrieve tree information for internal use. ;  ; namespace  TThreadedObjectUtils;  ; namespace  VecOps;  . Classes; class  ClassDefGenerateInitInstanceLocalInjector;  ; class  DictSelectionReader;  ; struct  GetFunctorType;  Internal class used by TF1 for obtaining the type from a functor out of the set of valid operator() signatures. More...;  ; struct  GetFunctorType< T(F::*)(const T *, const double *) const >;  ; struct  GetFunctorType< T(F::*)(const T *, const double *)>;  ; struct  GetFunctorType< T(F::*)(T *, double *) const >;  ; struct  GetFunctorType< T(F::*)(T *, double *)>;  ; struct  InterpreterMutexRegistrationRAII;  ; struct  ParsingStateRAII;  RAII used to store Parser, Sema, Preprocessor state for recursive parsing. More...;  ; struct  RBaseType;  ; struct  RCast;  ; struct  RCast< T, false, false >;  ; struct  RCast< T, false, true >;  ; class  RConcurrentHashColl;  This class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. More...;  ; struct  RDavixFileDes;  ; struct  RecurseCounts;  ; struct  RHashMap;  ; class  RIoUring;  ; class  RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  RRawFileDavix;  The RRawFileDavix class provides read-only access to remote non-ROOT files. More...;  ; class  RRawFileNetXNG;  The RRawFileNetXNG class provides read-only access to remote files using root/roots protocol. More...;  ; struct  RRawFileNetXNGImpl;  ; class  RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  RSlotStack;  A thread-safe stack of N ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:1350,safe,safe,1350,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['safe'],['safe']
Safety," nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0)=0; TVirtualGeoPainter::Testvirtual void Test(Int_t npoints, Option_t *option)=0; TVirtualGeoPainter::SetVisOptionvirtual void SetVisOption(Int_t option=0)=0; TVirtualGeoPainter::GetViewBoxvirtual Double_t * GetViewBox()=0; TVirtualGeoPainter::EstimateCameraMovevirtual void EstimateCameraMove(Double_t, Double_t, Double_t *, Double_t *)Definition TVirtualGeoPainter.h:83; TVirtualGeoPainter::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)=0; TVirtualGeoPainter::SetNsegmentsvirtual void SetNsegments(Int_t nseg=20)=0; TVirtualGeoPainter::RandomRaysvirtual void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol, Bool_t check_norm)=0; TVirtualGeoPainter::RandomPointsvirtual void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""")=0; TVirtualGeoPainter::CountVisibleNodesvirtual Int_t CountVisibleNodes()=0; TVirtualGeoPainter::DefaultAnglesvirtual void DefaultAngles()=0; TVirtualGeoPainter::SetNmeshPointsvirtual void SetNmeshPoints(Int_t npoints)=0; TVirtualGeoPainter::UnbombTranslationvirtual void UnbombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::EditGeometryvirtual void EditGeometry(Option_t *option="""")=0; TVirtualGeoPainter::GetBombFactorsvirtual void GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const =0; TVirtualGeoPainter::CheckPointvirtual void CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0; TVirtualGeoPainter::BombTranslationvirtual void BombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:247962,safe,safety,247962,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safety']
Safety," norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidComputeTwist(); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:3291,safe,safe,3291,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['safe'],['safe']
Safety," not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl2)   templateClassImp(name);  ; #define ClassImp3T(name, Tmpl1, Tmpl2, Tmpl3)   templateClassImp(name);  ; #define ClassImpT(name, Tmpl)   templateClassImp(name);  ; #define ClassImpUnique(name, key);  ; #define CLRBIT(n, i)   ((n) &= ~BIT(i));  ; #define NamespaceImp(name)   NamespaceImpUnique(name,default);  ; #define NamespaceImpUnique(name, key);  Macro for Namespace. ;  ; #define R__ADD_INCLUDE_PATH(PATH);  ; #define R__ADD_LIBRARY_PATH(PATH);  ; #define R__CLING_PTRCHECK(ONOFF);  ; #define R__LOAD_LIBRARY(LIBRARY);  ; #",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h.html:1778,redund,redundant,1778,doc/master/Rtypes_8h.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html,2,['redund'],['redundant']
Safety," nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; TList*fFileNodesnodes with files; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Long64_t GetEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:10895,avoid,avoid,10895,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,1,['avoid'],['avoid']
Safety," nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoParaboloid::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToParaboloid(). Double_t TGeoParaboloid::DistToParaboloid ; (; const Double_t * ; point, . const Double_t * ; dir, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoParaboloid::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoParaboloid::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoParaboloid::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetDz(). Double_t TGeoParaboloid::GetDz ; (; ); const. inline . Definition at line 58 of file TGeoParaboloid.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoParaboloid::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetMeshNumbers(). void TGeoParaboloid::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNmeshVertices(). Int_t TGeoParaboloid::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoParaboloid::GetPointsOnSegments ; (; Int_t ; , . Double_t * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 64 of file TGeoParaboloid.h. ◆ GetRhi(). Double_t TGeoParaboloid::GetRhi ; (; ); const. inline . Definition at line 57 of file TGeoParaboloid.h. ◆ GetRlo(). Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:26503,avoid,avoid,26503,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['avoid'],['avoid']
Safety," nz); Default constructor. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone sha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:13117,safe,safe,13117,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,3,['safe'],['safe']
Safety," n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 506 of file TBufferSQL.cxx. ◆ WriteFastArray() [9/15]. void TBufferSQL::WriteFastArray ; (; const UChar_t * ; uc, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 486 of file TBufferSQL.cxx. ◆ WriteFastArray() [10/15]. void TBufferSQL::WriteFastArray ; (; const UInt_t * ; ui, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. ◆ WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:54687,abort,aborts,54687,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation ;  CFumiliStandardMaximumLikelihoodFCNClass implementing the Elements member function for the standard maximum likelihood method ;  CFunctionGradient;  CFunctionMinimizerBase class for function minimizers; user may give FCN or FCN with Gradient, Parameter starting values and initial Error guess (sigma) (or ""step size""), or Parameter starting values and initial covariance matrix; covariance matrix is stored in Upper triangular packed storage format, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:62928,predict,predicted,62928,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['predict'],['predicted']
Safety," of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nullptr;; 119 if (classname[0]) {; 120 cl = TClass::GetClass(classname);; 121 if (!cl) {; 122 Error(""TDirectoryFile"",""Invalid class name: %s"",classname);; 123 return;; 124 }; 125 } else {; 126 cl = TDirectoryFile::IsA();; 127 }; 128 ; 129 fBufferSize = 0;; 130 fWritable = kTRUE;; 131 ; 132 InitDirectoryFile(cl);; 133 ; 134 fModified = kFALSE;; 135 ; 136 // Temporarily redundant, see comment on lock early in the function.; 137 // R__LOCKGUARD(gROOTMutex);; 138 gROOT->GetUUIDs()->AddUUID(fUUID,this);; 139 // We should really be doing this now rather than in Build, see; 140 // comment at the start of the function.; 141 // if (initMotherDir && strlen(GetName()) != 0) initMotherDir->Append(this);; 142}; 143 ; 144////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:4629,redund,redundant,4629,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['redund'],['redundant']
Safety," of bytes for the object on file; Int_tfObjlenLength of uncompressed object in bytes; UShort_tfPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:9415,avoid,avoid,9415,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,2,['avoid'],['avoid']
Safety," of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). Method & operator=(const TGenCollectionProxy& ); { call = m.call; return *this; }. void Resize(size_t nelement). TGenCollectionProxy* Initialize(Bool_t silent) const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:6640,avoid,avoid,6640,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,1,['avoid'],['avoid']
Safety," of first compound parent, if kSCBTakeAnyParentAsMaster bit is set;; If non of the above is true, *this* is returned. void AddParent(TEveElement* re); Add re into the list parents.; Adding parent is subordinate to adding an element.; This is an internal function. void RemoveParent(TEveElement* re); Remove re from the list of parents.; Removing parent is subordinate to removing an element.; This is an internal function. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check external references to this and eventually auto-destruct; the render-element. void CollectSceneParents(TEveElement::List_t& scenes); Collect all parents of class TEveScene. This is needed to; automatically detect which scenes need to be updated. Overriden in TEveScene to include itself and return. void CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); Collect scene-parents from all children. This is needed to; automatically detect which scenes need to be updated during/after; a full sub-tree update.; Argument parent specifies parent in traversed hierarchy for which we can; skip the upwards search. void ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); Populates parent with elements.; parent must be an already existing representation of *this*.; Returns number of inserted elements.; If parent already has children, it does nothing. Element can be inserted in a list-tree several times, thus we can not; search through fItems to get parent here.; Anyhow, it is probably known as it must have been selected by the user. void DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); Destroy sub-tree under item 'parent' in list-tree 'ltree'. TGListTreeItem* AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); Add this element into ltree to an already existing item; parent_lti. Children, if any, are added as below the newly created item.; Returns the newly created list-tree-item. TGListTreeItem* AddIntoListT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:17964,detect,detect,17964,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,6,['detect'],['detect']
Safety," of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84834,recover,recover,84834,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recover']
Safety," of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type float and size nbinsy+1 ; [in]nbinsznumber of bins ; [in]zbinsarray of low-edges for each bin. This is an array of type float and size nbinsz+1 . Definition at line 142 of file TH3.cxx. ◆ TH3() [4/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . const Double_t * ; ybins, . Int_t ; nbinsz, . const Double_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input arrays of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type double and size nbinsy+1 ; [in]nbinsznumber of bins ; [in]zbinsarray of low-edges for each bin. This is an array of type double and size nbinsz+1 . Definition at line 179 of file TH3.cxx. ◆ TH3() [5/5]. TH3::TH3 ; (; const TH3 & ; ). privatedelete . ◆ ~TH3(). TH3::~TH3 ; (; ). override . Destructor. ; Definition at line 200 of file TH3.cxx. Member Function Documentation. ◆ AddBinContent() [1/4]. void TH3::AddBinContent ; (; Int_t ; bin). overridevirtual . Increment bin content by 1. ; Passing an out-of-range bin leads to undefined behavior ; Reimplemented from TH1.; Reimplemented in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:61540,avoid,avoid,61540,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['avoid'],['avoid']
Safety," of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855641,safe,safe,855641,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:38861,avoid,avoids,38861,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['avoid'],['avoids']
Safety," of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0); Create a PROOF player. TVirtualProofPlayer(); { ResetBit(TVirtualProofPlayer::kIsSubmerger); }. virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:13954,abort,abort,13954,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," of the OS interface. ;  ; virtual TSignalHandler * RemoveSignalHandler (TSignalHandler *sh);  Remove a signal handler from list of signal handlers. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual TTimer * RemoveTimer (TTimer *t);  Remove timer from list of system timers. ;  ; virtual int Rename (const char *from, const char *to);  Rename a file. ;  ; virtual void ResetSignal (ESignals sig, Bool_t reset=kTRUE);  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; virtual void ResetSignals ();  Reset signals handlers to previous behaviour. ;  ; virtual void ResetTimer (TTimer *);  ; virtual void Run ();  System event loop. ;  ; virtual Int_t Select (TFileHandler *fh, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual Int_t Select (TList *active, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual int SendBuf (int sock, const void *buffer, int length);  Send a buffer headed by a length indicator. ;  ; virtual int SendRaw (int sock, const void *buffer, int length, int flag);  Send exactly length bytes from buffer. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; virtual void SetDynamicPath (const char *pathname);  Set the dynamic path to a new value. ;  ; virtual void Setenv (const char *name, const char *value);  Set environment variable. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  Flags",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:15349,timeout,timeout,15349,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,6,['timeout'],['timeout']
Safety," off when fAutoFlush == 0. Release 6.24/06; Published on September 1, 2021; Bugs and Issues fixed in this release. [#8931] - TDirectory::RegisterGDirectory is MT unsafe; [#8011] - Bug in RooAbsPdf::extendedTerm when expected events is negative. Release 6.24/08; Published on September 29, 2022; Bugs and Issues fixed in this release. [ROOT-10829] - pure virtual method called error; [#8933] - CMAKE_INSTALL_PYTHONDIR on macOS creates broken symlinks; [#9017] - Access of deleted object during hadd tear down.; [#8072] - Failures with root 6.24.00 on Fedora 33 ppc64le; [#9297] - ROOT 6.24 debug build failed on ppc64le; [#9424] - ROOT 6.24 failed to build with GCC10 or 11 on ppc64le arch; [#9547] - [RF] RooFit crashes when ROOT is built with Clang 13; [#9543] - roottest-root-treeformula-stl-make crashes during process termination; [#8987] - Missing operator= in code generated by MakeProject; [#7754] - Segfault when using schema evolution; [#8428] - I/O customization rule not run on split sub-object of a non-collection object.; [#9899] - TTree incorrectly run I/O customization rules on “new” data members.; [#9939] - Hadd super slow since TFileMerger modification; [#10170] - Crashes when reading a TTree with a friend; [#8549] - A crash when opening a TTree and its friend on TFile::Close(); [#10131] - Open too many different non-versioned layouts for pair; [#10353] - Thread-safety issue in TClassEdit (StdLen)? [6.24.06]; [#7276] - [RF] ROOT 6.22/06 crashes reading old workspace file; [#10548] - Use of undeclared identifier on Mac ARM; [#10478] - runtime_cxxmodules fails to build with GCC12; [#11080] - Backport the fix on computation of the radiation and nuclear interaction lengths to v6.24; [#10645] - [TTreeReader] Cannot read Float16_t branch; [#11260] - TTreeReaderArray does not support Double32_t; [#11383] - Deadlock in ErrorHandler when invoked at library initialization time. HEAD of the v6-24-00-patches branch; These changes will be part of a future 6.24/10. None so far. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:51132,safe,safety,51132,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['safe'],['safety']
Safety," on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void ErrorHandler (Int_t level, Bool_t abort, const char *location, const char *msg);  The error handler function. ;  ;  Static Protected Member Functions inherited from TApplication; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static function used to attach to an existing remote application or to start one. ;  ; static Int_t ParseRemoteLine (const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script);  Parse the content of a line starting with "".R"" (already stripped-off) The format is. ;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:19232,abort,abort,19232,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['abort'],['abort']
Safety," open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is changed to this file. ; Reimplemented in TSQLFile, TXMLFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 2162 of file TFile.cxx. ◆ ResetErrno(). void TFile::ResetErrno ; (; ); const. virtual . Method resetting the errno. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, and TMemFile.; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:90089,recover,recovery,90089,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovery']
Safety," operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:14850,safe,safe,14850,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,3,['safe'],['safe']
Safety," operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoXtru.html:15509,safe,safe,15509,root/html528/TGeoXtru.html,https://root.cern,https://root.cern/root/html528/TGeoXtru.html,2,['safe'],['safe']
Safety," option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11621,abort,abort,11621,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety," or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TKey::EStatusBits. private . EnumeratorkIsDirectoryFile ; kReproducible . Definition at line 31 of file TKey.h. Constructor & Destructor Documentation. ◆ TKey() [1/9]. TKey::TKey ; (; const TKey & ; ). privatedelete . ◆ TKey() [2/9]. TKey::TKey ; (; ). TKey default constructor. ; Definition at line 87 of file TKey.cxx. ◆ TKey() [3/9]. TKey::TKey ; (; TDirectory * ; motherDir). TKey default constructor. ; Definition at line 99 of file TKey.cxx. ◆ TKey() [4/9]. TKey::TKey ; (; TDirectory * ; motherDir, . const TKey & ; orig, . UShort_t ; pidOffset . ). Copy a TKey from its original directory to the new 'motherDir'. ; Definition at line 111 of file TKey.cxx. ◆ TKey() [5/9]. TKey::TKey ; (; const char * ; name, . const char * ; title, . const TClass * ; cl, . Int_t ; nbytes, . TDirectory * ; motherDir . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 191 of file TKey.cxx. ◆ TKey() [6/9]. TKey::TKey ; (; const TString & ; name, . const TString & ; title, . const TClass * ; cl, . Int_t ; nbytes, . TDirectory * ; motherDir . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 207 of file TKey.cxx. ◆ TKey() [7/9]. TKey::TKey ; (; const TObject * ; obj, . const char * ; name, . Int_t ; bufsize, . TDirectory * ; motherDir . ). Create a TKey object for a TObject* and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 223 of file TKey.cxx. ◆ TKey() [8/9]. TKey::TKey ; (; const void * ; obj, . const TClass * ; cl, . const char * ; name, . Int_t ; bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:18261,avoid,avoid,18261,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['avoid'],['avoid']
Safety," or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; additi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11244,unsafe,unsafe,11244,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['unsafe'],['unsafe']
Safety," or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 3938 return UnixHomedirectory(name, path, mydir);; 3939}; 3940 ; 3941////////////////////////////////////////////////////////////////////////////; 3942/// Returns the user's home directory.; 3943 ; 3944const char *TUnixSystem::UnixHomedirectory(const char *name, char *path, char *mydir); 3945{; 3946 struct passwd *pw;; 3947 if (name) {; 3948 pw = getpwnam(name);; 3949 if (pw) {; 3950 strncpy(path, pw->pw_dir, kMAXPATHLEN-1);; 3951 path[kMAXPATHLEN-1] = '\0';; 3952 return path;; 3953 }; 3954 } else {; 3955 if (mydir[0]); 3956 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125462,timeout,timeout,125462,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety," or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D tran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:723163,avoid,avoid,723163,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," or to extend some collection kinds. Bool_t IsDrawableClass(TClass* cl); return true if object can be drawn. void ScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store, Bool_t only_fields = kFALSE); scan ROOT hierarchy with provided store object. void * FindInHierarchy(const char* path, TClass** cl = 0, TDataMember** member = 0, Int_t* chld = 0); Search element with specified path; Returns pointer on element; Optionally one could obtain element class, member description; and number of childs. When chld!=0, not only element is searched,; but also number of childs are counted. When member!=0, any object; will be scanned for its data members (disregard of extra options). TObject * FindTObjectInHierarchy(const char* path); Search element in hierarchy, derived from TObject. ULong_t GetStreamerInfoHash(); Returns hash value for streamer infos; At the moment - just number of items in streamer infos list. ULong_t GetItemHash(const char* itemname); Get hash function for specified item; used to detect any changes in the specified object. Bool_t CanDrawItem(const char* path); Method verifies if object can be drawn. Bool_t CanExploreItem(const char* path); Method returns true when object has childs or; one could try to expand item. void CreateMemFile(); Creates TMemFile instance, which used for objects streaming; One could not use TBufferFile directly,; while one also require streamer infos list. Bool_t ProduceJson(const char* path, const char* options, TString& res); produce JSON data for specified item; For object conversion TBufferJSON is used. Bool_t ExecuteCmd(const char* path, const char* options, TString& res); execute command marked as _kind=='Command'. Bool_t ProduceItem(const char* path, const char* options, TString& res, Bool_t asjson = kTRUE); produce JSON/XML for specified item; contrary to h.json request, only fields for specified item are stored. Bool_t ProduceXml(const char* path, const char* options, TString& res); produce XML data for sp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSniffer.html:14237,detect,detect,14237,root/html534/TRootSniffer.html,https://root.cern,https://root.cern/root/html534/TRootSniffer.html,2,['detect'],['detect']
Safety," origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; TGeoVolumeAssembly*fVolumeassembly volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShapeAssembly.html:11939,safe,safe,11939,root/html528/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html,3,['safe'],['safe']
Safety," other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:1451,detect,detector,1451,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['detect'],['detector']
Safety," output, . std::span< const double > ; xVals, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). private . A vectorized version of interpolateDim for boundary safe linear interpolation of one dimensional histograms. ; Parameters. [out]outputAn array of interpolated weights corresponding to the values in xVals. ; [in]xValsAn array of event coordinates for which the weights should be calculated. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: Underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1263 of file RooDataHist.cxx. ◆ interpolateQuadratic(). void RooDataHist::interpolateQuadratic ; (; double * ; output, . std::span< const double > ; xVals, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). private . A vectorized version of interpolateDim for boundary safe quadratic interpolation of one dimensional histograms. ; Parameters. [out]outputAn array of interpolated weights corresponding to the values in xVals. ; [in]xValsAn array of event coordinates for which the weights should be calculated. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: Underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1156 of file RooDataHist.cxx. ◆ IsA(). TClass * RooDataHist::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsData.; Definition at line 282 of file RooDataHist.h. ◆ isNonPoissonWeighted(). bool RooDataHist::isNonPoissonWeighted ; (; ); const. overridevirtual . Returns true if dataset contains entries with a non-integer weight. ; Reimplemented from RooAbsData.; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:64986,safe,safe,64986,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safe']
Safety," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Fri Dec 2 14:26:49 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenContext.html:10300,unsafe,unsafe,10300,root/html532/RooGenContext.html,https://root.cern,https://root.cern/root/html532/RooGenContext.html,1,['unsafe'],['unsafe']
Safety," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Mon Jul 4 15:23:00 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenContext.html:10181,unsafe,unsafe,10181,root/html530/RooGenContext.html,https://root.cern,https://root.cern/root/html530/RooGenContext.html,1,['unsafe'],['unsafe']
Safety," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Sat Sep 5 16:40:26 2015 » Last generated: 2015-09-05 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenContext.html:10322,unsafe,unsafe,10322,root/html534/RooGenContext.html,https://root.cern,https://root.cern/root/html534/RooGenContext.html,1,['unsafe'],['unsafe']
Safety," override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 165 Double_t *step) const override;; 166 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 167 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 168 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 169 Double_t *step) const override;; 170 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 171 Double_t GetTwistAngle() const { return fTwistAngle; }; 172 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 173 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 174 void SetDimensions(Double_t *param) override;; 175 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GTRA shape; 178};; 179 ; 180#endif; Int_tint Int_tDefinition RtypesCore.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:8907,safe,safe,8907,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,2,['safe'],['safe']
Safety," p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11430,recover,recover,11430,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety," p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.372361 cHl3=0.491134 cHq3=-0.886807; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=5.8312, denominator=wrap_pdf_Int[pTV]=12183.6; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:InputArguments -- RooAbsData::plotOn(pseudo_dh) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:15764,recover,recover,15764,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety," param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:4367,timeout,timeout,4367,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['timeout'],['timeout']
Safety," pass a pointer to this object to timer, see the SetObject() method.; Pass an interpreter command to timer, see SetCommand() method.; Create a TTimer, connect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at line 51 of file TTimer.h. Public Member Functions;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1840,timeout,timeout,1840,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety," path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:44212,risk,risk,44212,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['risk'],['risk']
Safety," pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKey.html:9684,avoid,avoid,9684,root/html532/TKey.html,https://root.cern,https://root.cern/root/html532/TKey.html,2,['avoid'],['avoid']
Safety," points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:2711,safe,safe,2711,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,3,['safe'],['safe']
Safety, private . ! Derivative for curvature matrix ; Definition at line 129 of file TSVDUnfold.h. ◆ fDHist. TH1D* TSVDUnfold::fDHist. private . ! Distribution of d (for checking regularization) ; Definition at line 132 of file TSVDUnfold.h. ◆ fKReg. Int_t TSVDUnfold::fKReg. private . ! Regularisation parameter ; Definition at line 131 of file TSVDUnfold.h. ◆ fMatToyMode. Bool_t TSVDUnfold::fMatToyMode. private . ! Internal switch for evaluation of statistical uncertainties from response matrix ; Definition at line 152 of file TSVDUnfold.h. ◆ fNdim. Int_t TSVDUnfold::fNdim. private . ! Truth and reconstructed dimensions ; Definition at line 128 of file TSVDUnfold.h. ◆ fNormalize. Bool_t TSVDUnfold::fNormalize. private . ! Normalize unfolded spectrum to 1 ; Definition at line 130 of file TSVDUnfold.h. ◆ fSVHist. TH1D* TSVDUnfold::fSVHist. private . ! Distribution of singular values ; Definition at line 133 of file TSVDUnfold.h. ◆ fToyhisto. TH1D* TSVDUnfold::fToyhisto. private . ! Toy MC histogram ; Definition at line 149 of file TSVDUnfold.h. ◆ fToymat. TH2D* TSVDUnfold::fToymat. private . ! Toy MC detector response matrix ; Definition at line 150 of file TSVDUnfold.h. ◆ fToyMode. Bool_t TSVDUnfold::fToyMode. private . ! Internal switch for covariance matrix propagation ; Definition at line 151 of file TSVDUnfold.h. ◆ fXini. const TH1D* TSVDUnfold::fXini. private . Truth distribution (MC) ; Definition at line 143 of file TSVDUnfold.h. ◆ fXinv. TH2D* TSVDUnfold::fXinv. private . ! Computed inverse of covariance matrix ; Definition at line 135 of file TSVDUnfold.h. ◆ fXtau. TH2D* TSVDUnfold::fXtau. private . ! Computed regularized covariance matrix ; Definition at line 134 of file TSVDUnfold.h. Libraries for TSVDUnfold:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TSVDUnfold.h; hist/hist/src/TSVDUnfold.cxx. TSVDUnfold. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:36 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:26446,detect,detector,26446,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety," private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses BVH to do so. ; Definition at line 802 of file TGeoParallelWorld.cxx. ◆ GetGeometry(). TGeoManager * TGeoParallelWorld::GetGeometry ; (; ); const. inline . Definition at line 142 of file TGeoParallelWorld.h. ◆ GetLoopSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetLoopSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses trivial algorithm to do so. ; Definition at line 740 of file TGeoParallelWorld.cxx. ◆ GetVolume(). TGeoVolume * TGeoParallelWorld::GetVolume ; (; ); const. inline . Definition at line 144 of file TGeoParallelWorld.h. ◆ InitSafetyVoxel(). void TGeoParallelWorld::InitSafetyVoxel ; (; TGeoVoxelGridIndex const & ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line 916 of file TGeoParallelWorld.cxx. ◆ IsA(). TClass * TGeoParallelWorld::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 184 of file TGeoParallelWorld.h. ◆ IsClosed(). Bool_t TGeoParallelWorld::IsClosed ; (; ); const. inline . Definition at line 143 of file TGeoParallelWorld.h. ◆ IsUsingOverlaps(). Bool_t TGeoParallelWorld::IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. ◆ operator=(). TGeoParallelWorld & TGeoParallelWorld::operator= ; (; const TGeoParallelWorld & ; ). protecteddelete . ◆ PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. ◆ PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:24236,safe,safety,24236,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety," processed ; [in]callbackA callable with signature void(unsigned int, Value_t&) where Value_t is the type of the value contained in this RResultPtr . Returnsthis RResultPtr, to allow chaining of OnPartialResultSlot with other calls; See OnPartialResult for a generic explanation of the callback mechanism. Compared to OnPartialResult, this method has two major differences:; all worker threads invoke the callback once every specified number of events. The event count is per-thread, and callback invocation might happen concurrently (i.e. the callback must be thread-safe); the callable must take an extra unsigned int parameter corresponding to a multi-thread ""processing slot"": this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the callback concurrently but always with different slot numbers.; a value of 0 for everyNEvents indicates the callback must be executed once per slot. For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; std::string progress;; std::mutex bar_mutex;; c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; std::lock_guard<std::mutex> lg(bar_mutex);; progress.push_back('#');; std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; });; std::cout << ""Analysis running..."" << std::endl;; *c; // trigger the event loop by accessing an action's result; std::cout << ""\nDone!"" << std::endl;; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70. Definition at line 364 of file RResultPtr.hxx. ◆ operator bool(). template<typename T > . ROOT::RDF::RResultPtr< T >::operator bool ; (; ); const. inlineexplicit . Definition at line 214 of file RResultPtr.hxx. ◆ operator*(). template<typename T > . T & ROOT::RDF::RResultPtr< T >::operator* ; (; ). inline . Get a pointer to the encapsulated object. ; Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:13168,safe,safe,13168,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['safe'],['safe']
Safety," progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21881,abort,aborted,21881,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,1,['abort'],['aborted']
Safety," public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringfFileNamePrefix; intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(); {}. ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html:8274,predict,predictions,8274,root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLite.html:11137,timeout,timeout,11137,root/html604/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLite.html,1,['timeout'],['timeout']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSuperMaster.html:11547,timeout,timeout,11547,root/html604/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSuperMaster.html,1,['timeout'],['timeout']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLite.html:11210,timeout,timeout,11210,root/html534/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLite.html,1,['timeout'],['timeout']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSuperMaster.html:11637,timeout,timeout,11637,root/html534/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSuperMaster.html,1,['timeout'],['timeout']
Safety," read by TObject::Streamer, the pidf is read.; At this point, robj is entered into the table of objects of the TProcessID; corresponding to pidf. WARNING1: If MyClass is the class of the referenced object, The TObject; part of MyClass must be Streamed. One should not; call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2: A TRef cannot point to another TRef. ObjectNumber. When an object is referenced (see TRef assignement operator or TRefArray::Add); a unique identifier is computed and stored in both the fUniqueID of the; referenced and referencing object. This uniqueID is computed by incrementing; by one the static global in TProcessID::fgNumber. fUniqueID is some sort of; serial object number in the current session. One can retrieve at any time; the current value of fgNumber by calling the static function TProcessID::GetObjectCount; or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example,; one processes many events in a loop, it might be necessary to reset the; ObjectNumber at the end of processing of one event. See an example; in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be; saved at the beginning of one event and reset to this original value; at the end of the event via TProcessID::SetObjectCount(saveNumber). These; actions may be stacked. Action on Demand. The normal behaviour of a TRef has been described above. In addition,; TRef supports also ""Actions on Demand"". It may happen that the object; referenced is not yet in memory, on a separate file or not yet computed.; In this case TRef is able to automatically execute an action:; - call to a compiled function (static function of member function); - call to an interpreted function; - execution of a CINT script. How to select this option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName. points to something; Whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:4166,avoid,avoid,4166,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,6,['avoid'],['avoid']
Safety," reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of the column at compile-time. In this case RDataFrame infers the type of the column from the TTree itself. This is why we never needed to specify the column types for all actions in the above snippets.; When the column type is not a common one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:63599,detect,detects,63599,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['detect'],['detects']
Safety," receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TStopTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TStopTimer(). TStopTimer::TStopTimer ; (; TProofPlayer * ; p, . Bool_t ; abort, . Int_t ; to . ). Constructor for the timer to stop/abort processing. ; The 'timeout' is in seconds. Make sure that 'to' make sense, i.e. not larger than 10 days; the minimum value is 10 ms (0 does not seem to start the timer ...). ; Definition at line 186 of file TProofPlayer.cxx. Member Function Documentation. ◆ Notify(). Bool_t TStopTimer::Notify ; (; ). overridevirtual . Handle the signal coming from the expiration of the timer associated with an abort or stop request. ; We raise an exception which will be processed in the event loop. ; Implements TSysEvtHandler.; Definition at line 205 of file TProofPlayer.cxx. Member Data Documentation. ◆ fAbort. Bool_t TStopTimer::fAbort. private . Definition at line 171 of file TProofPlayer.cxx. ◆ fPlayer. TProofPlayer* TStopTimer::fPlayer. private . Definition at line 172 of file TProofPlayer.cxx. proof/proofplayer/src/TProofPlayer.cxx. TStopTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:33 (GVA Time) using Doxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStopTimer.html:17486,abort,abort,17486,doc/master/classTStopTimer.html,https://root.cern,https://root.cern/doc/master/classTStopTimer.html,1,['abort'],['abort']
Safety," regularisation parameter ;  ; Int_t RegularizeBins (int start, int step, int nbin, ERegMode regmode);  add regularisation conditions for a group of bins ;  ; Int_t RegularizeBins2D (int start_bin, int step1, int nbin1, int step2, int nbin2, ERegMode regmode);  add regularisation conditions for 2d unfolding ;  ; Int_t RegularizeCurvature (int left_bin, int center_bin, int right_bin, Double_t scale_left=1.0, Double_t scale_right=1.0);  add a regularisation condition on the curvature of three truth bin ;  ; Int_t RegularizeDerivative (int left_bin, int right_bin, Double_t scale=1.0);  add a regularisation condition on the difference of two truth bin ;  ; Int_t RegularizeSize (int bin, Double_t scale=1.0);  add a regularisation condition on the magnitude of a truth bin ;  ; virtual Int_t ScanLcurve (Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph **lCurve, TSpline **logTauX=nullptr, TSpline **logTauY=nullptr, TSpline **logTauCurvature=nullptr);  scan the L curve, determine tau and unfold at the final value of tau ;  ; virtual Int_t ScanSURE (Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph **logTauSURE=nullptr, TGraph **df_chi2A=nullptr, TGraph **lCurve=nullptr);  minimize Stein's unbiased risk estimator ""SURE"" using successive calls to DoUnfold at various tau. ;  ; void SetBias (const TH1 *bias);  set bias vector ;  ; void SetConstraint (EConstraint constraint);  set type of area constraint ;  ; void SetEpsMatrix (Double_t eps);  set numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:22096,risk,risk,22096,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,2,['risk'],['risk']
Safety," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:20294,safe,safe,20294,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,2,['safe'],['safe']
Safety," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoCone.html:22048,safe,safe,22048,root/html604/TGeoCone.html,https://root.cern,https://root.cern/root/html604/TGeoCone.html,2,['safe'],['safe']
Safety," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCone.html:22048,safe,safe,22048,root/html602/TGeoCone.html,https://root.cern,https://root.cern/root/html602/TGeoCone.html,2,['safe'],['safe']
Safety," required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; TGeoShape::DistFromOutsid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:5572,safe,safe,5572,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['safe'],['safe']
Safety," return(0);; 371}; 372 ; 373 ; 374int rsa_num_sget(rsa_NUMBER *n, char *s); 375{; 376#if rsa_MAXINT == ( (1 << rsa_MAXBIT) - 1 ); 377 rsa_INT *p;; 378 const char *hp;; 379 int bi,ab,i;; 380 long b;; 381 int first = 1;; 382 ; 383 bi = 4 * strlen(s);; 384 ab = rsa_MAXBIT - (bi + rsa_MAXBIT -1) % rsa_MAXBIT -1;; 385 i = (bi + rsa_MAXBIT-1) / rsa_MAXBIT;; 386 p = &n->n_part[ i -1 ];; 387 n->n_len = i;; 388 ; 389 if ( i > rsa_MAXLEN ); 390 return(EOF);; 391 ; 392 b = 0;; 393 while (bi > 0) {; 394 if ( (hp = strchr( gHEX, *s )) ); 395 i = hp - gHEX;; 396 else if ((hp = strchr( ghex, *s )) ); 397 i = hp - ghex;; 398 else; 399 return(EOF);; 400 s++;; 401 ; 402 b <<= 4;; 403 b |= (unsigned long)i;; 404 bi -= 4;; 405 ab += 4;; 406 while (ab >= rsa_MAXBIT) {; 407 i = (b >> (ab - rsa_MAXBIT));; 408 b &= ( 1L << (ab - rsa_MAXBIT)) -1L;; 409 ab -= rsa_MAXBIT;; 410 if (first && !i) {; 411 p--;; 412 n->n_len--;; 413 }; 414 else {; 415 first = 0;; 416 *p-- = i;; 417 }; 418 }; 419 }; 420 if (b); 421 abort();; 422 *s = '\0';; 423 ; 424 return (0);; 425#else; 426 char *p;; 427 int i,c;; 428 ; 429 if (! ginit); 430 num_init();; 431 ; 432 n->n_len = 0;; 433 while ( (c = *s++ & 0xFF)) {; 434 if ( p= strchr( gHEX, c) ); 435 i = p - gHEX;; 436 else if ( p= strchr( ghex, c) ); 437 i = p - ghex;; 438 else; 439 return(EOF);; 440 ; 441 a_mult( n, &gbits[4], n );; 442 if (i); 443 a_add( n, &gint16[i-1], n );; 444 }; 445 ; 446 return(0);; 447#endif; 448}; 449 ; 450int rsa_num_fget(rsa_NUMBER *n, FILE *f); 451{; 452 int j,c;; 453 char *np;; 454 char n_print[ rsa_STRLEN + 1 ];; 455 ; 456 np = n_print;; 457 j = sizeof(n_print);; 458 while ( (c=getc(f)) != EOF && ( isxdigit(c) || isspace(c)) ) {; 459 if (isspace(c)); 460 continue;; 461 if (! --j); 462 return(EOF);; 463 *np++ = (char)c;; 464 }; 465 *np = '\0';; 466 ; 467 if (c != EOF); 468 ungetc(c,f);; 469 ; 470 if ( rsa_num_sget( n, n_print) == EOF ); 471 return( EOF );; 472 ; 473 return(0);; 474}; 475 ; 476int rsa_cmp(rsa_NUMBER *c1, rsa_NUMBER *c2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rsalib_8cxx_source.html:9542,abort,abort,9542,doc/master/rsalib_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html,1,['abort'],['abort']
Safety," rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:14427,safe,safe,14427,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,6,['safe'],['safe']
Safety," send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1216 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1158 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer time For instance, batch browser will be stopped if no activity for 30 sec is there. ; Definition at line 658 of file RWebWindow.cxx. ◆ CheckPendingConnections(). void RWebWindow::CheckPendingConnections ; (; ). private . Check if started process(es) establish connection. ; After timeout such processed will be killed Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data ; Definition at line 624 of file RWebWindow.cxx. ◆ CloseConnection(). void RWebWindow::CloseConnection ; (; unsigned ; connid). Close specified connection. ; Parameters. connidconnection id, when 0 - all connections will be closed . Definition at line 1447 of file RWebWindow.cxx. ◆ CloseConnections(). void RWebWindow::CloseConnections ; (; ). Closes all connection to clients Normally leads to closing of all correspondent browser windows Some browsers (like firefox) do not allow by default to close window. ; Definition at line 1438 of file RWebWindow.cxx. ◆ CompleteWSSend(). void RWebWindow::CompleteWSSend ; (; unsigned ; wsid). private . Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be started. ; Definition at line 1088 of file RWebWindow.cxx. ◆ Create(). std::shared_ptr< RWebWindow > RWebWindow::Create ; (; ). static . Create new RWebWindow Using default RWebWindowsManager. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:26594,timeout,timeout,26594,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety," send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1249 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1191 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer time For instance, batch browser will be stopped if no activity for 30 sec is there. ; Definition at line 659 of file RWebWindow.cxx. ◆ CheckPendingConnections(). void RWebWindow::CheckPendingConnections ; (; ). private . Check if started process(es) establish connection. ; After timeout such processed will be killed Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data ; Definition at line 625 of file RWebWindow.cxx. ◆ CloseConnection(). void RWebWindow::CloseConnection ; (; unsigned ; connid). Close specified connection. ; Parameters. connidconnection id, when 0 - all connections will be closed . Definition at line 1489 of file RWebWindow.cxx. ◆ CloseConnections(). void RWebWindow::CloseConnections ; (; ). Closes all connection to clients Normally leads to closing of all correspondent browser windows Some browsers (like firefox) do not allow by default to close window. ; Definition at line 1480 of file RWebWindow.cxx. ◆ CompleteWSSend(). void RWebWindow::CompleteWSSend ; (; unsigned ; wsid). private . Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be started. ; Definition at line 1121 of file RWebWindow.cxx. ◆ Create(). std::shared_ptr< RWebWindow > RWebWindow::Create ; (; ). static . Create new RWebWindow Using default RWebWindowsManager. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:26197,timeout,timeout,26197,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety," sequentially in the specified order until a successful open. If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile, etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc for regular expressions that will be checked) and as last a local file will be tried. Before opening a file via TNetFile a check is made to see if the URL specifies a local file. If that is the case the file will be opened via a normal TFile. To force the opening of a local file via a TNetFile use either TNetFile directly or specify as host ""localhost"". The netopt argument is only used by TNetFile. For the meaning of the options and other arguments see the constructors of the individual file classes. In case of error, it returns a nullptr.; For TFile implementations supporting asynchronous file open, see TFile::AsyncOpen(...), it is possible to request a timeout with the option TIMEOUT=<secs>: the timeout must be specified in seconds and it will be internally checked with granularity of one millisec. For remote files there is the option: CACHEREAD opens an existing file for reading through the file cache. The file will be downloaded to the cache and opened from there. If the download fails, it will be opened remotely. The file will be downloaded to the directory specified by SetCacheFileDir().; The caller is responsible for deleting the pointer. In READ mode, a nullptr is returned if the file does not exist or cannot be opened. In CREATE mode, a nullptr is returned if the file already exists or cannot be created. In RECREATE mode, a nullptr is returned if the file can not be created. In UPDATE mode, a nullptr is returned if the file cannot be created or opened. ; Definition at line 4089 of file TFile.cxx. ◆ Open() [2/2]. TFile * TFile::Open ; (; TFileOpenHandle * ; fh). static . Waits for the completion of an asynchronous open request. ; Returns the pointer to the associated TFile, transferrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:83557,timeout,timeout,83557,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,['timeout'],['timeout']
Safety," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35289,recover,recovered,35289,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety," socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:13882,timeout,timeout,13882,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,3,['timeout'],['timeout']
Safety," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMLPAnalyzer.html:7559,risk,risk,7559,root/html528/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html,3,['risk'],['risk']
Safety," start web browser for such windows, one can provide real URL of the web server which will connect with that FastCGI instance: WebGui.FastCgiServer: https://your_apache_server.com/root_cgi_path. Definition at line 351 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 536 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 178 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float ROOT::RWebWindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; Definition at line 61 of file RWebWindowsManager.hxx. ◆ GetServer(). THttpServer * ROOT::RWebWindowsManager::GetServer ; (; ); const. inline . Returns THttpServer instance. ; Definition at line 84 of file RWebWindowsManager.hxx. ◆ GetServerAddr(). std::string ROOT::RWebWindowsManager::GetServerAddr ; (; ); const. inline . Returns http address of the server, empty string when not available. ; Definition at line 87 of file RWebWindowsManager.hxx. ◆ GetUrl(). std::string RWebWindowsManager::GetUrl ; (; RWebWindow & ; win, . bool ; remote = false, . std::string * ; produced_key = nullptr . ). private . Provide URL address to access specified window from inside or from remote. ; Definition at line 600 of file RWebWindowsManager.cxx. ◆ InformListener(). bool RWebWindowsManager::InformListener ; (; const std::string & ; msg). private . If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ; Definition at line 227 of file RWebWind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:11088,timeout,timeout,11088,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety," start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179773,timeout,timeout,179773,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179805,timeout,timeout,179805,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStart; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGRecorder.html:22197,timeout,timeouts,22197,root/html534/TGRecorder.html,https://root.cern,https://root.cern/root/html534/TGRecorder.html,1,['timeout'],['timeouts']
Safety," static voidTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidFlushSocket(); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char* grp, Int_t priority); virtual voidSetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. static Int_tGetProofdProtocol(TSocket* s); voidInit(const char* host, Int_t stype); voidParseBuffer(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TSlave::EStatusBits { kOutputRequested; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSlave.html:6726,abort,abort,6726,root/html534/TXSlave.html,https://root.cern,https://root.cern/root/html534/TXSlave.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," std::runtime_error(std::string("">>> Interpreter compilation error:\n"") + reason);; 862 }; 863}; 864 ; 865//______________________________________________________________________________; 866//; 867//; 868//; 869 ; 870////////////////////////////////////////////////////////////////////////////////; 871 ; 872namespace{; 873 // An instance of this class causes the diagnostics of clang to be suppressed; 874 // during its lifetime; 875 class clangDiagSuppr {; 876 public:; 877 clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){; 878 fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();; 879 fDiagEngine.setIgnoreAllWarnings(true);; 880 }; 881 ; 882 ~clangDiagSuppr() {; 883 fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);; 884 }; 885 private:; 886 clang::DiagnosticsEngine& fDiagEngine;; 887 bool fOldDiagValue;; 888 };; 889 ; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Allow calling autoparsing from TMetaUtils; 894bool TClingLookupHelper__AutoParse(const char *cname); 895{; 896 return gCling->AutoParse(cname);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Try hard to avoid looking up in the Cling database as this could enduce; 901/// an unwanted autoparsing.; 902 ; 903bool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,; 904 std::string &result); 905{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:31876,avoid,avoid,31876,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety," t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; Hook function for trace evaluation (dummy). RooCatType evaluate() const. » Last changed: Mon Dec 7 13:45:35 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:24456,safe,safe,24456,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['safe'],['safe']
Safety," table in which there are three color end points: RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white The first 40% of the table is used to go linearly from blue to red. The remaining 60% of the table is used to go linearly from red to white.; If you define a very short interval such that less than one color fits in it, no colors at all will be allocated. If this occurs for all intervals, ROOT will revert to the default palette.; Original code by Andreas Zoglauer (zog@m.nosp@m.pe.m.nosp@m.pg.de) ; Definition at line 2730 of file TColor.cxx. ◆ DeclFileName(). static const char * TColor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 113 of file TColor.h. ◆ DefinedColors(). Bool_t TColor::DefinedColors ; (; Int_t ; set_always_on = 0). static . Static method returning kTRUE if some new colors have been defined after initialisation or since the last call to this method. ; This allows to avoid the colors and palette streaming in TCanvas::Streamer if not needed. If method called once with set_always_on = 1, all next canvases will be To reset such mode, just call methoid once with set_always_on = -1 ; Definition at line 1537 of file TColor.cxx. ◆ GetAlpha(). Float_t TColor::GetAlpha ; (; ); const. inline . Definition at line 66 of file TColor.h. ◆ GetBlue(). Float_t TColor::GetBlue ; (; ); const. inline . Definition at line 62 of file TColor.h. ◆ GetColor() [1/4]. Int_t TColor::GetColor ; (; const char * ; hexcolor). static . Static method returning color number for color specified by hex color string of form: ""#rrggbb"", where rr, gg and bb are in hex between [0,FF], e.g. ; ""#c0c0c0"".; The color retrieval is done using a threshold defined by SetColorThreshold.; If specified color does not exist it will be created with as name ""#rrggbb"" with rr, gg and bb in hex between [0,FF]. ; Definition at line 1920 of file TColor.cxx. ◆ GetColor() [2/4]. Int_t TColor::GetColor ; (; Float_t ; r, . Float_t ; g, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:50487,avoid,avoid,50487,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['avoid'],['avoid']
Safety," that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlave* sl, Int_t output_size); Redirect output of worker sl to some merger. Int_t FindNextFreeMerger(); Return a merger, which is both active and still accepts some workers to be; assigned to it. It works on the 'round-robin' basis. void AskForOutput(TSlave* sl); Master as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:42869,timeout,timeout,42869,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,9,['timeout'],['timeout']
Safety," that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection.; Collect also stops its execution from time to time to check for new; workers in Dynamic Startup mode. Int_t PollForNewWorkers(); Asks the PROOF Serv for new workers in Dynamic Startup mode and activates; them. Returns the number of new workers found, or <0 on errors. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:46725,timeout,timeout,46725,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,9,['timeout'],['timeout']
Safety," that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89559,recover,recovered,89559,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Safety," the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3218,recover,recovery,3218,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety," the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:43880,detect,detection,43880,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,3,['detect'],['detection']
Safety," the Vegas algorithm ; Definition at line 439 of file GSLMCIntegrator.cxx. ◆ DoInitialize(). void ROOT::Math::GSLMCIntegrator::DoInitialize ; (; ). protected . Definition at line 401 of file GSLMCIntegrator.cxx. ◆ Error(). double ROOT::Math::GSLMCIntegrator::Error ; (; ); const. overridevirtual . return the estimate of the absolute Error of the last Integral calculation ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 253 of file GSLMCIntegrator.cxx. ◆ ExtraOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::GSLMCIntegrator::ExtraOptions ; (; ); const. get the specific options (for Vegas or Miser) in term of string- name. ; return a new option object which is managed by user; This is for querying existing options and return object is managed by the user ; Definition at line 484 of file GSLMCIntegrator.cxx. ◆ GetType(). MCIntegration::Type ROOT::Math::GSLMCIntegrator::GetType ; (; ); const. inline . return the type (need to be called GetType to avoid a conflict with typedef) ; Definition at line 273 of file GSLMCIntegrator.h. ◆ GetTypeName(). const char * ROOT::Math::GSLMCIntegrator::GetTypeName ; (; ); const. return the name ; Definition at line 466 of file GSLMCIntegrator.cxx. ◆ Integral() [1/2]. double ROOT::Math::GSLMCIntegrator::Integral ; (; const double * ; a, . const double * ; b . ). overridevirtual . evaluate the integral using the previously defined function ; Implements ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 182 of file GSLMCIntegrator.cxx. ◆ Integral() [2/2]. double ROOT::Math::GSLMCIntegrator::Integral ; (; const GSLMonteFuncPointer & ; f, . unsigned int ; dim, . double * ; a, . double * ; b, . void * ; p = nullptr . ). evaluate the Integral of a function f over the defined hypercube (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; dimthe dimension ; alower value of the integration interval ; bupper value of the integration interval ; ppointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html:8067,avoid,avoid,8067,doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,1,['avoid'],['avoid']
Safety," the callable is applied to must be exactly T. Example usage together with RDataFrame (""varX"" columns must all be float variables): bool myVecFunc(std::vector<float> args);; df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});. Definition at line 103 of file RDFHelpers.hxx. ◆ RunGraphs(). unsigned int ROOT::RDF::RunGraphs ; (; std::vector< RResultHandle > ; handles). Trigger the event loop of multiple RDataFrames concurrently. ; Parameters. [in]handlesA vector of RResultHandles . ReturnsThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:14112,safe,safe,14112,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['safe'],['safe']
Safety," the current directory. ;  ; void Reset ();  Reset the key as it had not been 'filled' yet. ;  ; virtual Int_t WriteFileKeepBuffer (TFile *f=nullptr);  Write the encoded object supported by this key. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TBranch * fBranch {nullptr};  Pointer to the basket support branch. ;  ; Int_t fBufferSize {0};  fBuffer length in bytes ;  ; TBuffer * fCompressedBufferRef {nullptr};  ! Compressed buffer. ;  ; Int_t * fDisplacement {nullptr};  ![fNevBuf] Displacement of entries in fBuffer(TKey) ;  ; Int_t * fEntryOffset {nullptr};  [fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. ;  ; bool fHeaderOnly {false};  True when only the basket header must be read/written. ;  ; UChar_t fIOBits {0};  !IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed. ;  ; Int_t fLast {0};  Pointer to last used byte in basket. ;  ; Int_t fLastWriteBufferSize [3] = {0,0,0};  ! Size of the buffer last three buffers we wrote it to disk ;  ; Int_t fNevBuf {0};  Number of entries in basket. ;  ; Int_t fNevBufSize {0};  Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null! ;  ; UChar_t fNextBufferSizeRecord {0};  ! Index into fLastWriteBufferSize of the last buffer written to disk ;  ; bool fOwnsCompressedBuffer {false};  ! Whether or not we own the compressed buffer. ;  ; bool fReadEntryOffset {false};  !Set to true if offset array was read from a file. ;  ; bool fResetAllocation {false};  ! True if last reset re-allocated the memory ;  ;  Protected Attributes inherited from TKey; char * fBuffer;  Object buffer. ;  ; TBuffer * fBufferRef;  Pointer to the TBuffer object. ;  ; TString fClassName;  Object Class name. ;  ; Short_t fCycle;  Cycle number. ;  ; TDatime fDatime;  Date/T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:18027,avoid,avoid,18027,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['avoid'],['avoid']
Safety," the errno has been reset and the method can be called again. ; Definition at line 3901 of file TUnixSystem.cxx. ◆ UnixSend(). int TUnixSystem::UnixSend ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Send exactly length bytes from buffer. ; Returns -1 in case of error, otherwise number of sent bytes. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4558 of file TUnixSystem.cxx. ◆ UnixSetitimer(). int TUnixSystem::UnixSetitimer ; (; Long_t ; ms). staticprotected . Set interval timer to time-out in ms milliseconds. ; Definition at line 3875 of file TUnixSystem.cxx. ◆ UnixSigAlarmInterruptsSyscalls(). void TUnixSystem::UnixSigAlarmInterruptsSyscalls ; (; Bool_t ; set). staticprotected . When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ; This is typically used in case one wants to put a timeout on an I/O operation. By default interrupted syscalls will always be restarted (for all signals). This can be controlled for each a-synchronous TTimer via the method TTimer::SetInterruptSyscalls(). ; Definition at line 3777 of file TUnixSystem.cxx. ◆ UnixSignal(). void TUnixSystem::UnixSignal ; (; ESignals ; sig, . SigHandler_t ; h . ). staticprotected . Set a signal handler for a signal. ; Definition at line 3703 of file TUnixSystem.cxx. ◆ UnixSigname(). const char * TUnixSystem::UnixSigname ; (; ESignals ; sig). staticprotected . Return the signal name associated with a signal. ; Definition at line 3813 of file TUnixSystem.cxx. ◆ UnixTcpConnect(). int TUnixSystem::UnixTcpConnect ; (; const char * ; hostname, . int ; port, . int ; tcpwindowsize . ). staticprotected . Open a TCP/IP connection to server and connect to a service (i.e. ; port). Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:76130,timeout,timeout,76130,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21954,safe,safe,21954,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safe']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21915,safe,safe,21915,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safe']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:21225,safe,safe,21225,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safe']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21317,safe,safe,21317,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety," the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Create a TKey object for a TObject* and fill output buffer; 219///; 220/// WARNING: in name avoid special characters like '^','$','.' that are used; 221/// by the regular expression parser (see TRegexp).; 222 ; 223TKey::TKey(const TObject *obj, const char *name, Int_t bufsize, TDirectory* motherDir); 224 : TNamed(name, obj->GetTitle()); 225{; 226 R__ASSERT(obj);; 227 ; 228 if (!obj->IsA()->HasDefaultConstructor()) {; 229 Warning(""TKey"", ""since %s has no public constructor\n""; 230 ""\twhich can be called without argument, objects of this class\n""; 231 ""\tcan not be read with the current library. You will need to\n""; 232 ""\tadd a default constructor before attempting to read it."",; 233 obj->ClassName());; 234 }; 235 ; 236 Build(motherDir, obj->ClassName(), -1);; 237 ; 238 Int_t lbuf, nout, noutot, bufmax, nzip;; 239 fBufferRef = new TBufferFile(TBuffer::kWrite, bufsize)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:7649,avoid,avoid,7649,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['avoid'],['avoid']
Safety," the list of memory objects of the current; directory or its sub-directories.; After this call the current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectoryFile::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offers better protection and avoids the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectoryFile.html:16629,avoid,avoids,16629,root/html528/TDirectoryFile.html,https://root.cern,https://root.cern/root/html528/TDirectoryFile.html,6,['avoid'],['avoids']
Safety," the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t flag); Activate/deactivate overlap usage. {fUseOverlaps = flag;}. Bool_t IsUsingOverlaps() const; {return fUseOverlaps;}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:02:24 2015 » Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParallelWorld.html:9001,safe,safety,9001,root/html604/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html604/TGeoParallelWorld.html,1,['safe'],['safety']
Safety," the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:26581,abort,abort,26581,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['abort'],['abort']
Safety," the; 174/// object to be notified (if it was set).; 175 ; 176void TTimer::SetCommand(const char *command); 177{; 178 fObject = nullptr;; 179 fCommand = command;; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:7062,timeout,timeout,7062,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['timeout'],['timeout']
Safety," this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If not element match the condition, the result is zero. To avoid the; the result is zero. To avoid the consequent peak a zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flatened/linearilized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:73864,avoid,avoid,73864,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['avoid'],['avoid']
Safety," this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If not element match the condition, the result is zero. To avoid the; the result is zero. To avoid the consequent peak a zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr[0]+arr2[0] ; arr[1]+arr2[1] and arr[1]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:30046,avoid,avoid,30046,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['avoid'],['avoid']
Safety," thread. ; Definition at line 510 of file TThread.cxx. ◆ Kill() [1/3]. Int_t TThread::Kill ; (; ). Kill this thread. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 590 of file TThread.cxx. ◆ Kill() [2/3]. Int_t TThread::Kill ; (; const char * ; name). static . Static method to kill thread by name. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 622 of file TThread.cxx. ◆ Kill() [3/3]. Int_t TThread::Kill ; (; Long_t ; id). static . Static method to kill the thread by id. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 606 of file TThread.cxx. ◆ Lock(). Int_t TThread::Lock ; (; ). static . Static method to lock the main thread mutex. ; Definition at line 772 of file TThread.cxx. ◆ operator=(). TThread & TThread::operator= ; (; const TThread & ; ). privatedelete . ◆ Printf(). void TThread::Printf ; (; const char * ; fmt, .  ; ... . ). static . Static method providing a thread safe printf. Appends a newline. ; Definition at line 916 of file TThread.cxx. ◆ Ps(). void TThread::Ps ; (; ). static . Static method listing the existing threads. ; Definition at line 843 of file TThread.cxx. ◆ ps(). static void TThread::ps ; (; ). inlinestatic . Definition at line 132 of file TThread.h. ◆ Run(). Int_t TThread::Run ; (; void * ; arg = nullptr, . const int ; affinity = -1 . ). Start the thread. ; This starts the static method TThread::Function() which calls the user function specified in the TThread ctor with the arg argument. If affinity is specified (>=0), a CPU affinity will be associated with the current thread. Returns 0 on success, otherwise an error number will be returned. ; Definition at line 566 of file TThread.cxx. ◆ Self(). TThread * TThread::Self ; (; ). static . Static method returning pointer to current thread. ; Definition at line 495 of file TThread.cxx. ◆ SelfId(). Long_t TThread::SelfId ; (; ). static . Static method returning the id for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:27074,safe,safe,27074,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['safe'],['safe']
Safety," timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTipDelayTimer.html:2013,timeout,timeout,2013,doc/master/classTTipDelayTimer.html,https://root.cern,https://root.cern/doc/master/classTTipDelayTimer.html,3,['timeout'],['timeout']
Safety," to advance the readers to the desired data entry. Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files: auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). Computation graphs (storing and reusing sets of transformations); As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a computation graph in which several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced.; RDataFrame detects when several actions use the same filter or the same defined column, and only evaluates each filter or defined column once per event, regardless of how many times that result is used down the computation graph. Objects read from each column are built once and never copied, for maximum efficiency. When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated, so it might be advisable to put the strictest filters first in the graph. Visualizing the computation graph; It is possible to print the computation graph from any node to obtain a DOT (graphviz) representation either on the standard output or in a file.; Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch the node belongs to is printed. By using the head node, the entire computation graph is printed.; Following there is an example of usage: // First, a sample computational graph is built; ROOT::RDataFrame df(""tree"", ""f.root"");; ; auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:73308,detect,detects,73308,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['detect'],['detects']
Safety," to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoadingRAII autoLoadOff(this);; 6310 // Try using externally provided callback first.; 6311 if (fAutoLoadCallBack) {; 6312 int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);; 6313 if (success); 6314 return success;; 6315 }; 6316 ; 6317 // During the 'Deep' part of the search we will call GetClassSharedLibsForModule; 6318 // (when module are enabled) which might end up calling AutoParsing but; 6319 // that should only be for the cases where the library has no generated pcm; 6320 // and in that case a rootmap should be available.; 6321 // This avoids a very costly operation (for generally no gain) but reduce the; 6322 // quality of the search (i.e. bad in case of library with no pcm and no rootmap; 6323 // file).; 6324 TInterpreter::SuspendAutoParsing autoParseRaii(this);; 6325 std::unordered_set<std::string> visited;; 6326 return DeepAutoLoadImpl(cls, visited, false /*normalized*/);; 6327}; 6328 ; 6329////////////////////////////////////////////////////////////////////////////////; 6330/// Parse the payload or header.; 6331 ; 6332static cling::Interpreter::CompilationResult ExecAutoParse(const char *what,; 6333 Bool_t header,; 6334 cling::Interpreter *interpreter); 6335{; 6336 std::string code = gNonInterpreterClassDef ;; 6337 if (!header) {; 6338 // This is the complete header file content and not the; 6339 // name of a header.; 6340 code += what;; 6341 ; 6342 } else {; 6343 code += (""#include \"""");; 6344 code += what;; 6345 code += ""\""\n"";; 6346 }; 6347 code += (""#ifdef __ROOTCLING__\n""; 6348 ""#undef __ROOTCLING__\n""; 6349 + gInterpreterClassDef +; 6350 ""#endif"");; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:245490,avoid,avoids,245490,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoids']
Safety," to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:46:23 2015 » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerMulti.html:10656,abort,abort,10656,root/html534/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html534/TPacketizerMulti.html,1,['abort'],['abort']
Safety," to components. ;  ;  ~TGeoIntersection () override;  Destructor — deletion of components handled by TGeoManager class. ;  ; void ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin) override;  Compute bounding box corresponding to a intersection of two shapes. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ;  ; Bool_t Contains (const Double_t *point) const override;  Find if a intersection of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this intersection. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:1616,safe,safe,1616,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safe']
Safety," to fall within 0-360 range.; Parameters. [in]huehue in degrees in range 0-360. This allows to limit impact of color adjustment to affect only limited range of hues.; [in]radiusvalue in degrees to be used in order to calculate the range of affected hues. Range is determined by substracting and adding this value from/to affected_hue.; [in]Hvalue by which to change hues in affected range. ; [in]Svalue by which to change saturation of the pixels in affected hue range. ; [in]Vvalue by which to change Value(brightness) of pixels in affected hue range.; [in]x,yposition on infinite surface tiled with original image, of the left-top corner of the area to be used for new image.; [in]width,heightsize of the area of the original image to be used for new image. Default is current width, height of the image. . Reimplemented from TImage.; Definition at line 2945 of file TASImage.cxx. ◆ Idx(). Int_t TASImage::Idx ; (; Int_t ; idx). inlineprivate . Return a valid index in fImage tables to avoid seg-fault by accessing out of indices out of array's ranges. ; Definition at line 6838 of file TASImage.cxx. ◆ Image2Drawable(). void TASImage::Image2Drawable ; (; ASImage * ; im, . Drawable_t ; wid, . Int_t ; x, . Int_t ; y, . Int_t ; xsrc = 0, . Int_t ; ysrc = 0, . UInt_t ; wsrc = 0, . UInt_t ; hsrc = 0, . Option_t * ; opt = """" . ). static . Draw asimage on drawable. ; Definition at line 1228 of file TASImage.cxx. ◆ InitVisual(). Bool_t TASImage::InitVisual ; (; ). staticprotected . Static function to initialize the ASVisual. ; Definition at line 2201 of file TASImage.cxx. ◆ IsA(). TClass * TASImage::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 211 of file TASImage.h. ◆ IsEditable(). Bool_t TASImage::IsEditable ; (; ); const. inlineoverridevirtual . Reimplemented from TImage.; Definition at line 95 of file TASImage.h. ◆ IsGray(). Bool_t TASImage::IsGray ; (; ); const. inlineoverridevirtual . Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:64529,avoid,avoid,64529,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['avoid'],['avoid']
Safety," to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; list->Add(myt);. // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);. se->Modified();; return se;; } . Function Members (Methods); public:. virtual~TPaveStats(); voidTObject::AbstractMethod(const char* method) const; virtual TBox*AddBox(Double_t, Double_t, Double_t, Double_t); virtual TLine*AddLine(Double_t, Double_t, Double_t, Double_t); virtual TText*TPaveText::AddText(const char* label); virtual TText*TPaveText::AddText(Double_t x1, Double_t y1, const char* label); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPaveText::Clear(Option_t* option = """")MENU ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPaveStats.html:5875,avoid,avoid,5875,root/html602/TPaveStats.html,https://root.cern,https://root.cern/root/html602/TPaveStats.html,2,['avoid'],['avoid']
Safety," to write the results of TTree::Draw and TChain::Draw into an entry list. Example: tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; ; Example of Loop on TEntryList with a TChain; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);; ; for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::GetEntryNumberLong64_t GetEntryNumber(Long64_t entry) const overrideReturn entry number corresponding to entry.Definition TChain.cxx:1021; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t *opt="""") overrideSet the input entry list (processing the entries of the chain will then be limited to the entries in ...Definition TChain.cxx:2703; TChain::Addvirtual Int_t Add(TChain *chain)Add all files referenced by the passed chain to this chain.Definition TChain.cxx:219; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; TChain::GetEntriesLong64_t GetEntries() const overrideReturn the total number of entries in the chain.Definition TChain.cxx:978; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:2417,redund,redundant,2417,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['redund'],['redundant']
Safety," two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111217,detect,detector,111217,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety," typename to SQL typename. ;  ; TBasket * CreateBasket (TBranch *br) override;  Create a TBasketSQL. ;  ; virtual void CreateBranch (const TString &branchName, const TString &typeName);  Create the column(s) in the database that correspond to the branch/. ;  ; void CreateBranches ();  determine leaf description string ;  ; bool CreateTable (const TString &table);  Create the database table corresponding to this TTree. ;  ; std::vector< Int_t > * GetColumnIndice (TBranch *branch);  Return a vector of columns index corresponding to the current SQL table and the branch given as argument Returns 0 if no columns indices is found Otherwise returns a pointer to a vector to be deleted by the caller. ;  ; void Init ();  Initialization routine. ;  ; void ResetQuery ();  Reset the internal query. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:39761,detect,detection,39761,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['detect'],['detection']
Safety," unconnected bins, each with a dedicated name. . bins organized in a multidimensional distribution, defined by a set of axes. The axes are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, control distribution, etc) by their name, then: . Use the method GetGlobalBinNumber() to locate a bin in a distribution, then: . Use the TH1::Fill() method and the bin number to fill the appropriate bin in one of the histograms booked above. . Unfolding: Specify the response matrix and the binning schemes when constructing a TUnfoldDensity object. Tell TUnfoldDensity about the data, bakcground, systematic error histograms using the correspondi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:2168,detect,detector,2168,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety," used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);; 2289 return (sf == 2);; 2290}; 2291 ; 2292static void; 2293STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2294{; 2295 stop_flag_t sf;; 2296 do {; 2297 sf = mg_atomic_compare_and_swap(f, *f, v);; 2298 } while (sf != v);; 2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physical context:; 2314 * This holds threads, ports, timeouts, ...; 2315 * set for the entire server, independent from the; 2316 * addressed hostname.; 2317 */; 2318 ; 2319 /* Connection related */; 2320 int context_type; /* See CONTEXT_* above */; 2321 ; 2322 struct socket *listening_sockets;; 2323 struct mg_pollfd *listening_socket_fds;; 2324 unsigned int num_listening_sockets;; 2325 ; 2326 struct mg_connection *worker_connections; /* The connection struct, pre-; 2327 * allocated for each worker */; 2328 ; 2329#if defined(USE_SERVER_STATS); 2330 volatile ptrdif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:71412,timeout,timeouts,71412,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety," used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);; 2290 return (sf == 2);; 2291}; 2292 ; 2293static void; 2294STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2295{; 2296 stop_flag_t sf;; 2297 do {; 2298 sf = mg_atomic_compare_and_swap(f, *f, v);; 2299 } while (sf != v);; 2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:71444,timeout,timeouts,71444,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety," useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922338,safe,safe,922338,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety," variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1978 if (projDataNeededVars) delete projDataNeededVars ;; 1979 return frame ;; 1980 }; 1981 ; 1982 RooAbsReal *projection = const_cast<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot projection object is "" << projection->GetName() << std::endl ;; 1984 if (dologD(Plotting)) {; 1985 projection->printStream(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:87296,abort,abort,87296,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['abort'],['abort']
Safety," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:2074,safe,safe,2074,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,12,['safe'],['safe']
Safety," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35039,recover,recovered,35039,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,"['recover', 'safe']","['recovered', 'safely']"
Safety," viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRobustEstimator.html:1197,detect,detected,1197,root/html528/TRobustEstimator.html,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html,6,['detect'],['detected']
Safety," virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:8433,safe,safe,8433,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['safe'],['safe']
Safety," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:19693,timeout,timeout,19693,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,2,['timeout'],['timeout']
Safety," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; Bool_tS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:19410,timeout,timeout,19410,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,2,['timeout'],['timeout']
Safety," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; Bool_tStartT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:19839,timeout,timeout,19839,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,1,['timeout'],['timeout']
Safety," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBoolNode.html:2451,safe,safe,2451,root/html528/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html528/TGeoBoolNode.html,2,['safe'],['safe']
Safety," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:2514,safe,safe,2514,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,6,['safe'],['safe']
Safety," virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TSVDUnfold.h>. Inheritance diagram for TSVDUnfold:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSVDUnfold() [1/3]. TSVDUnfold::TSVDUnfold ; (; const TH1D * ; bdat, . const TH1D * ; bini, . const TH1D * ; xini, . const TH2D * ; Adet . ). Alternative constructor User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. ; Definition at line 75 of file TSVDUnfold.cxx. ◆ TSVDUnfold() [2/3]. TSVDUnfold::TSVDUnfold ; (; const TH1D * ; bdat, . TH2D * ; Bcov, . const TH1D * ; bini, . const TH1D * ; xini, . const TH2D * ; Adet . ). Default constructor Initialisation of TSVDUnfold User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. ; Definition at line 127 of file TSVDUnfold.cxx. ◆ TSVDUnfold() [3/3]. TSVDUnfold::TSVDUnfold ; (; const TSVDUnfold & ; other). Copy constructor. ; Definition at line 171 of file TSVDUnfold.cxx. ◆ ~TSVDUnfold(). TSVDUnfold::~TSVDUnfold ; (; ). override . Destructor. ; Definition at line 196 of file TSVDUnfold.cxx. Member Function Documentation. ◆ Class(). static TClass * TSVDUnfold::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSVDUnfold::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSVDUnfold::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 156 of file TSVDUnfold.h. ◆ CompProd(). TVectorD TSVDUnfold::CompProd ; (; const TVectorD & ; vec1, . const TVectorD & ; vec2 . ). staticprivate . Multiply entries of two vectors. ; Definition at line 702",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:18323,detect,detector,18323,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety," virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBoolNode.html:2325,safe,safe,2325,root/html528/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html528/TGeoBoolNode.html,2,['safe'],['safe']
Safety," virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBoolNode.html:2354,safe,safe,2354,root/html532/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html,1,['safe'],['safe']
Safety," virtual~TGeoIntersection(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoIntersection.html:2431,safe,safe,2431,root/html532/TGeoIntersection.html,https://root.cern,https://root.cern/root/html532/TGeoIntersection.html,1,['safe'],['safe']
Safety," void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAnd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorus.html:13393,safe,safe,13393,root/html528/TGeoTorus.html,https://root.cern,https://root.cern/root/html528/TGeoTorus.html,3,['safe'],['safe']
Safety," void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. void SetExitStatus(TVirtualProofPlayer::EExitStatus ). Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). void SetMerging(Bool_t on = kTRUE). Long64_t GetCacheSize(). Int_t GetLearnEntries(). void UpdateProgressInfo(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. void SetOutputFilePath(const char* fp). Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:15653,abort,abort,15653,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," void SetVisDensity(Double_t dens = 0.01); // *MENU*; 241 void SetVisLevel(Int_t level = 3); // *MENU*; 242 void SetVisOption(Int_t option = 0);; 243 void ViewLeaves(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsVisLeaves; 244 void SaveAttributes(const char *filename = ""tgeoatt.C""); // *MENU*; 245 void RestoreMasterVolume(); // *MENU*; 246 void SetMaxVisNodes(Int_t maxnodes = 10000); // *MENU*; 247 //--- geometry checking; 248 void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t *option = ""/*""); // *MENU*; 249 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); // *MENU*; 250 void CheckBoundaryReference(Int_t icheck = -1);; 251 void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0.,; 252 Option_t *option = ""ob""); // *MENU*; 253 void CheckGeometry(Option_t *option = """");; 254 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """"); // *MENU*; 255 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.); // *MENU*; 256 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);; 257 void ConvertReflections();; 258 void DrawCurrentPoint(Int_t color = 2); // *MENU*; 259 void DrawTracks(Option_t *option = """"); // *MENU*; 260 void SetParticleName(const char *pname) { fParticleName = pname; }; 261 const char *GetParticleName() const { return fParticleName.Data(); }; 262 void DrawPath(const char *path, Option_t *option = """");; 263 void PrintOverlaps() const; // *MENU*; 264 void RandomPoints(const TGeoVolume *vol, Int_t npoints = 10000, Option_t *option = """");; 265 void RandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 266 const char *target_vol = nullptr, Bool_t check_norm = kFALSE);; 267 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil = 1E-5, const char *g3path = """");; 268 void SetNmeshPoints(Int_t npoints = 1000);; 269 void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:12862,safe,safety,12862,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['safe'],['safety']
Safety," void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tTServerSocket::Recv(TMessage*&); virtual Int_tTServerSocket::Recv(Int_t&, Int_t&); virtual Int_tTServerSocket::Recv(char*, Int_t); virtual Int_tTServerSocket::Recv(char*, Int_t, Int_t&); virtual Int_tTServerSocket::RecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tTServerSocket::Send(const TMessage&); virtual Int_tTServerSocket::Send(Int_t); virtual Int_tTServerSocket::Send(Int_t, Int_t); virtual Int_tTServerSocket::Send(const char*, Int_t = kMESS_STRING); virtual Int_tTServerSocket::SendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tTServerSocket::SendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidTServerSocket::SetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPServerSocket.html:6208,timeout,timeout,6208,root/html530/TPServerSocket.html,https://root.cern,https://root.cern/root/html530/TPServerSocket.html,5,['timeout'],['timeout']
Safety," voidShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:18546,timeout,timeout,18546,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['timeout'],['timeout']
Safety," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTube.html:2546,safe,safe,2546,root/html530/TGeoTube.html,https://root.cern,https://root.cern/root/html530/TGeoTube.html,1,['safe'],['safe']
Safety," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrap.html:3060,safe,safe,3060,root/html532/TGeoTrap.html,https://root.cern,https://root.cern/root/html532/TGeoTrap.html,1,['safe'],['safe']
Safety," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGtra.html:3039,safe,safe,3039,root/html532/TGeoGtra.html,https://root.cern,https://root.cern/root/html532/TGeoGtra.html,1,['safe'],['safe']
Safety," voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:17491,abort,abort,17491,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,4,['abort'],['abort']
Safety," voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterObj&operator=(const TEventIterObj&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterObj.html:4616,abort,abort,4616,root/html530/TEventIterObj.html,https://root.cern,https://root.cern/root/html530/TEventIterObj.html,2,['abort'],['abort']
Safety," voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidTProofServ::FilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:4052,abort,abort,4052,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,2,['abort'],['abort']
Safety," void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  Set half-space parameters as stored in an array. ;  ; void SetPoints (Double_t *) const override;  ; void SetPoints (Float_t *) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:5325,avoid,avoid,5325,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['avoid'],['avoid']
Safety," void SendDNDPosition (Window_t target, int x, int y, Atom_t action, Time_t timestamp);  Send DND position message to target window. ;  ; void SendDNDStatus (Window_t target, Atom_t action);  Send DND status message to source window. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Atom_t fAcceptedAction;  ; Cursor_t fDNDNoDropCursor;  no drop cursor type ;  ; Atom_t * fDraggerTypes;  lists of DND types ;  ; Bool_t fDragging;  kTRUE while dragging ;  ; TGDragWindow * fDragWin;  drag window ;  ; Bool_t fDropAccepted;  kTRUE if drop accepted ;  ; TTimer * fDropTimeout;  drop timeout ;  ; Atom_t fDropType;  drop type ;  ; UInt_t fGrabEventMask;  pointer grab event mask ;  ; Int_t fHotx;  ; Int_t fHoty;  hot point coordinates ;  ; Atom_t fLocalAction;  accepted and local actions ;  ; TGFrame * fLocalSource;  ; TGFrame * fLocalTarget;  local source and target ;  ; TGFrame * fMain;  pointer on TGMainFrame ;  ; Pixmap_t fMask;  pixmap used for the drag window ;  ; Pixmap_t fPic;  ; Bool_t fProxyOurs;  kTRUE if root proxy is ours ;  ; Window_t fSource;  ; Bool_t fStatusPending;  kTRUE if status is pending ;  ; Window_t fTarget;  source and target windows ;  ; Bool_t fTargetIsDNDAware;  kTRUE if target is DND aware ;  ; Atom_t * fTypelist;  ; Bool_t fUseVersion;  kTRUE if DND version is used ;  ; Atom_t fVersion;  not really an Atom, but a long ;  . Static Protected Attributes; static Atom_t fgDNDActionAsk = kNone;  ; static Atom_t fgDNDActionCopy = kNone;  ; static Atom_t fgDNDActionDescrip = kNone;  ; static Atom_t fgDNDActionLink = kNone;  ; static Atom_t fgDNDActionList = kNone;  ; static Atom_t fgDNDActionMove = kNone;  ; static Atom_t fgDNDActionPrivate = kNone;  ; static Atom_t fgDNDAware = kNone;  ; static Atom_t fgDNDDrop = kNone;  ; static Atom_t fgDNDEnter = kNone;  ; static Ato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:12702,timeout,timeout,12702,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['timeout'],['timeout']
Safety," we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6216#if defined(USE_MBEDTLS); 6217 } else if (conn->ssl != NULL) {; 6218 struct mg_pollfd pfd[1];; 6219 int to_read;; 6220 int pollres;; 6221 ; 6222 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; 6225 /* We already know there is no more data buffered in conn->buf; 6226 * but there is more available in the SSL layer. So don't poll; 6227 * conn->client.sock yet. */; 6228 ; 6229 pollres = 1;; 6230 if (to_read > len); 6231 to_read = len;; 6232 } else {; 6233 pfd[0].fd = conn->client.sock;; 6234 pfd[0].events = POLLIN;; 6235 ; 6236 to_read = len;; 6237 ; 6238 pollres = mg_poll(pfd,; 6239 1,; 6240 (int)(timeout * 1000.0),; 6241 &(conn->phys_ctx->stop_flag));; 6242 ; 6243 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6244 return -2;; 6245 }; 6246 }; 6247 ; 6248 if (pollres > 0) {; 6249 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6250 if (nread <= 0) {; 6251 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:181901,timeout,timeout,181901,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6217#if defined(USE_MBEDTLS); 6218 } else if (conn->ssl != NULL) {; 6219 struct mg_pollfd pfd[1];; 6220 int to_read;; 6221 int pollres;; 6222 ; 6223 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; 6226 /* We already know there is no more data buffered in conn->buf; 6227 * but there is more available in the SSL layer. So don't poll; 6228 * conn->client.sock yet. */; 6229 ; 6230 pollres = 1;; 6231 if (to_read > len); 6232 to_read = len;; 6233 } else {; 6234 pfd[0].fd = conn->client.sock;; 6235 pfd[0].events = POLLIN;; 6236 ; 6237 to_read = len;; 6238 ; 6239 pollres = mg_poll(pfd,; 6240 1,; 6241 (int)(timeout * 1000.0),; 6242 &(conn->phys_ctx->stop_flag));; 6243 ; 6244 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6245 return -2;; 6246 }; 6247 }; 6248 ; 6249 if (pollres > 0) {; 6250 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6251 if (nread <= 0) {; 6252 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:181933,timeout,timeout,181933,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:27270,detect,detect,27270,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['detect'],['detect']
Safety," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:26587,detect,detect,26587,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,2,['detect'],['detect']
Safety," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:28089,detect,detect,28089,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['detect'],['detect']
Safety," will return 0; 2211 // for both.; 2212 if (firstbin == 0 && lastbin == 0); 2213 {; 2214 firstbin = 1;; 2215 lastbin = inAxis->GetNbins();; 2216 }; 2217 }; 2218 if (firstbin < 0) firstbin = 0;; 2219 if (lastbin < 0) lastbin = inNbin + 1;; 2220 if (lastbin > inNbin+1) lastbin = inNbin + 1;; 2221 ; 2222 // Create the projection histogram; 2223 char *pname = (char*)name;; 2224 if (name && strcmp(name,expectedName) == 0) {; 2225 Int_t nch = strlen(GetName()) + 4;; 2226 pname = new char[nch];; 2227 snprintf(pname,nch,""%s%s"",GetName(),name);; 2228 }; 2229 TH1D *h1=nullptr;; 2230 //check if histogram with identical name exist; 2231 // if compatible reset and re-use previous histogram; 2232 // (see https://savannah.cern.ch/bugs/?54340); 2233 TObject *h1obj = gROOT->FindObject(pname);; 2234 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 2235 if (h1obj->IsA() != TH1D::Class() ) {; 2236 Error(""DoProjection"",""Histogram with name %s must be a TH1D and is a %s"",name,h1obj->ClassName());; 2237 return nullptr;; 2238 }; 2239 h1 = (TH1D*)h1obj;; 2240 // reset the existing histogram and set always the new binning for the axis; 2241 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 2242 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 2243 h1->Reset();; 2244 const TArrayD *xbins = outAxis->GetXbins();; 2245 if (xbins->fN == 0) {; 2246 if ( originalRange ); 2247 h1->SetBins(outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2248 else; 2249 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2250 } else {; 2251 // case variable bins; 2252 if (originalRange ); 2253 h1->SetBins(outAxis->GetNbins(),xbins->fArray);; 2254 else; 2255 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2256 }; 2257 }; 2258 ; 2259 Int_t ncuts = 0;; 2260 if (opt.Contains(""["")) {; 2261 ((TH2 *)this)->GetPainter();; 2262 if (f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:91312,avoid,avoid,91312,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety," with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:19354,safe,safe,19354,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,2,['safe'],['safe']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Double_t PruneTree(); prune the decision tree if requested (good for individual trees that are best grown out, and then; pruned back, while boosted decision trees are best 'small' trees to start with. Well, at least the; standard ""optimal pruning algorithms"" don't result in 'weak enough' classifiers !!. Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodDT.html:22623,avoid,avoided,22623,root/html534/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodDT.html,3,['avoid'],['avoided']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:21623,avoid,avoided,21623,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,1,['avoid'],['avoided']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodDT.html:22243,avoid,avoided,22243,root/html530/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodDT.html,1,['avoid'],['avoided']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodDT.html:22243,avoid,avoided,22243,root/html532/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodDT.html,1,['avoid'],['avoided']
Safety," work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:27499,avoid,avoiding,27499,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['avoid'],['avoiding']
Safety," wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:13005,timeout,timeout,13005,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety," x.setRange(""left"", 0.0, 4.0); x.setRange(""right"", 6.0, 10.0); ; model2 = ROOT.RooAddPdf(model); r2 = model2.fitTo(data, Range=""left,right"", Save=True, PrintLevel=-1); r2.Print(); ; frame2 = x.frame(Title=""Fit in left/right sideband""); data.plotOn(frame2); model2.plotOn(frame2, VisualizeError=r2); model2.plotOn(frame2); model2.paramOn(frame2); frame2.Draw(); ; ; # Fit in one region; # -------------------------------------------; # Note how restricting the region to only the left tail increases; # the fit uncertainty; ; canv.cd(3); x.setRange(""leftToMiddle"", 0.0, 5.0); ; model3 = ROOT.RooAddPdf(model); r3 = model3.fitTo(data, Range=""leftToMiddle"", Save=True, PrintLevel=-1); r3.Print(); ; frame3 = x.frame(Title=""Fit from left to middle""); data.plotOn(frame3); model3.plotOn(frame3, VisualizeError=r3); model3.plotOn(frame3); model3.paramOn(frame3); frame3.Draw(); ; canv.Draw(); ; canv.SaveAs(""rf204a_extendedLikelihood.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html:3855,safe,safe,3855,doc/master/rf204a__extendedLikelihood_8py.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html,1,['safe'],['safe']
Safety," x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1132 // an array with parameter values; 1133 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1134 der = rd.Derivative1(wf, x, h);; 1135 }; 1136 ; 1137 gErrorTF1 = rd.Error();; 1138 return der;; 1139 ; 1140}; 1141 ; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Returns the second derivative of the function at point x,; 1145/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1146/// to compute a third, more accurate estimation); 1147/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:40356,avoid,avoid,40356,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety," zmin, zmax;. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(const Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:15167,safe,safe,15167,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['safe'],['safe']
Safety," { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCollection.html:10167,safe,safeDeleteList,10167,root/html534/RooAbsCollection.html,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html,2,['safe'],"['safe', 'safeDeleteList']"
Safety," {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);; ; df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; Notice how we created one double variable for each processing slot and later merged their results via std::accumulate. Dataset joins with friend trees; Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain out of the desired trees and pass that to RDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:69012,safe,safe,69012,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['safe'],['safe']
Safety," {; 5024 // Destroy an array of pointers to not-pre-allocated objects.; 5025 Int_t len = ele->GetArrayLength();; 5026 if (!len) {; 5027 len = 1;; 5028 }; 5029 void** r = (void**) eaddr;; 5030 for (Int_t j = len - 1; j >= 0; --j) {; 5031 if (r[j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201664,avoid,avoid,201664,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety," {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179446,timeout,timeout,179446,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179478,timeout,timeout,179478,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TMVA::KDEKernel Class ReferenceTMVA. ; KDE Kernel for ""smoothing"" the PDFs. ; Definition at line 50 of file KDEKernel.h. Public Types; enum  EKernelBorder { kNoTreatment = 1; , kKernelRenorm = 2; , kSampleMirror = 3; };  ; enum  EKernelIter { kNonadaptiveKDE = 1; , kAdaptiveKDE = 2; };  ; enum  EKernelType { kNone = 0; , kGauss = 1; };  . Public Member Functions;  KDEKernel (EKernelIter kiter=kNonadaptiveKDE, const TH1 *hist=nullptr, Float_t lower_edge=0., Float_t upper_edge=1., EKernelBorder kborder=kNoTreatment, Float_t FineFactor=1.);  constructor sanity check ;  ; virtual ~KDEKernel (void);  destructor ;  ; Float_t GetBinKernelIntegral (Float_t lowr, Float_t highr, Float_t mean, Int_t binnum);  calculates the integral of the Kernel ;  ; const char * GetName () const;  ; virtual TClass * IsA () const;  ; void SetKernelType (EKernelType ktype=kGauss);  fIter == 1 —> nonadaptive KDE fIter == 2 —> adaptive KDE ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Float_t fFineFactor;  fine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function ;  ; TH1F * fFirstIterHist;  histogram to be filled in the hidden iteration ;  ; Bool_t fHiddenIteration;  Defines if whats currently running is the. ;  ; TH1F * fHist;  copy of input histogram ;  ; EKernelIter fIter;  iteration number ;  ; EKernelBorder fKDEborder;  The method to take care about ""border"" effects. ;  ; TF1 * fKernel_integ;  the integral of the Kernel function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:851,sanity check,sanity check,851,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"  ; ERegularization GetRegularization () const;  ; Scalar_t GetWeightDecay () const;  ; void Initialize (EInitialization m);  Initialize the weights in the net with the initialization method. ;  ; void InitializeGradients ();  Initialize the gradients in the net to zero. ;  ; LayerIterator_t LayersBegin ();  Iterator to the first layer of the net. ;  ; LayerIterator_t LayersEnd ();  Iterator to the last layer of the net. ;  ; Scalar_t Loss (const Matrix_t &Y, const Matrix_t &weights, bool includeRegularization=true) const;  Evaluate the loss function of the net using the activations that are currently stored in the output layer. ;  ; Scalar_t Loss (Matrix_t &X, const Matrix_t &Y, const Matrix_t &weights, bool applyDropout=false, bool includeRegularization=true);  Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ;  ; void Prediction (Matrix_t &Y_hat, EOutputFunction f) const;  Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ;  ; void Prediction (Matrix_t &Y_hat, Matrix_t &X, EOutputFunction f);  Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ;  ; void Print ();  ; void SetBatchSize (size_t batchSize);  ; void SetDropoutProbabilities (const std::vector< Double_t > &probabilities);  ; void SetInputWidth (size_t inputWidth);  ; void SetLossFunction (ELossFunction J);  ; void SetRegularization (ERegularization R);  ; void SetWeightDecay (Scalar_t weightDecay);  . Private Attributes; size_t fBatchSize;  Batch size for training and evaluation of the Network. ;  ; Matrix_t fDummy;  Empty matrix for last step in back propagation. ;  ; size_t fInputWidth;  Number of features in a single input event. ;  ; ELossFunction fJ;  The loss function of the network. ;  ; std::vector< L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:4154,predict,prediction,4154,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['predict'],['prediction']
Safety,"  ; Long64_t GetSeekInfo () const final;  ; Long64_t GetSize () const final;  Returns the current file size. ;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const final;  return kTRUE if file is opened and can be accessed ;  ; void MakeFree (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in the file. ;  ; void ReadFree () final;  Read the FREE linked list. ;  ; Int_t Recover () final;  Attempt to recover file if not correctly closed. ;  ; Int_t ReOpen (Option_t *mode) final;  Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ;  ; void ResetErrno () const final;  Method resetting the errno. ;  ; void Seek (Long64_t, ERelativeTo=kBeg) final;  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; void SetEND (Long64_t) final;  ; void SetStoreStreamerInfos (Bool_t iConvert=kTRUE) final;  If true, all correspondent to file TStreamerInfo objects will be stored in file this allows to apply schema evolution later for this file may be useful, when file used outside ROOT and TStreamerInfo objects does not required Can be changed only for newly created file. ;  ; void SetUsedDtd (Bool_t use=kTRUE) final;  Specify usage of DTD for this file. ;  ; void SetUseNamespaces (Bool_t iUseNamespaces=kTRUE) final;  Specify usage of namespaces in xml file In current implementation every instrumented class in file gets its unique n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:3902,recover,recover,3902,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recover']
Safety,  ; RooAbsReal * _func = nullptr;  Pointer to original input function. ;  ; std::vector< std::unique_ptr< RooAbsTestStatistic > > _gofArray;  ! Array of sub-contexts representing part of the combined test statistic ;  ; GOFOpMode _gofOpMode = Slave;  Operation mode of test statistic instance. ;  ; bool _init = false;  ! Is object initialized ;  ; pRooRealMPFE * _mpfeArray = nullptr;  ! Array of parallel execution frond ends ;  ; RooFit::MPSplit _mpinterl = RooFit::BulkPartition;  Use interleaving strategy rather than N-wise split for partitioning of dataset for multiprocessor-split. ;  ; Int_t _nCPU = 1;  Number of processors to use in parallel calculation mode. ;  ; Int_t _nEvents = 0;  Total number of events in test statistic calculation. ;  ; Int_t _numSets = 1;  Total number of partitions in parallel calculation mode. ;  ; ROOT::Math::KahanSum< double > _offset {0.0};  ! Offset as KahanSum to avoid loss of precision ;  ; RooSetProxy _paramSet;  Parameters of the test statistic (=parameters of the input function) ;  ; const RooArgSet * _projDeps = nullptr;  Pointer to set with projected observables. ;  ; std::string _rangeName;  Name of range in which to calculate test statistic. ;  ; Int_t _setNum = 0;  Partition number of this instance in parallel calculation mode. ;  ; Int_t _simCount = 1;  Total number of component p.d.f.s in RooSimultaneous (if any) ;  ; bool _splitRange = false;  Split rangeName in RooSimultaneous index labels if true. ;  ; const bool _takeGlobalObservablesFromData = false;  If the global observable values are taken from data. ;  ; bool _verbose = false;  Verbose messaging if true. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:62304,avoid,avoid,62304,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['avoid'],['avoid']
Safety,"  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNodeBVH (Double_t point[3]);  Finds physical node containing the point. ;  ; TGeoPhysicalNode * FindNodeLoop (Double_t point[3]);  Finds physical node containing the point using simple algorithm (for debugging) ;  ; TGeoPhysicalNode * FindNodeOrig (Double_t point[3]);  Finds physical node containing the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:15987,safe,safety,15987,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"  ; class  PDFIntegral;  ; struct  PlaceExpr;  ; struct  PlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  ; struct  PlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  ; struct  PlaceMatrix;  Structure to deal when a submatrix is placed in a matrix. More...;  ; struct  PlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  ; struct  PlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  ; struct  PlainParameters;  ; struct  PlusEquals;  Evaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) More...;  ; struct  PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >;  Specialization for symmetrix += general : NOT Allowed operation. More...;  ; struct  PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) More...;  ; class  Polar2D;  Class describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polar3D;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polynomial;  Parametric Function class describing polynomials of order n. More...;  ; class  PositionVector2D;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  PositionVector3D;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  PtEtaPhiE4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:25360,avoid,avoid,25360,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['avoid'],['avoid']
Safety,"  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static Bool_t CheckFile (const char *path, const char *location=0);  CheckFile() returns kTRUE on success and kFALSE on failure. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TString GetDcapPath (const char *path);  Transform the input path into a path usuable by the dcap C library, i.e either dcap://nodename.org/where/filename.root or /pnfs/where/filename.root. ;  ; static const char * GetDcapVersion ();  Return dCache version string. ;  ; static void SetOnError (EOnErrorAction=kOnErrorDefault);  Set on error handler. ;  ; static void SetOpenTimeout (UInt_t secs);  Set file open timeout. ;  ; static void SetReplyHostName (const char *host_name);  Set reply host name. ;  ; static Bool_t Stage (const char *path, UInt_t secs, const char *location=0);  Stage() returns kTRUE on success and kFALSE on failure. ;  ;  Static Public Member Functions inherited from TFile; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName ();  ; static EAsyncOpenStatus GetAsyncOpenStatus (const char *name);  Get st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:26993,timeout,timeout,26993,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['timeout'],['timeout']
Safety,"  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:7870,avoid,avoid,7870,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['avoid'],['avoid']
Safety,"  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Int_t Fill () override;  Fill a Ntuple with current values in fArgs. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:39460,detect,detection,39460,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['detect'],['detection']
Safety,"  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ;  CSparseData;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:17327,safe,safe,17327,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['safe'],['safe']
Safety,"  Reset this marker attributes to the default values. ;  ; virtual void SaveMarkerAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attributes. ;  ; virtual void SetMarkerColor (Color_t mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static void AbsValue (Bool_t reject=kTRUE);  Static function: set the fgAbsValue flag. ;  ; static void CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11);  Type safe interface (static method) The number of sampling points are taken from the TGraph. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Bool_t DefaultAddToGlobalList (Bool_t on=kTRUE);  Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ;  ; static Double_t DerivativeError ();  Static function returning the error of the last call to the of Derivative's functions. ;  ; static TF1 * GetCurrent ();  Static function returning the current function being processed. ;  ; static void InitStandardFunctions ();  Create the basic function objects. ;  ; static Bool_t RejectedPoint ();  See TF1::RejectPoint above. ;  ; static void RejectPoint (Bool_t reject=kTRUE);  Static function to set the global flag to reject points the fgRejectPoint global flag i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:41230,safe,safe,41230,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['safe'],['safe']
Safety,"  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Publi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7580,abort,abort,7580,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"  TEveElementListProjected;  A projected element list – required for proper propagation of render state to projected views. More...;  ; class  TEveEventManager;  Base class for event management and navigation. More...;  ; class  TEveException;  Exception class thrown by TEve classes and macros. More...;  ; class  TEveFrameBox;  Description of a 2D or 3D frame that can be used to visually group a set of objects. More...;  ; class  TEveFrameBoxGL;  A class encapsulating GL rendering of TEveFrameBox via a static member function. More...;  ; class  TEveGDoubleValuator;  Composite GUI element for selection of range (label, two number-entries and double-slider). More...;  ; class  TEveGedEditor;  Specialization of TGedEditor for proper update propagation to TEveManager. More...;  ; class  TEveGedNameFrame;  Specialization of TGedNameFrame used in EVE. More...;  ; class  TEveGedNameTextButton;  Specialization of TGTextButton for EVE name frame. More...;  ; class  TEveGeoManagerHolder;  Exception safe wrapper for setting gGeoManager. More...;  ; class  TEveGeoNode;  Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement. More...;  ; class  TEveGeoNodeEditor;  Editor for TEveGeoNode class. More...;  ; class  TEveGeoPolyShape;  Description of TEveGeoPolyShape. More...;  ; class  TEveGeoShape;  Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for non-linear projections). More...;  ; class  TEveGeoShapeExtract;  Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts. More...;  ; class  TEveGeoShapeProjected;  A 3D projected TEveGeoShape. More...;  ; class  TEveGeoTopNode;  A wrapper over a TGeoNode, possibly displaced with a global trasformation stored in TEveElement. More...;  ; class  TEveGeoTopNodeEditor;  Editor for TEveGeoTopNode class. More...;  ; class  TEveGListTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:7013,safe,safe,7013,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['safe'],['safe']
Safety,"  flag that last geometric step was null ;  ; TGeoHMatrix * fGlobalMatrix;  current stored global matrix ;  ; Bool_t fIsEntering;  flag a safe start for point classification ;  ; Bool_t fIsExiting;  flag if current step just got into a new node ;  ; Bool_t fIsNullStep;  flag that a new point is in the same node as previous ;  ; Bool_t fIsOnBoundary;  flag that current point is outside geometry ;  ; Bool_t fIsOutside;  flag that next geometric step will exit current volume ;  ; Bool_t fIsSameLocation;  flag that current point is on some boundary ;  ; Bool_t fIsStepEntering;  flag that current track is about to leave current node ;  ; Bool_t fIsStepExiting;  flag that next geometric step will enter new volume ;  ; TGeoNode * fLastNode;  top physical node ;  ; Double_t fLastPoint [3];  current direction ;  ; Double_t fLastPWSafety {-1};  last point for which parallel world safety was ""evaluated"" ;  ; Double_t fLastPWSaftyPnt [3];  last point for which safety was computed ;  ; Double_t fLastSafety;  safety radius from current point ;  ; Int_t fLevel;  thread id for this navigator ;  ; Int_t fNextDaughterIndex;  number of overlapping nodes on current branch ;  ; TGeoNode * fNextNode;  last searched node ;  ; Int_t fNmany;  current geometry level; ;  ; Double_t fNormal [3];  last computed safety radius ;  ; Int_t * fOverlapClusters;  current recursive position in fOverlapClusters ;  ; Int_t fOverlapMark;  current size of fOverlapClusters ;  ; Int_t fOverlapSize;  next daughter index after FindNextBoundary ;  ; TString fPath;  current local matrix of the selected division cell ;  ; Double_t fPoint [3];  unit vector to current checked shape ;  ; Double_t fSafety;  step to be done from current point and direction ;  ; Bool_t fSearchOverlaps;  internal array for overlaps ;  ; Bool_t fStartSafe;  flags the type of the current node ;  ; Double_t fStep;  ; Int_t fThreadId;  last safety returned from parallel world (negative if invalid) ;  ; TGeoNode * fTopNode;  current node ;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:20341,safe,safety,20341,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,3,['safe'],['safety']
Safety," ◆ DistFromInside(). Double_t TGeoCompositeShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from inside point to outside of this composite shape. ; Reimplemented from TGeoBBox.; Definition at line 357 of file TGeoCompositeShape.cxx. ◆ DistFromInside_v(). void TGeoCompositeShape::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 607 of file TGeoCompositeShape.cxx. ◆ DistFromOutside(). Double_t TGeoCompositeShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from outside point to this composite shape. ; Check if the bounding box is crossed within the requested distance ; Reimplemented from TGeoBBox.; Definition at line 343 of file TGeoCompositeShape.cxx. ◆ DistFromOutside_v(). void TGeoCompositeShape::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoCompositeShape.cxx. ◆ Divide(). TGeoVolume * TGeoCompositeShape::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Divide all range of iaxis in range/step cells. ; Reimplemented from TGeoBBox.; Definition at line 368 of file TGeoCompositeShape.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:38579,safe,safe,38579,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety," ◆ DistFromInside(). Double_t TGeoTubeSeg::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromInside_v(). void TGeoTubeSeg::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromInsideS(). static Double_t TGeoTubeSeg::DistFromInsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; c1, . Double_t ; s1, . Double_t ; c2, . Double_t ; s2, . Double_t ; cm, . Double_t ; sm, . Double_t ; cdfi . ). static . ◆ DistFromOutside(). Double_t TGeoTubeSeg::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromOutside_v(). void TGeoTubeSeg::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromOutsideS(). static Double_t TGeoTubeSeg::DistFromOutsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; c1, . Double_t ; s1, . Double_t ; c2, . Double_t ; s2, . Double_t ; cm, . Double_t ; sm, . Double_t ; cdfi . ). static . ◆ Divide(). TGeoVolume * TGeoTubeSeg::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoTube. ◆ GetAxisRange(). Double_t TGeoTubeSeg::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:28651,safe,safe,28651,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['safe'],['safe']
Safety," ◆ SetROOTVersion(). void TSlave::SetROOTVersion ; (; const char * ; rv). inline . Definition at line 159 of file TSlave.h. ◆ SetSessionTag(). void TSlave::SetSessionTag ; (; const char * ; st). inline . Definition at line 161 of file TSlave.h. ◆ SetSocket(). void TSlave::SetSocket ; (; TSocket * ; s). inlineprotected . Definition at line 112 of file TSlave.h. ◆ SetStatus(). virtual void TSlave::SetStatus ; (; Int_t ; st). inlineprotectedvirtual . Definition at line 113 of file TSlave.h. ◆ SetTXSlaveHook(). void TSlave::SetTXSlaveHook ; (; TSlave_t ; xslavehook). static . Set hook to TXSlave ctor. ; Definition at line 665 of file TSlave.cxx. ◆ SetupServ(). Int_t TSlave::SetupServ ; (; Int_t ; stype, . const char * ; conffile . ). virtual . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Reimplemented in TSlaveLite.; Definition at line 178 of file TSlave.cxx. ◆ StopProcess(). void TSlave::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout . ). protectedvirtual . Sent stop/abort request to PROOF server. ; Definition at line 629 of file TSlave.cxx. ◆ Streamer(). void TSlave::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TSlaveLite. ◆ StreamerNVirtual(). void TSlave::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 167 of file TSlave.h. ◆ Touch(). virtual void TSlave::Touch ; (; ). inlinevirtual . Definition at line 165 of file TSlave.h. Friends And Related Symbol Documentation. ◆ TProof. friend class TProof. friend . Definition at line 48 of file TSlave.h. ◆ TProofLite. friend class TProofLite. friend . Definition at line 49 of file TSlave.h. ◆ TSlaveLite. friend class TSlaveLite. friend . Definition at line 50 of file TSlave.h. ◆ TXSlave. friend class TXSlave. friend . Definition at line 51 of file TSlave.h. Member Data Documentation. ◆ fArchComp. TStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:23636,abort,abort,23636,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['abort'],['abort']
Safety," ◆ fInputShape. std::vector<size_t> TMVA::MethodDL::fInputShape. private . Contains the batch size (no. ; of images in the batch), input depth (no. channels) and further input dimensions of the data (image height, width ...) ; Definition at line 178 of file MethodDL.h. ◆ fLayoutString. TString TMVA::MethodDL::fLayoutString. private . The string defining the layout of the deep net. ; Definition at line 194 of file MethodDL.h. ◆ fLossFunction. DNN::ELossFunction TMVA::MethodDL::fLossFunction. private . The loss function. ; Definition at line 190 of file MethodDL.h. ◆ fNet. std::unique_ptr<DeepNetImpl_t> TMVA::MethodDL::fNet. private . Definition at line 209 of file MethodDL.h. ◆ fNumValidationString. TString TMVA::MethodDL::fNumValidationString. private . The string defining the number (or percentage) of training data used for validation. ; Definition at line 199 of file MethodDL.h. ◆ fOutputFunction. DNN::EOutputFunction TMVA::MethodDL::fOutputFunction. private . The output function for making the predictions. ; Definition at line 189 of file MethodDL.h. ◆ fRandomSeed. size_t TMVA::MethodDL::fRandomSeed. private . The random seed used to initialize the weights and shuffling batches (default is zero) ; Definition at line 186 of file MethodDL.h. ◆ fResume. bool TMVA::MethodDL::fResume. private . Definition at line 200 of file MethodDL.h. ◆ fSettings. KeyValueVector_t TMVA::MethodDL::fSettings. private . Map for the training strategy. ; Definition at line 203 of file MethodDL.h. ◆ fTrainingSettings. std::vector<TTrainingSettings> TMVA::MethodDL::fTrainingSettings. private . The vector defining each training strategy. ; Definition at line 204 of file MethodDL.h. ◆ fTrainingStrategyString. TString TMVA::MethodDL::fTrainingStrategyString. private . The string defining the training strategy. ; Definition at line 196 of file MethodDL.h. ◆ fWeightInitialization. DNN::EInitialization TMVA::MethodDL::fWeightInitialization. private . The initialization method. ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:54259,predict,predictions,54259,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['predict'],['predictions']
Safety,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitterMinuit.html:13585,avoid,avoid,13585,root/html528/TFitterMinuit.html,https://root.cern,https://root.cern/root/html528/TFitterMinuit.html,4,['avoid'],['avoid']
Safety,""""", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayer.html:10679,abort,abort,10679,root/html604/TProofPlayer.html,https://root.cern,https://root.cern/root/html604/TProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"""); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:15050,safe,safety,15050,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,5,['safe'],['safety']
Safety,""", ""Any files (*)"", ""Image files (*png *.jpg)"" Should be specified before starting dialog. ;  ; void SetSelectedFilter (const std::string &name);  Configure selected filter Has to be one of the string from NameFilters entry. ;  ; void SetWorkingPath (const std::string &);  Change current working path of file dialog If dialog already shown, change will be immediately applied. ;  ; void Show (const RWebDisplayArgs &args="""");  Show or update RFileDialog in web window If web window already started - just refresh it like ""reload"" button does Reset result of file selection (if any) ;  . Static Public Member Functions; static std::shared_ptr< RFileDialog > Embed (const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args);  Create dialog instance to use as embedded dialog inside other widget Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embed() providing received string as second argument. ;  ; static bool IsMessageToStartDialog (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RFileDialog::Embedded() to really create file dialog instance inside existing widget. ;  ; static std::string NewFile (const std::string &title="""", const std::string &fname="""");  Start NewFile dialog. ;  ; static std::string OpenFile (const std::string &title="""", const std::string &fname="""");  Start OpenFile dialog. ;  ; static std::string SaveAs (const std::string &title="""", const std::string &fname="""");  Start SaveAs dialog. ;  . Protected Member Functions; std::string GetRegexp (const std::string &name) const;  Returns regexp for selected filter String should have form ""Filter name (*.ext1 *.ext2 ...) ;  ; void InvokeCallBack ();  Invoke specified callback. ;  ; void ProcessMsg (unsigned connid, const std::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html:2745,detect,detect,2745,doc/v632/classROOT_1_1RFileDialog.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html,2,['detect'],['detect']
Safety,""", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::RSofieReaderTMVA::RSofieReader class for reading external Machine Learning models in ONNX files,...Definition RSofieReader.hxx:45; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; outputstatic void output(); ; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; Event prediction = 0.212106; AuthorLorenzo Moneta ; Definition in file TMVA_SOFIE_RSofieReader.C. tutorialstmvaTMVA_SOFIE_RSofieReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:3509,predict,prediction,3509,doc/master/TMVA__SOFIE__RSofieReader_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html,1,['predict'],['prediction']
Safety,""", [bkg, sig1, sig2], [bkgfrac, sig1frac], True); ; # NB: Each coefficient is interpreted as the fraction of the; # left-hand component of the i-th recursive sum, i.e.; #; # sum4 = A + ( B + ( C + D) with fraction fA, and fC expands to; #; # sum4 = fA*A + (1-fA)*(fB*B + (1-fB)*(fC*C + (1-fC)*D)); ; # Plot recursive addition model; # ---------------------------------------------------------; model2.plotOn(xframe, LineColor=""r"", LineStyle=""--""); model2.plotOn(xframe, Components={bkg, sig2}, LineColor=""r"", LineStyle=""--""); model2.Print(""t""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x5b64db0 RooAddPdf::model",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8py.html:3774,safe,safe,3774,doc/master/rf201__composite_8py.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html,1,['safe'],['safe']
Safety,"""; 29#include ""TMatrixT.h""; 30#include ""CudaBuffers.h""; 31 ; 32//#include ""TMVA/RTensor.hxx""; 33 ; 34#ifdef R__HAS_CUDNN; 35#include ""cudnn.h""; 36#define CUDNNCHECK(ans) {cudnnError((ans), __FILE__, __LINE__); }; 37#endif; 38 ; 39namespace TMVA {; 40 ; 41 ; 42 ; 43#ifndef TMVA_RTENSOR; 44 ; 45namespace Experimental {; 46/// Memory layout type (copy from RTensor.hxx); 47enum class MemoryLayout : uint8_t {; 48 RowMajor = 0x01,; 49 ColumnMajor = 0x02; 50};; 51}; 52#endif; 53 ; 54namespace DNN {; 55 ; 56using MemoryLayout = TMVA::Experimental::MemoryLayout;; 57 ; 58#ifdef R__HAS_CUDNN; 59/**; 60 * Function to handle the status output of cuDNN function calls. See also; 61 * CUDACHECK in CudaMatrix.h.; 62 */; 63inline void cudnnError(cudnnStatus_t status, const char *file, int line, bool abort=true); 64{; 65 if (status != CUDNN_STATUS_SUCCESS) {; 66 fprintf(stderr, ""CUDNN Error: %s %s %d\n"", cudnnGetErrorString(status), file, line);; 67 if (abort); 68 exit(status);; 69 }; 70}; 71#endif; 72//____________________________________________________________________________; 73//; 74// Cuda Tensor; 75//____________________________________________________________________________; 76 ; 77/** TCudaTensor Class; 78 *; 79 * The TCudaTensor class extends the TCudaMatrix class for dimensions > 2.; 80 *; 81 */; 82template<typename AFloat>; 83class TCudaTensor; 84{; 85public:; 86 ; 87 using Shape_t = std::vector<size_t>;; 88 using MemoryLayout = TMVA::Experimental:: MemoryLayout;; 89 using Scalar_t = AFloat;; 90 ; 91 ; 92private:; 93 ; 94#ifdef R__HAS_CUDNN; 95 struct TensorDescriptor {; 96 cudnnTensorDescriptor_t fCudnnDesc;; 97 };; 98 ; 99 static std::vector<cudnnHandle_t> fCudnnHandle; ///< Holds the cuddn library context (one for every CUDA stream); 100 ; 101 static cudnnDataType_t fDataType; ///< Cudnn datatype used for the tensor; 102#else; 103 struct TensorDescriptor {; 104 };; 105#endif; 106 ; 107 /** For each GPU device keep the CUDA streams in which tensors are used.; 108 * Inst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaTensor_8h_source.html:2075,abort,abort,2075,doc/master/CudaTensor_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaTensor_8h_source.html,2,['abort'],['abort']
Safety,"""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList"")) useList = kTRUE;; }; ; ; Bool_t h1analysis::Process(Long64_t entry); {; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; ; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Read only the necessary branches to select entries.; // return as soon as a bad entry is detected; // to read complete event, call fChain->GetTree()->GetEntry(entry); b_md0_d->GetEntry(entry); if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; b_ptds_d->GetEntry(entry); if (ptds_d <= 2.5) return kFALSE;; b_etads_d->GetEntry(entry); if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; b_ik->GetEntry(entry); ik--; //original ik used f77 convention starting at 1; b_ipi->GetEntry(entry); ipi--;; b_ntracks->GetEntry(entry);; b_nhitrp->GetEntry(entry);; if (nhitrp[ik]*nhitrp[ipi] <= 1) return kFALSE;; b_rend->GetEntry(entry);; b_rstart->GetEntry(entry);; if (rend[ik] -rstart[ik] <= 22) return kFALSE;; if (rend[ipi]-rstart[ipi] <= 22) return kFALSE;; b_nlhk->GetEntry(entry); if (nlhk[ik] <= 0.1) return kFALSE;; b_nlhpi->GetEntry(entry); if (nlhpi[ipi] <= 0.1) return kFALSE;; b_ipis->GetEntry(entry); ipis--; if (nlhpi[ipis] <= 0.1) return kFALSE;; b_njets->GetEntry(entry); if (njets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; // to read complete event, call fChain->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:9332,detect,detected,9332,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['detect'],['detected']
Safety,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGFont.html:14436,sanity check,sanity check,14436,root/html530/TGFont.html,https://root.cern,https://root.cern/root/html530/TGFont.html,1,['sanity check'],['sanity check']
Safety,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFont.html:14436,sanity check,sanity check,14436,root/html532/TGFont.html,https://root.cern,https://root.cern/root/html532/TGFont.html,1,['sanity check'],['sanity check']
Safety,"## Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.; 2961 ///; 2962 /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; 2963 /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; 2964 /// RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; 2965 /// * `ROOT::RDF::SampleCallback_t GetSampleCallback()`: if present, it must return a callable with the; 2966 /// appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing; 2967 /// of every sample, as in DefinePerSample().; 2968 /// * `Helper MakeNew(void *newResult)`: if implemented, it enables varying the action's result with VariationsFor(). It takes a; 2969 /// type-erased new result that can be safely cast to a `std::shared_ptr<Result_t> *` (a pointer to shared pointer) and should; 2970 /// be used as the action's output result.; 2971 ///; 2972 /// In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled; 2973 /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; 2974 ///; 2975 /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; 2976 ///; 2977 /// ### Examples; 2978 /// See [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html) for an example implementation of an action helper.; 2979 ///; 2980 /// It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx.; 2981 ///; 2982 // clang-format on; 2983 template <typename FirstColumn = RDFDetail::RInferredType, typename... OtherColumns, typename Helper>; 2984 RResultPtr<typename std::decay_t<Helper>::Result_t> Book(Helper &&helper,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:168604,safe,safely,168604,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safely']
Safety,"####################################################################################; 116 ; 117# Instantiating EncodeProcessDecode Model; 118 ; 119printMemory(""before instantiating""); 120ep_model = EncodeProcessDecode(); 121printMemory(""after instantiating""); 122 ; 123# Initializing randomized input data with maximum number of nodes/edges; 124GraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, node_size, edge_size, global_size); 125 ; 126#input_graphs is a tuple representing the initial data; 127input_graph_data = utils_tf.data_dicts_to_graphs_tuple([GraphData]); 128 ; 129# Initializing randomized input data for core; 130# note that the core network has as input a double number of features; 131CoreGraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, 2*LATENT_SIZE, 2*LATENT_SIZE, 2*LATENT_SIZE); 132input_core_graph_data = utils_tf.data_dicts_to_graphs_tuple([CoreGraphData]); 133 ; 134#initialize graph data for decoder (input is LATENT_SIZE); 135DecodeGraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, LATENT_SIZE, LATENT_SIZE, LATENT_SIZE); 136 ; 137# Make prediction of GNN. This will initialize the GNN with weights; 138printMemory(""before first eval""); 139output_gn = ep_model(input_graph_data, processing_steps); 140printMemory(""after first eval""); 141#print(""---> Input:\n"",input_graph_data); 142#print(""\n\n------> Input core data:\n"",input_core_graph_data); 143#print(""\n\n---> Output:\n"",output_gn); 144 ; 145# Make SOFIE Model, the model will be made using a maximum number of nodes/edges which are inside GraphData; 146 ; 147encoder = ROOT.TMVA.Experimental.SOFIE.RModel_GraphIndependent.ParseFromMemory(ep_model._encoder._network, GraphData, filename = ""encoder""); 148encoder.Generate(); 149encoder.OutputGenerated(); 150 ; 151core = ROOT.TMVA.Experimental.SOFIE.RModel_GNN.ParseFromMemory(ep_model._core._network, CoreGraphData, filename = ""core""); 152core.Generate(); 153core.OutputGenerated(); 154 ; 155decoder = ROOT.TMVA.Experim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html:5736,predict,prediction,5736,doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,1,['predict'],['prediction']
Safety,"& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. ROOT::Math::BaseIntegratorOptionsBaseIntegratorOptions(); voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance; ROOT::Math::IOptions*fExtraOptionsextra options; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions(); protected constructor to avoid user creating this class. BaseIntegratorOptions(const ROOT::Math::BaseIntegratorOptions& opt); copy constructor. BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__BaseIntegratorOptions.html:2010,avoid,avoid,2010,root/html602/ROOT__Math__BaseIntegratorOptions.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__BaseIntegratorOptions.html,2,['avoid'],['avoid']
Safety,"& strlen(library_specified) ) {; 2972 // Use the specified name instead of the default; 2973 libname = BaseName( library_specified );; 2974 library = library_specified;; 2975 ExpandPathName( library );; 2976 if (! IsAbsoluteFileName(library) ) {; 2977 AssignAndDelete( library , ConcatFileName( WorkingDirectory(), library ) );; 2978 }; 2979 library = TString(library) + ""."" + fSoExt;; 2980 }; 2981 library = gSystem->UnixPathName(library);; 2982 ; 2983 TString libname_ext ( libname );; 2984 libname_ext += ""."" + fSoExt;; 2985 ; 2986 TString lib_dirname = GetDirName( library );; 2987 // For some probably good reason, DirName on Windows returns the 'name' of; 2988 // the directory, omitting the drive letter (even if there was one). In; 2989 // consequence the result is not useable as a 'root directory', we need to; 2990 // add the drive letter if there was one..; 2991 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2992 lib_dirname.Prepend(library(0,2));; 2993 }; 2994 // Strip potential, somewhat redundant '/.' from the pathname ...; 2995 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""/."", 2) == 0 ) {; 2996 lib_dirname.Remove(lib_dirname.Length()-2);; 2997 }; 2998 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""\\."", 2) == 0 ) {; 2999 lib_dirname.Remove(lib_dirname.Length()-2);; 3000 }; 3001 TString lib_location( lib_dirname );; 3002 Bool_t mkdirFailed = kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:100217,redund,redundant,100217,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['redund'],['redundant']
Safety,"& var, Bool_t silent = kFALSE); Add element to non-owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is specified to own its elements. Eventual error messages; can be suppressed with the silent flag. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add element to an owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg* addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add clone of specified element to an owning set. If sucessful, the; set will own the clone, not the original. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg& operator[](const char* name) const; Array operator. Named element must exist in set, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. Bool_t checkForDup(const RooAbsArg& arg, Bool_t silent) const; Check if element with var's name is already in set. Double_t getRealValue(const char* name, Double_t defVal = 0, Bool_t verbose = kFALSE) const; Get value of a RooAbsReal stored in set with given name. If none is found, value of defVal is returned.; No error messages are printed unless the verbose flag is set. Bool_t setRealValue(const char* name, Double_t newVal = 0, Bool_t verbose = kFALSE); Set value of a RooAbsRealLValye stored in set with given name to newVal; No error messages are printed unless the verbose flag is set. const char* getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; Get state name of a RooAbsCategory stored in set with given name. If none is found, value of defVal is returned.; No error messages ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgSet.html:18260,abort,abort,18260,root/html528/RooArgSet.html,https://root.cern,https://root.cern/root/html528/RooArgSet.html,6,['abort'],['abort']
Safety,"& ; biasGradients . ). protectedvirtual . Update the biases, given the current bias gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 206 of file Adadelta.h. ◆ UpdateWeights(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . auto TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::UpdateWeights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedvirtual . Update the weights, given the current weight gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 147 of file Adadelta.h. Member Data Documentation. ◆ fEpsilon. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::fEpsilon. protected . The Smoothing term used to avoid division by zero. ; Definition at line 52 of file Adadelta.h. ◆ fPastSquaredBiasGradients. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredBiasGradients. protected . The accumulation of the square of the past bias gradients associated with the deep net. ; Definition at line 55 of file Adadelta.h. ◆ fPastSquaredBiasUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredBiasUpdates. protected . The accumulation of the square of the past bias updates associated with the deep net. ; Definition at line 60 of file Adadelta.h. ◆ fPastSquaredWeightGradients. template<typename Architect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:10837,avoid,avoid,10837,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['avoid'],['avoid']
Safety,"(!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:597849,abort,abort,597849,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:597882,abort,abort,597882,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nread =; 6299 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6300 if (nread <= 0) {; 6301 err = SSL_get_error(conn->ssl, nread);; 6302 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6303 err = ERRNO;; 6304 } else if ((err == SSL_ERROR_WANT_READ); 6305 || (err == SSL_ERROR_WANT_WRITE)) {; 6306 nread = 0;; 6307 } else {; 6308 /* All errors should return -2 */; 6309 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6310 ERR_clear_error();; 6311 return -2;; 6312 }; 6313 ERR_clear_error();; 6314 } else {; 6315 err = 0;; 6316 }; 6317 } else if (pollres < 0) {; 6318 /* Error */; 6319 return -2;; 6320 } else {; 6321 /* pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 6347 /* error callint poll */; 6348 return -2;; 6349 } else {; 6350 /* pollres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:184346,timeout,timeout,184346,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nread =; 6300 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6301 if (nread <= 0) {; 6302 err = SSL_get_error(conn->ssl, nread);; 6303 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6304 err = ERRNO;; 6305 } else if ((err == SSL_ERROR_WANT_READ); 6306 || (err == SSL_ERROR_WANT_WRITE)) {; 6307 nread = 0;; 6308 } else {; 6309 /* All errors should return -2 */; 6310 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6311 ERR_clear_error();; 6312 return -2;; 6313 }; 6314 ERR_clear_error();; 6315 } else {; 6316 err = 0;; 6317 }; 6318 } else if (pollres < 0) {; 6319 /* Error */; 6320 return -2;; 6321 } else {; 6322 /* pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 6348 /* error callint poll */; 6349 return -2;; 6350 } else {; 6351 /* pollres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:184378,timeout,timeout,184378,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"() [6/9]. TKey::TKey ; (; const TString & ; name, . const TString & ; title, . const TClass * ; cl, . Int_t ; nbytes, . TDirectory * ; motherDir . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 207 of file TKey.cxx. ◆ TKey() [7/9]. TKey::TKey ; (; const TObject * ; obj, . const char * ; name, . Int_t ; bufsize, . TDirectory * ; motherDir . ). Create a TKey object for a TObject* and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 223 of file TKey.cxx. ◆ TKey() [8/9]. TKey::TKey ; (; const void * ; obj, . const TClass * ; cl, . const char * ; name, . Int_t ; bufsize, . TDirectory * ; motherDir . ). Create a TKey object for any object obj of class cl d and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 298 of file TKey.cxx. ◆ TKey() [9/9]. TKey::TKey ; (; Long64_t ; pointer, . Int_t ; nbytes, . TDirectory * ; motherDir = nullptr . ). Create a TKey object to read keys. ; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile. A TKey object is created to read the keys structure itself. ; Definition at line 175 of file TKey.cxx. ◆ ~TKey(). TKey::~TKey ; (; ). override . TKey default destructor. ; Definition at line 526 of file TKey.cxx. Member Function Documentation. ◆ Browse(). void TKey::Browse ; (; TBrowser * ; b). overridevirtual . Read object from disk and call its Browse() method. ; If object with same name already exist in memory delete it (like TDirectoryFile::Get() is doing), except when the key references a folder in which case we don't want to re-read the folder object since it might contain new objects not yet saved. ; Reimplemented from TObject.; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:19404,avoid,avoid,19404,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['avoid'],['avoid']
Safety,"() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoShape.html:7902,safe,safe,7902,root/html530/TGeoShape.html,https://root.cern,https://root.cern/root/html530/TGeoShape.html,1,['safe'],['safe']
Safety,"()) return;; 897 UShort_t pidf;; 898 if (R__b.IsReading()) {; 899 R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }; 900 R__b >> fUniqueID;; 901 const UInt_t isonheap = fBits & kIsOnHeap; // Record how this instance was actually allocated.; 902 R__b >> fBits;; 903 fBits |= isonheap | kNotDeleted; // by definition de-serialized object are not yet deleted.; 904 if (TestBit(kIsReferenced)) {; 905 //if the object is referenced, we must read its old address; 906 //and store it in the ProcessID map in gROOT; 907 R__b >> pidf;; 908 pidf += R__b.GetPidOffset();; 909 TProcessID *pid = R__b.ReadProcessID(pidf);; 910 if (pid) {; 911 UInt_t gpid = pid->GetUniqueID();; 912 if (gpid>=0xff) {; 913 fUniqueID = fUniqueID | 0xff000000;; 914 } else {; 915 fUniqueID = ( fUniqueID & 0xffffff) + (gpid<<24);; 916 }; 917 pid->PutObjectWithID(this);; 918 }; 919 }; 920 } else {; 921 R__b.WriteVersion(TObject::IsA());; 922 // Can not read TFile.h here and avoid going through the interpreter by; 923 // simply hard-coding this value.; 924 // This **must** be equal to TFile::k630forwardCompatibility; 925 constexpr int TFile__k630forwardCompatibility = BIT(2);; 926 const auto parent = R__b.GetParent();; 927 if (!TestBit(kIsReferenced)) {; 928 R__b << fUniqueID;; 929 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 930 R__b << fBits;; 931 else; 932 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 933 } else {; 934 //if the object is referenced, we must save its address/file_pid; 935 UInt_t uid = fUniqueID & 0xffffff;; 936 R__b << uid;; 937 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 938 R__b << fBits;; 939 else; 940 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 941 TProcessID *pid = TProcessID::GetProcessWithUID(fUniqueID,this);; 942 //add uid to the TRefTable if there is one; 943 TRefTable *table = TRefTable::GetRefTable();; 944 if(table) table->Add(uid, pid);; 945 pidf = R__b.WriteProcessID(pid);; 946 R__b <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:33999,avoid,avoid,33999,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(), len2 = stack2.size(), len = (len1 < len2) ? len1 : len2, indx = 0;; 273 while (indx < len) {; 274 if (stack1[indx] < stack2[indx]); 275 return -1;; 276 if (stack1[indx] > stack2[indx]); 277 return 1;; 278 ++indx;; 279 }; 280 ; 281 if (len1 < len2); 282 return -1;; 283 if (len1 > len2); 284 return 1;; 285 ; 286 return 0;; 287}; 288} // namespace; 289 ; 290/////////////////////////////////////////////////////////////////////; 291/// Issue signal, which distributed on all handlers - excluding source handler; 292 ; 293void RGeomDescription::IssueSignal(const void *handler, const std::string &kind); 294{; 295 std::vector<RGeomSignalFunc_t> funcs;; 296 ; 297 {; 298 TLockGuard lock(fMutex);; 299 for (auto &pair : fSignals); 300 if (!handler || (pair.first != handler)); 301 funcs.emplace_back(pair.second);; 302 }; 303 ; 304 // invoke signal outside locked mutex to avoid any locking; 305 for (auto func : funcs); 306 func(kind);; 307}; 308 ; 309/////////////////////////////////////////////////////////////////////; 310/// Add signal handler; 311 ; 312void RGeomDescription::AddSignalHandler(const void *handler, RGeomSignalFunc_t func); 313{; 314 TLockGuard lock(fMutex);; 315 fSignals.emplace_back(handler, func);; 316}; 317 ; 318/////////////////////////////////////////////////////////////////////; 319/// Remove signal handler; 320 ; 321void RGeomDescription::RemoveSignalHandler(const void *handler); 322{; 323 TLockGuard lock(fMutex);; 324 ; 325 for (auto iter = fSignals.begin(); iter != fSignals.end(); ++iter); 326 if (handler == iter->first) {; 327 fSignals.erase(iter);; 328 return;; 329 }; 330}; 331 ; 332/////////////////////////////////////////////////////////////////////; 333/// Pack matrix into vector, which can be send to client; 334/// Following sizes can be used for vector:; 335/// 0 - Identity matrix; 336/// 3 - Translation; 337/// 4 - Scale (last element always 1); 338/// 9 - Rotation; 339/// 16 - Full size; 340 ; 341void RGeomDescription::PackMatrix(std::vector<f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:7308,avoid,avoid,7308,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['avoid'],['avoid']
Safety,"(). Bool_t TCling::HasPCMForLibrary ; (; const char * ; libname); const. finalvirtual . Return true if ROOT has cxxmodules pcm for a given library name. ; Implements TInterpreter.; Definition at line 3147 of file TCling.cxx. ◆ Initialize(). void TCling::Initialize ; (; ). finalvirtual . Initialize the interpreter, once TROOT::fInterpreter is set. ; Implements TInterpreter.; Definition at line 1636 of file TCling.cxx. ◆ InitRootmapFile(). void TCling::InitRootmapFile ; (; const char * ; name). private . Create a resource table and read the (possibly) three resource files, i.e. ; $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and $PWD/<name>. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can read additional user defined resource files by creating additional TEnv objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of the $HOME/<name> resource file will be skipped. This might be useful in case the home directory resides on an automounted remote file system and one wants to avoid the file system from being mounted. ; Definition at line 5655 of file TCling.cxx. ◆ InspectMembers(). void TCling::InspectMembers ; (; TMemberInspector & ; insp, . const void * ; obj, . const TClass * ; cl, . Bool_t ; isTransient . ). finalvirtual . Visit all members over members, recursing over base classes. ; Implements TInterpreter.; Definition at line 2684 of file TCling.cxx. ◆ InvalidateCachedDecl(). void TCling::InvalidateCachedDecl ; (; const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > & ; Lists, . const clang::Decl * ; D . ). private . Invalidate cached TCling information for the given declaration, and removed it from the appropriate object list. ; Parameters. [in]Lists- std::tuple<TListOfDataMembers&, TListOfFunctions&, TListOfFunctionTemplates&, TListOfEnums&> of pointers to the (global/class) object lists. ; [in]D- Decl to discard. . Definition at line 6891 of file TCling.cxx. ◆ I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:107913,avoid,avoid,107913,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['avoid'],['avoid']
Safety,"(). Volumes themselves support different visualization settings :; TGeoVolume::SetVisibility() : set volume visibility.; TGeoVolume::VisibleDaughters() : set daughters visibility. All these actions automatically updates the current view if any. Checking the geometry; Several checking methods are accessible from the volume context menu. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class from the painting package.; Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z). This method is drawing the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. The point will be drawn in red, as well as a sphere having this closest distance as radius. In case a non-zero distance is given by the user as fifth argument of CheckPoint, this distance will be used as radius of the safety sphere. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and it will draw this volume with current visualization settings. Random points are generated in the bounding box of the top drawn volume. The points are classified and drawn with the color of their deepest container. Only points in visible nodes will be drawn. Raytracing.; Can be called from TGeoVolume::RandomRays() (context menu of volumes) and will shoot rays from a given point in the local reference frame with random directions. The intersections with displayed nodes will appear as segments having the color of the touched node. Drawn geometry will be then made invisible in order to enhance rays. Definition at line 44 of file TGeoManager.h. Public Types; enum  EDefaultUnits { kG4Units = 0; , kRootUnits = 1; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:18648,safe,safety,18648,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safety']
Safety,"(). const TMatrixDSparse * TUnfold::GetEinv ; (; void ; ); const. inlineprotected . matrix E-1, using internal bin counting ; Definition at line 256 of file TUnfold.h. ◆ GetEmatrix(). void TUnfold::GetEmatrix ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr . ); const. get output covariance matrix, possibly cumulated over several bins ; Parameters. [out]ematrixhistogram to store the covariance. The bin contents are overwritten. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 3446 of file TUnfold.cxx. ◆ GetEpsMatrix(). Double_t TUnfold::GetEpsMatrix ; (; void ; ); const. inline . get numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ; Definition at line 352 of file TUnfold.h. ◆ GetFoldedOutput(). void TUnfold::GetFoldedOutput ; (; TH1 * ; out, . const Int_t * ; binMap = nullptr . ); const. get unfolding result on detector level ; Parameters. [out]outhistogram to store the correlation coefficiencts. The bin contents and errors are overwritten. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. This method returns the unfolding output folded by the response matrix, i.e. the vector Ax.; The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 2962 of file TUnfold.cxx. ◆ GetInput(). void TUnfold::GetInput ; (; TH1 * ; out, . const Int_t * ; binMap = nullptr . ); const. Input vector of measurements. ; Parameters. [out]outhistogram to store the measurements. Bin content and bin errors are overwritte. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. Bins which had an uncertainty of zero in the call to SetInput() maye acquire bin contents or bin errors different from the original settings in SetInput().; The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:35945,detect,detector,35945,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['detect'],['detector']
Safety,"(). virtual void TBuffer::ClassMember ; (; const char * ; , . const char * ; = nullptr, . Int_t ; = -1, . Int_t ; = -1 . ). pure virtual . Implemented in TBufferFile, TBufferJSON, TBufferSQL2, and TBufferXML. ◆ DeclFileName(). static const char * TBuffer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 340 of file TBuffer.h. ◆ DecrementLevel(). virtual void TBuffer::DecrementLevel ; (; TVirtualStreamerInfo * ; ). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ DetachBuffer(). void TBuffer::DetachBuffer ; (; ). inline . Definition at line 99 of file TBuffer.h. ◆ Expand(). void TBuffer::Expand ; (; Int_t ; newsize, . Bool_t ; copy = kTRUE . ). Expand (or shrink) the I/O buffer to newsize bytes. ; If copy is true (the default), the existing content of the buffer is preserved, otherwise the buffer is returned zero-ed out.; In order to avoid losing data, if the current length is greater than the requested size, we only shrink down to the current length. ; Definition at line 223 of file TBuffer.cxx. ◆ ForceWriteInfo(). virtual void TBuffer::ForceWriteInfo ; (; TVirtualStreamerInfo * ; info, . Bool_t ; force . ). pure virtual . Implemented in TBufferIO, and TMessage. ◆ ForceWriteInfoClones(). virtual void TBuffer::ForceWriteInfoClones ; (; TClonesArray * ; a). pure virtual . Implemented in TBufferIO. ◆ GetBufferDisplacement(). virtual Int_t TBuffer::GetBufferDisplacement ; (; ); const. pure virtual . Implemented in TBufferIO. ◆ GetBufferVersion(). Int_t TBuffer::GetBufferVersion ; (; ); const. inline . Definition at line 85 of file TBuffer.h. ◆ GetClass() [1/2]. TClass * TBuffer::GetClass ; (; const char * ; className). static . Forward to TROOT::GetClass(). ; Definition at line 336 of file TBuffer.cxx. ◆ GetClass() [2/2]. TClass * TBuffer::GetClass ; (; const std::type_info & ; typeinfo). static . Forward to TROOT::GetClass(). ; Definition at line 328 of file TBuffer.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:31263,avoid,avoid,31263,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['avoid'],['avoid']
Safety,"(). void ROOT::RGeomDescription::SetNSegments ; (; int ; n = 0). inline . Set number of segments for cylindrical shapes, if 0 - default value will be used. ; Definition at line 342 of file RGeomData.hxx. ◆ SetPhysNodeVisibility() [1/2]. bool RGeomDescription::SetPhysNodeVisibility ; (; const std::string & ; path, . bool ; on = true . ). Set visibility of physical node by itemname itemname in string with path like ""/TOP_1/SUB_2/NODE_3"". ; Definition at line 2016 of file RGeomData.cxx. ◆ SetPhysNodeVisibility() [2/2]. bool RGeomDescription::SetPhysNodeVisibility ; (; const std::vector< std::string > & ; path, . bool ; on = true . ). Set visibility of physical node by path It overrules TGeo visibility flags - but only for specific physical node. ; Definition at line 1970 of file RGeomData.cxx. ◆ SetPreferredOffline(). void ROOT::RGeomDescription::SetPreferredOffline ; (; bool ; on). inline . Set preference of offline operations. ; Server provides more info to client from the begin on to avoid communication ; Definition at line 358 of file RGeomData.hxx. ◆ SetSearch(). bool RGeomDescription::SetSearch ; (; const std::string & ; query, . const std::string & ; json . ). Change search query and belongs to it json string Returns true if any parameter was really changed. ; Definition at line 2130 of file RGeomData.cxx. ◆ SetTopVisible(). void ROOT::RGeomDescription::SetTopVisible ; (; bool ; on = true). inline . Set draw options as string for JSROOT TGeoPainter. ; Definition at line 332 of file RGeomData.hxx. ◆ SetVisLevel(). void ROOT::RGeomDescription::SetVisLevel ; (; int ; lvl = 3). inline . Set maximal visible level. ; Definition at line 327 of file RGeomData.hxx. Friends And Related Symbol Documentation. ◆ RGeomBrowserIter. friend class RGeomBrowserIter. friend . Definition at line 212 of file RGeomData.hxx. Member Data Documentation. ◆ fActiveItemName. std::string ROOT::RGeomDescription::fActiveItemName. private . ! name of item which should be activated in hierarchy ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:27737,avoid,avoid,27737,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['avoid'],['avoid']
Safety,"(). void TBufferSQL::WriteCharStar ; (; char * ; s). finalvirtual . Write a char* string. ; Reimplemented from TBufferFile.; Definition at line 344 of file TBufferSQL.cxx. ◆ WriteDouble(). void TBufferSQL::WriteDouble ; (; Double_t ; d). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 212 of file TBufferSQL.cxx. ◆ WriteFastArray() [1/15]. void TBufferSQL::WriteFastArray ; (; const bool * ; b, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 427 of file TBufferSQL.cxx. ◆ WriteFastArray() [2/15]. void TBufferSQL::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 447 of file TBufferSQL.cxx. ◆ WriteFastArray() [3/15]. void TBufferSQL::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 688 of file TBufferSQL.cxx. ◆ WriteFastArray() [4/15]. void TBufferSQL::WriteFastArray ; (; const Float_t * ; f, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:51181,abort,aborts,51181,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,"(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:9085,safe,safe,9085,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,1,['safe'],['safe']
Safety,"(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPcon.html:8647,safe,safe,8647,root/html602/TGeoPcon.html,https://root.cern,https://root.cern/root/html602/TGeoPcon.html,2,['safe'],['safe']
Safety,"(1.0 - (effBH - effB))) / (1.0 + effS);; 934 // alternative idea; 935 //if (effBH<0) eta = (1.e-6+effB)/(1.0 + effS);; 936 //else eta = (effB - effBH) * (1.0 + 10.* effS);; 937 ; 938 // if a point is found which is better than an existing one, ... replace it.; 939 // preliminary best event -> backup; 940 if (effBH < 0 || effBH > effB) {; 941 fEffBvsSLocal->SetBinContent( ibinS, effB );; 942 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 943 fCutMin[ivar][ibinS-1] = fTmpCutMin[ivar]; // bin 1 stored in index 0; 944 fCutMax[ivar][ibinS-1] = fTmpCutMax[ivar];; 945 }; 946 }; 947 ; 948 // caution (!) this value is not good for a decision for MC, .. it is designed for GA; 949 // but .. it doesn't matter, as MC samplings are independent from the former ones; 950 // and the replacement of the best variables by better ones is done about 10 lines above.; 951 // ( if (effBH < 0 || effBH > effB) { .... ); 952 ; 953 if (ibinS<=1) {; 954 // add penalty for effS=0 bin; 955 // to avoid that the minimizer gets stuck in the zero-bin; 956 // force it towards higher efficiency; 957 Double_t penalty=0.,diff=0.;; 958 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 959 diff=(fCutRange[ivar]->GetMax()-fTmpCutMax[ivar])/(fCutRange[ivar]->GetMax()-fCutRange[ivar]->GetMin());; 960 penalty+=diff*diff;; 961 diff=(fCutRange[ivar]->GetMin()-fTmpCutMin[ivar])/(fCutRange[ivar]->GetMax()-fCutRange[ivar]->GetMin());; 962 penalty+=4.*diff*diff;; 963 }; 964 ; 965 if (effS<1.e-4) return 10.0+penalty;; 966 else return 10.*(1.-10.*effS);; 967 }; 968 return eta;; 969}; 970 ; 971////////////////////////////////////////////////////////////////////////////////; 972/// translates parameters into cuts; 973 ; 974void TMVA::MethodCuts::MatchParsToCuts( const std::vector<Double_t> & pars,; 975 Double_t* cutMin, Double_t* cutMax ); 976{; 977 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 978 Int_t ipar = 2*ivar;; 979 cutMin[ivar] = ((*fRangeSign)[ivar] > 0) ? pars[ipar] : pars[ipar] - pars[ipar+1];; 980 cutMax[ivar] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:35564,avoid,avoid,35564,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TGeoBBox; Double_t fDX;  ; Double_t fDY;  ; Double_t fDZ;  ; Double_t fOrigin [3];  ;  Protected Attributes inherited from TGeoShape; UInt_t fShapeBits;  ; Int_t fShapeId;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TGeoCompositeShape.h>. Inheritance diagram for TGeoCompositeShape:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoCompositeShape() [1/5]. TGeoCompositeShape::TGeoCompositeShape ; (; const TGeoCompositeShape & ; ). protecteddelete . ◆ TGeoCompositeShape() [2/5]. TGeoCompositeShape::TGeoCompositeShape ; (; ). Default constructor. ; Definition at line 218 of file TGeoCompositeShape.cxx. ◆ TGeoCompositeShape() [3/5]. TGeoCompositeShape::TGeoCompositeShape ; (; const char * ; name, . const char * ; expression . ). Default constructor. ; Definition at line 227 of file TGeoCompositeShape.cxx. ◆ TGeoCompositeShape() [4/5]. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:32710,detect,detection,32710,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['detect'],['detection']
Safety,"(2,0,10*rms);; 376 ; 377 ; 378#ifdef DEBUG; 379 std::cout << ""Gaussian initial par values"" << constant << "" "" << mean << "" "" << rms << std::endl;; 380#endif; 381 ; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385/// Compute Initial values of parameters for a gaussian; 386/// derived from function H1InitGaus defined in TH1.cxx; 387 ; 388void Init2DGaus(const ROOT::Fit::BinData & data, TF1 * f1); 389{; 390 ; 391 static const double sqrtpi = 2.506628;; 392 ; 393 // - Compute mean value and RMS of the data; 394 unsigned int n = data.Size();; 395 if (n == 0) return;; 396 double sumx = 0, sumy = 0;; 397 double sumx2 = 0, sumy2 = 0;; 398 double allcha = 0;; 399 double valmax = 0;; 400 double rangex = data.Coords(n-1)[0] - data.Coords(0)[0];; 401 double rangey = data.Coords(n-1)[1] - data.Coords(0)[1];; 402 // to avoid binwidthx = 0 set arbitrarly to 1; 403 double binwidthx = 1, binwidthy = 1;; 404 if ( rangex > 0) binwidthx = rangex;; 405 if ( rangey > 0) binwidthy = rangey;; 406 double x0 = 0, y0 = 0;; 407 for (unsigned int i = 0; i < n; ++i) {; 408 double val;; 409 const double *coords = data.GetPoint(i,val);; 410 double x = coords[0], y = coords[1];; 411 sumx += val*x;; 412 sumy += val*y;; 413 sumx2 += val*x*x;; 414 sumy2 += val*y*y;; 415 allcha += val;; 416 if (val > valmax) valmax = val;; 417 if (i > 0) {; 418 double dx = x - x0;; 419 if (dx < binwidthx) binwidthx = dx;; 420 double dy = y - y0;; 421 if (dy < binwidthy) binwidthy = dy;; 422 }; 423 x0 = x;; 424 y0 = y;; 425 }; 426 ; 427 if (allcha <= 0) return;; 428 double meanx = sumx/allcha, meany = sumy/allcha;; 429 double rmsx = sumx2/allcha - meanx*meanx;; 430 double rmsy = sumy2/allcha - meany*meany;; 431 ; 432 ; 433 if (rmsx > 0); 434 rmsx = std::sqrt(rmsx);; 435 else; 436 rmsx = binwidthx*n/4;; 437 ; 438 if (rmsy > 0); 439 rmsy = std::sqrt(rmsy);; 440 else; 441 rmsy = binwidthy*n/4;; 442 ; 443 ; 444 //if the distribution is really gaussian, the best approximatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:13215,avoid,avoid,13215,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(999999). ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInside(). Double_t TGeoTube::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInside_v(). void TGeoTube::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInsideS(). static Double_t TGeoTube::DistFromInsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). static . ◆ DistFromOutside(). Double_t TGeoTube::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromOutside_v(). void TGeoTube::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromOutsideS(). static Double_t TGeoTube::DistFromOutsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). static . ◆ DistToTube(). static void TGeoTube::DistToTube ; (; Double_t ; rsq, . Double_t ; nsq, . Double_t ; rdotn, . Double_t ; radius, . Double_t & ; b, . Double_t & ; delta . ). static . ◆ Divide(). TGeoVolume * TGeoTube::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ GetAxi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:26558,safe,safe,26558,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['safe'],['safe']
Safety,"(; Ssiz_t ; nc). Return string capacity. ; If nc != current capacity Clone() the string in a string with the desired capacity. ; Definition at line 442 of file TString.cxx. ◆ Chop(). TString & TString::Chop ; (; ). inline . Definition at line 691 of file TString.h. ◆ Class(). static TClass * TString::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:25427,abort,abort,25427,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['abort'],['abort']
Safety,"(Double_t *param);  ;  TGeoPara (Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi);  ;  ~TGeoPara () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha () const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi () const;  ; Double_t GetTheta () const;  ; Double_t GetTxy () const;  ; Double_t GetTxz () const;  ; Double_t GetTyz () const;  ; Double_t GetX () const;  ; Double_t GetY () const;  ; Double_t GetZ () const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:1513,safe,safe,1513,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety,"(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:9986,avoid,avoid,9986,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,4,['avoid'],['avoid']
Safety,"(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:8936,safe,safe,8936,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,2,['safe'],"['safe', 'safety']"
Safety,"(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoIntersection.html:9036,safe,safe,9036,root/html530/TGeoIntersection.html,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html,2,['safe'],"['safe', 'safety']"
Safety,"(TTree *t). Called every time a new TTree is attached.; void TSelector::SlaveBegin(). Create e.g. histograms in this method. This method is called (with or without PROOF) before looping on the entries in the Tree. When using PROOF, this method is called on each worker node.; void TSelector::Begin(). Mostly for backward compatibility; use SlaveBegin() instead. Both methods are called before looping on the entries in the Tree. When using PROOF, Begin() is called on the client only.; bool TSelector::Notify(). This method is called at the first entry of a new file in a chain.; bool TSelector::Process(Long64_t entry). This method is called to process an entry. It is the user's responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the entry is selected histograms can be filled. Processing stops when this function returns false. This function combines the next two functions in one, avoiding to have to maintain state in the class to communicate between these two functions. See WARNING below about entry. This method is used by PROOF.; bool TSelector::ProcessCut(Long64_t entry). This method is called before processing entry. It is the user's responsibility to read the corresponding entry in memory (may be just a partial read). The function returns true if the entry must be processed, false otherwise. This method is obsolete, use Process(). See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called for all selected entries. User fills histograms in this function. This method is obsolete, use Process(). See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of the loop on all PROOF worker nodes. In local mode this method is called on the client too.; void TSelector::Terminate(). This method is called at the end of the loop on all entries. When using PROOF Terminate() is call on the client only. Typicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:1495,avoid,avoiding,1495,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['avoid'],['avoiding']
Safety,"(arg*arg * halfBySigmaSq);; + output[i] = RooBatchCompute::fast_exp(arg*arg * halfBySigmaSq);; Unbiased binned fits; When RooFit performs binned fits, it takes the probability density at the bin centre as a proxy for the probability in the bin. This can lead to a bias. To alleviate this, the new class RooBinSamplingPdf has been added to RooFit. Also see arxiv:2012.02746.; More accurate residual and pull distributions; When making residual or pull distributions with RooPlot::residHist or RooPlot::pullHist, the histogram is now compared with the curve’s average values within a given bin by default, ensuring that residual and pull distributions are valid for strongly curved distributions. The old default behaviour was to interpolate the curve at the bin centres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the minimiser. The minimiser can use this to compute a gradient to find its way out of the undefined region. This can drastically improve its ability to recover when unstable fit models are used, for example RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in deri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:21675,recover,recovery,21675,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['recover'],['recovery']
Safety,"(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed, so there's no need to; sync() them manually. Int_t SysStat(Int_t fd, Long_t* i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:24184,timeout,timeout,24184,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,3,['timeout'],['timeout']
Safety,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html:6895,avoid,avoid,6895,root/html602/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html,10,['avoid'],['avoid']
Safety,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html:6826,avoid,avoid,6826,root/html534/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html,6,['avoid'],['avoid']
Safety,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:6895,avoid,avoid,6895,root/html604/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html,10,['avoid'],['avoid']
Safety,"(const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:12424,recover,recover,12424,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recover']
Safety,"(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:10085,abort,abort,10085,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,1,['abort'],['abort']
Safety,"(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:17318,timeout,timeout,17318,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,2,['timeout'],['timeout']
Safety,"(default: http://consult.cern.ch/xwho/people?); Root.Html.XWho:; If set to Doc++, allow method documentation in front of method even for methods in the source file (default: """"); Root.Html.DescriptionStyle:; Search path for the source and header files with their default settings:; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; URL stem for ROOT documentation pages (default is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1260088,detect,detecting,1260088,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detecting']
Safety,"(delta);; 9639 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP{typedDelta};; 9640 gCoreMutex->Apply(std::move(typedDelta->fDelta));; 9641 // Now that we have the lock, update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 std::swap(uniqueP->fInitialState, fInitialMutex);; 9670 uniqueP->fDelta = gCoreMutex->Rewind(*uniqueP->fInitialState.fState);; 9671 return uniqueP.release();; 9672 }; 9673 R__ASSERT(fInitialMutex.fRecurseCount == 0);; 9674 return nullptr;; 9675}; ClingRAII.h; R__EXTERN#define R_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:373393,safe,safety,373393,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safety']
Safety,"(nout == 0 || nout >= fObjlen) { //this happens when the buffer cannot be compressed; 265 delete[] fBuffer;; 266 bufcur = nullptr;; 267 fBuffer = fBufferRef->Buffer();; 268 Create(fObjlen);; 269 fBufferRef->SetBufferOffset(0);; 270 Streamer(*fBufferRef); //write key itself again; 271 return;; 272 }; 273 bufcur += nout;; 274 noutot += nout;; 275 objbuf += kMAXZIPBUF;; 276 nzip += kMAXZIPBUF;; 277 }; 278 Create(noutot);; 279 fBufferRef->SetBufferOffset(0);; 280 Streamer(*fBufferRef); //write key itself again; 281 memcpy(fBuffer,fBufferRef->Buffer(),fKeylen);; 282 delete fBufferRef; fBufferRef = 0;; 283 } else {; 284 fBuffer = fBufferRef->Buffer();; 285 Create(fObjlen);; 286 fBufferRef->SetBufferOffset(0);; 287 Streamer(*fBufferRef); //write key itself again; 288 }; 289}; 290 ; 291////////////////////////////////////////////////////////////////////////////////; 292/// Create a TKey object for any object obj of class cl d and fill; 293/// output buffer.; 294///; 295/// WARNING: in name avoid special characters like '^','$','.' that are used; 296/// by the regular expression parser (see TRegexp).; 297 ; 298TKey::TKey(const void *obj, const TClass *cl, const char *name, Int_t bufsize, TDirectory* motherDir); 299 : TNamed(name, ""object title""); 300{; 301 R__ASSERT(obj && cl);; 302 ; 303 if (!cl->HasDefaultConstructor()) {; 304 Warning(""TKey"", ""since %s has no public constructor\n""; 305 ""\twhich can be called without argument, objects of this class\n""; 306 ""\tcan not be read with the current library. You will need to\n""; 307 ""\tadd a default constructor before attempting to read it."",; 308 cl->GetName());; 309 }; 310 ; 311 TClass *clActual = cl->GetActualClass(obj);; 312 const void* actualStart;; 313 if (clActual) {; 314 const char *temp = (const char*) obj;; 315 // clActual->GetStreamerInfo();; 316 Int_t offset = (cl != clActual) ?; 317 clActual->GetBaseClassOffset(cl) : 0;; 318 temp -= offset;; 319 actualStart = temp;; 320 } else {; 321 // We could not determine the real ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:10679,avoid,avoid,10679,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(nullptr); return 1; }; 82 Int_t CleanUp() override { WriteUnLock(nullptr); return 1; }; 83 ; 84 virtual std::unique_ptr<State> GetStateBefore() = 0;; 85 virtual std::unique_ptr<StateDelta> Rewind(const State& earlierState) = 0;; 86 virtual void Apply(std::unique_ptr<StateDelta> &&delta) = 0;; 87 ; 88 TVirtualRWMutex *Factory(Bool_t /*recursive*/ = kFALSE) override = 0;; 89 ; 90 ClassDefOverride(TVirtualRWMutex, 0) // Virtual mutex lock class; 91};; 92 ; 93//////////////////////////////////////////////////////////////////////////; 94// //; 95// TReadLockGuard //; 96// //; 97// This class provides RW mutex resource management in a guaranteed and //; 98// exception safe way. Use like this: //; 99// { //; 100// TReadLockGuard guard(mutex); //; 101// ... // read something //; 102// } //; 103// where mutex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itself. //; 109// //; 110//////////////////////////////////////////////////////////////////////////; 111 ; 112class TReadLockGuard {; 113 ; 114private:; 115 TVirtualRWMutex *const fMutex;; 116 TVirtualRWMutex::Hint_t *fHint;; 117 ; 118 TReadLockGuard(const TReadLockGuard&) = delete;; 119 TReadLockGuard& operator=(const TReadLockGuard&) = delete;; 120 ; 121public:; 122 TReadLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 123 if (fMutex) fHint = fMutex->ReadLock();; 124 }; 125 ; 126 ~TReadLockGuard() { if (fMutex) fMutex->ReadUnLock(fHint); }; 127 ; 128 ClassDefNV(TReadLockGuard,0) // Exception safe read locking/unlocking of mutex; 129};; 130 ; 131class TWriteLockGuard {; 132 ; 133private:; 134 TVirtualRWMutex *const fMutex;; 135 TVirtualRWMutex::Hint_t *fHint;; 136 ; 137 TWriteLockGuard(const TWrite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:3996,safe,safe,3996,doc/master/TVirtualRWMutex_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html,2,['safe'],['safe']
Safety,"(quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2-36. At most 64 bit data can be converted.; 2193 ; 2194TString TString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); 2195{; 2196 TString s_out = ""!"" ; // return value in case of issue; 2197 // checking base range; 2198 if (base_in < 2 || base_in > 36 || base_out < 2 || base_out > 36) {; 2199 Error(""TString::BaseConvert"", ""only bases 2-36 are supported (base_in=%d, base_out=%d)."", base_in, base_out);; 2200 return (s_out);; 2201 }; 2202 // cleaning s_in; 2203 TString s_in_ = s_in;; 2204 Bool_t isSigned = kFALSE;; 2205 if (s_in_[0] == '-') {; 2206 isSigned = kTRUE;; 2207 s_in_.Remove(0, 1);; 2208 }; 2209 if (!isSigned && s_in_[0] == '+') s_in_.Remove(0, 1); // !isSigned to avoid strings beginning with ""-+""; 2210 if (base_in == 16 && s_in_.BeginsWith(""0x"")) s_in_.Remove(0, 2); // removing hex prefix if any; 2211 s_in_ = TString(s_in_.Strip(TString::kLeading, '0')); // removing leading zeros (necessary for length comparison below); 2212 if (!s_in_.Length()) s_in_ += '0';; 2213 // checking s_in_ is expressed in the mentioned base; 2214 if (!s_in_.IsInBaseN(base_in)) {; 2215 Error(""TString::BaseConvert"", ""s_in=\""%s\"" is not in base %d"", s_in.Data(), base_in);; 2216 return (s_out);; 2217 }; 2218 // checking s_in <= 64 bits; 2219 TString s_max = TString::ULLtoa(18446744073709551615ULL, base_in);; 2220 if (s_in_.Length() > s_max.Length()) {; 2221 // string comparison (s_in_>s_max) does not take care of length; 2222 Error(""TString::BaseConvert"", ""s_in=\""%s\"" > %s = 2^64-1 in base %d."", s_in.Data(), s_max.Data(), base_in);; 2223 return (s_out);; 2224 } else if (s_in_.Length() == s_max.Length()) {; 2225 // if ( s_in_.Length() < s_max.Length() ) everything's fine; 2226 s_in_.ToLower(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:70387,avoid,avoid,70387,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D, E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ""unnecessary"" volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:33030,avoid,avoid,33030,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7345 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:36550,safe,safe,36550,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety,"(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7412 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:37131,safe,safe,37131,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety,"(the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; the class is deleted. void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Double_t& f, const Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:18855,predict,prediction,18855,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,2,['predict'],['prediction']
Safety,") / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6216#if defined(USE_MBEDTLS); 6217 } else if (conn->ssl != NULL) {; 6218 struct mg_pollfd pfd[1];; 6219 int to_read;; 6220 int pollres;; 6221 ; 6222 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:180409,timeout,timeout,180409,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,") / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6217#if defined(USE_MBEDTLS); 6218 } else if (conn->ssl != NULL) {; 6219 struct mg_pollfd pfd[1];; 6220 int to_read;; 6221 int pollres;; 6222 ; 6223 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:180441,timeout,timeout,180441,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,") = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:173578,timeout,timeout,173578,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,") const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetPoints (Double_t *points) const override;  No mesh for assemblies. ;  ; void SetPoints (Float_t *points) const override;  No mesh for assemblies. ;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  Fill TBuffer3D structure for segments and polygons. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Double_t Capacity () const override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:5069,avoid,avoid,5069,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['avoid'],['avoid']
Safety,") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:3963,safe,safe,3963,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,") const; voidRooAbsCollection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSetProxy.html:11428,safe,safeDeleteList,11428,root/html526/RooSetProxy.html,https://root.cern,https://root.cern/root/html526/RooSetProxy.html,2,['safe'],['safeDeleteList']
Safety,") const; { return fTopSessionTag; }. const char * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. const char * GetDataDirOpts() const; { return fDataDirOpts; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofServ.html:35684,timeout,timeout,35684,root/html604/TProofServ.html,https://root.cern,https://root.cern/root/html604/TProofServ.html,1,['timeout'],['timeout']
Safety,") const; { return fTopSessionTag; }. const char * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. const char * GetDataDirOpts() const; { return fDataDirOpts; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:35682,timeout,timeout,35682,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,1,['timeout'],['timeout']
Safety,") const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerObject.html:3050,detect,detected,3050,doc/master/classTStreamerObject.html,https://root.cern,https://root.cern/doc/master/classTStreamerObject.html,2,['detect'],['detected']
Safety,") elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; ; void h1analysis::SlaveBegin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; //initialize the Tree branch addresses; Init(tree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.Data(), tree);; ; //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList"")) useList = kTRUE;; }; ; ; Bool_t h1analysis::Process(Long64_t entry); {; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; ; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Read only the necessary branches to select entries.; // return as soon as a bad entry is detected; // to read complete event, call fChain->GetTree()->GetEntry(entry); b_md0_d->GetEntry(entry); if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; b_ptds_d->GetEntry(entry); if (ptds_d <= 2.5) return kFALSE;; b_etads_d->GetEntry(entry); if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; b_ik->GetEntry(entry); ik--; //original ik used f77 convention starting at 1; b_ipi->GetEntry(entry); ipi--;; b_ntracks-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:8714,avoid,avoid,8714,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['avoid'],['avoid']
Safety,") only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110158,timeout,timeout,1110158,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['timeout'],['timeout']
Safety,") {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""Internal error"");; 17742 *err = 500;; 17743 return 0;; 17744 }; 17745 ; 17746 /* Set the time the request was received. This value should be used for; 17747 * timeouts. */; 17748 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17749 ; 17750 conn->request_len =; 17751 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17752 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17753 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17754 mg_snprintf(conn,; 17755 NULL, /* No truncation check for ebuf */; 17756 ebuf,; 17757 ebuf_len,; 17758 ""%s"",; 17759 ""Invalid message size"");; 17760 *err = 500;; 17761 return 0;; 17762 }; 17763 ; 17764 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17765 mg_snprintf(conn,; 17766 NULL, /* No truncation check for ebuf */; 17767 ebuf,; 17768 ebuf_len,; 17769 ""%s"",; 17770 ""Message too large"");; 17771 *err = 413;; 17772 return 0;; 17773 }; 17774 ; 17775 if (conn->request_len <= 0) {; 17776 if (conn->data_len > 0) {; 17777 mg_snprintf(conn,; 17778 NULL, /* No truncation check for ebuf */; 17779 ebuf,; 17780 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:527410,timeout,timeouts,527410,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety,") {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""Internal error"");; 17743 *err = 500;; 17744 return 0;; 17745 }; 17746 ; 17747 /* Set the time the request was received. This value should be used for; 17748 * timeouts. */; 17749 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17750 ; 17751 conn->request_len =; 17752 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17753 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17754 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17755 mg_snprintf(conn,; 17756 NULL, /* No truncation check for ebuf */; 17757 ebuf,; 17758 ebuf_len,; 17759 ""%s"",; 17760 ""Invalid message size"");; 17761 *err = 500;; 17762 return 0;; 17763 }; 17764 ; 17765 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17766 mg_snprintf(conn,; 17767 NULL, /* No truncation check for ebuf */; 17768 ebuf,; 17769 ebuf_len,; 17770 ""%s"",; 17771 ""Message too large"");; 17772 *err = 413;; 17773 return 0;; 17774 }; 17775 ; 17776 if (conn->request_len <= 0) {; 17777 if (conn->data_len > 0) {; 17778 mg_snprintf(conn,; 17779 NULL, /* No truncation check for ebuf */; 17780 ebuf,; 17781 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:527443,timeout,timeouts,527443,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety,") {; 351 Error(""TPad"", ""illegal height: %f"", yup-ylow);; 352 zombie = kTRUE;; 353 }; 354 ; 355 if (zombie) {; 356 // error in creating pad occurred, make this pad a zombie; 357 MakeZombie();; 358 return;; 359 }; 360 ; 361 ; 362 fLogx = gStyle->GetOptLogx();; 363 fLogy = gStyle->GetOptLogy();; 364 fLogz = gStyle->GetOptLogz();; 365 ; 366 fUxmin = fUymin = fUxmax = fUymax = 0;; 367 ; 368 // Set pad parameters and Compute conversion coefficients; 369 SetPad(name, title, xlow, ylow, xup, yup, color, bordersize, bordermode);; 370 Range(0, 0, 1, 1);; 371 SetBit(kMustCleanup);; 372 SetBit(kCanDelete);; 373}; 374 ; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 auto primitives = fPrimitives;; 386 // In some cases, fPrimitives has the kMustCleanup bit set which will lead; 387 // its destructor to call RecursiveRemove and since this pad is still; 388 // likely to be (indirectly) in the list of cleanups, we must set; 389 // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; 390 // a member function of a partially destructed object.; 391 fPrimitives = nullptr;; 392 delete primitives;; 393 SafeDelete(fExecs);; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:11473,avoid,avoid,11473,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety,") {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree0_8C.html:2747,detect,detector,2747,doc/master/tree0_8C.html,https://root.cern,https://root.cern/doc/master/tree0_8C.html,1,['detect'],['detector']
Safety,") || (n > fMaximum)) {; 4281 if (IsMissingCollection()) {; 4282 n = 0;; 4283 b.SetBufferOffset(b.Length()-sizeof(n));; 4284 } else {; 4285 Error(""ReadLeaves"", ""Incorrect size read for the container in %s\n\tThe size read is %d while the maximum is %d\n\tThe size is reset to 0 for this entry (%lld)"", GetName(), n, fMaximum, GetReadEntry());; 4286 n = 0;; 4287 }; 4288 }; 4289 fNdata = n;; 4290 ; 4291 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4292 ; 4293 // Note: Proxy-helper needs to ""embrace"" the entire; 4294 // streaming of this STL container if the container; 4295 // is a set/multiset/map/multimap (what we do not; 4296 // know here).; 4297 // For vector/list/deque Allocate == Resize; 4298 // and Commit == noop.; 4299 // TODO: Exception safety a la TPushPop; 4300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:158942,safe,safety,158942,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['safe'],['safety']
Safety,")); , kHelixStraight = (1ULL << ( 17 )); , kHelixCircle = (1ULL << ( 18 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGeoHelix ();  Dummy constructor. ;  ;  TGeoHelix (Double_t curvature, Double_t step, Int_t charge=1);  Normal constructor. ;  ;  ~TGeoHelix () override;  Destructor. ;  ; Double_t ComputeSafeStep (Double_t epsil=1E-6) const;  Compute safe linear step that can be made such that the error between linear-helix extrapolation is less than EPSIL. ;  ; const Double_t * GetCurrentDirection () const;  ; const Double_t * GetCurrentPoint () const;  ; Double_t GetStep () const;  ; Double_t GetTotalCurvature () const;  Compute helix total curvature. ;  ; Double_t GetXYcurvature () const;  ; void InitDirection (Double_t *dir, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitDirection (Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitPoint (Double_t *point);  Set initial point on the helix. ;  ; void InitPoint (Double_t x0, Double_t y0, Double_t z0);  Initialize coordinates of a point on the helix. ;  ; TClass * IsA () const override;  ; Bool_t IsRightHanded () const;  ; void ResetStep ();  Reset current point/direction to initial values. ;  ; void SetCharge (Int_t charge);  Po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:2759,safe,safe,2759,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['safe'],['safe']
Safety,")); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:139287,safe,safe,139287,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,")); 3714 return fBase;; 3715 }; 3716 }; 3717 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3718 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3719 LoadClassInfo();; 3720 }; 3721 }; 3722 if (!fClassInfo); 3723 return nullptr;; 3724 ; 3725 if (!gInterpreter); 3726 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3727 ; 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 if (!fBase.load()) {; 3730 gInterpreter->CreateListOfBaseClasses(this);; 3731 }; 3732 }; 3733 return fBase;; 3734}; 3735 ; 3736////////////////////////////////////////////////////////////////////////////////; 3737/// Return a list containing the TEnums of a class.; 3738///; 3739/// The list returned is safe to use from multiple thread without explicitly; 3740/// taking the ROOT global lock.; 3741///; 3742/// In the case the TClass represents a namespace, the returned list will; 3743/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3744///; 3745/// In the case the TClass represents a class or struct and requestListLoading; 3746/// is true, the list is immutable (and thus safe to access from multiple thread; 3747/// without taking the global lock at all).; 3748///; 3749/// In the case the TClass represents a class or struct and requestListLoading; 3750/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3751/// which will implicit take the ROOT global lock upon any access.; 3752 ; 3753TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3754{; 3755 auto temp = fEnums.load();; 3756 if (temp) {; 3757 if (requestListLoading) {; 3758 if (fProperty == -1) Property();; 3759 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3760 R__LOCKGUARD(gROOTMutex);; 3761 temp->Load();; 3762 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3763 // We have a class for which the list was not loaded fully at; 3764 // first use.; 3765 R__LOCKGUARD(gROOTMutex);; 3766 temp->Load();; 3767 }; 3768 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:142038,safe,safe,142038,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,")*.001;; 6137 ymax += dyy;; 6138 ymin -= dyy;; 6139 mnbins(ymin, ymax, maxny, ymin, ymax, ny, bwidy);; 6140 any = (Double_t) ny;; 6141 // if first point is blank, it is an 'origin'; 6142 if (chbest == ' ') goto L50;; 6143 xbest = (xmax + xmin)*.5;; 6144 ybest = (ymax + ymin)*.5;; 6145L50:; 6146 // find scale constants; 6147 ax = 1 / bwidx;; 6148 ay = 1 / bwidy;; 6149 bx = -ax*xmin + 2;; 6150 by = -ay*ymin - 2;; 6151 // convert points to grid positions; 6152 for (i = 1; i <= nxypt; ++i) {; 6153 xpt[i-1] = ax*xpt[i-1] + bx;; 6154 ypt[i-1] = any - ay*ypt[i-1] - by;; 6155 }; 6156 nxbest = Int_t((ax*xbest + bx));; 6157 nybest = Int_t((any - ay*ybest - by));; 6158 // print the points; 6159 ny += 2;; 6160 nx += 2;; 6161 isp1 = 1;; 6162 linodd = 1;; 6163 overpr = kFALSE;; 6164 for (i = 1; i <= ny; ++i) {; 6165 for (ibk = 1; ibk <= nx; ++ibk) { cline[ibk-1] = ' '; }; 6166 cline[nx] = '\0';; 6167 cline[nx+1] = '\0';; 6168 cline[0] = '.';; 6169 // not needed - but to avoid a wrongly reported compiler warning (see ROOT-6496); 6170 if (nx>0) cline[nx-1] = '.';; 6171 cline[nxbest-1] = '.';; 6172 if (i != 1 && i != nybest && i != ny) goto L320;; 6173 for (j = 1; j <= nx; ++j) { cline[j-1] = '.'; }; 6174L320:; 6175 yprt = ymax - Double_t(i-1)*bwidy;; 6176 if (isp1 > nxypt) goto L350;; 6177 // find the points to be plotted on this line; 6178 for (k = isp1; k <= nxypt; ++k) {; 6179 ks = Int_t(ypt[k-1]);; 6180 if (ks > i) goto L345;; 6181 ix = Int_t(xpt[k-1]);; 6182 if (cline[ix-1] == '.') goto L340;; 6183 if (cline[ix-1] == ' ') goto L340;; 6184 if (cline[ix-1] == chpt[k-1]) continue;; 6185 overpr = kTRUE;; 6186 // OVERPR is true if one or more positions contains more than; 6187 // one point; 6188 cline[ix-1] = '&';; 6189 continue;; 6190L340:; 6191 cline[ix-1] = chpt[k-1];; 6192 }; 6193 isp1 = nxypt + 1;; 6194 goto L350;; 6195L345:; 6196 isp1 = k;; 6197L350:; 6198 if (linodd == 1 || i == ny) goto L380;; 6199 linodd = 1;; 6200 ctemp = cline;; 6201 Printf("" %s"",(const char*)ctemp);; 62",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:200131,avoid,avoid,200131,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['avoid'],['avoid']
Safety,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21263,avoid,avoid,21263,root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,3,['avoid'],['avoid']
Safety,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20374,avoid,avoid,20374,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['avoid'],['avoid']
Safety,"). Int_t TGeoBBox::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Implements TGeoShape.; Reimplemented in TGeoTessellated, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ DistFromInside() [1/2]. static Double_t TGeoBBox::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . const Double_t * ; origin, . Double_t ; stepmax = TGeoShape::Big() . ). static . ◆ DistFromInside() [2/2]. Double_t TGeoBBox::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromInside_v(). void TGeoBBox::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ DistFromOutside() [1/2]. static Double_t TGeoBBox::DistFromOutside ; (; const Double_t * ; point, . const Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:26446,safe,safe,26446,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['safe'],['safe']
Safety,"). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ◆ SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const & ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. ◆ SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_t ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. ◆ Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. ◆ TestVoxelGrid(). void TGeoPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26282,safe,safety,26282,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"). private:. virtual void*GetSender(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSysEvtHandler.html:9470,avoid,avoid,9470,root/html534/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html534/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"). template<> . double TMVA::DNN::computeRegularization< EnumRegularization::L1 > ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . Definition at line 219 of file NeuralNet.icc. ◆ computeRegularization< EnumRegularization::L2 >(). template<> . double TMVA::DNN::computeRegularization< EnumRegularization::L2 > ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . Definition at line 226 of file NeuralNet.icc. ◆ crossEntropy(). template<typename ItProbability , typename ItTruth , typename ItDelta , typename ItInvActFnc > . double TMVA::DNN::crossEntropy ; (; ItProbability ; itProbabilityBegin, . ItProbability ; itProbabilityEnd, . ItTruth ; itTruthBegin, . ItTruth ; , . ItDelta ; itDelta, . ItDelta ; itDeltaEnd, . ItInvActFnc ; , . double ; patternWeight . ). cross entropy error function ; Definition at line 412 of file NeuralNet.icc. ◆ cudaError(). void TMVA::DNN::cudaError ; (; cudaError_t ; code, . const char * ; file, . int ; line, . bool ; abort = true . ). inline . Function to check cuda return code. ; Taken from http://stackoverflow.com/questions/14038589/ ; Definition at line 198 of file CudaMatrix.h. ◆ CurandInitializationKernel(). __global__ void TMVA::DNN::CurandInitializationKernel ; (; unsigned long long ; seed, . curandState_t * ; state . ). Definition at line 26 of file CudaMatrix.cu. ◆ debugTensor(). template<typename Architecture > . auto TMVA::DNN::debugTensor ; (; const typename Architecture::Tensor_t & ; A, . const std::string ; name = ""tensor"" . ); -> void. Definition at line 582 of file GeneralLayer.h. ◆ evaluate() [1/3]. template<typename Architecture_t > . auto TMVA::DNN::evaluate ; (; ELossFunction ; f, . const typename Architecture_t::Matrix_t & ; Y, . const typename Architecture_t::Matrix_t & ; output, . const typename Architecture_t::Matrix_t & ; weights . ); -> decltype(Architecture_t::CrossEntropy(Y, output, weights)). inline . Compute the value of the objective function f for given activations of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:27452,abort,abort,27452,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['abort'],['abort']
Safety,"). virtual void TVirtualPacketizer::MarkBad ; (; TSlave * ; , . TProofProgressStatus * ; , . TList ** ;  . ). inlinevirtual . Reimplemented in TPacketizerAdaptive, and TPacketizerMulti.; Definition at line 141 of file TVirtualPacketizer.h. ◆ operator=(). void TVirtualPacketizer::operator= ; (; const TVirtualPacketizer & ; ). protected . ◆ SetFailedPackets(). void TVirtualPacketizer::SetFailedPackets ; (; TList * ; list). inline . Definition at line 129 of file TVirtualPacketizer.h. ◆ SetInitTime(). void TVirtualPacketizer::SetInitTime ; (; ). virtual . Set the initialization time. ; Definition at line 429 of file TVirtualPacketizer.cxx. ◆ SetProgressStatus(). void TVirtualPacketizer::SetProgressStatus ; (; TProofProgressStatus * ; st). inline . Definition at line 145 of file TVirtualPacketizer.h. ◆ SetTotalEntries(). void TVirtualPacketizer::SetTotalEntries ; (; Long64_t ; ent). inline . Definition at line 146 of file TVirtualPacketizer.h. ◆ StopProcess(). void TVirtualPacketizer::StopProcess ; (; Bool_t ; abort, . Bool_t ; stoptimer = kFALSE . ). virtual . Stop process. ; Reimplemented in TPacketizerMulti.; Definition at line 243 of file TVirtualPacketizer.cxx. ◆ Streamer(). void TVirtualPacketizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TVirtualPacketizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 152 of file TVirtualPacketizer.h. Member Data Documentation. ◆ fActWrksLast. Int_t TVirtualPacketizer::fActWrksLast. protected . Definition at line 90 of file TVirtualPacketizer.h. ◆ fAWLastFill. Bool_t TVirtualPacketizer::fAWLastFill. protected . Definition at line 94 of file TVirtualPacketizer.h. ◆ fCircN. Long_t TVirtualPacketizer::fCircN. protected . Definition at line 86 of file TVirtualPacketizer.h. ◆ fCircProg. TNtupleD* TVirtualPacketizer::fCircProg. protected . Definition at line 84 of file TVirtualPacketizer.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualPacketizer.html:20922,abort,abort,20922,doc/master/classTVirtualPacketizer.html,https://root.cern,https://root.cern/doc/master/classTVirtualPacketizer.html,1,['abort'],['abort']
Safety,").; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXNetSystem.html:23228,avoid,avoid,23228,root/html534/TXNetSystem.html,https://root.cern,https://root.cern/root/html534/TXNetSystem.html,1,['avoid'],['avoid']
Safety,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:16121,avoid,avoid,16121,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['avoid'],['avoid']
Safety,"); 27 void *fWcsTitle{nullptr}; ///<!Used by TMathText; 28 ; 29public:; 30 // TText status bits; 31 enum {; 32 kTextNDC = BIT(14) ///< The text position is in the NDC space; 33 };; 34 ; 35 TText() {} // NOLINT: not allowed to use = default because of TObject::kIsOnHeap detection, see ROOT-10300; 36 TText(Double_t x, Double_t y, const char *text);; 37 TText(Double_t x, Double_t y, const wchar_t *text);; 38 TText(const TText &text);; 39 ~TText() override;; 40 ; 41 TText &operator=(const TText &src);; 42 ; 43 void Copy(TObject &text) const override;; 44 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 45 virtual TText *DrawText(Double_t x, Double_t y, const char *text);; 46 virtual TText *DrawText(Double_t x, Double_t y, const wchar_t *text);; 47 virtual TText *DrawTextNDC(Double_t x, Double_t y, const char *text);; 48 virtual TText *DrawTextNDC(Double_t x, Double_t y, const wchar_t *text);; 49 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 50 ; 51 virtual void GetControlBox(Int_t x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TText_8h_source.html:1252,detect,detection,1252,doc/master/TText_8h_source.html,https://root.cern,https://root.cern/doc/master/TText_8h_source.html,1,['detect'],['detection']
Safety,"); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:2806,redund,redundant,2806,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['redund'],['redundant']
Safety,"); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier; static Bool_tfgPromptUserkTRUE if user prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:9796,timeout,timeout,9796,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['timeout'],['timeout']
Safety,"); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf605_profilellDefinition rf605_profilell.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf605__profilell_8C.html:5829,safe,safe,5829,doc/master/rf605__profilell_8C.html,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html,1,['safe'],['safe']
Safety,"); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:19691,predict,prediction,19691,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,1,['predict'],['prediction']
Safety,"); const. finalvirtual . Interface to cling function. ; Implements TInterpreter.; Definition at line 8085 of file TCling.cxx. ◆ CheckClassInfo(). TInterpreter::ECheckClassInfo TCling::CheckClassInfo ; (; const char * ; name, . Bool_t ; autoload, . Bool_t ; isClassOrNamespaceOnly = kFALSE . ). finalvirtual . Checks if an entity with the specified name is defined in Cling. ; Returns kUnknown if the entity is not defined. Returns kWithClassDefInline if the entity exists and has a ClassDefInline Returns kKnown if the entity is defined.; By default, structs, namespaces, classes, enums and unions are looked for. If the flag isClassOrNamespaceOnly is true, classes, structs and namespaces only are considered. I.e. if the name is an enum or a union, the returned value is false.; In the case where the class is not loaded and belongs to a namespace or is nested, looking for the full class name is outputting a lots of (expected) error messages. Currently the only way to avoid this is to specifically check that each level of nesting is already loaded. In case of templates the idea is that everything between the outer '<' and '>' has to be skipped, e.g.: aap<pippo<noot>::klaas>::a_class ; Implements TInterpreter.; Definition at line 4177 of file TCling.cxx. ◆ CheckClassTemplate(). Bool_t TCling::CheckClassTemplate ; (; const char * ; name). finalvirtual . Return true if there is a class template by the given name ... ; Implements TInterpreter.; Definition at line 4349 of file TCling.cxx. ◆ ClassInfo_ClassProperty(). Long_t TCling::ClassInfo_ClassProperty ; (; ClassInfo_t * ; info); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8176 of file TCling.cxx. ◆ ClassInfo_Contains(). Bool_t TCling::ClassInfo_Contains ; (; ClassInfo_t * ; info, . DeclId_t ; declid . ); const. finalvirtual . Return true if the entity pointed to by 'declid' is declared in the context described by 'info'. ; If info is null, look into the global scope (translation unit scope). ; Im",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:67352,avoid,avoid,67352,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['avoid'],['avoid']
Safety,"); hh_model_3 = model_3.createHistogram(""hh_model_3"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model_4 = model_4.createHistogram(""hh_model_4"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model_1.SetLineColor(ROOT.kBlue); hh_model_2.SetLineColor(ROOT.kBlue); hh_model_3.SetLineColor(ROOT.kBlue); hh_model_4.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calcula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:3408,safe,safe,3408,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['safe'],['safe']
Safety,"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:2374,safe,safe,2374,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoBBox&operator=(const TGeoBBox&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidSetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:9989,safe,safe,9989,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCone.html:9014,safe,safe,9014,root/html602/TGeoCone.html,https://root.cern,https://root.cern/root/html602/TGeoCone.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCtub.html:9839,safe,safe,9839,root/html602/TGeoCtub.html,https://root.cern,https://root.cern/root/html602/TGeoCtub.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoEltu.html:8857,safe,safe,8857,root/html602/TGeoEltu.html,https://root.cern,https://root.cern/root/html602/TGeoEltu.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoGtra&operator=(const TGeoGtra&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:10017,safe,safe,10017,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPara&operator=(const TGeoPara&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPara.html:8508,safe,safe,8508,root/html602/TGeoPara.html,https://root.cern,https://root.cern/root/html602/TGeoPara.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrap&operator=(const TGeoTrap&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrap.html:9876,safe,safe,9876,root/html602/TGeoTrap.html,https://root.cern,https://root.cern/root/html602/TGeoTrap.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd1&operator=(const TGeoTrd1&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1.html:8469,safe,safe,8469,root/html602/TGeoTrd1.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd2&operator=(const TGeoTrd2&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd2.html:8505,safe,safe,8505,root/html602/TGeoTrd2.html,https://root.cern,https://root.cern/root/html602/TGeoTrd2.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTube.html:9311,safe,safe,9311,root/html602/TGeoTube.html,https://root.cern,https://root.cern/root/html602/TGeoTube.html,2,['safe'],['safe']
Safety,"); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:10900,timeout,timeout,10900,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"); virtual voidShowMembers(TMemberInspector& insp); RooAbsCollection*RooAbsCollection::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooArgList(); Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgList.html:11922,safe,safeDeleteList,11922,root/html532/RooArgList.html,https://root.cern,https://root.cern/root/html532/RooArgList.html,1,['safe'],['safeDeleteList']
Safety,"); virtual voidShowMembers(TMemberInspector& insp); RooAbsCollection*RooAbsCollection::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooArgList(); Default constructor. RooArgList(const RooArgSet& set); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgList.html:11860,safe,safeDeleteList,11860,root/html530/RooArgList.html,https://root.cern,https://root.cern/root/html530/RooArgList.html,1,['safe'],['safeDeleteList']
Safety,"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:2926,safe,safe,2926,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,1,['safe'],['safe']
Safety,"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:1946,safe,safe,1946,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,1,['safe'],['safe']
Safety,"); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSuperMaster.html:10951,abort,abort,10951,root/html528/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety,");. TGeoEltu Class. 18.3.2.11 Hyperboloids - TGeoHype Class; A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);. rmin1: internal radius at Z is -dz; rmax1: external radius at Z is -dz; rmin2: internal radius at Z is +dz; rmax2: external radius at Z is +dz; dz: half length in Z (a cone ranges from -dz to +dz). A cone has Z-axis as its symmetry axis. TGeoCone Class. 18.3.2.13 Cone Segments - TGeoConeSeg Class; A cone segment is a cone having a range in phi. The cone segment class derives from TGeoCone, having two extra parameters: phi1 and phi2.; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; Parametersphi1 and phi2 have the same meaning and co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:907214,avoid,avoid,907214,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,");; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:6162,avoid,avoids,6162,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoids']
Safety,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:13218,safe,safe,13218,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['safe'],['safe']
Safety,")` : return the sum of the value of the elements of the; 4217/// formula given as a parameter. For example the mean for all the elements in; 4218/// one entry can be calculated with: `Sum$(formula )/Length$(formula )`; 4219/// - `Min$(formula )` : return the minimum (within one TTree entry) of the value of the; 4220/// elements of the formula given as a parameter.; 4221/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:170043,avoid,avoid,170043,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,")b).PeekDataCache(),compinfo,i,i+1,narr,eoffset, arrayMode);; 159 }; 160 continue;; 161 } else {; 162 if (gDebug > 1) {; 163 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d,""; 164 "" %s, bufpos=%d, arr=%p, eoffset=%d, not a write rule, skipping.\n"",; 165 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 166 aElement->ClassName(),b.Length(),arr[0], eoffset);; 167 }; 168 // The rule was a cached element for a read, rule, the real offset is in the; 169 // next element (the one for the rule itself).; 170 if (aElement->TestBit(TStreamerElement::kRepeat)) continue;; 171 ioffset = eoffset+compinfo[i]->fOffset;; 172 continue;; 173 }; 174 }; 175 ; 176 if (gDebug > 1) {; 177 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d, %s, ""; 178 ""bufpos=%d, arr=%p, offset=%d\n"",; 179 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,aElement->ClassName(),; 180 b.Length(),arr[0],ioffset);; 181 }; 182 ; 183 switch (compinfo[i]->fType+typeOffset) {; 184 // In this switch we intentionally use 'continue' instead of; 185 // 'break' to avoid running the 2nd switch (see later in this; 186 // function).; 187 ; 188 case TStreamerInfo::kBool: WriteBasicType(Bool_t); continue;; 189 case TStreamerInfo::kChar: WriteBasicType(Char_t); continue;; 190 case TStreamerInfo::kShort: WriteBasicType(Short_t); continue;; 191 case TStreamerInfo::kInt: WriteBasicType(Int_t); continue;; 192 case TStreamerInfo::kLong: WriteBasicType(Long_t); continue;; 193 case TStreamerInfo::kLong64: WriteBasicType(Long64_t); continue;; 194 case TStreamerInfo::kFloat: WriteBasicType(Float_t); continue;; 195 case TStreamerInfo::kDouble: WriteBasicType(Double_t); continue;; 196 case TStreamerInfo::kUChar: WriteBasicType(UChar_t); continue;; 197 case TStreamerInfo::kUShort: WriteBasicType(UShort_t); continue;; 198 case TStreamerInfo::kUInt: WriteBasicType(UInt_t); continue;; 199 case TStreamerInfo::kULong: WriteBasicType(ULong_t); continue;; 200 case TStreamerInfo::kULong64: WriteBasicType(ULong64_t); con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:6251,avoid,avoid,6251,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety,"* 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; F_mj = sum_i [ (dX_m / dA_ij) * A_ij ]; G_mj = sum_i [ (dX_m / dA_ij) * Rsq_ij ]. In order to avoid explicitly calculating the 3-dimensional tensor; (dX_m/dA_ij) the sums are evaluated further, using; dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j. and. sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; + sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; - sum_i [ M1_mi * H_ni + M1_ni * H_mi]; where:; H_mi = Z0_i * sum_j [ M0_mj * Z1_j * Rsq_ij ]. collect all contributions:; Vxx_nm = r0 -r1 -r2 +r3 +r4 -r5 -r6; r0 = sum_j [ F_mj * F_nj * SRsq_j ]; r1 = sum_j [ G_mj * F_nj ]; r2 = sum_j [ F_mj * G_nj ]; r3 = sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; r4 = sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systemat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:23402,avoid,avoid,23402,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,3,['avoid'],['avoid']
Safety,"* Canvas(const TCanvas* canvas); static: return the TQtWidget backend for TCanvas *canvas object. TQtWidget * Canvas(Int_t id); static: return TQtWidget by TCanvas id. TApplication * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void RefreshCB(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:24933,avoid,avoid,24933,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['avoid'],['avoid']
Safety,"* Canvas(const TCanvas* canvas); static: return the TQtWidget backend for TCanvas *canvas object. TQtWidget * Canvas(Int_t id); static: return TQtWidget by TCanvas id. TApplication * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:8324,avoid,avoid,8324,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,3,['avoid'],['avoid']
Safety,"* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:2527,avoid,avoids,2527,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,1,['avoid'],['avoids']
Safety,"* motherDir) : TNamed(); 176{; 177 Build(motherDir, """", pointer);; 178 ; 179 fSeekKey = pointer;; 180 fNbytes = nbytes;; 181 fBuffer = new char[nbytes];; 182 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 183}; 184 ; 185////////////////////////////////////////////////////////////////////////////////; 186/// Create a TKey object with the specified name, title for the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Create a TKey object for a TObject* and fill output buffer; 219///; 220/// WARNING: in name avoid special characters like '^','$','.' that are used; 221/// by the regular expression parser (see TRegexp).; 222 ; 223TKey::TKey(const TObject *obj, const char *name, Int_t bufsize, TDirectory* motherDir); 224 : TNamed(name, obj->GetTitle()); 225{; 226 R__ASSERT(obj);; 227 ; 228 if (!obj->IsA()->HasDefaultConstructor()) {; 229 Warning(""TKey"", ""since %s has no public constructor\n""; 230 ""\twhich can be called without ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:7072,avoid,avoid,7072,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['avoid'],['avoid']
Safety,"* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:14672,safe,safe,14672,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,3,['safe'],['safe']
Safety,"* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:7798,safe,safe,7798,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['safe'],['safe']
Safety,"* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:26988,abort,abort,26988,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,2,['abort'],"['abort', 'aborts']"
Safety,"* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:26988,abort,abort,26988,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['abort'],"['abort', 'aborts']"
Safety,"* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:3041,safe,safe,3041,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,3,['safe'],['safe']
Safety,"***************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// values to the same resouce name. //; 42// //; 43// E.g.: //; 44// //; 45// Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib //; 46// myapp.Root.Debug:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8h_source.html:1327,avoid,avoid,1327,doc/master/TEnv_8h_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html,1,['avoid'],['avoid']
Safety,"*************/; 11 ; 12#include ""THttpServer.h""; 13 ; 14#include ""TThread.h""; 15#include ""TTimer.h""; 16#include ""TSystem.h""; 17#include ""TROOT.h""; 18#include ""TUrl.h""; 19#include ""TEnv.h""; 20#include ""TError.h""; 21#include ""TClass.h""; 22#include ""RConfigure.h""; 23#include ""TRegexp.h""; 24#include ""TObjArray.h""; 25 ; 26#include ""THttpEngine.h""; 27#include ""THttpLongPollEngine.h""; 28#include ""THttpWSHandler.h""; 29#include ""TRootSniffer.h""; 30#include ""TRootSnifferStore.h""; 31#include ""TCivetweb.h""; 32#include ""TFastCgi.h""; 33 ; 34#include <chrono>; 35#include <cstdlib>; 36#include <cstring>; 37#include <fstream>; 38#include <memory>; 39#include <string>; 40#include <thread>; 41 ; 42class THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are man",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:1934,timeout,timeout,1934,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['timeout'],['timeout']
Safety,"*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:38130,avoid,avoid,38130,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['avoid'],['avoid']
Safety,"*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TList*fPacketslist of packets processed packets; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIter(); Default constructor. TEventIter(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. TEventIter(). Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0). void PreProcessEvent(Long64_t ). TList * GetPackets(); { return fPackets; }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 09:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEventIter.html:7617,abort,abort,7617,root/html604/TEventIter.html,https://root.cern,https://root.cern/root/html604/TEventIter.html,1,['abort'],['abort']
Safety,"*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TList*fPacketslist of packets processed packets; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIter(); Default constructor. TEventIter(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. TEventIter(). Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0). void PreProcessEvent(Long64_t ). TList * GetPackets(); { return fPackets; }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIter.html:7617,abort,abort,7617,root/html602/TEventIter.html,https://root.cern,https://root.cern/root/html602/TEventIter.html,1,['abort'],['abort']
Safety,"*h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:40390,avoid,avoid,40390,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['avoid'],['avoid']
Safety,"*h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:38726,avoid,avoid,38726,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['avoid'],['avoid']
Safety,"*notmergeable = nullptr;; 205 Bool_t mergeable = kTRUE;; 206 while ((object = nextobject())) { // loop objects in this collection; 207 mergeable = kTRUE;; 208 // If current object has not dictionary just add it; 209 if (!object->IsA()) {; 210 mergeable = kFALSE;; 211 } else {; 212 // If current object is not mergeable just add it; 213 callEnv.InitWithPrototype(object->IsA(), ""Merge"", ""TCollection*"");; 214 if (!callEnv.IsValid()) mergeable = kFALSE;; 215 }; 216 if (mergeable) {; 217 // Current object mergeable - get corresponding objects in input lists; 218 templist = (TSeqCollection*)IsA()->New();; 219 // Make sure original objects are not deleted; some containers, e.g. TSelectorList, maybe owners; 220 templist->SetOwner(kFALSE);; 221 } else {; 222 templist = nullptr;; 223 }; 224 nextlist.Reset();; 225 Int_t indcoll = 0;; 226 while ((collcrt = nextlist())) { // loop input lists; 227 if (!collcrt->InheritsFrom(TSeqCollection::Class())) {; 228 Error(""Merge"", ""some objects in the input list are not collections - merging aborted"");; 229 SafeDelete(templist);; 230 return 0;; 231 }; 232 if (indobj > ((TSeqCollection*)collcrt)->LastIndex()) {; 233 // We reached the end of this collection.; 234 continue;; 235 }; 236 // The next object to be merged with is a collection; 237 // the iterator skips the 'holes' the collections, we also need to do so.; 238 objtomerge = ((TSeqCollection*)collcrt)->At(indobj);; 239 if (!objtomerge) {; 240 Warning(""Merge"", ""object of type %s (position %d in list) not found in list %d. Continuing..."",; 241 object->ClassName(), indobj, indcoll);; 242 continue;; 243 }; 244/*; 245 // Dangerous - may try to merge non-corresponding histograms (A.G); 246 while (objtomerge == 0; 247 && indobj < ((TSeqCollection*)collcrt)->LastIndex(); 248 ) {; 249 ++indobj;; 250 objtomerge = ((TSeqCollection*)collcrt)->At(indobj);; 251 }; 252*/; 253 if (object->IsA() != objtomerge->IsA()) {; 254 Error(""Merge"", ""object of type %s at index %d not matching object of type %s in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSeqCollection_8cxx_source.html:7833,abort,aborted,7833,doc/master/TSeqCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSeqCollection_8cxx_source.html,1,['abort'],['aborted']
Safety,"+ Progress bar would be better.; [#9292] - Integer overflow in TTreeCache::FillBuffer; [#8959] - ninja clean does not remove modules.idx; [#8952] - Make hadd return a non-zero exit code when encountering a corrupted file; [#8942] - cannot buid the dependent project; [#8794] - [TGNumberEntry] centiseconds; [#8720] - Apply TChain::SetImplicitMT() to underlying trees; [#8639] - (RDataFrame) AsNumpy returns Boolean branches as ‘object’ dtype numpy arrays; [#8582] - TThreadTimer behavior; [#8581] - [ntuple] RNTupleModel columns ownership issue; [#8517] - Add integer support to TVectorT; [#8494] - cling crashes on conditional parameter in template; [#8260] - Build system cannot detect version of oneTBB; [#8148] - Document TMethodCall class limitations; [#7950] - Assertion exception including header file with GaudiPython module; [#7900] - Support spectator variables in RReader; [#7872] - TExecutorCRTP::Map() should support void; [#7871] - Usability of TExecutor::MapReduce; [#7845] - Improve TMatrix reference documentation; [#7805] - Inconsistent and unintuitive behaviour of TFormula::SetParNames and TFormula::SetParameters; [#7774] - Unreasonably slow behaviour of CompileMacro; [#7699] - [VecOps] Make free functions in VecOps better visible; [#7686] - PyROOT Segfault when creating proxy to derived class with multiple overloads; [#7669] - Inconsistent behaviour in wildcard import; [#7644] - Provide in the cmake configuration the C++ standard which was used to compile ROOT; [#7627] - Fix TMVA group links; [#7159] - TNetXNGFile::Open fails with double slash (//) in path; [#7128] - Cannot build ROOT if another ROOT at /usr/local; [#6900] - mathmore: invalid roots for a quartic polynomial; [#6811] - Bug displaying several 3D objects such as TGraph2D on the same canvas; [#6755] - Greek letter epsilon not rendered correctly using TLatex with OpenGL.CanvasPreferGL option, segmentation fault.; [#6753] - CMake dependency on Python: use targets; [#6616] - hadd writes files with unspe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:37340,detect,detect,37340,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['detect'],['detect']
Safety,"+ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attributes. ;  ; virtual void SetMarkerColor (Color_t mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TF1; static void AbsValue (Bool_t reject=kTRUE);  Static function: set the fgAbsValue flag. ;  ; static void CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11);  Type safe interface (static method) The number of sampling points are taken from the TGraph. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Bool_t DefaultAddToGlobalList (Bool_t on=kTRUE);  Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ;  ; static Double_t DerivativeError ();  Static function returning the error of the last call to the of Derivative's functions. ;  ; static TF1 * GetCurrent ();  Static function returning the current function being processed. ;  ; static void InitStandardFunctions ();  Create the basic function objects. ;  ; static Bool_t RejectedPoint ();  See TF1::RejectPoint above. ;  ; static void RejectPoint (Bool_t reject=kTRUE);  Static function to set the global flag to reject points the fgRejectPoint global flag i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF12.html:32211,safe,safe,32211,doc/master/classTF12.html,https://root.cern,https://root.cern/doc/master/classTF12.html,2,['safe'],['safe']
Safety,"++ interpreter we decided to reuse existing code. Code that we can still influence, but that's nevertheless production-grade. We expected that this will solve the maintenance and correctness issues. And because it's correct we don't need Reflex, but can instead use one central, fast (compiler!) reflection database.; So yes, this is a major overhaul of ROOT and the dictionaries. We will signal that with a new major ROOT version number. But we expect it to solve the correctness, stability, memory and CPU-consumption as well as the maintenance issues we currently have. The current implementation of cling (which is not yet complete) uses a mere 5000 lines of custom code developed by HEP; everything else is provided through LLVM and clang.; And regarding PyROOT: I am sure Wim will make good use of the new JIT power that comes with cling! Just like we expect the JIT to leave traces e.g. in TFormula, and the real reflection database in the I/O, THtml etc. It gets us unstuck, flexible and future-safe in many central areas of ROOT. O the places you'll go!; Cheers,. Axel Naumann's blog. Comments. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:48 Permalink . Other Python bindings . I noticed that there are multiple other ways to call C++ code from Python, one of them being included in the Boost library. What would it do to the complexity (and dependencies) to use an interface that doesn't build on top of CINT/Reflex?. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram,; Thanks for your question. The main issue about the boost binding is that it is - as far as I understand - completely static and intrusive. PyROOT on the other hand is based on refection data, and it has features that e.g. the Boost binding doesn't offer (e.g. the mapping of concepts). Other bindings (e.g. SWIG-based ones) are difficult to maintain, not compatible with C++, and don't offer PyROOT's features either. So the cost is both o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:5147,safe,safe,5147,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['safe'],['safe']
Safety,"++i); 1885 // xInput.emplace_back(Matrix_t(n1,n2));; 1886 ; 1887 // create pointer to output matrix used for the predictions; 1888 Matrix_t yHat(deepNet.GetBatchSize(), deepNet.GetOutputWidth() );; 1889 ; 1890 // use timer; 1891 Timer timer( nEvents, GetName(), kTRUE );; 1892 ; 1893 if (logProgress); 1894 Log() << kHEADER << Form(""[%s] : "",DataInfo().GetName()); 1895 << ""Evaluation of "" << GetMethodName() << "" on ""; 1896 << (Data()->GetCurrentType() == Types::kTraining ? ""training"" : ""testing""); 1897 << "" sample ("" << nEvents << "" events)"" << Endl;; 1898 ; 1899 ; 1900 // eventg loop; 1901 std::vector<double> mvaValues(nEvents);; 1902 ; 1903 ; 1904 for ( Long64_t ievt = firstEvt; ievt < lastEvt; ievt+=batchSize) {; 1905 ; 1906 Long64_t ievt_end = ievt + batchSize;; 1907 // case of batch prediction for; 1908 if (ievt_end <= lastEvt) {; 1909 ; 1910 if (ievt == firstEvt) {; 1911 Data()->SetCurrentEvent(ievt);; 1912 size_t nVariables = GetEvent()->GetNVariables();; 1913 ; 1914 if (n1 == batchSize && n0 == 1) {; 1915 if (n2 != nVariables) {; 1916 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1917 << "" n-event variables "" << nVariables << "" expected input matrix "" << n1 << "" x "" << n2; 1918 << Endl;; 1919 }; 1920 } else {; 1921 if (n1*n2 != nVariables || n0 != batchSize) {; 1922 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1923 << "" n-event variables "" << nVariables << "" expected input tensor "" << n0 << "" x "" << n1 << "" x "" << n2; 1924 << Endl;; 1925 }; 1926 }; 1927 }; 1928 ; 1929 auto batch = testData.GetTensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:76158,predict,prediction,76158,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"+= contLevel->GetSize();; }. nGraphs = 0;. TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);. hr->Draw();; Double_t x0, y0, z0;; TLatex l;; l.SetTextSize(0.03);; char val[20];. for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) z0 = contours[2-i];; else z0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", z0);. // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, x0, y0);; if (z0<0) curv->SetLineColor(kRed);; if (z0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());. 	 // Draw clones of the graphs to avoid deletions in case the 1st; 	 // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");. sprintf(val,""%g"",z0);; l.DrawLatex(x0,y0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }. Double_t SawTooth(Double_t x, Double_t WaveLen){. // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //. Double_t y;; if ( (x < -WaveLen/2) || (x > WaveLen/2)) y = -99999999; // Error X out of bounds; if (x <= -WaveLen/4) {; y = x + 2.0;; } else if ((x > -WaveLen/4) && (x <= WaveLen/4)) {; y = -x ;; } else if (( x > WaveLen/4) && (x <= WaveLen/2)) {; y = x - 2.0;; }; return y;; }; The following op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:39610,avoid,avoid,39610,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['avoid'],['avoid']
Safety,"+it) {; 2293#endif; 2294 Int_t stop = *it;; 2295 if (stop - 1 >= start + 1) {; 2296 TString tok = (*this)(start+1, stop-start-1);; 2297 TObjString *objstr = new TObjString(tok);; 2298 arr->Add(objstr);; 2299 }; 2300 start = stop;; 2301 }; 2302 ; 2303 return arr;; 2304}; 2305 ; 2306////////////////////////////////////////////////////////////////////////////////; 2307/// Formats a string using a printf style format descriptor.; 2308/// Existing string contents will be overwritten.; 2309 ; 2310void TString::FormImp(const char *fmt, va_list ap); 2311{; 2312 Ssiz_t buflen = 20 + 20 * strlen(fmt); // pick a number, any strictly positive number; 2313 buflen = Clobber(buflen); // Update buflen, as Clobber clamps length to MaxSize (if Fatal does not abort); 2314 ; 2315 va_list sap;; 2316 R__VA_COPY(sap, ap);; 2317 ; 2318 int n, vc = 0;; 2319again:; 2320 n = vsnprintf(GetPointer(), buflen, fmt, ap);; 2321 // old vsnprintf's return -1 if string is truncated new ones return; 2322 // total number of characters that would have been written; 2323 if (n == -1 || n >= buflen) {; 2324 if (n == -1); 2325 buflen *= 2;; 2326 else; 2327 buflen = n+1;; 2328 buflen = Clobber(buflen);; 2329 va_end(ap);; 2330 R__VA_COPY(ap, sap);; 2331 vc = 1;; 2332 goto again;; 2333 }; 2334 va_end(sap);; 2335 if (vc); 2336 va_end(ap);; 2337 ; 2338 SetSize(strlen(Data()));; 2339}; 2340 ; 2341////////////////////////////////////////////////////////////////////////////////; 2342/// Formats a string using a printf style format descriptor.; 2343/// Existing string contents will be overwritten.; 2344/// See also the static version TString::Format; 2345/// ~~~ {.cpp}; 2346/// TString formatted;; 2347/// formatted.Form(""%s in <%s>: %s"", type, location, msg);; 2348///; 2349/// lines.emplace_back(TString::Format(""Welcome to ROOT %s%%shttp://root.cern"",; 2350/// gROOT->GetVersion()));; 2351/// ~~~; 2352///; 2353/// Note: this is not to be confused with ::Format and ::Form (in the global namespace); 2354/// which return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:74376,abort,abort,74376,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['abort'],['abort']
Safety,", ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Rename(const char *f, const char *t); 1633{; 1634 int ret = ::rename(f, t);; 1635 GetLastErrorString() = GetError();; 1636 return ret;; 1637}; 1638 ; 1639////////////////////////////////////////////////////////////////////////////////; 1640/// Returns TRUE if the url in 'path' points to the local file system.; 1641/// This is used to avoid going through the NIC card for local operations.; 1642 ; 1643Bool_t TUnixSystem::IsPathLocal(const char *path); 1644{; 1645 TSystem *helper = FindHelper(path);; 1646 if (helper); 1647 return helper->IsPathLocal(path);; 1648 ; 1649 return TSystem::IsPathLocal(path);; 1650}; 1651 ; 1652////////////////////////////////////////////////////////////////////////////////; 1653/// Get info about a file. Info is returned in the form of a FileStat_t; 1654/// structure (see TSystem.h).; 1655/// The function returns 0 in case of success and 1 if the file could; 1656/// not be stat'ed.; 1657 ; 1658int TUnixSystem::GetPathInfo(const char *path, FileStat_t &buf); 1659{; 1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:50247,avoid,avoid,50247,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety,", &skey); seekkey = (Long64_t)skey;; 1631 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 1632 }; 1633 frombuf(buffer, &nwhc);; 1634 if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1635 nwhc = nwheader - (buffer-header);; 1636 for (int i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 1637 classname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1638 if (idcur == fSeekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1662 nwhc = nwheader - (buffer-header);; 1663 }; 1664 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keytitle[i]);; 1665 keytitle[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1666 ; 1667 extrainfo.Form("" name: %-16s title: %s"", keyname, keytitle);; 1668 }; 1669 ; 1670 TDatime::GetDateTime(datime, date, time);; 1671 if (!forComp) {; 1672 if (objlen != nbytes - keylen) {; 1673 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1674 Printf(""%d/%06d At:%-*lld N=%-8d %-14s CX = %5.2f %s"", date, time, nDigits + 1, idcur, nbytes, classname,; 1675 cx, extrainfo.Data());; 1676 } else {; 1677 Printf(""%d/%06d At:%-*lld N=%-8d %-14",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:60287,avoid,avoid,60287,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:2051,recover,recover,2051,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recover']
Safety,", . bool ; doOffset = false . ); const. Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; For successful operation, the PDF implementation must indicate that it is extendable by overloading canBeExtended(), and must implement the expectedEvents() function.; Parameters. [in]sumEntriesThe number of observed events. ; [in]nsetThe normalization set when asking the pdf for the expected number of events. ; [in]observedSumW2The number of observed events when weighting with squared weights. If non-zero, the weight-squared error correction is applied to the extended term. ; [in]doOffsetOffset the extended term by a counterterm where the expected number of events equals the observed number of events. This constant shift results in a term closer to zero that is approximately chi-square distributed. It is useful to do this also when summing multiple NLL terms to avoid numeric precision loss that happens if you sum multiple terms of different orders of magnitude. The weight-squared error correction works as follows: adjust poisson such that estimate of \(N_\mathrm{expect}\) stays at the same value, but has a different variance, rescale both the observed and expected count of the Poisson with a factor \( \sum w_{i} / \sum w_{i}^2 \) (the effective weight of the Poisson term), i.e., change \(\mathrm{Poisson}(N_\mathrm{observed} = \sum w_{i} | N_\mathrm{expect} )\) to \( \mathrm{Poisson}(\sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 | N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 ) \), weighted by the effective weight \( \sum w_{i}^2 / \sum w_{i} \) in the likelihood. Since here we compute the likelihood with the weight square, we need to multiply by the square of the effective weight:; \( W_\mathrm{expect} = N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 \) : effective expected entries; \( W_\mathrm{observed} = \sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 \) : e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:100123,avoid,avoid,100123,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['avoid'],['avoid']
Safety,", 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2670,safe,safe,2670,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['safe'],['safe']
Safety,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18397,safe,safety,18397,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,18,['safe'],"['safe', 'safety']"
Safety,", CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Cristina Cristescu, CERN/SFT,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Aurelie Flandi, CERN/SFT,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Lukasz Janyst, CERN/IT,; Christopher Jones, Fermilab, CMS,; Wim Lavrijsen, LBNL, PyRoot,; Sergey Linev, GSI, http,; Pere Mato, CERN/SFT,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Danilo Piparo, CERN/SFT,; Timur Pocheptsov, CERN/SFT,; Fons Rademakers, CERN/SFT,; Enric Tejedor Saavedra, CERN/SFT,; Liza Sakellari, CERN/SFT,; Manuel Tobias Schiller,; David Smith, CERN/IT,; Matevz Tadel, UCSD/CMS, Eve,; Vassil Vassilev, CERN/SFT; Wouter Verkerke, NIKHEF/Atlas, RooFit,; Yue Shi Lai, MIT,; Maciej Zimnoch, GSOC; Core Libraries; General; Platform support; ROOT now works on linuxarm64 / AArch64 / ARMv8 64-bit - thanks, David Abdurachmanov!; ROOT supports GCC 5.0 (using the GCC4 ABI) and XCode 6.3, Mac OSX 10.10.3; Thread-Safety; A lot of effort went into improving the thread-safety of Core and Meta classes / functions. A special thanks to Chris Jones from CMS!; std::string_view; Introduce a preview of C++17’s std::string_view. To take advantage of this new class use:; #include ""RStringView.h""; The documentation of this can be found at http://en.cppreference.com/w/cpp/experimental/basic_string_view The implementation provided is extracted from libcxx. Whenever the current compiler and standard library provide an implmentation, it is used.; The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero.; This type is used throughout the ROOT code to avoid copying strings when a sub-string is needed and to extent interfaces that uses to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; …; ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:2882,safe,safety,2882,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['safe'],['safety']
Safety,", Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:3808,safe,safe,3808,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,['safe'],['safe']
Safety,", Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:2828,safe,safe,2828,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,3,['safe'],['safe']
Safety,", Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDirectory.; It is too costly and it can be abused. TObject * Next(Int_t nSkip); return the pointer to the object defined by next TKey; This method is not recommended. It was done for the sake; of the compatibility with TListIter. void PurgeKeys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileIter.html:8124,avoid,avoid,8124,root/html528/TFileIter.html,https://root.cern,https://root.cern/root/html528/TFileIter.html,6,['avoid'],['avoid']
Safety,", Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:7939,safe,safe,7939,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['safe'],['safe']
Safety,", Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; virtual TObject * Remove (TObject *obj)=0;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:6286,safe,safe,6286,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['safe'],['safe']
Safety,", N2 where N1 and N2 are the dimension of the sub-matrix (SubMatrix::kRows and SubMatrix::kCols ) Condition row0+N1 <= D1 && col0+N2 <=D2 ;  ; SVector< T, D1 > Diagonal () const;  return diagonal elements of a matrix as a Vector. ;  ; template<class Vector > ; void SetDiagonal (const Vector &v);  Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (statically) is done on diagonal size == vector size. ;  ; T Trace () const;  return the trace of a matrix Sum of the diagonal elements ;  ; SVector< T, D1 *(D2+1)/2 > UpperBlock () const;  return the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2. ;  ; SVector< T, D1 *(D2+1)/2 > LowerBlock () const;  return the lower Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2. ;  ; — Other Functions —; bool IsInUse (const T *p) const;  Function to check if a matrix is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation. ;  ; std::ostream & Print (std::ostream &os) const;  Print: used by operator<<() ;  . Public Attributes; — Data Member —; R fRep;  Matrix Storage Object containing matrix data. ;  . #include <Math/SMatrix.h>; Member Typedef Documentation. ◆ const_iterator. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . typedef const T* ROOT::Math::SMatrix< T, D1, D2, R >::const_iterator. STL const_iterator interface. ; Definition at line 115 of file SMatrix.h. ◆ iterator. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . typedef T* ROOT::Math::SMatrix< T, D1, D2, R >::iterator. STL iterator interface. ; Definition at line 112 of file SMatrix.h. ◆ rep_type. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . typedef R ROOT::Math::SMatrix< T, D1, D2, R >::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:12001,avoid,avoid,12001,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['avoid'],['avoid']
Safety,", UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:2549,avoid,avoids,2549,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,2,['avoid'],['avoids']
Safety,", column contain class version; *:object - other object, column contain object id; *:rawdata - raw data, column contains id of raw data from _streamer_ table; *:Int_t - column with integer value; Use TSQLFile::SetUseSuffixes(kFALSE) to disable suffixes usage. This and several other options can be changed only when; TSQLFile created with options ""CREATE"" or ""RECREATE"" and only before; first write operation. These options are:; SetUseSuffixes() - suffix usage in column names (default - on); SetArrayLimit() - defines maximum array size, which can; has column for each element (default 21); SetTablesType() - table type name in MySQL database (default ""InnoDB""); SetUseIndexes() - usage of indexes in database (default kIndexesBasic); Normally these functions should be called immidiately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:4365,detect,detects,4365,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['detect'],['detects']
Safety,", const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; Bool_t IsCylType () const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetDimensions (Double_t *param) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTessellated.html:8220,safe,safe,8220,doc/master/classTGeoTessellated.html,https://root.cern,https://root.cern/doc/master/classTGeoTessellated.html,1,['safe'],['safe']
Safety,", const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:8516,safe,safe,8516,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,", from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16222,safe,safe,16222,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,", kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoScaledShape.h>. Inheritance diagram for TGeoScaledShape:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:22552,detect,detection,22552,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['detect'],['detection']
Safety,", kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoShapeAssembly.h>. Inheritance diagram for TGeoShapeAssembly:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:22121,detect,detection,22121,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['detect'],['detection']
Safety,", kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoBBox; Double_t fDX;  ; Double_t fDY;  ; Double_t fDZ;  ; Double_t fOrigin [3];  ;  Protected Attributes inherited from TGeoShape; UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:22330,detect,detection,22330,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,3,['detect'],['detection']
Safety,", s.Data(), TMath::Min(s.Length(), n2)); }. TString & ReplaceAll(const TString& s1, const TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { return GetPointer()[i]; }. char operator()(Ssiz_t i) const; { return GetPointer()[i]; }. char & operator[](Ssiz_t i); { AssertElement(i); return GetPointer()[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return GetPointer()[i]; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. const char * Data() const. Ssiz_t Length() const; { return fExtent; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. Ssiz_t Align(Ssiz_t s); { return (s + (kAlignment-1)) & ~(kAlignment-1); }. Ssiz_t Recommend(Ssiz_t s); { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }. Bool_t IsLong() const; { return Bool_t(fRep.fShort.fSize & kShortMask); }. void SetShortSize(Ssiz_t s); { fRep.fShort.fSize = (unsigned char)(s << 1); }. Ssiz_t GetShortSize() const; { return fRep.fShort.fSize >> 1; }. void SetLongSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const; { return fRep.fLong.fData; }. char * GetShortPointer(); { return fRep.fShort.fData; }. const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TString.html:22551,detect,detecting,22551,root/html532/TString.html,https://root.cern,https://root.cern/root/html532/TString.html,2,['detect'],['detecting']
Safety,", s.Data(), TMath::Min(s.Length(), n2)); }. TString & ReplaceAll(const TString& s1, const TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { return GetPointer()[i]; }. char operator()(Ssiz_t i) const; { return GetPointer()[i]; }. char & operator[](Ssiz_t i); { AssertElement(i); return GetPointer()[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return GetPointer()[i]; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. const char * Data() const. Ssiz_t Length() const; { return fExtent; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. TString(const char* a1, Ssiz_t n1, const char* a2, Ssiz_t n2); Special concatenation constructor. Ssiz_t Align(Ssiz_t s); { return (s + (kAlignment-1)) & ~(kAlignment-1); }. Ssiz_t Recommend(Ssiz_t s); { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }. Bool_t IsLong() const; { return Bool_t(fRep.fShort.fSize & kShortMask); }. void SetShortSize(Ssiz_t s); { fRep.fShort.fSize = (unsigned char)(s << 1); }. Ssiz_t GetShortSize() const; { return fRep.fShort.fSize >> 1; }. void SetLongSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TString.html:22489,detect,detecting,22489,root/html530/TString.html,https://root.cern,https://root.cern/root/html530/TString.html,1,['detect'],['detecting']
Safety,", stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int opt, int val) override;  Set socket option. ;  ; void Sleep (UInt_t milliSec) override;  Slee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11428,timeout,timeout,11428,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,", these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; TGeoScale * GetScale () const;  ; TGeoShape * GetShape () const;  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () const override;  ; Bool_t IsAssembly () const override;  Returns true if the scaled shape is an assembly. ;  ; Bool_t IsCylType () const override;  ; Bool_t IsReflected () const override;  Check if the scale transformation is a reflection. ;  ; TBuffer3D * MakeBuffer3D () const override;  Creates a TBuffer3D describing this shape. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  computes the closest distance from given point to this shape, according to option. ;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetPoints (Double_t *points) const override;  Mesh points for scaled shapes. ;  ; void SetPoints (Float_t *points) const override;  Mesh points for scaled shapes. ;  ; void SetScale (TGeoScale *scale);  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  Fill TBuffer3D structure for segments and polygons. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:4070,safe,safe,4070,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,2,['safe'],['safe']
Safety,",-2,2);; 2819 f3->SetClippingBoxOn(0,0,0);; 2820 f3->SetFillColor(30);; 2821 f3->SetLineColor(15);; 2822 f3->Draw(""FBBB"");; 2823}; 2824End_Macro; 2825 ; 2826 ; 2827\anchor HP28; 2828### Associated functions drawing; 2829 ; 2830 ; 2831An associated function is created by `TH1::Fit`. More than on fitted; 2832function can be associated with one histogram (see `TH1::Fit`).; 2833 ; 2834A `TF1` object `f1` can be added to the list of associated; 2835functions of an histogram `h` without calling `TH1::Fit`; 2836simply doing:; 2837 ; 2838 h->GetListOfFunctions()->Add(f1);; 2839 ; 2840or; 2841 ; 2842 h->GetListOfFunctions()->Add(f1,someoption);; 2843 ; 2844To retrieve a function by name from this list, do:; 2845 ; 2846 TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);; 2847 ; 2848or; 2849 ; 2850 TF1 *f1 = h->GetFunction(name);; 2851 ; 2852Associated functions are automatically painted when an histogram is drawn.; 2853To avoid the painting of the associated functions the option `HIST`; 2854should be added to the list of the options used to paint the histogram.; 2855 ; 2856 ; 2857\anchor HP29; 2858### Drawing using OpenGL; 2859 ; 2860 ; 2861The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; 2862graphics library. The plotting options start with `GL` keyword.; 2863In addition, in order to inform canvases that OpenGL should be used to render; 28643D representations, the following option should be set:; 2865 ; 2866 gStyle->SetCanvasPreferGL(true);; 2867 ; 2868 ; 2869\anchor HP29a; 2870#### General information: plot types and supported options; 2871 ; 2872The following types of plots are provided:; 2873 ; 2874For lego plots the supported options are:; 2875 ; 2876| Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:113533,avoid,avoid,113533,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snpri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:597280,abort,abort,597280,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:597313,abort,abort,597313,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,",py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:17177,safe,safe,17177,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z for a given ray inside a given sector; and fills coefficients:; Rproj = a + b*z. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set PGON dimensions starting from an array. void SetPoints(Double_t* points) const; create polygone mesh points. void SetPoints(Float_t* points) const; create polygone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:18125,safe,safety,18125,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,3,['safe'],['safety']
Safety,"-----------------------------------------------------------------------; ; # Construct a simultaneous pdf using category sample as index: associate model; # with the physics state and model_ctl with the control state; simPdf = ROOT.RooSimultaneous(""simPdf"", ""simultaneous pdf"", {""physics"": model, ""control"": model_ctl}, sample); ; # Perform a simultaneous fit; # ---------------------------------------------------; ; # Perform simultaneous fit of model to data and model_ctl to data_ctl; fitResult = simPdf.fitTo(combData, PrintLevel=-1, Save=True); fitResult.Print(); ; # Plot model slices on data slices; # ----------------------------------------------------------------; ; # Make a frame for the physics sample; frame1 = x.frame(Title=""Physics sample""); ; # Plot all data tagged as physics sample; combData.plotOn(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:3536,predict,prediction,3536,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,1,['predict'],['prediction']
Safety,"-------------------------------------------------------; ; # Read parameters from file; params.readFromFile(""rf505_asciicfg_example.txt""); params.Print(""v""); ; configFile = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf505_asciicfg.txt""; ; # Read parameters from section 'Section2' of file; params.readFromFile(configFile, """", ""Section2""); params.Print(""v""); ; # Read parameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.selectByAttrib(""READ"", False)); ; # Read parameters from section 'Section4' of file, contains; # 'include file' statement of rf505_asciicfg_example.txt; # so that we effective read the same; params.readFromFile(configFile, """", ""Section4""); params.Print(""v""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x803b610 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_examp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf505__asciicfg_8py.html:2359,safe,safe,2359,doc/master/rf505__asciicfg_8py.html,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html,1,['safe'],['safe']
Safety,"--------------; ; # Construct a simultaneous pdf with the following form; #; # model_run1(x) = f*gauss_run1(x,m_run1,s) + (1-f)*poly; # model_run2(x) = f*gauss_run2(x,m_run2,s) + (1-f)*poly; # simpdf(x,c) = model_run1(x) if c==""run1""; # = model_run2(x) if c==""run2""; #; # Returned pdf is owned by the workspace; model_sim = sct.build(""model_sim"", ""model"", SplitParam=(""m"", ""c"")); ; # Print tree structure of model; model_sim.Print(""t""); ; # Adjust model_sim parameters in workspace; w.var(""m_run1"").setVal(-3); w.var(""m_run2"").setVal(+3); ; # Print contents of workspace; w.Print(""v""); ; # Build a simultaneous model with product split; # -----------------------------------------------------------------------------------------; ; # Build another simultaneous pdf using a composite split in states c X d; model_sim2 = sct.build(""model_sim2"", ""model"", SplitParam=(""p0"", ""c,d"")); ; # Print tree structure of self model; model_sim2.Print(""t""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::d; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::s; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::f; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooPolynomial::p; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf504__simwstool_8py.html:2631,safe,safe,2631,doc/master/rf504__simwstool_8py.html,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8py.html,1,['safe'],['safe']
Safety,"---------; ; # Construct sum of models on one go using recursive fraction interpretations; #; # model2 = bkg + (sig1 + sig2); #; model2 = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig1, sig2], [bkgfrac, sig1frac], True); ; # NB: Each coefficient is interpreted as the fraction of the; # left-hand component of the i-th recursive sum, i.e.; #; # sum4 = A + ( B + ( C + D) with fraction fA, and fC expands to; #; # sum4 = fA*A + (1-fA)*(fB*B + (1-fB)*(fC*C + (1-fC)*D)); ; # Plot recursive addition model; # ---------------------------------------------------------; model2.plotOn(xframe, LineColor=""r"", LineStyle=""--""); model2.plotOn(xframe, Components={bkg, sig2}, LineColor=""r"", LineStyle=""--""); model2.Print(""t""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8py.html:3607,safe,safe,3607,doc/master/rf201__composite_8py.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html,1,['safe'],['safe']
Safety,"-----; ; # Plot single background component specified by name; model.plotOn(xframe2, Components=""bkg"", LineColor=""c""); ; # Plot multiple background components specified by name; model.plotOn(xframe2, Components=""bkg1,sig2"", LineStyle="":"", LineColor=""c""); ; # Plot multiple background components specified by regular expression on; # name; model.plotOn(xframe2, Components=""sig*"", LineStyle=""--"", LineColor=""c""); ; # Plot multiple background components specified by multiple regular; # expressions on name; model.plotOn(xframe2, Invisible=True, Components=""bkg1,sig*"", LineStyle=""--"", LineColor=""y""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf205_compplot"", ""rf205_compplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf205_compplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2,sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf205__compplot_8py.html:4167,safe,safe,4167,doc/master/rf205__compplot_8py.html,https://root.cern,https://root.cern/doc/master/rf205__compplot_8py.html,1,['safe'],['safe']
Safety,"-32-00"");; 1596 return 15;; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Set default resize increment for all TStrings. Default is 16.; 1601 ; 1602Ssiz_t TString::ResizeIncrement(Ssiz_t); 1603{; 1604 ::Obsolete(""TString::ResizeIncrement"", ""v5-30-00"", ""v5-32-00"");; 1605 return 16;; 1606}; 1607 ; 1608////////////////////////////////////////////////////////////////////////////////; 1609/// Set maximum space that may be wasted in a string before doing a resize.; 1610/// Default is 15.; 1611 ; 1612Ssiz_t TString::MaxWaste(Ssiz_t); 1613{; 1614 ::Obsolete(""TString::MaxWaste"", ""v5-30-00"", ""v5-32-00"");; 1615 return 15;; 1616}; 1617 ; 1618/** \class TSubString; 1619A zero length substring is legal. It can start; 1620at any character. It is considered to be ""pointing""; 1621to just before the character.; 1622 ; 1623A ""null"" substring is a zero length substring that; 1624starts with the nonsense index kNPOS. It can; 1625be detected with the member function IsNull().; 1626*/; 1627 ; 1628////////////////////////////////////////////////////////////////////////////////; 1629/// Private constructor.; 1630 ; 1631TSubString::TSubString(const TString &str, Ssiz_t start, Ssiz_t nextent); 1632 : fStr((TString&)str), fBegin(start), fExtent(nextent); 1633{; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return sub-string of string starting at start with length len.; 1638 ; 1639TSubString TString::operator()(Ssiz_t start, Ssiz_t len) const; 1640{; 1641 if (start < Length() && len > 0) {; 1642 if (start+len > Length()); 1643 len = Length() - start;; 1644 } else {; 1645 start = kNPOS;; 1646 len = 0;; 1647 }; 1648 return TSubString(*this, start, len);; 1649}; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Returns a substring matching ""pattern"", or the null substring; 1653/// if there is no such match. It would be nice if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:49478,detect,detected,49478,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['detect'],['detected']
Safety,"->AddLast(fVolumes->At(i));; 1545 }; 1546 fClosed = kTRUE;; 1547 if (fParallelWorld) {; 1548 if (fgVerboseLevel > 0); 1549 Info(""CloseGeometry"", ""Recreating parallel world %s ..."", fParallelWorld->GetName());; 1550 fParallelWorld->CloseGeometry();; 1551 }; 1552 ; 1553 if (fgVerboseLevel > 0); 1554 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1555 GetTitle());; 1556 if (fgVerboseLevel > 0); 1557 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1558 return;; 1559 }; 1560 ; 1561 // Create a geometry navigator if not present; 1562 if (!GetCurrentNavigator()); 1563 fCurrentNavigator = AddNavigator();; 1564 nnavigators = GetListOfNavigators()->GetEntriesFast();; 1565 SelectTrackingMedia();; 1566 CheckGeometry();; 1567 if (fgVerboseLevel > 0); 1568 Info(""CloseGeometry"", ""Counting nodes..."");; 1569 fNNodes = CountNodes();; 1570 fNLevel = fMasterVolume->CountNodes(1, 3) + 1;; 1571 if (fNLevel < 30); 1572 fNLevel = 100;; 1573 ; 1574 // BuildIdArray();; 1575 // avoid voxelization if requested to speed up geometry startup; 1576 if (!opt.Contains(""nv"")) {; 1577 Voxelize(""ALL"");; 1578 } else {; 1579 TGeoVolume *vol;; 1580 TIter next(fVolumes);; 1581 while ((vol = (TGeoVolume *)next())) {; 1582 vol->SortNodes();; 1583 }; 1584 }; 1585 if (fgVerboseLevel > 0); 1586 Info(""CloseGeometry"", ""Building cache..."");; 1587 CountLevels();; 1588 for (Int_t i = 0; i < nnavigators; i++) {; 1589 nav = (TGeoNavigator *)GetListOfNavigators()->At(i);; 1590 nav->GetCache()->BuildInfoBranch();; 1591 if (nodeid); 1592 nav->GetCache()->BuildIdArray();; 1593 }; 1594 fClosed = kTRUE;; 1595 if (fgVerboseLevel > 0) {; 1596 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1597 GetTitle());; 1598 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1599 }; 1600}; 1601 ; 1602////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:58564,avoid,avoid,58564,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['avoid'],['avoid']
Safety,"->GetD() and/or using pseudo-experiments. ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV(). ; See also the tutorial for a toy example. ; Definition at line 46 of file TSVDUnfold.h. Public Member Functions;  TSVDUnfold (const TH1D *bdat, const TH1D *bini, const TH1D *xini, const TH2D *Adet);  Alternative constructor User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. ;  ;  TSVDUnfold (const TH1D *bdat, TH2D *Bcov, const TH1D *bini, const TH1D *xini, const TH2D *Adet);  Default constructor Initialisation of TSVDUnfold User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. ;  ;  TSVDUnfold (const TSVDUnfold &other);  Copy constructor. ;  ;  ~TSVDUnfold () override;  Destructor. ;  ; Double_t ComputeChiSquared (const TH1D &truspec, const TH1D &unfspec);  Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper. ;  ; TH2D * GetAdetCovMatrix (Int_t ntoys, Int_t seed=1);  Determine covariance matrix of unfolded spectrum from finite statistics in response matrix using pseudo experiments ""ntoys"" - number of pseudo experiments use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:3578,detect,detector,3578,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety,"->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }. The TCanvas::Print(""file.ps("") mechanism is very useful, but it can; be a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated in some; loop one needs to detect the special cases of first and last page and then; munge the argument to Print() accordingly.; The ""["" and ""]"" can be used instead of ""("" and "")"" as shown below.; Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; c1.Print(""file.ps""); // Actually print canvas to the file; }; c1.Print(""file.ps]""); // No actual print, just close the file. Color Model; TPostScript support two color model RGB and CMYK. CMY and CMYK models are; subtractive color models unlike RGB which is an additive. They are mainly; used for printing purposes. CMY means Cyan Magenta Yellow to convert RGB; to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more; component K (black). The conversion from RGB to CMYK is:. Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);. CMYK add the black c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPostScript.html:5858,detect,detect,5858,root/html528/TPostScript.html,https://root.cern,https://root.cern/root/html528/TPostScript.html,3,['detect'],['detect']
Safety,"->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 15738 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15739 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15740 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15741 /* Don't wait if the server is going to be stopped. */; 15742 break;; 15743 }; 15744 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15745 /* Simply retry the function call. */; 15746 mg_sleep(50);; 15747 } else {; 15748 /* Need to retry the function call ""later"".; 15749 * See https://linux.die.net/man/3/ssl_get_error; 15750 * This is typical for non-blocking sockets. */; 15751 struct mg_pollfd pfd;; 15752 int pollres;; 15753 pfd.fd = conn->client.sock;; 15754 pfd.events = ((err == SSL_ERROR_WANT_CONNECT); 15755 || (err == SSL_ERROR_WANT_WRITE)); 15756 ? POLLOUT; 15757 : POLLIN;; 15758 pollres =; 15759 mg_poll(&pfd, 1, 50, &(conn->phys_ctx->stop_flag));; 15760 if (pollres < 0) {; 15761 /* Break if error occured (-1); 15762 * or server shutdown (-2) */; 15763 br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:464876,timeout,timeout,464876,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 15739 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15740 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15741 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15742 /* Don't wait if the server is going to be stopped. */; 15743 break;; 15744 }; 15745 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15746 /* Simply retry the function call. */; 15747 mg_sleep(50);; 15748 } else {; 15749 /* Need to retry the function call ""later"".; 15750 * See https://linux.die.net/man/3/ssl_get_error; 15751 * This is typical for non-blocking sockets. */; 15752 struct mg_pollfd pfd;; 15753 int pollres;; 15754 pfd.fd = conn->client.sock;; 15755 pfd.events = ((err == SSL_ERROR_WANT_CONNECT); 15756 || (err == SSL_ERROR_WANT_WRITE)); 15757 ? POLLOUT; 15758 : POLLIN;; 15759 pollres =; 15760 mg_poll(&pfd, 1, 50, &(conn->phys_ctx->stop_flag));; 15761 if (pollres < 0) {; 15762 /* Break if error occured (-1); 15763 * or server shutdown (-2) */; 15764 br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:464909,timeout,timeout,464909,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"-activated handler. ; Definition at line 32 of file TSysEvtHandler.cxx. ◆ Activated(). virtual void TSysEvtHandler::Activated ; (; ). inlinevirtual . Definition at line 47 of file TSysEvtHandler.h. ◆ Add(). virtual void TSysEvtHandler::Add ; (; ). pure virtual . Implemented in TFileHandler, TSignalHandler, TStdExceptionHandler, and TTimer. ◆ Added(). virtual void TSysEvtHandler::Added ; (; ). inlinevirtual . Definition at line 50 of file TSysEvtHandler.h. ◆ Class(). static TClass * TSysEvtHandler::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSysEvtHandler::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSysEvtHandler::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 53 of file TSysEvtHandler.h. ◆ DeActivate(). void TSysEvtHandler::DeActivate ; (; ). De-activate a system event handler. ; Use this method to temporarily disable an event handler to avoid it from being recursively called. Use DeActivate() / Activate() instead of Remove() / Add() for this purpose, since the Add() will add the handler back to the end of the list of handlers and cause it to be called again for the same, already handled, event. ; Definition at line 46 of file TSysEvtHandler.cxx. ◆ DeActivated(). virtual void TSysEvtHandler::DeActivated ; (; ). inlinevirtual . Definition at line 48 of file TSysEvtHandler.h. ◆ DeclFileName(). static const char * TSysEvtHandler::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 53 of file TSysEvtHandler.h. ◆ GetSender(). void * TSysEvtHandler::GetSender ; (; ). inlineoverrideprivatevirtual . Reimplemented from TQObject.; Definition at line 33 of file TSysEvtHandler.h. ◆ IsA(). TClass * TSysEvtHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TTimer.; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSysEvtHandler.html:16507,avoid,avoid,16507,doc/master/classTSysEvtHandler.html,https://root.cern,https://root.cern/doc/master/classTSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34650,detect,detected,34650,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,3,"['detect', 'timeout']","['detected', 'timeout']"
Safety,"-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013182,detect,detector,1013182,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,". ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 486 of file TBufferSQL.cxx. ◆ WriteFastArray() [10/15]. void TBufferSQL::WriteFastArray ; (; const UInt_t * ; ui, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. ◆ WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 608 of file TBufferSQL.cxx. ◆ WriteFastArray() [13/15]. void TBufferSQL::WriteFastArray ; (; const UShort_t * ; us, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:55129,abort,aborts,55129,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,". ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 608 of file TBufferSQL.cxx. ◆ WriteFastArray() [13/15]. void TBufferSQL::WriteFastArray ; (; const UShort_t * ; us, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 527 of file TBufferSQL.cxx. ◆ WriteFastArray() [14/15]. Int_t TBufferSQL::WriteFastArray ; (; void ** ; startp, . const TClass * ; cl, . Long64_t ; n = 1, . bool ; isPreAlloc = false, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 717 of file TBufferSQL.cxx. ◆ WriteFastArray() [15/15]. void TBufferSQL::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 708 of file TBufferSQL.cxx. ◆ WriteFastArrayString(). void TBufferSQL::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:56010,abort,aborts,56010,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,". ; This method is not adequate for being called inside tight loops as it implies a lookup in a mapping between the threadIDs and the slot indices. A good practice consists in copying the pointer onto the stack and proceed with the loop as shown in this work item (psudo-code) which will be sent to different threads: auto workItem = [](){; auto objPtr = tthreadedObject.Get();; for (auto i : ROOT::TSeqI(1000)) {; // tthreadedObject->FastMethod(i); // don't do this! Inefficient!; objPtr->FastMethod(i);; }; }; ROOT::TSeqA pseudo container class which is a generator of indices.Definition TSeq.hxx:67; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. Definition at line 280 of file TThreadedObject.hxx. ◆ GetAtSlot(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlot ; (; unsigned ; i). inline . Access a particular processing slot. ; This method is thread-safe as long as concurrent calls request different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of GetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 202 of file TThreadedObject.hxx. ◆ GetAtSlotRaw(). template<class T > . T * ROOT::TThreadedObject< T >::GetAtSlotRaw ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to a single thread. ; This overload is faster than the GetAtSlotUnchecked method but the caller is responsible to make sure that the slot exists, to check that the contained object is initialized and that the returned pointer will not outlive the TThreadedObject that returned it, which maintains ownership of the actual object. ; Definition at line 260 of file TThreadedObject.hxx. ◆ GetAtSlotUnchecked(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlotUnchecked ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:5846,safe,safe,5846,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['safe'],['safe']
Safety,". ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferSize;  Allocated size of fBuffer. ;  ; TFile * fFile;  Pointer to file. ;  ; Int_t fNtot;  Total size of cached blocks. ;  ; Bool_t fRecursive;  flag to avoid recursive calls ;  ; Long64_t fSeekStart;  Seek value of first block in cache. ;  . Private Member Functions;  TFileCacheWrite (const TFileCacheWrite &)=delete;  ; TFileCacheWrite & operator= (const TFileCacheWrite &)=delete;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:10264,avoid,avoid,10264,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['avoid'],['avoid']
Safety,". ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TStopTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TStopTimer(). TStopTimer::TStopTimer ; (; TProofPlayer * ; p, . Bool_t ; abort, . Int_t ; to . ). Constructor for the timer to stop/abort processing. ; The 'timeout' is in seconds. Make sure that 'to' make sense, i.e. not larger than 10 days; the minimum value is 10 ms (0 does not seem to start the timer ...). ; Definition at line 186 of file TProofPlayer.cxx. Member Function Documentation. ◆ Notify(). Bool_t TStopTimer::Notify ; (; ). overridevirtual . Handle the signal coming from the expiration of the timer associated with an abort or stop request. ; We raise an exception which will be processed in the event loop. ; Implements TSysEvtHandler.; Definition at line 205 of file TProofPlayer.cxx. Member Data Documentation. ◆ fAbort. Bool_t TStopTimer::fAbort. private . Definition at line 171 of file TProofPlayer.cxx. ◆ fPlayer. TProofPlayer* TStopTimer::fPlayer. private . Definition at line 172 of file TProofPlayer.cxx. proof/proofplayer/src/TProofPlayer.cxx. TStopTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStopTimer.html:17545,abort,abort,17545,doc/master/classTStopTimer.html,https://root.cern,https://root.cern/doc/master/classTStopTimer.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,". ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Attributes; TArrayC * fClassSent;  ; TMessage fMessage;  ; Int_t fServerIdx;  ; TUrl fServerLocation;  ; Int_t fServerVersion;  ; TSocket * fSocket;  . Additional Inherited Members;  Public Types inherited from TMemFile; using ExternalDataPtr_t = std::shared_ptr< const std::vector< char > >;  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelMergingFile.html:31541,timeout,timeout,31541,doc/master/classTParallelMergingFile.html,https://root.cern,https://root.cern/doc/master/classTParallelMergingFile.html,1,['timeout'],['timeout']
Safety,". Bool_t TGeoNavigator::IsEntering ; (; ); const. inline . Definition at line 140 of file TGeoNavigator.h. ◆ IsExiting(). Bool_t TGeoNavigator::IsExiting ; (; ); const. inline . Definition at line 141 of file TGeoNavigator.h. ◆ IsNullStep(). Bool_t TGeoNavigator::IsNullStep ; (; ); const. inline . Definition at line 146 of file TGeoNavigator.h. ◆ IsOnBoundary(). Bool_t TGeoNavigator::IsOnBoundary ; (; ); const. inline . Definition at line 145 of file TGeoNavigator.h. ◆ IsOutside(). Bool_t TGeoNavigator::IsOutside ; (; ); const. inline . Definition at line 144 of file TGeoNavigator.h. ◆ IsPWSafetyCaching(). static Bool_t TGeoNavigator::IsPWSafetyCaching ; (; ). inlinestatic . Definition at line 232 of file TGeoNavigator.h. ◆ IsSafeStep(). Bool_t TGeoNavigator::IsSafeStep ; (; Double_t ; proposed, . Double_t & ; newsafety . ); const. In case a previous safety value was computed, check if the safety region is still safe for the current point and proposed step. ; Return value changed only if proposed distance is safe. ; Definition at line 2609 of file TGeoNavigator.cxx. ◆ IsSameLocation() [1/2]. Bool_t TGeoNavigator::IsSameLocation ; (; ); const. inline . Definition at line 133 of file TGeoNavigator.h. ◆ IsSameLocation() [2/2]. Bool_t TGeoNavigator::IsSameLocation ; (; Double_t ; x, . Double_t ; y, . Double_t ; z, . Bool_t ; change = kFALSE . ). Checks if point (x,y,z) is still in the current node. ; check if this is an overlapping node ; Definition at line 2446 of file TGeoNavigator.cxx. ◆ IsSamePoint(). Bool_t TGeoNavigator::IsSamePoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ); const. Check if a new point with given coordinates is the same as the last located one. ; Definition at line 2634 of file TGeoNavigator.cxx. ◆ IsStartSafe(). Bool_t TGeoNavigator::IsStartSafe ; (; ); const. inline . Definition at line 135 of file TGeoNavigator.h. ◆ IsStepEntering(). Bool_t TGeoNavigator::IsStepEntering ; (; ); const. inline . Definition at line 142 of file TGeoNavi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:37646,safe,safe,37646,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,". Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrap(); constructors. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetH1() const; {return fH1;}. Double_t GetBl1() const; {return fBl1;}. Double_t GetTl1() const; {return fTl1;}. Double_t GetAlpha1() const; {return fAlpha1;}. Double_t GetH2() const; {return fH2;}. Double_t GetBl2() const; {return fBl2;}. Double_t GetTl2() const; {return fTl2;}. Double_t GetAlpha2() const; {return fAlpha2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:17759,safe,safe,17759,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,2,['safe'],['safe']
Safety,". Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- kind=1; 42// DCT-III(REDFT01 in FFTW3 notation)- kind=2; 43// DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 44// DST-I (RODFT00 in FFTW3 notation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8h_source.html:1326,redund,redundant,1326,doc/master/TVirtualFFT_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html,1,['redund'],['redundant']
Safety,". If NN is omitted the delay between subimages is zero. For an animation that stops after last subimage is reached, one has to write the last image as .gif+ (zero delay of last image) or .gif+NN (NN*10ms delay of last image).; For repeated animation (looping), the last subimage must be specified as:; ""myfile.gif++NN++"" if you want an infinite looping gif with NN*10ms delay of the last image.; ""myfile.gif++"" for an infinite loop with zero delay of last image.; ""myfile.gif+NN++RR"" if you want a finite looping gif with NN*10ms delay of the last image and the animation to be stopped after RR repeats. RR is not restricted to two digits. A deprecated version for saving the last subimage of a looping gif animation is:; ""myfile.gif++NN"" for a finite loop where NN is number of repetitions and NN*10ms the delay of last image. (No separate control of repeats and delay). Note: If the file ""myfile.gif"" already exists, the new frames are appended at the end of the file. To avoid this, delete it first with gSystem->Unlink(myfile.gif);. The following macro creates animated gif from jpeg images with names; imageNN.jpg, where 1<= NN <= 10; The delays are set to 10*10ms. {; TImage *img = 0;; gSystem->Unlink(""anim.gif""); // delete existing file; ; for (int i = 1; i <= 10; i++) {; delete img; // delete previous image; ; // Read image data. Image can be in any format, e.g. png, gif, etc.; img = TImage::Open(Form(""image%d.jpg"", i));; ; if (i < 10) {; img->WriteImage(""anim.gif+10""); // 10 centiseconds delay; } else { // the last image written. ""++"" stands for infinit animation.; img->WriteImage(""anim.gif++10++""); // 10 centiseconds delay of last image; }; }; }; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TImage::WriteImagevirtual void WriteImage(const char *, EImageFileTypes=TImage::kUnknown)Definition TImage.h:115; TSystem::Unlinkvirtual int Unlink(const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:80233,avoid,avoid,80233,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['avoid'],['avoid']
Safety,". Index of CINT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. ROOT; » CINT. Index of CINT; CINT - The C++ Interpreter; The CINT package consists of. CINT; the current CINT core: interpreter, parser, etc.; CINT7; the new CINT core, using Reflex instead of arrays of C structures; Reflex; A C++ library for reflection data, i.e. to store information about available types, members, their sizes, etc.; Cintex; An interface between Reflex and the current CINT version. More information can be obtained from the CINT website.; The main area of work is currently getting CINT7 to work as well as the old CINT.; Once this merge with Reflex is finished, CINT will be a lot easier to maintain, use less memory, and also run faster than the current CINT.; You can watch our progress in the nightly test status for the rows labeled new.; The next major overhaul will convert CINT into a true C++ layout and make it thread-safe, with >= one interpreter per thread.; We have a draft proposal for the new layout written as C++ headers; a document describing this will follow.; For now you can peek at the subversion repository containing the set of headers.; Further Reading; bytecode; cint; cintapi; extlib; ifdef; limitati; limitnum; makecint; message; ref; List of Classes; CINT Modules; REFLEX. » Last changed: 2009-12-14 18:22 » Last generated: 2009-12-14 18:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/CINT_Index.html:933,safe,safe,933,root/html526/CINT_Index.html,https://root.cern,https://root.cern/root/html526/CINT_Index.html,1,['safe'],['safe']
Safety,". Index of CINT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. ROOT; » CINT. Index of CINT; CINT - The C++ Interpreter; The CINT package consists of. CINT; the current CINT core: interpreter, parser, etc.; CINT7; the new CINT core, using Reflex instead of arrays of C structures; Reflex; A C++ library for reflection data, i.e. to store information about available types, members, their sizes, etc.; Cintex; An interface between Reflex and the current CINT version. More information can be obtained from the CINT website.; The main area of work is currently getting CINT7 to work as well as the old CINT.; Once this merge with Reflex is finished, CINT will be a lot easier to maintain, use less memory, and also run faster than the current CINT.; You can watch our progress in the nightly test status for the rows labeled new.; The next major overhaul will convert CINT into a true C++ layout and make it thread-safe, with >= one interpreter per thread.; We have a draft proposal for the new layout written as C++ headers; a document describing this will follow.; For now you can peek at the subversion repository containing the set of headers.; Further Reading; bytecode; cint; cintapi; extlib; ifdef; limitati; limitnum; makecint; message; ref; List of Classes; CINT Modules; REFLEX. » Last changed: 2010-12-15 15:10 » Last generated: 2010-12-15 15:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/CINT_Index.html:933,safe,safe,933,root/html528/CINT_Index.html,https://root.cern,https://root.cern/root/html528/CINT_Index.html,1,['safe'],['safe']
Safety,". Int_t TBufferFile::WriteFastArray ; (; void ** ; start, . const TClass * ; cl, . Long64_t ; n = 1, . Bool_t ; isPreAlloc = kFALSE, . TMemberStreamer * ; streamer = nullptr . ). overridevirtual . Write an array of object starting at the address '*start' and of length 'n' the objects in the array are of class 'cl' 'isPreAlloc' indicates whether the data member is marked with '->' Return: . 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.); -1: underflow, operation skipped . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2435 of file TBufferFile.cxx. ◆ WriteFastArray() [15/15]. void TBufferFile::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; streamer = nullptr . ). overridevirtual . Write an array of object starting at the address 'start' and of length 'n' the objects in the array are assumed to be of class 'cl'. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2404 of file TBufferFile.cxx. ◆ WriteFastArrayDouble32(). void TBufferFile::WriteFastArrayDouble32 ; (; const Double_t * ; d, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n doubles (as float) into the I/O buffer. ; see comments about Double32_t encoding at TBufferFile::WriteDouble32 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:87042,abort,aborts,87042,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,". Int_t TSlave::GetSlaveType ; (; ); const. inline . Definition at line 139 of file TSlave.h. ◆ GetSocket(). TSocket * TSlave::GetSocket ; (; ); const. inline . Definition at line 134 of file TSlave.h. ◆ GetStatus(). Int_t TSlave::GetStatus ; (; ); const. inline . Definition at line 140 of file TSlave.h. ◆ GetUser(). const char * TSlave::GetUser ; (; ); const. inline . Definition at line 128 of file TSlave.h. ◆ GetWorkDir(). const char * TSlave::GetWorkDir ; (; ); const. inline . Definition at line 127 of file TSlave.h. ◆ Init() [1/2]. void TSlave::Init ; (; const char * ; host, . Int_t ; port, . Int_t ; stype . ). private . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Definition at line 87 of file TSlave.cxx. ◆ Init() [2/2]. void TSlave::Init ; (; TSocket * ; s, . Int_t ; stype . ). protected . Init a PROOF slave object using the connection opened via s. ; Used to avoid double opening when an attempt via TXSlave found a remote proofd. ; Definition at line 259 of file TSlave.cxx. ◆ Interrupt(). void TSlave::Interrupt ; (; Int_t ; type). protectedvirtual . Send interrupt OOB byte to master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 510 of file TSlave.cxx. ◆ IsA(). TClass * TSlave::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 167 of file TSlave.h. ◆ IsSortable(). Bool_t TSlave::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 122 of file TSlave.h. ◆ IsValid(). virtual Bool_t TSlave::IsValid ; (; ); const. inlinevirtual . Definition at line 150 of file TSlave.h. ◆ OldAuthSetup(). Int_t TSlave::OldAuthSetup ; (; Bool_t ; master, . TString ; wconf . ). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 403 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:19831,avoid,avoid,19831,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['avoid'],['avoid']
Safety,". Masters always shutdown the remote counterpart. ; Definition at line 1798 of file TProof.cxx. ◆ CloseProgressDialog(). void TProof::CloseProgressDialog ; (; ). Close progress dialog. ; Definition at line 9283 of file TProof.cxx. ◆ Collect() [1/4]. Int_t TProof::Collect ; (; const TSlave * ; sl, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2669 of file TProof.cxx. ◆ Collect() [2/4]. Int_t TProof::Collect ; (; ESlaves ; list = kActive, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. ◆ Collect() [3/4]. Int_t TProof::Collect ; (; TList * ; slaves, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 of file TProof.cxx. ◆ Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:77635,timeout,timeout,77635,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['timeout'],['timeout']
Safety,". Minuit 2; 1 Foreword; 1.1 What M is intended to do; 1.2 What M is not intended to do; 1.3 Further remarks. 2 Introduction: M basic concepts; 2.1 The organization of M; 2.2 Design aspects of M in; 2.3 Internal and external parameters; 2.3.1 The transformation for parameters with limits. 2.4 M strategy; 2.5 Parameter errors; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; 2.5.2 The error matrix; 2.5.3 \(\mbox{MINOS}\) errors; 2.5.4 \(\mbox{CONTOURS}\) plotting. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.5.1 From to; 3.5.2 Memory allocation and thread safety; 3.5.3 M parameters. 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); 4.1.2 FCNBase::up(); 4.1.3 \(\mbox{FCN}\) function with gradient. 4.2 M parameters; 4.2.1 Minimal required interface; 4.2.2 MnUserParameters; 4.2.3 MnUserCovariance; 4.2.4 MnUserParameterState. 4.3 Input to M; 4.3.1 What the user must supply; 4.3.2 What the user can supply. 4.4 Running a M minimization; 4.4.1 Direct usage of minimizers; 4.4.2 Using an application (MnMigrad); 4.4.3 Subsequent minimizations; 4.4.4 M fails to find a minimum. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; 4.5.2 User representable format: MnUserParameterState; 4.5.3 Access values, errors, covariance; 4.5.4 Printout of the result; 4.5.5 Global correlation coefficients. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.1.1 isValid(); 5.1.2 fval(), edm(), nfcn(). 5.2 MnContours; 5.2.1 MnContours(const FCNBase&, const FunctionMinimum&); 5.2.2 operator(); 5.2.3 contour(…). 5.3 MnEigen; 5.3.1 MnEigen(); 5.3.2 operator(). 5.4 MnHesse; 5.4.1 MnHesse(); 5.4.2 operator(). 5.5 MnMachinePrecision; 5.5.1 MnMachinePrecision(); 5.5.2 setPrecision(double eps). 5.6 MnMigrad and VariableMetricMinimizer; 5.6.1 MnMig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:669,safe,safety,669,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['safe'],['safety']
Safety,". Only used for testing. */; 172 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j) const;; 173 ; 174 void Print() const {; 175 TMatrixT<AFloat> mat(*this);; 176 mat.Print();; 177 }; 178 ; 179 void Zero() {; 180 cudaMemset(GetDataPointer(), 0, sizeof(AFloat) * GetNoElements());; 181 }; 182 ; 183 ; 184private:; 185 ; 186 /** Initializes all shared devices resource and makes sure that a sufficient; 187 * number of curand states are allocated on the device and initialized as; 188 * well as that the one-vector for the summation over columns has the right; 189 * size. */; 190 void InitializeCuda();; 191 void InitializeCurandStates();; 192 ; 193};; 194 ; 195//; 196// Inline Functions.; 197//______________________________________________________________________________; 198inline void cudaError(cudaError_t code, const char *file, int line, bool abort); 199{; 200 if (code != cudaSuccess); 201 {; 202 fprintf(stderr,""CUDA Error: %s %s %d\n"", cudaGetErrorString(code), file, line);; 203 if (abort) exit(code);; 204 }; 205}; 206 ; 207//______________________________________________________________________________; 208template<typename AFloat>; 209TCudaDeviceReference<AFloat>::TCudaDeviceReference(AFloat * devicePointer); 210 : fDevicePointer(devicePointer); 211{; 212 // Nothing to do here.; 213}; 214 ; 215//______________________________________________________________________________; 216template<typename AFloat>; 217TCudaDeviceReference<AFloat>::operator AFloat(); 218{; 219 AFloat buffer;; 220 cudaMemcpy(& buffer, fDevicePointer, sizeof(AFloat),; 221 cudaMemcpyDeviceToHost);; 222 return buffer;; 223}; 224 ; 225//______________________________________________________________________________; 226template<typename AFloat>; 227void TCudaDeviceReference<AFloat>::operator=(const TCudaDeviceReference &other); 228{; 229 cudaMemcpy(fDevicePointer, other.fDevicePointer, sizeof(AFloat),; 230 cudaMemcpyDeviceToDevice);; 231}; 232 ; 233//_____________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:7839,abort,abort,7839,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,2,['abort'],['abort']
Safety,". ROOT Version 6.06 Release Notes. ROOT Version 6.06 Release Notes; 2015-12-10. Introduction; ROOT reference manual; Core Libraries; Dictionary generation; Thread safety and thread awareness; TDirectory::TContext; Collections; Global resources.; Code Cleanups. Interpreter; I/O Libraries; hadd; Command line utilities; TBufferFile.; I/O New functionalities. TTree Libraries; Improvement of handling of default number of entries; MakeSelector. Histogram Libraries; TH1; TGraph; TGraph2D; Fitting; TFormula. Math Libraries; Random numbers. R Interface; TMVA; RooFit Libraries; 2D Graphics Libraries; THistPainter; TTeXDump; TLatex; TColor; TMultiGraph; TASImage; TCreatePrimitives; TCanvas; Cocoa Backend; freetype library. 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; TNetXNGFileStager; TWebFile. GUI Libraries; Montecarlo Libraries; Multi-processing; Language Bindings; Notebooks. JavaScript ROOT; Class Reference Guide; Tutorials; Build, Configuration and Testing Infrastructure; Patch Releases; Release 6.06/02; Core; Dictionaries; Interpreter; Meta Library; TTree; Histogram Libraries; Math; TColor; PyROOT; Bug Fixes and Tasks. Release 6.06/04; General; Dictionaries; Interpreter Library; I/O; Meta; Core; Minuit; Bug fixes. Release 6.06/06; Cling; Core; Dictionaries; TTree; Bugs fixed in this release. Release 6.06/08; Core; Hist. Bugs fixed in this release; HEAD of the v6-06-00-patches branch. Introduction; ROOT version 6.06/00 was released on December 10, 2015.; For more information, see:; http://root.cern.ch; The following people have contributed to this new version:; David Abdurachmanov, CERN, CMS,; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Cristina Cristescu, CERN/SFT,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/SFT,; Enrico Guiraud, CERN/SFT,; Burt Holzman, Fermilab, CMS,; Lukasz Janyst, CERN/IT,; Christopher Jones, Fermilab, CMS,; Wim ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:163,safe,safety,163,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safety']
Safety,". ROOT Version 6.24 Release Notes. ROOT Version 6.24 Release Notes; 2022-09-29. Introduction; General; Deprecation and Removal; Header Dependency Reduction. Core Libraries; Dynamic Path: ROOT_LIBRARY_PATH; Interpreter; Multithreading. I/O Libraries; TTree Libraries; RDataFrame; New features; Behavior changes; Notable bug fixes and improvements; Distributed computing with RDataFrame. Histogram Libraries; Math Libraries; Minuit2. TMVA; RooFit Libraries; Massive speed up of RooFit’s BatchMode on CPUs with vector extensions; Unbiased binned fits; More accurate residual and pull distributions; Improved recovery from invalid parameters; Modernised RooDataHist; New fully parametrised Crystal Ball shape class. 2D Graphics Libraries; Networking Libraries; Multithreaded support for FastCGI; Better security for THttpServer with webgui; Enabled WLCG Bearer Tokens support in RDavix; Xrootd client support. GUI Libraries; RBrowser improvements. JavaScript ROOT; Major JSROOT update to version 6. Class Reference Guide; Build, Configuration and Testing Infrastructure; PyROOT; Bugs and Issues fixed in this release; Release 6.24/02; RDataFrame; Bugs and Issues fixed in this release. Release 6.24/04; Bugs and Issues fixed in this release. Release 6.24/06; Bugs and Issues fixed in this release. Release 6.24/08; Bugs and Issues fixed in this release. HEAD of the v6-24-00-patches branch. Introduction; ROOT version 6.24/00 was released on April 14, 2022.; For more information, see:; http://root.cern; The following people have contributed to this new version:; Guilherme Amadio, CERN/SFT,; Bertrand Bellenot, CERN/SFT,; Josh Bendavid, CERN/CMS,; Jakob Blomer, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Anirudh Dagar, CERN-SFT/GSOC,; Hans Dembinski, TU Dortmund/LHCb,; Massimiliano Galli, CERN/SFT,; Andrei Gheata, CERN/SFT,; Hadrien Grasland, IJCLab/LAL,; Enrico Guiraud, CERN/SFT,; Claire Guyot, CERN/SFT,; Jonas Hahnfeld, CERN/SFT,; Emmanouil Michalainas, CER",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:605,recover,recovery,605,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['recover'],['recovery']
Safety,". ROOT Version 6.32 Release Notes. ROOT Version 6.32 Release Notes; 2024-05-26. Introduction; Deprecation and Removal; Core Libraries; I/O Libraries; hadd respects compression settings. TTree Libraries; Add files from subdirectories with TChain::Add globbing; Improved efficiency of TTree friends with indices. RNTuple; Histogram Libraries; Parallelism; RooFit Libraries; New CPU likelihood evaluation backend by default; Asymptotically correct uncertainties for extended unbinned likelihood fits; Compile your code with memory safe interfaces; Removal of some memory-unsafe interfaces; Deprecation of legacy iterators; Deprecation of legacy test statistics classes in public interface; Change of RooParamHistFunc; Renaming of some RooFit classes. RDataFrame; Graphics backends; 2D Graphics Libraries; 3D Graphics Libraries; REve. PROOF Libraries; PyROOT; Different representation of std::string; No more implicit conversion of static size char buffer to Python strings; Deprecate the attribute pythonization of TDirectory in favor of item-getting syntax; Removal of Python 2 support; More usage of the public cppyy API. Class Reference Guide; Build, Configuration and Testing Infrastructure; Bugs and Issues fixed in this release; Release 6.32.02; Items addressed in this release. Release 6.32.04; Items addressed in this release. Release 6.32.06; Items addressed in this release. HEAD of the v6-32-00-patches branch. Introduction; ROOT version 6.32.00 was released on 28 May 2024. This release is a long term support one, ideal for inclusion in production or data taking software stacks of experiments.; For more information, see:; http://root.cern; The following people have contributed to this new version:; Anton Alkin, Sungkyunkwan University; Guilherme Amadio, CERN/IT,; Abhigyan Acherjee, University of Cincinnati,; Bertrand Bellenot, CERN/EP-SFT,; Jakob Blomer, CERN/EP-SFT,; Rene Brun,; Carsten Burgard, DESY; Will Buttinger, RAL,; Philippe Canal, FNAL,; Jolly Chen, CERN/EP-SFT,; Olivier Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:528,safe,safe,528,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,. ROOT: Basic 3D graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Basic 3D graphics.Graphics » 3D Graphics. ; The basic 3D classes. . Shapes.; TPolyMarker3D example. . Classes; class  TAxis3D;  The 3D axis painter class. More...;  ; class  TBRIK;  A box with faces perpendicular to the axes. More...;  ; class  TCONE;  A conical tube. More...;  ; class  TCONS;  A segment of a conical tube. More...;  ; class  TCTUB;  A cut tube with 11 parameters. More...;  ; class  TELTU;  A cylinder with an elliptical section. More...;  ; class  TGeometry;  TGeometry description. More...;  ; class  TGTRA;  A general twisted trapezoid. More...;  ; class  THelix;  THelix has two different constructors. More...;  ; class  THYPE;  An hyperboloid (not implemented) More...;  ; class  TMarker3DBox;  A special 3-D marker designed for event display. More...;  ; class  TMaterial;  Manages a detector material. More...;  ; class  TMixture;  Manages a detector mixture. More...;  ; class  TNode;  TNode description. More...;  ; class  TNodeDiv;  Description of parameters to divide a 3-D geometry object. More...;  ; class  TPARA;  A parallelepiped. More...;  ; class  TPCON;  A polycone. More...;  ; class  TPGON;  A polygon. More...;  ; class  TPoints3DABC;  Abstract class to define Arrays of 3D points. More...;  ; class  TPointSet3D;  TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering. More...;  ; class  TPolyLine3D;  A 3-dimensional polyline. More...;  ; class  TPolyMarker3D;  A 3D polymarker. More...;  ; class  TRotMatrix;  Manages a detector rotation matrix. More...;  ; class  TShape;  This is the base class for all geometry shapes. More...;  ; class  TSPHE;  A Sphere. More...;  ; class  TTRAP;  A general trapezoid. More...;  ; class  TTRD1;  A trapezoid with the x dimension varying along z. More...;  ; class  TTRD2;  A trapezoid with both x and y dimensions varying along z. More...;  ; class  TTUBE;  A tube. More...;  ; class  TTUBS; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__g3d.html:928,detect,detector,928,doc/master/group__g3d.html,https://root.cern,https://root.cern/doc/master/group__g3d.html,2,['detect'],['detector']
Safety,". ROOT: Event display tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Event display tutorialsTutorials. ; Examples showing the ""Event display classes"" usage. . Files; file  alice_esd.C;  Complex example showing ALICE ESD track visualization. ;  ; file  alice_esd_html_summary.C;  Html table and event summary for alice_esd.C. ;  ; file  alice_esd_split.C;  Complex example showing ALICE ESD visualization in several views. ;  ; file  alice_vsd.C;  Complex example showing ALICE VSD visualization. ;  ; file  annotation.C;  Demonstrates usage of TGLAnnotation class. ;  ; file  arrow.C;  Demonstrates usage of TEveArrow class. ;  ; file  arrow_standalone.C;  How to use EVE without the standard window. ;  ; file  assembly.C;  Geometry detector assembly example. ;  ; file  box.C;  Demonstrates usage of TEveBox class. ;  ; file  box.C;  Demonstrates usage of TEveBox class. ;  ; file  boxset.C;  Demonstrates usage of TEveBoxSet class. ;  ; file  boxset.C;  Demonstrates usage of REveBoxSet class. ;  ; file  boxset_cones.C;  Demonstrates usage of 'cone' mode in TEveBoxSet class. ;  ; file  boxset_cones.C;  Demonstrates usage of 'cone' mode in REveBoxSet class. ;  ; file  calo_detail.C;  Calorimeter detailed view by using TEveCaloDataVec as data-source. ;  ; file  calorimeters.C;  Demonstrates usage of EVE calorimetry classes. ;  ; file  camera_restore.C;  ; file  compound.C;  Demonstrates usage of EVE compound objects - class TEveCompound. ;  ; file  csgdemo.C;  Combinatorial Solid Geometry example. ;  ; file  geom_alias.C;  Demonstrates usage of geometry aliases - merge ALICE ITS with ATLAS MUON. ;  ; file  geom_alice_its.C;  Shows geometry of ALICE ITS. ;  ; file  geom_alice_tpc.C;  Shows geometry of ALICE TPC. ;  ; file  geom_atlas.C;  Shows ATLAS geometry. ;  ; file  geom_atlas_playback.C;  Plays back event-recording of a root session running geom_atlas.C tutorial. ;  ; file  geom_cms.C;  Shows CMS geometry. ;  ; file  geom_cm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__eve.html:787,detect,detector,787,doc/master/group__tutorial__eve.html,https://root.cern,https://root.cern/doc/master/group__tutorial__eve.html,1,['detect'],['detector']
Safety,". ROOT: Fit Tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Fit TutorialsTutorials. ; These tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code. . Files; file  combinedFit.C;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ; file  combinedFit.py;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ; file  ConfidenceIntervals.C;   Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ; file  ErrorIntegral.C;   Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ;  ; file  exampleFit3D.C;   example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  ; file  fit1.C;   Simple fitting example (1-d histogram with an interpreted function) ;  ; file  fit2.C;   Fitting a 2-D histogram This tutorial illustrates : ;  ; file  fit2a.C;   Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  ; file  fit2d.C;   Example illustrating how to fit a 2-d histogram of type y=f(x) ;  ; file  fit2dHist.C;   Example to fit two histograms at the same time via the Fitter class. ;  ; file  fitCircle.C;   Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  ; file  fitcont.C;   Example illustrating how to draw the n-sigma contour of a Minuit fit. ;  ; file  fitConvolution.C;   Tutorial for convolution of two functions ;  ; file  fitConvolution.py;   Tutorial for convolution of two functions ;  ; file  fitExclude.C;   Illustrates how to fit excluding points in a given range. ;  ; file  fithist.C;   Example of fit where the model is histogram + function ;  ; file  fitLinear.C;   Example of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__fit.html:944,predict,predictor,944,doc/master/group__tutorial__fit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__fit.html,1,['predict'],['predictor']
Safety,". ROOT: Geometry tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Geometry tutorialsTutorials. ; Various ROOT geometry package examples. . Files; file  assembly.C;  Geometry detector assembly example. ;  ; file  building.C;  Drawing a building where Dept. ;  ; file  cheongwadae.C;  Drawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class. ;  ; file  csgdemo.C;  Combinatorial Solid Geometry example. ;  ; file  geodemo.C;  GUI to draw the geometry shapes. ;  ; file  geomAlice.C;  Script drawing a detector geometry (here ALICE). ;  ; file  geomAlice_itsv.C;  Script drawing a detector geometry (here ITSV from Alice). ;  ; file  geomAtlas.C;  Script drawing a detector geometry (here ATLAS). ;  ; file  geomBrahms.C;  Script drawing a detector geometry (here BRAHMS). ;  ; file  geomD0.C;  Script drawing a detector geometry (here D0). ;  ; file  geometry.C;  Example of the old geometry package (now obsolete) ;  ; file  lego.C;  Drawing a figure, made of lego block, using ROOT geometry class. ;  ; file  mp3player.C;  Drawing a mp3 type music player, using ROOT geometry class. ;  ; file  na49.C;  This file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:225,detect,detector,225,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,6,['detect'],['detector']
Safety,". ROOT: JetEvent Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; JetEvent Class Reference. . Definition at line 64 of file JetEvent.h. Public Member Functions;  JetEvent ();  Create a JetEvent object. ;  ;  ~JetEvent () override;  ; Hit * AddHitA ();  Add a new hit to the list of hits in detector A. ;  ; Hit * AddHitB ();  Add a new hit to the list of hits in detector B. ;  ; Jet * AddJet ();  Add a new Jet to the list of tracks for this event. ;  ; Track * AddTrack ();  Add a new track to the list of tracks for this event. ;  ; void Build (Int_t jetm=3, Int_t trackm=10, Int_t hitam=100, Int_t hitbm=10);  Build one event. ;  ; void Clear (Option_t *option="""") override;  ; TClonesArray * GetJets () const;  ; Int_t GetNhitA () const;  ; Int_t GetNhitB () const;  ; Int_t GetNjet () const;  ; Int_t GetNtrack () const;  ; void Reset (Option_t *option="""");  Static function to reset all static objects for this event. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classJetEvent.html:462,detect,detector,462,doc/master/classJetEvent.html,https://root.cern,https://root.cern/doc/master/classJetEvent.html,2,['detect'],['detector']
Safety,". ROOT: Multicore tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Multicore tutorialsTutorials. ; These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. . Files; file  imt001_parBranchProcessing.C;   Demonstrate how to activate and use the implicit parallelisation of TTree::GetEntry. ;  ; file  imt101_parTreeProcessing.C;   Illustrate the usage of the TTreeProcessorMT::Process method. ;  ; file  mp001_fillHistos.C;   Fill histograms in parallel and write them on file. ;  ; file  mp101_fillNtuples.C;   Fill n-tuples in distinct workers. ;  ; file  mp102_readNtuplesFillHistosAndFit.C;   Read n-tuples in distinct workers, fill histograms, merge them and fit. ;  ; file  mp103_processSelector.C;   Illustrate the usage of the multiproc TSelector interfaces with the h1 analysis example. ;  ; file  mp104_processH1.C;   Illustrate the usage of the multiproc to process the H1 analysis example. ;  ; file  mp105_processEntryList.C;   Illustrate the usage of the multiproc to process TEntryList with the H1 analysis example. ;  ; file  mp201_parallelHistoFill.C;   Parallel fill of a histogram This tutorial shows how a histogram can be filled in parallel with a multiprocess approach. ;  ; file  mp_H1_lambdas.C;   Lambdas used to check and fit the result of the H1 analysis. ;  ; file  mt001_fillHistos.C;   Fill histograms in parallel and write them on file. ;  ; file  mt101_fillNtuples.C;   Fill n-tuples in distinct workers. ;  ; file  mt102_readNtuplesFillHistosAndFit.C;   Read n-tuples in distinct workers, fill histograms, merge them and fit. ;  ; file  mt103_fillNtupleFromMultipleThreads.C;   Fill the same TNtuple from different threads. ;  ; file  mt201_parallelHistoFill.C;   Parallel fill of a histogram. ;  ; file  mt301_TTaskGroupSimple.C;   Shows how to run items of work asynchronously with a TTaskGroup. ;  ; file  mt304_fillHistos.C;   Fill hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__multicore.html:244,safe,safety,244,doc/master/group__tutorial__multicore.html,https://root.cern,https://root.cern/doc/master/group__tutorial__multicore.html,1,['safe'],['safety']
Safety,". ROOT: RNTuple Introduction. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RNTuple Introduction. RNTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of templates, and the ownership is well-defined through the use of smart pointers. For instance tree->Branch(""px"", &Category, ""px/F"");; becomes auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>; The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on most modern architectures. Combined with a clear separation of offset/index data and payload data for collections, uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; RNTuple shall investigate improvements of the TTree I/O in the following ways. More speed; Improve mapping to vectorized and parallel hardware; For types known at compile / JIT time: generate optimized code; Optimized for simple types (float, int, and vectors of them); Better memory control: work with a fixed budget of pre-defined I/O buffers; Naturally thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:339,safe,safe,339,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['safe'],['safe']
Safety,". ROOT: ROOT::Experimental::RFieldBase Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Member Functions |; Static Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RFieldBase Class ReferenceabstractNTuple-related classes. ; A field translates read and write calls from/to underlying columns to/from tree values. ; A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns. The field knows based on its type and the field name the type(s) and name(s) of the columns.; Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes. This is and can only be partially enforced through C++. ; Definition at line 67 of file RFieldBase.hxx. Classes; class  RBulk;  Similar to RValue but manages an array of consecutive values. More...;  ; struct  RBulkSpec;  ; struct  RCheckResult;  Used in the return value of the Check() method. More...;  ; class  RColumnRepresentations;  Some fields have multiple possible column representations, e.g. More...;  ; struct  RCreateObjectDeleter;  ; struct  RCreateObjectDeleter< void >;  ; class  RDeleter;  A functor to release the memory acquired by CreateValue (memory and constructor). More...;  ; class  RSchemaIteratorTemplate;  Iterates over the sub tree of fields in depth-first search order. More...;  ; struct  RSharedPtrDeleter;  ; class  RTypedDeleter;  A deleter for templated RFieldBase descendents where the value type is known. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:747,safe,safe,747,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['safe'],['safe']
Safety,". ROOT: ROOT::Internal::RConcurrentHashColl Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; ROOT::Internal::RConcurrentHashColl Class Reference. ; This class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. ; Definition at line 30 of file RConcurrentHashColl.hxx. Classes; class  HashValue;  . Public Member Functions;  RConcurrentHashColl ();  ;  ~RConcurrentHashColl ();  ; const RUidColl * Find (const HashValue &hash) const;  Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ;  ; bool Insert (const HashValue &hash, RUidColl &&coll) const;  If the hash is there, return false. ;  . Static Public Member Functions; static HashValue Hash (char *buf, int len);  Return the hash object corresponding to the buffer. ;  . Private Attributes; std::unique_ptr< RHashMap > fHashMap;  ; std::unique_ptr< ROOT::TRWSpinLock > fRWLock;  . #include <ROOT/RConcurrentHashColl.hxx>; Constructor & Destructor Documentation. ◆ RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::RConcurrentHashColl ; (; ). Definition at line 41 of file RConcurrentHashColl.cxx. ◆ ~RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::~RConcurrentHashColl ; (; ). default . Member Function Documentation. ◆ Find(). const RUidColl * ROOT::Internal::RConcurrentHashColl::Find ; (; const HashValue & ; hash); const. Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ; Definition at line 46 of file RConcurrentHashColl.cxx. ◆ Hash(). RConcurrentHashColl::HashValue ROOT::Internal::RConcurrentHashColl::Hash ; (; char * ; buf, . int ; len . ). static . Return the hash object correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html:359,safe,safe,359,doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,1,['safe'],['safe']
Safety,". ROOT: ROOT::Internal::RDF::RColumnRegister Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Internal::RDF::RColumnRegister Class ReferenceDataframe. ; A binder for user-defined columns, variations and aliases. ; The storage is copy-on-write and shared between all instances of the class that have the same values.; Several components of an RDF computation graph make use of a column register. It keeps track of which columns have been defined, varied or aliased at each point of the computation graph. In many cases, the contents of the different column register instances are the same or only differ by a single extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines, fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data members with the previous instance except for the one data member that needed updating, which is replaced with a new updated instance.; The contents of the collections that keep track of other objects of the computation graph are not owned by the RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the RColumnRegister. ; Definition at line 68 of file RColumnRegister.hxx. Public Member Functions;  RColumnRegister (ROOT::Detail::RDF::RLoopManager *lm);  ; void AddAlias (std::string_view alias, std::string_view colName);  Add a new alias to the ledger. ;  ; void AddDefine (std::shared_ptr< RDFDetail::RDefineBase > column);  Add a new defined column. ;  ; void AddVariation (std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:875,avoid,avoid,875,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. ; Definition at line 131 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &, const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > &);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; , . const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > & ;  . ). inlinestatic . Definition at line 133 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html:569,avoid,avoid,569,doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::IBaseParam Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; ROOT::Math::IBaseParam Class ReferenceabstractMath » MathCore » Function Classes and Interfaces » Parametric Function Evaluation Interfaces. ; Documentation for the abstract class IBaseParam. ; It defines the interface for dealing with the function parameters This is used only for internal convenience, to avoid redefining the Parameter API for the one and the multi-dim functions. Concrete class should derive from ROOT::Math::IParamFunction and not from this class. ; Definition at line 51 of file IParamFunction.h. Public Member Functions; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IBaseParam:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~IBaseParam(). virtual ROOT::Math::IBaseParam::~IBaseParam ; (; ). inlinevirtual . Virtual Destructor (no operations) ; Definition at line 59 of file IParamFunction.h. Member Function Documentation. ◆ NPar(). virtual unsigned int ROOT::Math::IBaseParam::NPar ; (; ); const. pure virtual . Return the number of Parameters. ; Implemented in ROOT::Math::ParamFunction< IParamGradFunction >, ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::MultiDimParamGradFunctionAdapter, RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html:508,avoid,avoid,508,doc/master/classROOT_1_1Math_1_1IBaseParam.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html,2,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices. ; Evaluate the expression performing a -= operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A -= A + B ) ; Definition at line 315 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 317 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html:683,avoid,avoid,683,doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 232 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 234 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html:677,avoid,avoid,677,doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::PxPyPzM4D< ScalarType > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Attributes |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::PxPyPzM4D< ScalarType > Class Template ReferenceMath » Physics Vectors. ; template<class ScalarType = double>; class ROOT::Math::PxPyPzM4D< ScalarType >Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). ; This system is useful to describe ultra-relativistic particles (like electrons at LHC) to avoid numerical errors evaluating the mass when E >>> m The metric used is (-,-,-,+) Spacelike particles (M2 < 0) are described with negative mass values, but in this case m2 must always be less than P2 to preserve a positive value of E2; See alsoOverview of the physics vector library ; Definition at line 49 of file PxPyPzM4D.h. Public Types; typedef ScalarType Scalar;  . Public Member Functions;  PxPyPzM4D ();  Default constructor with x=y=z=m=0. ;  ; template<class CoordSystem > ; constexpr PxPyPzM4D (const CoordSystem &v);  construct from any 4D coordinate system class implementing X(), Y(), X() and M() ;  ;  PxPyPzM4D (const PxPyPzM4D &v);  copy constructor ;  ;  PxPyPzM4D (Scalar px, Scalar py, Scalar pz, Scalar m);  Constructor from x, y , z , m values. ;  ; Scalar E () const;  Energy. ;  ; Scalar E2 () const;  energy squared ;  ; Scalar Et () const;  transverse energy ;  ; Scalar Et2 () const;  transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; void GetCoordinates (Scalar &px, Scalar &py, Scalar &pz, Scalar &m) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; Scalar M () const;  ; Scalar M2 () const;  vector magnitude squared (or mass squared) In case of negative mass (spacelike pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html:667,avoid,avoid,667,doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,1,['avoid'],['avoid']
Safety,. ROOT: ROOT::Math::Util Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; ROOT::Math::Util Namespace Reference. namespace defining Utility functions needed by mathcore ; More... Functions; template<class T > ; T EvalLog (T x);  safe evaluation of log(x) with a protections against negative or zero argument to the log smooth linear extrapolation below function values smaller than epsilon (better than a simple cut-off) ;  ; template<class T > ; std::string ToString (const T &val);  Utility function for conversion to strings. ;  . Detailed Description; namespace defining Utility functions needed by mathcore ; Function Documentation. ◆ EvalLog(). template<class T > . T ROOT::Math::Util::EvalLog ; (; T ; x). inline . safe evaluation of log(x) with a protections against negative or zero argument to the log smooth linear extrapolation below function values smaller than epsilon (better than a simple cut-off) ; Definition at line 64 of file Util.h. ◆ ToString(). template<class T > . std::string ROOT::Math::Util::ToString ; (; const T & ; val). Utility function for conversion to strings. ; Definition at line 50 of file Util.h. ROOTMathUtil. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:25 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Util.html:293,safe,safe,293,doc/master/namespaceROOT_1_1Math_1_1Util.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Util.html,2,['safe'],['safe']
Safety,". ROOT: ROOT::Math::WrappedFunction< Func > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::WrappedFunction< Func > Class Template ReferenceMath » MathCore » Function Classes and Interfaces » Generic Function Evaluation Interfaces. ; template<typename Func = FreeFunctionPtr>; class ROOT::Math::WrappedFunction< Func >Template class to wrap any C++ callable object which takes one argument i.e. ; implementing operator() (double x) in a One-dimensional function interface. It provides a ROOT::Math::IGenFunction-like signature; Note: If you want to wrap just the reference (to avoid copying) you need to use Func& or const Func & as template parameter. The former should be used when the operator() is not a const method of Func ; Definition at line 45 of file WrappedFunction.h. Public Member Functions;  WrappedFunction (Func f);  construct from the pointer to the object and the member function ;  ; WrappedFunction * Clone () const override;  clone (required by the interface) ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Private Member Functions; double DoEval (double x) const override;  implementation of the evaluation function. Must be implemented by derived classes ;  . Private Attributes; Func fFunc;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . #include <Math/WrappedFunction.h>. Inheritance diagram for ROOT::Math::WrappedFunction< Func >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedFunction.html:770,avoid,avoid,770,doc/master/classROOT_1_1Math_1_1WrappedFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedFunction.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::WrappedMultiFunction< Func > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::WrappedMultiFunction< Func > Class Template ReferenceMath » MathCore » Function Classes and Interfaces » Generic Function Evaluation Interfaces. ; template<typename Func = FreeMultiFunctionPtr>; class ROOT::Math::WrappedMultiFunction< Func >Template class to wrap any C++ callable object implementing operator() (const double * x) in a multi-dimensional function interface. ; It provides a ROOT::Math::IGenMultiFunction-like signature; Note: If you want to wrap just the reference (to avoid copying) you need to use Func& or const Func & as template parameter. The former should be used when the operator() is not a const method of Func ; Definition at line 143 of file WrappedFunction.h. Public Member Functions;  WrappedMultiFunction (Func f, unsigned int dim=1);  construct from the pointer to the object and the member function ;  ; WrappedMultiFunction * Clone () const override;  clone (required by the interface) ;  ; unsigned int NDim () const override;  Retrieve the dimension of the function. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  . Private Member Functions; double DoEval (const double *x) const override;  . Private Attributes; unsigned int fDim;  ; Func fFunc;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; typedef T BackendType;  ; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  . #include <Math/WrappedFunction.h>. Inheritance diagram for ROOT::Math::WrappedMultiFunction< Func >:. This browser is not able to show ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiFunction.html:775,avoid,avoid,775,doc/master/classROOT_1_1Math_1_1WrappedMultiFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiFunction.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::RBrowserTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RBrowserTimer Class Reference. . Definition at line 47 of file RBrowser.cxx. Public Member Functions;  RBrowserTimer (Long_t milliSec, Bool_t mode, RBrowser &br);  !< browser processing postponed requests ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RBrowserTimer.html:462,timeout,timeout,462,doc/master/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RBrowserTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: ROOT::RBrowserTimer Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RBrowserTimer Class Reference. . Definition at line 47 of file RBrowser.cxx. Public Member Functions;  RBrowserTimer (Long_t milliSec, Bool_t mode, RBrowser &br);  !< browser processing postponed requests ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html:461,timeout,timeout,461,doc/v632/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Attributes |; List of all members ; ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; template<typename T, bool isDynamic, typename Range_t>; class ROOT::RRangeCast< T, isDynamic, Range_t >Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. ; Range_tThe type of the input range, which should be usually a reference type to avoid copying. . Definition at line 135 of file RRangeCast.hxx. Public Types; using const_iterator = Internal::TypedIter< T, decltype(std::cbegin(std::declval< Range_t >())), isDynamic >;  ; using iterator = Internal::TypedIter< T, decltype(std::begin(std::declval< Range_t >())), isDynamic >;  . Public Member Functions;  RRangeCast (Range_t &&inputRange);  ; iterator begin ();  ; const_iterator begin () const;  ; iterator end ();  ; const_iterator end () const;  . Private Attributes; Range_t fInputRange;  . #include <ROOT/RRangeCast.hxx>. Inheritance diagram for ROOT::RRangeCast< T, isDynamic, Range_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ const_iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>. Definition at line 144 of file RRangeCast.hxx. ◆ iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>. Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RRangeCast.html:769,avoid,avoid,769,doc/master/classROOT_1_1RRangeCast.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RRangeCast.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Attributes |; List of all members ; ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; template<typename T, bool isDynamic, typename Range_t>; class ROOT::RRangeCast< T, isDynamic, Range_t >Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. ; Range_tThe type of the input range, which should be usually a reference type to avoid copying. . Definition at line 135 of file RRangeCast.hxx. Public Types; using const_iterator = Internal::TypedIter< T, decltype(std::cbegin(std::declval< Range_t >())), isDynamic >;  ; using iterator = Internal::TypedIter< T, decltype(std::begin(std::declval< Range_t >())), isDynamic >;  . Public Member Functions;  RRangeCast (Range_t &&inputRange);  ; iterator begin ();  ; const_iterator begin () const;  ; iterator end ();  ; const_iterator end () const;  . Private Attributes; Range_t fInputRange;  . #include <ROOT/RRangeCast.hxx>. Inheritance diagram for ROOT::RRangeCast< T, isDynamic, Range_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ const_iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>. Definition at line 144 of file RRangeCast.hxx. ◆ iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>. Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RRangeCast.html:768,avoid,avoid,768,doc/v632/classROOT_1_1RRangeCast.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RRangeCast.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::RTreeDrawInvokeTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RTreeDrawInvokeTimer Class Reference. . Definition at line 86 of file RTreeViewer.cxx. Public Member Functions;  RTreeDrawInvokeTimer (Long_t milliSec, bool mode, RTreeViewer &viewer);  constructor ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RTreeDrawInvokeTimer.html:462,timeout,timeout,462,doc/master/classROOT_1_1RTreeDrawInvokeTimer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RTreeDrawInvokeTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: ROOT::RTreeDrawInvokeTimer Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RTreeDrawInvokeTimer Class Reference. . Definition at line 86 of file RTreeViewer.cxx. Public Member Functions;  RTreeDrawInvokeTimer (Long_t milliSec, bool mode, RTreeViewer &viewer);  constructor ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RTreeDrawInvokeTimer.html:461,timeout,timeout,461,doc/v632/classROOT_1_1RTreeDrawInvokeTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RTreeDrawInvokeTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: ROOT::TMetaUtils::TClingLookupHelper Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::TMetaUtils::TClingLookupHelper Class Reference. . Definition at line 160 of file TClingUtils.h. Public Types; typedef bool(* AutoParse_t) (const char *name);  ; typedef bool(* ExistingTypeCheck_t) (const std::string &tname, std::string &result);  . Public Member Functions;  TClingLookupHelper (cling::Interpreter &interpreter, TNormalizedCtxt &normCtxt, ExistingTypeCheck_t existingTypeCheck, AutoParse_t autoParse, bool *shuttingDownPtr, const int *pgDebug=nullptr);  ; virtual ~TClingLookupHelper ();  ; bool ExistingTypeCheck (const std::string &tname, std::string &result) override;  Helper routine to ry hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ;  ; void GetPartiallyDesugaredName (std::string &nameLong) override;  ; bool GetPartiallyDesugaredNameWithScopeHandling (const std::string &tname, std::string &result, bool dropstd=true) override;  We assume that we have a simple type: [const] typename[*&][const]. ;  ; bool IsAlreadyPartiallyDesugaredName (const std::string &nondef, const std::string &nameLong) override;  ; bool IsDeclaredScope (const std::string &base, bool &isInlined) override;  ; void ShuttingDownSignal () override;  ;  Public Member Functions inherited from TClassEdit::TInterpreterLookupHelper;  TInterpreterLookupHelper ();  ; virtual ~TInterpreterLookupHelper ();  . Private Member Functions; bool WantDiags () const;  . Private Attributes; AutoParse_t fAutoParse;  ; ExistingTypeCheck_t fExistingTypeCheck;  ; cling::Interpreter * fInterpreter;  ; bool * fInterpreterIsShuttingDownPtr;  ; TNormalizedCtxt * fNormalizedCtxt;  ; const int * fPDebug;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html:905,avoid,avoid,905,doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,1,['avoid'],['avoid']
Safety,". ROOT: RooGenContext Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooGenContext Class ReferenceRooFit » RooFit Core. ; Implements a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context. ; This generator context queries the input p.d.f which observables it can generate internally and delegates generation of those observables to the p.d.f if it deems that safe. The other observables are generated use a RooAcceptReject sampling technique. ; Definition at line 29 of file RooGenContext.h. Public Member Functions;  RooGenContext (const RooAbsPdf &model, const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, const RooArgSet *forceDirect=nullptr);  Initialize a new context for generating events with the specified variables, using the specified PDF model. ;  ;  ~RooGenContext () override;  ; void attach (const RooArgSet &params) override;  Attach the cloned model to the event buffer we will be filling. ;  ; TClass * IsA () const override;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose=false, TString indent="""") const override;  Printing interface. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsGenContext;  RooAbsGenContext (const RooAbsPdf &model, const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool _verbose=false);  Constructor. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents when printing. ;  ; StyleOption defaultPrintStyle (Option_t *opt) const override;  Define default print style. ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenContext.html:628,safe,safe,628,doc/master/classRooGenContext.html,https://root.cern,https://root.cern/doc/master/classRooGenContext.html,1,['safe'],['safe']
Safety,". ROOT: RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; template<typename T>; struct RooHelpers::WrapIntoTObject< T >Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI. ; Definition at line 57 of file RooHelpers.h. Public Member Functions;  WrapIntoTObject (T &obj);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:416,avoid,avoid,416,doc/master/structRooHelpers_1_1WrapIntoTObject.html,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html,1,['avoid'],['avoid']
Safety,". ROOT: RooStats::MarkovChain Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooStats::MarkovChain Class ReferenceRooFit » RooStats. ; Stores the steps in a Markov Chain of points. ; Allows user to access the weight and NLL value (if applicable) with which a point was added to the MarkovChain. ; Definition at line 33 of file MarkovChain.h. Public Member Functions;  MarkovChain ();  ;  MarkovChain (const char *name, const char *title, RooArgSet &parameters);  ;  MarkovChain (RooArgSet &parameters);  ;  ~MarkovChain () override;  ; virtual void Add (MarkovChain &otherChain, double discardEntries=0.0);  add another markov chain ;  ; virtual void Add (RooArgSet &entry, double nllValue, double weight=1.0);  safely add an entry to the chain ;  ; virtual void AddFast (RooArgSet &entry, double nllValue, double weight=1.0);  add an entry to the chain ONLY IF you have constructed with parameters or called SetParameters ;  ; virtual void AddWithBurnIn (MarkovChain &otherChain, Int_t burnIn=0);  add another markov chain ;  ; virtual const RooArgSet * Get () const;  get the entry at the current position ;  ; virtual const RooArgSet * Get (Int_t i) const;  get the entry at position i ;  ; virtual const RooDataSet * GetAsConstDataSet () const;  ; virtual RooFit::OwningPtr< RooDataHist > GetAsDataHist (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6;  Get a clone of the markov chain on which this interval is based as a RooDataHist. ;  ; virtual RooFit::OwningPtr< RooDataHist > GetAsDataHist (RooArgSet *whichVars=nullptr) const;  get this MarkovChain as a RooDataHist whose entries contain the values of whichVars. ;  ; virtual RooF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html:893,safe,safely,893,doc/master/classRooStats_1_1MarkovChain.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html,1,['safe'],['safely']
Safety,". ROOT: Shapes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; ShapesThe Geometry Package. ; Shapes are geometrical objects that provide the basic modeling functionality. . Primitive Shapes; Navigation Methods Performed By Shapes; Creating Shapes; Dividing Shapes; Parametric Shapes. The ""shapes"" provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base **TGeoShape** class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:. Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinations. You can have a look and run the tutorial: geodemo.C. Primitive Shapes - the general inheritance scheme; Shapes are named objects and all primitives have constructors like:; TGeoXXX(const char *name,<type> param1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:866,safe,safe,866,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['safe'],['safe']
Safety,". ROOT: TClassTable Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Types |; Private Member Functions |; Static Private Member Functions |; Static Private Attributes |; Friends |; List of all members ; TClassTable Class ReferenceCore ROOT classes » Containers. ; This class registers for all classes their name, id and dictionary function in a hash table. ; Classes are automatically added by the ctor of a special init class when a global of this init class is initialized when the program starts (see the ClassImp macro).; All functions in TClassTable are thread-safe. ; Definition at line 37 of file TClassTable.h. Classes; class  NormalizeThenLock;  . Public Types; enum  { ;   kNoStreamer = 0x01; , kNoInputOperator = 0x02; , kAutoStreamer = 0x04; , kHasVersion = 0x08; , ;   kHasCustomStreamerMember = 0x10; , kNtplForceNativeMode = 0x20; , kNtplForceStreamerMode = 0x40. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  ~TClassTable ();  TClassTable singleton is deleted in Terminate(). ;  ; int Classes ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the class table. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:734,safe,safe,734,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['safe'],['safe']
Safety,". ROOT: TDirectory::TContext Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TDirectory::TContext Class ReferenceCore ROOT classes » Base ROOT classes. ; TDirectory::TContext keeps track and restore the current directory. ; With this tool C++ exceptions will be guaranteed to properly restore the current directory pointer.; For example code like:; TDirectory *sav = gDirectory;; mydirectory->cd();; if (...) {; ....; sav->cd();; return;; } else if (...) {; ....; sav->cd();; return;; }; sav->cd;; return;; gDirectory#define gDirectoryDefinition TDirectory.h:384; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::cdvirtual Bool_t cd()Change current directory to ""this"" directory.Definition TDirectory.cxx:538; can be replaced with the simpler and exception safe:; TDirectory::TContext context(gDirectory, mydirectory);; if (...) {; ....; return;; } else if (...) {; ....; return;; }; return;; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89. PyROOT; The functionality offered by TContext can be used in PyROOT with a context manager. Here are a few examples: import ROOT; from ROOT import TDirectory; ; with TDirectory.TContext():; # Open some file here; file = ROOT.TFile(...); # Retrieve contents from the file; histo = file.Get(""myhisto""); ; # After the 'with' statement, the current directory is restored to ROOT.gROOT; ; import ROOT; from ROOT import TDirectory; ; file1 = ROOT.TFile(""file1.root"", ""recreate""); #...; file2 = ROOT.TFile(""file2.root"", ""recreate""); #...; file3 = ROOT.TFile(""file3.root"", ""recreate""); ; # Before the 'with' statement, the current directory is file3 (the last file opened); with TDirectory.TContext(file1):; # Inside the statement, the current directory is file1; histo = ROOT.T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectory_1_1TContext.html:980,safe,safe,980,doc/master/classTDirectory_1_1TContext.html,https://root.cern,https://root.cern/doc/master/classTDirectory_1_1TContext.html,1,['safe'],['safe']
Safety,". ROOT: TEnv Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TEnv Class ReferenceCore ROOT classes » Base ROOT classes. ; The TEnv class reads config files, by default named .rootrc. ; Three types of config files are read: global, user and local files. The global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>) the user file is $HOME/<name> and the local file is ./<name>. By setting the shell variable ROOTENV_NO_HOME=1 the reading of the $HOME/<name> resource file will be skipped. This might be useful in case the home directory resides on an auto-mounted remote file system and one wants to avoid this file system from being mounted.; The format of the .rootrc file is similar to the .Xdefaults format: [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnv.html:817,avoid,avoid,817,doc/master/classTEnv.html,https://root.cern,https://root.cern/doc/master/classTEnv.html,1,['avoid'],['avoid']
Safety,". ROOT: TFFTComplexReal Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TFFTComplexReal Class Reference. ; One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. ; Only the basic interface of FFTW is implemented.; Computes the inverse of the real-to-complex transforms (class TFFTRealComplex) taking complex input (storing the non-redundant half of a logically Hermitian array) to real output (see FFTW manual for more details); How to use it:; Create an instance of TFFTComplexReal - this will allocate input and output arrays (unless an in-place transform is specified); Run the Init() function with the desired flags and settings; Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); Run the Transform() function; Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init() function and continue with steps 3)-5); NOTE:; running Init() function will overwrite the input array! Don't set any data before running the Init() function; FFTW computes unnormalized transform, so doing a transform followed by its inverse will lead to the original array scaled by the transform size; In Complex to Real transform the input array is destroyed. It cannot then be retrieved when using the Get's methods. . Definition at line 21 of file TFFTComplexReal.h. Public Member Functions;  TFFTComplexReal ();  default ;  ;  TFFTComplexReal (Int_t n, Bool_t inPlace);  For 1d transforms Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. ;  ;  TFFTComplexReal (Int_t ndim, Int_t *n, Bool_t inPlace);  For ndim-dimensional transforms Second argument contains sizes of the transform in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFFTComplexReal.html:587,redund,redundant,587,doc/master/classTFFTComplexReal.html,https://root.cern,https://root.cern/doc/master/classTFFTComplexReal.html,1,['redund'],['redundant']
Safety,". ROOT: TFileCacheRead Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFileCacheRead Class ReferenceInput/Output Library. ; A cache when reading files over the network. ; A caching system to speed up network I/O, i.e. when there is no operating system caching support (like the buffer cache for local disk I/O). The cache makes sure that every I/O is done with a (large) fixed length buffer thereby avoiding many small I/O's. Currently the read cache system is used by the classes TNetFile, TNetXNGFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that derives from this class is automatically created. ; Definition at line 22 of file TFileCacheRead.h. Public Member Functions;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual Int_t AddBranch (const char *, Bool_t=kFALSE);  ; virtual Int_t AddBranch (TBranch *, Bool_t=kFALSE);  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot () const;  ; Long64_t GetPrefetchedBlocks () const;  ; virtual TFilePrefetch * GetPrefetchObj ();  ; virtual Int_t GetReadCalls () const;  ; virtual Int_t GetUnzip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:638,avoid,avoiding,638,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['avoid'],['avoiding']
Safety,". ROOT: TFileCacheWrite Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFileCacheWrite Class ReferenceInput/Output Library. ; A cache when writing files over the network. ; A caching system to speed up network I/O, i.e. when there is no operating system caching support (like the buffer cache for local disk I/O). The cache makes sure that every I/O is done with a (large) fixed length buffer thereby avoiding many small I/O's. Currently the write cache system is used by the classes TNetFile, TNetXNGFile and TWebFile (via TFile::WriteBuffers()).; The write cache is automatically created when writing a remote file (created in TFile::Open()). ; Definition at line 19 of file TFileCacheWrite.h. Public Member Functions;  TFileCacheWrite ();  Default Constructor. ;  ;  TFileCacheWrite (TFile *file, Int_t buffersize);  Creates a TFileCacheWrite data structure. ;  ;  ~TFileCacheWrite () override;  Destructor. ;  ; virtual Bool_t Flush ();  Flush the current write buffer to the file. ;  ; virtual Int_t GetBytesInCache () const;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print class internal structure. ;  ; virtual Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Called by the read cache to check if the requested data is not in the write cache buffer. ;  ; virtual void SetFile (TFile *file);  Set the file using this cache. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t WriteBuffer (const char *buf, Long64_t pos, Int_t len);  Write buffer at position pos in the write buffer. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:610,avoid,avoiding,610,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['avoid'],['avoiding']
Safety,". ROOT: TFractionFitter Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFractionFitter Class Reference. ; Fits MC fractions to data histogram. ; A la HMCMLL, see R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f; The virtue of this fit is that it takes into account both data and Monte Carlo statistical uncertainties. The way in which this is done is through a standard likelihood fit using Poisson statistics; however, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimisation with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content. For more details please see the original publication cited above.; An example application of this fit is given below. For a TH1* histogram (""data"") fitted as the sum of three Monte Carlo sources (""mc""):; {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:705,predict,predictions,705,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['predictions']
Safety,". ROOT: TGContainerScrollTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; List of all members ; TGContainerScrollTimer Class Reference. . Definition at line 114 of file TGCanvas.cxx. Public Member Functions;  TGContainerScrollTimer (TGContainer *t);  ; Bool_t Notify () override;  on-timeout ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGContainerScrollTimer.html:411,timeout,timeout,411,doc/master/classTGContainerScrollTimer.html,https://root.cern,https://root.cern/doc/master/classTGContainerScrollTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: TGFont Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; Friends |; List of all members ; TGFont Class ReferenceGUI » Low level GUI widgets. ; Encapsulate fonts used in the GUI system. ; Definition at line 140 of file TGFont.h. Public Member Functions;  ~TGFont () override;  Delete font. ;  ; TGTextLayout * ComputeTextLayout (const char *string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t *width, UInt_t *height) const;  Computes the amount of screen space needed to display a multi-line, justified string of text. ;  ; void DrawChars (Drawable_t dst, GContext_t gc, const char *source, Int_t numChars, Int_t x, Int_t y) const;  Perform a quick sanity check to ensure we won't overflow the X coordinate space. ;  ; void DrawCharsExp (Drawable_t dst, GContext_t gc, const char *source, Int_t numChars, Int_t x, Int_t y) const;  Draw a string of characters on the screen. ;  ; FontAttributes_t GetFontAttributes () const;  ; FontH_t GetFontHandle () const;  ; void GetFontMetrics (FontMetrics_t *m) const;  Get font metrics. ;  ; FontStruct_t GetFontStruct () const;  ; TClass * IsA () const override;  ; Int_t MeasureChars (const char *source, Int_t numChars, Int_t maxLength, Int_t flags, Int_t *length) const;  Determine the number of characters from the string that will fit in the given horizontal span. ;  ; FontStruct_t operator() () const;  Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0) ;  ; Int_t PostscriptFontName (TString *dst) const;  Return the name of the corresponding Postscript font for this TGFont. ;  ; void Print (Option_t *option="""") const override;  Print font info. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save the used font as a C++ statement(s) on output stream out. ;  ; void Streamer (TBuffer &) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:865,sanity check,sanity check,865,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['sanity check'],['sanity check']
Safety,". ROOT: TGL5DDataSetEditor Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TGL5DDataSetEditor Class ReferenceGraphics » 3D Graphics » OpenGL rendering. ; GUI editor for OpenGL 5D Painter. ; Exception safety and ROOT's GUI are two mutually exclusive things. So, only ROOT's GUI here. ; Definition at line 30 of file TGL5DDataSetEditor.h. Classes; class  TGL5DEditorPrivate;  . Public Member Functions;  TGL5DDataSetEditor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  ;  ~TGL5DDataSetEditor () override;  ; void AddNewSurface ();  Add new iso-surface. ;  ; void AlphaChanged ();  Slot connected to the Alpha entry. ;  ; void AlphaChanged (Int_t alpha);  Change transparency of selected surface. ;  ; void ApplyAlpha ();  Slot connected to the ""Apply"" button for alpha value. ;  ; void ApplyGridParameters ();  ""Apply"" button was pressed in a ""Grid"" tab. ;  ; void ApplyPlanes ();  Slot connected to the Apply Planes button. ;  ; void BoxCutToggled ();  Slot connected to the Show BoxCut check button. ;  ; void ColorChanged (Pixel_t pixelColor);  Change the color of the selected surface. ;  ; void GridParametersChanged ();  Some of controls in a ""Grid"" tab was modified. ;  ; void HighlightClicked ();  Check, if selected surface must be highlighted. ;  ; TClass * IsA () const override;  ; void NContoursChanged ();  Slot connected to the Number of Planes value-entry. ;  ; void RemoveSurface ();  Remove selected surface. ;  ; void RollbackGridParameters ();  ""Cancel"" button was pressed in a ""Grid"" tab. ;  ; void SetModel (TObject *obj) override;  Set model or disables/hides viewer. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGL5DDataSetEditor.html:417,safe,safety,417,doc/master/classTGL5DDataSetEditor.html,https://root.cern,https://root.cern/doc/master/classTGL5DDataSetEditor.html,1,['safe'],['safety']
Safety,". ROOT: TGRecorder Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TGRecorder Class ReferenceGUI » Events recorder. ; Provides GUI for TRecorder class. ; Definition at line 630 of file TRecorder.h. Public Member Functions;  TGRecorder (const TGWindow *p=nullptr, UInt_t w=230, UInt_t h=150);  The GUI for the recorder. ;  ;  ~TGRecorder () override;  Destructor. Cleanup the GUI. ;  ; TClass * IsA () const override;  ; void Replay ();  Handles push of fReplay button according to the current recorder state. ;  ; void StartStop ();  Handles push of the fStartStop button according to the current recorder state. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Update ();  Called when fTimer timeouts (every 0.025 second) Updates GUI of recorder. ;  ;  Public Member Functions inherited from TGMainFrame;  TGMainFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a top level main frame. ;  ;  ~TGMainFrame () override;  TGMainFrame destructor. ;  ; virtual Bool_t BindKey (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Bind key to a window. ;  ; virtual void CloseWindow ();  Close and delete main frame. ;  ; void DontCallClose ();  Typically call this method in the slot connected to the CloseWindow() signal to prevent the calling of the default or any derived CloseWindow() methods to prevent premature or double deletion of this window. ;  ; TList * GetBindList () const;  ; void GetClassHints (const char *&className, const char *&resourceName) const;  ; const char * GetIconName () const override;  Returns mime type name of object. ;  ; const char * GetIconPixmap () const;  ; void GetMWMHints (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGRecorder.html:1031,timeout,timeouts,1031,doc/master/classTGRecorder.html,https://root.cern,https://root.cern/doc/master/classTGRecorder.html,1,['timeout'],['timeouts']
Safety,". ROOT: TGeoManager Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Attributes |; Private Types |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TGeoManager Class ReferenceThe Geometry Package » Geometry classes. ; The manager class for any TGeo geometry. ; Provides user interface for geometry creation, navigation, state querying, visualization, IO, geometry checking and other utilities. General architecture; The ROOT geometry package is a tool designed for building, browsing, tracking and visualizing a detector geometry. The code is independent from other external MC for simulation, therefore it does not contain any constraints related to physics. However, the package defines a number of hooks for tracking, such as media, materials, magnetic field or track state flags, in order to allow interfacing to tracking MC's. The final goal is to be able to use the same geometry for several purposes, such as tracking, reconstruction or visualization, taking advantage of the ROOT features related to bookkeeping, I/O, histogramming, browsing and GUI's.; The geometrical modeler is the most important component of the package and it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"".; The architecture of the modeler is a combination between a GEANT-like containment scheme and a normal CSG binary tree at the level of shapes. An important common feature of all detector geometry descriptions is the mother-daughter concept. This is the most natural approach when tracking is concerned and imposes a set of constraints to the way geometry is defined. Constructive solid geom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:761,detect,detector,761,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['detect'],['detector']
Safety,". ROOT: TGeoPhysicalNode Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TGeoPhysicalNode Class ReferenceThe Geometry Package » Geometry classes. ; Physical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. ; The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 1e6-1e9, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::TGeoPhysicalNodeTGeoPhysicalNode()Default constructor.Definition TGeoPhysicalNode.cxx:77; Once created, a physical node can be misaligned, meaning that its position or even shape can be changed:; pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; bool. Definition at line 35 of file TGeoPhysicalNode.h. Public Types; enum  {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPhysicalNode.html:699,detect,detector,699,doc/master/classTGeoPhysicalNode.html,https://root.cern,https://root.cern/doc/master/classTGeoPhysicalNode.html,1,['detect'],['detector']
Safety,". ROOT: TGeoShape Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Private Attributes |; List of all members ; TGeoShape Class ReferenceabstractThe Geometry Package » Shapes. ; Base abstract class for all shapes. ; Shapes are geometrical objects that provide the basic modelling functionality. They provide the definition of the LOCAL frame of coordinates, with respect to which they are defined. Any implementation of a shape deriving from the base TGeoShape class has to provide methods for :. finding out if a point defined in their local frame is or not contained inside;; computing the distance from a local point to getting outside/entering the shape, given a known direction;; computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods :; computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; algorithms for dividing the shape along a given axis and producing resulting divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes made as a result of boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (composition of composites). This allows the creation of a quite large number of different shape topologies and combinations.; Name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:1019,safe,safe,1019,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,". ROOT: TGeoVolumeAssembly Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TGeoVolumeAssembly Class ReferenceThe Geometry Package » Geometry classes. ; Volume assemblies. ; Assemblies a volumes that have neither a shape or a material/medium. Assemblies behave exactly like normal volumes grouping several daughters together, but the daughters can never extrude the assembly since this has no shape. However, a bounding box and a voxelization structure are built for assemblies as for normal volumes, so that navigation is still optimized. Assemblies are useful for grouping hierarchically volumes which are otherwise defined in a flat manner, but also to avoid clashes between container shapes. To define an assembly one should just input a name, then start adding other volumes (or volume assemblies) as content. ; Definition at line 316 of file TGeoVolume.h. Classes; struct  ThreadData_t;  . Public Member Functions;  TGeoVolumeAssembly ();  Default constructor. ;  ;  TGeoVolumeAssembly (const char *name);  Constructor. ;  ;  ~TGeoVolumeAssembly () override;  Destructor. The assembly is owner of its ""shape"". ;  ; TGeoNode * AddNode (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""") override;  Add a component to the assembly. ;  ; void AddNodeOverlap (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option) override;  Add an overlapping node - not allowed for assemblies. ;  ; void ClearThreadData () const override;  ; TGeoVolume * CloneVolume () const override;  Clone this volume. ;  ; void CreateThreadData (Int_t nthreads) override;  ; TGeoVolume * Divide (const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""") override;  Division makes no sense for assemblies. ;  ; TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:874,avoid,avoid,874,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['avoid'],['avoid']
Safety,". ROOT: TGeometry Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; List of all members ; TGeometry Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; TGeometry description. ; The Geometry class describes the geometry of a detector. The current implementation supports the GEANT3 style description. A special program provided in the ROOT utilities (toroot) can be used to automatically translate a GEANT detector geometry into a ROOT geometry.; a Geometry object is entered into the list of geometries into the ROOT main object (see TROOT description) when the TGeometry constructor is invoked. Several geometries may coexist in memory. / A Geometry object consist of the following linked lists:. the TMaterial list (material definition only).; the TRotmatrix list (Rotation matrices definition only).; the TShape list (volume definition only).; the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported.; The conversion program from Geant to Root has been added in the list of utilities in utils directory.(see g2root) The executable module of g2root can be found in $ROOTSYS/bin/g2root.; To use this conversion program, type the shell command:; g2root geant_rzfile macro_name; for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C; To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewer); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); d#define d(i)Definition RSha256.hxx:102; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeometry.html:417,detect,detector,417,doc/master/classTGeometry.html,https://root.cern,https://root.cern/doc/master/classTGeometry.html,2,['detect'],['detector']
Safety,". ROOT: TGondzioSolver Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TGondzioSolver Class Reference. ; Derived class of TQpSolverBase implementing Gondzio-correction version of Mehrotra's original predictor-corrector algorithm. ; Definition at line 56 of file TGondzioSolver.h. Public Member Functions;  TGondzioSolver ();  Default constructor. ;  ;  TGondzioSolver (const TGondzioSolver &another);  Copy constructor. ;  ;  TGondzioSolver (TQpProbBase *of, TQpDataBase *prob, Int_t verbose=0);  Constructor. ;  ;  ~TGondzioSolver () override;  Deconstructor. ;  ; void DefMonitor (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level) override;  Print information about the optimization process and monitor the convergence status of thye algorithm. ;  ; TClass * IsA () const override;  ; TGondzioSolver & operator= (const TGondzioSolver &source);  Assignment operator. ;  ; virtual void Reset_parameters ();  ; Int_t Solve (TQpDataBase *prob, TQpVar *iterate, TQpResidual *resid) override;  Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TQpSolverBase;  TQpSolverBase ();  Default constructor. ;  ;  TQpSolverBase (const TQpSolverBase &another);  Copy constructor. ;  ;  ~TQpSolverBase () override;  Deconstructor. ;  ; Double_t DataNorm ();  ; virtual void DefStart (TQpProbBase *formulation, TQpVar *iterate, TQpDataBase *prob, TQpResidual *resid, TQpVar *step);  Default starting point. ;  ; virtual Int_t DefStatus (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Int_t i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGondzioSolver.html:379,predict,predictor-corrector,379,doc/master/classTGondzioSolver.html,https://root.cern,https://root.cern/doc/master/classTGondzioSolver.html,1,['predict'],['predictor-corrector']
Safety,". ROOT: THttpTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; Private Attributes |; List of all members ; THttpTimer Class Reference. . Definition at line 42 of file THttpServer.cxx. Public Member Functions;  THttpTimer (Long_t milliSec, Bool_t mode, THttpServer &serv);  !< server processing requests ;  ; Bool_t IsSlow () const;  ; void SetSlow (Bool_t flag);  ; void Timeout () override;  timeout handler used to process http requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpTimer.html:518,timeout,timeout,518,doc/master/classTHttpTimer.html,https://root.cern,https://root.cern/doc/master/classTHttpTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: TMVA::LossFunctionEventInfo Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TMVA::LossFunctionEventInfo Class Reference. . Definition at line 48 of file LossFunction.h. Public Member Functions;  LossFunctionEventInfo ();  ;  LossFunctionEventInfo (Double_t trueValue_, Double_t predictedValue_, Double_t weight_);  ;  ~LossFunctionEventInfo ();  . Public Attributes; Double_t predictedValue;  ; Double_t trueValue;  ; Double_t weight;  . #include <TMVA/LossFunction.h>; Constructor & Destructor Documentation. ◆ LossFunctionEventInfo() [1/2]. TMVA::LossFunctionEventInfo::LossFunctionEventInfo ; (; ). inline . Definition at line 51 of file LossFunction.h. ◆ LossFunctionEventInfo() [2/2]. TMVA::LossFunctionEventInfo::LossFunctionEventInfo ; (; Double_t ; trueValue_, . Double_t ; predictedValue_, . Double_t ; weight_ . ). inline . Definition at line 56 of file LossFunction.h. ◆ ~LossFunctionEventInfo(). TMVA::LossFunctionEventInfo::~LossFunctionEventInfo ; (; ). inline . Definition at line 61 of file LossFunction.h. Member Data Documentation. ◆ predictedValue. Double_t TMVA::LossFunctionEventInfo::predictedValue. Definition at line 64 of file LossFunction.h. ◆ trueValue. Double_t TMVA::LossFunctionEventInfo::trueValue. Definition at line 63 of file LossFunction.h. ◆ weight. Double_t TMVA::LossFunctionEventInfo::weight. Definition at line 65 of file LossFunction.h. Libraries for TMVA::LossFunctionEventInfo:. [legend]; The documentation for this class was generated from the following file:; tmva/tmva/inc/TMVA/LossFunction.h. TMVALossFunctionEventInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1LossFunctionEventInfo.html:527,predict,predictedValue,527,doc/master/classTMVA_1_1LossFunctionEventInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1LossFunctionEventInfo.html,3,['predict'],['predictedValue']
Safety,". ROOT: TMaterial Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMaterial Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; Manages a detector material. ; See class TGeometry ; Definition at line 28 of file TMaterial.h. Public Member Functions;  TMaterial ();  Material default constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density);  Material normal constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density, Float_t radl, Float_t inter);  Material normal constructor. ;  ;  ~TMaterial () override;  Material default destructor. ;  ; virtual Float_t GetA () const;  ; virtual Float_t GetDensity () const;  ; virtual Float_t GetInterLength () const;  ; virtual Int_t GetNumber () const;  ; virtual Float_t GetRadLength () const;  ; virtual Float_t GetZ () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TMaterial. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMaterial.html:327,detect,detector,327,doc/master/classTMaterial.html,https://root.cern,https://root.cern/doc/master/classTMaterial.html,1,['detect'],['detector']
Safety,". ROOT: TMehrotraSolver Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMehrotraSolver Class Reference. ; Derived class of TQpSolverBase implementing the original Mehrotra predictor-corrector algorithm. ; Definition at line 55 of file TMehrotraSolver.h. Public Member Functions;  TMehrotraSolver ();  Default constructor. ;  ;  TMehrotraSolver (const TMehrotraSolver &another);  Copy constructor. ;  ;  TMehrotraSolver (TQpProbBase *of, TQpDataBase *prob, Int_t verbose=0);  Constructor. ;  ;  ~TMehrotraSolver () override;  Deconstructor. ;  ; void DefMonitor (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level) override;  Print information about the optimization process and monitor the convergence status of thye algorithm. ;  ; TClass * IsA () const override;  ; TMehrotraSolver & operator= (const TMehrotraSolver &source);  Assignment operator. ;  ; Int_t Solve (TQpDataBase *prob, TQpVar *iterate, TQpResidual *resid) override;  Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TQpSolverBase;  TQpSolverBase ();  Default constructor. ;  ;  TQpSolverBase (const TQpSolverBase &another);  Copy constructor. ;  ;  ~TQpSolverBase () override;  Deconstructor. ;  ; Double_t DataNorm ();  ; virtual void DefStart (TQpProbBase *formulation, TQpVar *iterate, TQpDataBase *prob, TQpResidual *resid, TQpVar *step);  Default starting point. ;  ; virtual Int_t DefStatus (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Int_t i, Double_t mu, Int_t level);  Default status method. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMehrotraSolver.html:353,predict,predictor-corrector,353,doc/master/classTMehrotraSolver.html,https://root.cern,https://root.cern/doc/master/classTMehrotraSolver.html,1,['predict'],['predictor-corrector']
Safety,". ROOT: TMixture Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMixture Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; Manages a detector mixture. ; See class TGeometry. ; Definition at line 27 of file TMixture.h. Public Member Functions;  TMixture ();  Mixture default constructor. ;  ;  TMixture (const char *name, const char *title, Int_t nmixt);  Mixture normal constructor. ;  ;  ~TMixture () override;  Mixture default destructor. ;  ; virtual void DefineElement (Int_t n, Float_t a, Float_t z, Float_t w);  Define one mixture element. ;  ; Float_t * GetAmixt () const;  ; Int_t GetNmixt () const;  ; Float_t * GetWmixt () const;  ; Float_t * GetZmixt () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMaterial;  TMaterial ();  Material default constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density);  Material normal constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density, Float_t radl, Float_t inter);  Material normal constructor. ;  ;  ~TMaterial () override;  Material default destructor. ;  ; virtual Float_t GetA () const;  ; virtual Float_t GetDensity () const;  ; virtual Float_t GetInterLength () const;  ; virtual Int_t GetNumber () const;  ; virtual Float_t GetRadLength () const;  ; virtual Float_t GetZ () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMixture.html:325,detect,detector,325,doc/master/classTMixture.html,https://root.cern,https://root.cern/doc/master/classTMixture.html,1,['detect'],['detector']
Safety,". ROOT: TObjectSpy Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TObjectSpy Class ReferenceCore ROOT classes » Base ROOT classes. ; Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. ; When this pointer is zero we know the object has been deleted. This avoids the unsafe TestBit(kNotDeleted) hack. The spied object must have the kMustCleanup bit set otherwise you will get an error. ; Definition at line 30 of file TObjectSpy.h. Public Member Functions;  TObjectSpy (TObject *obj=nullptr, Bool_t fixMustCleanupBit=kTRUE);  Register the object that must be spied. ;  ; virtual ~TObjectSpy ();  Cleanup. ;  ; TObject * GetObject () const;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Sets the object pointer to zero if the object is deleted in the RecursiveRemove() operation. ;  ; void SetObject (TObject *obj, Bool_t fixMustCleanupBit=kTRUE);  Set obj as the spy target. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectSpy.html:511,avoid,avoids,511,doc/master/classTObjectSpy.html,https://root.cern,https://root.cern/doc/master/classTObjectSpy.html,2,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,". ROOT: TPad Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TPad Class ReferenceGraphics » 2D Graphics » Graphics pad. ; The most important graphics class in the ROOT system. ; A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects, histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw member function of the object classes.; It is important to realize that the pad is a linked list of references to the original object. For example, in case of a histogram, the histogram.Draw() operation only stores a reference to the histogram object and not a graphical representation of this histogram. When the mouse is used to change (say the bin content), the bin content of the original histogram is changed.; The convention used in ROOT is that a Draw operation only adds a reference to the object. The effective drawing is performed when the canvas receives a signal to be painted. This signal is generally sent when typing carriage return in the command input or when a graphical operation has been performed on one of the pads of this canvas. When a Canvas/Pad is repainted, the member function Paint for all objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive is called for all the elements in the pad. DistancetoPrimitive returns the distance in pixels to this object.; When the object is within the distance window, the member function ExecuteEvent is called for this object.; In ExecuteEvent, move, changes can be performed on the object.; For examples of Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:666,detect,detectors,666,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['detect'],['detectors']
Safety,". ROOT: TParticle Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TParticle Class ReferenceMonte Carlo » EG. ; Description of the dynamic properties of a particle. ; A dynamic particle class created by event generators and used during the propagation in detectors. The static attributes of a TParticle are described by TParticlePDG.; Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Definition at line 26 of file TParticle.h. Public Member Functions;  TParticle ();  reference to the particle record in PDG database ;  ;  TParticle (const TParticle &part);  copy constructor ;  ;  TParticle (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, const TLorentzVector &p, const TLorentzVector &v);  constructor ;  ;  TParticle (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot, Double_t vx, Double_t vy, Double_t vz, Double_t time);  constructor ;  ;  ~TParticle () override;  destructor ;  ; Int_t Beauty () const;  Return beauty quantum number. ;  ; Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParticle.html:434,detect,detectors,434,doc/master/classTParticle.html,https://root.cern,https://root.cern/doc/master/classTParticle.html,1,['detect'],['detectors']
Safety,". ROOT: TQt5Timer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; TQt5Timer Class ReferenceWeb Display » QT5 Web Display. . Definition at line 70 of file rootqt5.cpp. Public Member Functions;  TQt5Timer (Long_t milliSec, Bool_t mode);  ; void Timeout () override;  timeout handler used to process all qt5 events in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt5Timer.html:387,timeout,timeout,387,doc/master/classTQt5Timer.html,https://root.cern,https://root.cern/doc/master/classTQt5Timer.html,1,['timeout'],['timeout']
Safety,". ROOT: TQt6Timer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; TQt6Timer Class ReferenceWeb Display » QT6 Web Display. . Definition at line 49 of file rootqt6.cpp. Public Member Functions;  TQt6Timer (Long_t milliSec, Bool_t mode);  ; void Timeout () override;  timeout handler used to process all qt6 events in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt6Timer.html:387,timeout,timeout,387,doc/master/classTQt6Timer.html,https://root.cern,https://root.cern/doc/master/classTQt6Timer.html,1,['timeout'],['timeout']
Safety,". ROOT: TRef Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Friends |; List of all members ; TRef Class ReferenceCore ROOT classes » Base ROOT classes. ; Persistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject. ; This object can be used instead of normal C++ pointers in case. the referenced object R and the pointer P are not written to the same file; P is read before R; R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects, the normal ROOT Streaming mechanism ensures that only one copy of each object in the tree/graph is written to the output buffer to avoid circular dependencies.; However if the object event is split into several files or into several branches of one or more Trees, normal C++ pointers cannot be used because each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with TRef fRef;; TRefPersistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject.Definition TRef.h:32; one can do: fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls in the same or different files, in the same or different branches of a Tree.; If the TRef is read and the referenced object has not yet been read, the TRef will return a null pointer. As soon as the referenced object will be read, the TRef will point to it. If the referenced object is contained in a TTree it can be auto-loaded using the TBranchRef mechanism, which is set up by simply calling TTree::BranchRef().; TRef also supports the complex situation where a TFile is updated multiple times on the same machine or a different machine. How does it work; A TRef is itself a TObject with an ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:855,avoid,avoid,855,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['avoid'],['avoid']
Safety,". ROOT: TRotMatrix Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TRotMatrix Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; Manages a detector rotation matrix. ; See class TGeometry. ; Definition at line 28 of file TRotMatrix.h. Public Types; enum  { kReflection = (1ULL << ( 23 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TRotMatrix ();  RotMatrix default constructor. ;  ;  TRotMatrix (const char *name, const char *title, Double_t *matrix);  RotMatrix normal constructor. ;  ;  TRotMatrix (const char *name, const char *title, Double_t theta, Double_t phi, Double_t psi);  RotMatrix normal constructor. ;  ;  TRotMatrix (const char *name, const char *title, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3);  RotMatrix normal constructor defined a la GEANT. ;  ;  ~TRotMatrix () override;  RotMatrix default destructor. ;  ; virtual Double_t Determinant () const;  Returns the value of the determinant of this matrix. ;  ; virtual Double_t * GetGLMatrix (Double_t *rGLMatrix) const;  Convert this matrix to the OpenGL [4x4]. ;  ; virtual Double_t * GetMatrix ();  ; virtual Int_t Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRotMatrix.html:373,detect,detector,373,doc/master/classTRotMatrix.html,https://root.cern,https://root.cern/doc/master/classTRotMatrix.html,1,['detect'],['detector']
Safety,". ROOT: TSessionQueryFrame Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Types |; Private Attributes |; List of all members ; TSessionQueryFrame Class Reference. . Definition at line 377 of file TSessionViewer.h. Public Member Functions;  TSessionQueryFrame (TGWindow *parent, Int_t w, Int_t h);  Constructor. ;  ;  ~TSessionQueryFrame () override;  Destructor. ;  ; void Build (TSessionViewer *gui);  Build query information frame. ;  ; void Feedback (TList *objs);  Feedback function connected to Feedback signal. ;  ; TEditQueryFrame * GetQueryEditFrame () const;  ; TCanvas * GetStatsCanvas () const;  ; TGTab * GetTab () const;  ; void IndicateStop (Bool_t aborted);  Indicate that Cancel or Stop was clicked. ;  ; TClass * IsA () const override;  ; void Modified (Bool_t mod=kTRUE);  Notify changes in query editor settings. ;  ; void OnBtnAbort ();  Abort processing query. ;  ; void OnBtnFinalize ();  Finalize query. ;  ; void OnBtnRetrieve ();  Retrieve query. ;  ; void OnBtnShowLog ();  Show query log. ;  ; void OnBtnStop ();  Stop processing query. ;  ; void OnBtnSubmit ();  Submit query. ;  ; void Progress (Long64_t total, Long64_t processed);  Update progress bar and status labels. ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti);  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses);  New version of Progress (just forward to the old version for the time being). ;  ; void ProgressLocal (Long64_t total, Long64_t processed);  Update progress bar and status labels. ;  ; void ResetProgressDialog (const char *selec, Int_t files, Long64_t first, Long64_t entries);  Reset progress frame information fields. ;  ; void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:806,abort,aborted,806,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['abort'],['aborted']
Safety,". ROOT: TStopTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; List of all members ; TStopTimer Class Reference. . Definition at line 169 of file TProofPlayer.cxx. Public Member Functions;  TStopTimer (TProofPlayer *p, Bool_t abort, Int_t to);  Constructor for the timer to stop/abort processing. ;  ; Bool_t Notify () override;  Handle the signal coming from the expiration of the timer associated with an abort or stop request. ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStopTimer.html:352,abort,abort,352,doc/master/classTStopTimer.html,https://root.cern,https://root.cern/doc/master/classTStopTimer.html,3,['abort'],['abort']
Safety,". ROOT: TTreeReaderValue< T > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; List of all members ; TTreeReaderValue< T > Class Template ReferencefinalTreePlayer Library. ; template<typename T>; class TTreeReaderValue< T >An interface for reading values stored in ROOT columnar datasets. ; The TTreeReaderValue is a type-safe tool to be used in association with a TTreeReader to access the values stored in TTree, TNtuple and TChain datasets. TTreeReaderValue can be also used to access collections such as std::vectors or TClonesArray stored in columnar datasets but it is recommended to use TTreeReaderArray instead as it offers several advantages.; See the documentation of TTreeReader for more details and examples. ; Definition at line 174 of file TTreeReaderValue.h. Public Types; using NonConstT_t = typename std::remove_const< T >::type;  ;  Public Types inherited from ROOT::Internal::TTreeReaderValueBase; typedef bool(ROOT::Detail::TBranchProxy::* BranchProxyRead_t) ();  ; enum  EReadStatus { kReadSuccess = 0; , kReadNothingYet; , kReadError; };  ; enum  ESetupStatus { ;   kSetupNotSetup = -7; , kSetupTreeDestructed = -8; , kSetupMakeClassModeMismatch = -9; , kSetupMissingCounterBranch = -6; , ;   kSetupMissingBranch = -5; , kSetupInternalError = -4; , kSetupMissingDictionary = -3; , kSetupMismatch = -2; , ;   kSetupNotACollection = -1; , kSetupMatch = 0; , kSetupMatchBranch = 7; , kSetupNoCheck = 5; , ;   kSetupMatchLeaf = 6. };  Status flags, 0 is good. More...;  . Public Member Functions;  TTreeReaderValue ()=delete;  ;  TTreeReaderValue (TTreeReader &tr, const char *branchname);  ; T * Get ();  Return a pointer to the value of the current entry. ;  ; T & operator* ();  Return a reference to the value of the current entry. ;  ; T * operator-> ();  Return a pointer to the value of the current entry. ;  ;  Public Mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReaderValue.html:476,safe,safe,476,doc/master/classTTreeReaderValue.html,https://root.cern,https://root.cern/doc/master/classTTreeReaderValue.html,1,['safe'],['safe']
Safety,". ROOT: TUnfold Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Member Functions |; Protected Attributes |; Private Member Functions |; Private Attributes |; List of all members ; TUnfold Class Reference. ; An algorithm to unfold distributions from detector to truth level. ; TUnfold is used to decompose a measurement y into several sources x, given the measurement uncertainties and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfold has an adjustable regularisation term and also supports an optional constraint on the total number of events.; For most applications, it is better to use the derived class TUnfoldDensity instead of TUnfold. TUnfoldDensity adds various features to TUnfold, such as: background subtraction, propagation of systematic uncertainties, complex multidimensional arrangements of the bins. For innocent users, the most notable improvement of TUnfoldDensity over TUnfold are the getter functions. For TUnfold, histograms have to be booked by the user and the getter functions fill the histogram bins. TUnfoldDensity simply returns a new, already filled histogram.; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfold: . a matrix (truth,reconstructed) is given as a two-dimensional histogram as argument to the constructor of TUnfold . a vector of measurements is given as one-dimensional histogram using the SetInput() method . The unfolding is performed . either once with a fixed parameter tau, method DoUnfold(tau) . or multiple ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:446,detect,detector,446,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['detect'],['detector']
Safety,". ROOT: TUnfold classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TUnfold classesHistogram Library. ; An algorithm to unfold distributions from detector to truth level.; AuthorStefan Schmitt DESY . Classes; class  TUnfoldSys;  An algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Unfold.html:194,detect,detector,194,doc/master/group__Unfold.html,https://root.cern,https://root.cern/doc/master/group__Unfold.html,2,['detect'],['detector']
Safety,". ROOT: TUnfoldDensity Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TUnfoldDensity Class Reference. ; An algorithm to unfold distributions from detector to truth level. ; TUnfoldDensity is used to decompose a measurement y into several sources x, given the measurement uncertainties, background b and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfoldDensity has an adjustable regularisation term and also supports an optional constraint on the total number of events. Background sources can be specified, with a normalisation constant and normalisation uncertainty. In addition, variants of the response matrix may be specified, these are taken to determine systematic uncertainties. Complex, multidimensional arrangements of signal and background bins are managed with the help of the class TUnfoldBinning.; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfoldSys:. Set up binning schemes for the truth and measured distributions. The binning schemes may be coded in the XML language, for reading use TUnfoldBinningXML. . A matrix (truth,reconstructed) is given as a two-dimensional histogram as argument to the constructor of TUnfold . A vector of measurements is given as one-dimensional histogram using the SetInput() method . Repeated calls to SubtractBackground() to specify background sources . Repeated calls to AddSysError() to specify systematic uncertainties . The unfolding is performed . either once with a fixed pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:373,detect,detector,373,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['detect'],['detector']
Safety,". ROOT: TUnfoldSys Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TUnfoldSys Class ReferenceHistogram Library » TUnfold classes. ; An algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties. ; TUnfoldSys is used to decompose a measurement y into several sources x, given the measurement uncertainties, background b and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfoldSys has an adjustable regularisation term and also supports an optional constraint on the total number of events. Background sources can be specified, with a normalisation constant and normalisation uncertainty. In addition, variants of the response matrix may be specified, these are taken to determine systematic uncertainties.; For most applications, it is better to use the derived class TUnfoldDensity instead of TUnfoldSys. TUnfoldDensity adds features to TUnfoldSys, related to possible complex multidimensional arrangements of bins. For innocent users, the most notable improvement of TUnfoldDensity over TUnfoldSys are the getter functions. For TUnfoldSys, histograms have to be booked by the user and the getter functions fill the histogram bins. TUnfoldDensity simply returns a new, already filled histogram.; If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfoldSys: . a matrix (truth,reconstructed) is given as a two-dimensional histogram as ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:428,detect,detector,428,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['detect'],['detector']
Safety,". ROOT: TVectorT< Element > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; List of all members ; TVectorT< Element > Class Template ReferenceMath » Matrix Linear Algebra. ; template<class Element>; class TVectorT< Element >TVectorT. ; Template class of Vectors in the linear algebra package.; See the Matrix Linear Algebra page for the documentation of the linear algebra package; Unless otherwise specified, vector indices always start with 0, spanning up to the specified limit-1.; For (n) vectors where n <= kSizeMax (5 currently) storage space is available on the stack, thus avoiding expensive allocation/ deallocation of heap space . However, this introduces of course kSizeMax overhead for each vector object . If this is an issue recompile with a new appropriate value (>=0) for kSizeMax; Another way to assign and store vector data is through Use see for instance stressLinear.cxx file .; Note that Constructors/assignments exists for all different matrix views; For usage examples see $ROOTSYS/test/stressLinear.cxx ; Definition at line 27 of file TVectorT.h. Public Member Functions;  TVectorT ();  ;  TVectorT (const TMatrixTColumn_const< Element > &mc);  Constructor : create vector from matrix column. ;  ;  TVectorT (const TMatrixTDiag_const< Element > &md);  Constructor : create vector from matrix diagonal. ;  ;  TVectorT (const TMatrixTRow_const< Element > &mr);  Constructor : create vector from matrix row. ;  ;  TVectorT (const TVectorT< Element > &another);  Copy constructor. ;  ; template<class Element2 > ;  TVectorT (const TVectorT< Element2 > &another);  ;  TVectorT (Int_t lwb, Int_t upb);  Constructor [lwb..upb]-vector. ;  ;  TVectorT (Int_t lwb, Int_t upb, const Element *elements);  Constructor [lwb..upb]-vector with data copied from array elements. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVectorT.html:797,avoid,avoiding,797,doc/master/classTVectorT.html,https://root.cern,https://root.cern/doc/master/classTVectorT.html,1,['avoid'],['avoiding']
Safety,". ROOT: TVirtualFFT Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Static Protected Attributes |; List of all members ; TVirtualFFT Class ReferenceabstractCore ROOT classes » Base ROOT classes. ; TVirtualFFT is an interface class for Fast Fourier Transforms. ; The default FFT library is FFTW. To use it, FFTW3 library should already be installed, and ROOT should be have fftw3 module enabled, with the directories of fftw3 include file and library specified (see installation instructions). Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT) in one or more dimensions, -1 in the exponent; ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT) in one or more dimensions, +1 in the exponent; ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT) in one or more dimensions,; ""C2R"" - inverse transforms to ""R2C"", taking complex input (storing the non-redundant half of a logically Hermitian array) to real output; ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format, i.e. real and imaginary parts for a transform of size n stored as r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; ""HC2R"" - computes the reverse of FFTW_R2HC, above; ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static function. 4 different kinds of sine and cosine transforms are available. DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFFT.html:1132,redund,redundant,1132,doc/master/classTVirtualFFT.html,https://root.cern,https://root.cern/doc/master/classTVirtualFFT.html,1,['redund'],['redundant']
Safety,". ROOT: TVirtualMutex Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; List of all members ; TVirtualMutex Class ReferenceabstractCore ROOT classes » Base ROOT classes. ; This class implements a mutex interface. ; The actual work is done via TMutex which is available as soon as the thread library is loaded.; and; TLockGuard; This class provides mutex resource management in a guaranteed and exception safe way. Use like this: {; TLockGuard guard(mutex);; ... // do something; }; TLockGuardDefinition TVirtualMutex.h:70; when guard goes out of scope the mutex is unlocked in the TLockGuard destructor. The exception mechanism takes care of calling the dtors of local objects so it is exception safe. ; Definition at line 32 of file TVirtualMutex.h. Public Member Functions;  TVirtualMutex (Bool_t=kFALSE);  ; virtual ~TVirtualMutex ();  ; Int_t Acquire ();  ; virtual Int_t CleanUp ()=0;  ; virtual TVirtualMutex * Factory (Bool_t=kFALSE)=0;  ; virtual TClass * IsA () const;  ; virtual Int_t Lock ()=0;  ; Int_t Release ();  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t TryLock ()=0;  ; virtual Int_t UnLock ()=0;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . #include <TVirtualMutex.h>. Inheritance diagram for TVirtualMutex:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TVirtualMutex(). TVirtualMutex::TVirtualMutex ; (; Bool_t ; = kFALSE). inline . Definition at line 35 of file TVirtualMutex.h. ◆ ~TVirtualMutex(). virtual TVirtualMutex::~TVirtualMutex ; (; ). inlinevirtual . Definition at line 36 of file TVirtualMutex.h. Member Function Documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualMutex.html:536,safe,safe,536,doc/master/classTVirtualMutex.html,https://root.cern,https://root.cern/doc/master/classTVirtualMutex.html,2,['safe'],['safe']
Safety,". ROOT: The Geometry Package. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; The Geometry Package. ; The ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA. Quick Start: Creating the world; Example 1: Creating the World; Example 2: A Geometrical Hierarchy Look and Feel. Selecting the System of Units in ROOT; Geometry Creation; The Volume Hierarchy; Creating and Positioning Volumes; Making Volumes; Example of Volume Creation; Positioned Volumes (Nodes); Virtual Containers and Assemblies of Volumes; Examples of Volume Positioning; Overlapping Volumes; Replicating Volumes; Volume Families; Dividing Volumes; Volume Assemblies. Geometrical Transformations; Matrix Creation Example; Rule for Creation of Transformations; Available Geometrical Transformations. Ownership of Geometry Objects. Navigation and Tracking; TGeoNavigator Class; Initializing the Starting Point; Initializing the Direction; Initializing the State; Checking the Current State; Saving and Restoring the Current State; Navigation Queries; Finding If Current State Is Changed For a New Point; Finding the Distance to the Next Boundary; Computing the Safe Radius; Making a Step; The Normal Vector to the Next Crossed Surface at Crossing Point. Creating and Visualizing Tracks. Checking the Geometry; The Overlap Checker; Graphical Checking Methods. The Drawing Package; Drawing Volumes and Hierarchies of Volumes; Visualization Settings and Attributes; Colors and Line Styles; Visibility Settings. Ray Tracing; Clipping Ray-traced Images. Representing Misalignments of the Ideal Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:232,detect,detector,232,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:997,safe,safe,997,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['safe'],['safe']
Safety,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first nor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClassTable_8cxx_source.html:996,safe,safe,996,doc/v632/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html,1,['safe'],['safe']
Safety,". ROOT: geom/geom/src/TGeoManager.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoManager.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 25/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoManager; 13\ingroup Geometry_classes; 14 ; 15The manager class for any TGeo geometry. Provides user; 16interface for geometry creation, navigation, state querying,; 17visualization, IO, geometry checking and other utilities.; 18 ; 19## General architecture; 20 ; 21 The ROOT geometry package is a tool designed for building, browsing,; 22tracking and visualizing a detector geometry. The code is independent from; 23other external MC for simulation, therefore it does not contain any; 24constraints related to physics. However, the package defines a number of; 25hooks for tracking, such as media, materials, magnetic field or track state flags,; 26in order to allow interfacing to tracking MC's. The final goal is to be; 27able to use the same geometry for several purposes, such as tracking,; 28reconstruction or visualization, taking advantage of the ROOT features; 29related to bookkeeping, I/O, histogramming, browsing and GUI's.; 30 ; 31 The geometrical modeler is the most important component of the package and; 32it provides answers to the basic questions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:1010,detect,detector,1010,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['detect'],['detector']
Safety,". ROOT: hist/hist/inc/HFitInterface.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. HFitInterface.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: L. Moneta Thu Aug 31 10:40:20 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class HFitInterface; 12// set of free functions used to couple the ROOT data object with the fitting classes; 13 ; 14// avoid including this file when running CINT since free functions cannot be re-defined; 15 ; 16#ifndef ROOT_HFitInterface; 17#define ROOT_HFitInterface; 18 ; 19 ; 20class TH1;; 21class THnBase;; 22class TF1;; 23class TF2;; 24class TGraph;; 25class TGraphErrors;; 26class TGraph2D;; 27class TMultiGraph;; 28struct Foption_t;; 29 ; 30#include ""TFitResultPtr.h""; 31 ; 32namespace ROOT {; 33 ; 34 namespace Math {; 35 class MinimizerOptions;; 36 }; 37 ; 38 namespace Fit {; 39 ; 40 //class BinData;; 41 ; 42 class FitResult;; 43 class DataRange;; 44 class BinData;; 45 class UnBinData;; 46 class SparseData;; 47 ; 48 enum class EFitObjectType {; 49 kHistogram,; 50 kGraph; 51 };; 52 ; 53 enum class EChisquareType {; 54 kNeyman = 0,; 55 kPLikeRatio,; 56 kPearson; 57 };; 58 ; 59 ; 60 ; 61 /**; 62 Decode list of options into fitOption; 63 */; 64 void FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption);; 65 ; 66 /**; 67 fitting function for a TH1 (called from TH1::Fit); 68 */; 69 TFitResultPtr FitObject(TH1 * h1, TF1 *f1, Foption_t & option, const ROOT::Math::MinimizerOptions & moption, const char *goption, ROOT::Fit::DataRange & range);; 70 ; 71 /**; 72 fitting function for a TGraph (called from TGraph::Fit); 73 */; 74 TFitResultPtr FitObject(TGraph * gr, TF1 *f1 , Foption_t & option , const ROOT::Math::MinimizerOptions & moption, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8h_source.html:637,avoid,avoid,637,doc/master/HFitInterface_8h_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8h_source.html,1,['avoid'],['avoid']
Safety,". ROOT: tmva/pymva/src/PyMethodBase.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. PyMethodBase.cxx. Go to the documentation of this file. 1// @(#)root/tmva/pymva $Id$; 2// Authors: Omar Zapata, Lorenzo Moneta, Sergei Gleyzer 2015, Stefan Wunsch 2017; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : PyMethodBase *; 8 * *; 9 * Description: *; 10 * Virtual base class for all MVA method based on python *; 11 * *; 12 **********************************************************************************/; 13 ; 14#include <Python.h> // Needs to be included first to avoid redefinition of _POSIX_C_SOURCE; 15#include <TMVA/PyMethodBase.h>; 16 ; 17#include ""TMVA/DataSet.h""; 18#include ""TMVA/DataSetInfo.h""; 19#include ""TMVA/MsgLogger.h""; 20#include ""TMVA/Results.h""; 21#include ""TMVA/Timer.h""; 22#include ""TMVA/Tools.h""; 23 ; 24#include ""TSystem.h""; 25 ; 26#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; 27#include <numpy/arrayobject.h>; 28 ; 29using namespace TMVA;; 30 ; 31namespace TMVA {; 32namespace Internal {; 33class PyGILRAII {; 34 PyGILState_STATE m_GILState;; 35 ; 36public:; 37 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 38 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 39};; 40} // namespace Internal; 41 ; 42/// get current Python executable used by ROOT; 43TString Python_Executable() {; 44 TString python_version = gSystem->GetFromPipe(""root-config --python-version"");; 45 if (python_version.IsNull()) {; 46 TMVA::gTools().Log() << kFATAL << ""Can't find a valid Python version used to build ROOT"" << Endl;; 47 return nullptr;; 48 }; 49#ifdef _MSC_VER; 50 // on Windows there is a space before the version and the executable is python.exe; 51 // for both versions of Python; 52 python_version.ReplaceAll("" "", """");; 53 if (python_version[0] == '2' || python_version[0] == ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PyMethodBase_8cxx_source.html:767,avoid,avoid,767,doc/master/PyMethodBase_8cxx_source.html,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df103_NanoAODHiggsAnalysis.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total size of only 51MB. If the fast mode is disabled, the tutorial runs over the full dataset with a size of 12GB. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""ROOT/RDF/RInterface.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TLegend.h""; #inclu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:613,detect,detector,613,doc/master/df103__NanoAODHiggsAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df103_NanoAODHiggsAnalysis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that make computations on data to define new columns or filter existing ones in a precise way, better suited to be written in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead create nodes of the computational graph (e.g. Filter, Define) remain inside the ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:628,detect,detector,628,doc/master/df103__NanoAODHiggsAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:537,detect,detector,537,doc/master/df104__HiggsToTwoPhotons_8py.html,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:534,detect,detector,534,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:527,detect,detector,527,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:542,detect,detector,542,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:578,detect,detector,578,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:544,detect,detector,544,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/fit Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  combinedFit.C;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ;  combinedFit.py;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ;  ConfidenceIntervals.C;   Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ;  ErrorIntegral.C;   Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ;  ;  exampleFit3D.C;   example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  ;  fit1.C;   Simple fitting example (1-d histogram with an interpreted function) ;  ;  fit2.C;   Fitting a 2-D histogram This tutorial illustrates : ;  ;  fit2a.C;   Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  ;  fit2d.C;   Example illustrating how to fit a 2-d histogram of type y=f(x) ;  ;  fit2dHist.C;   Example to fit two histograms at the same time via the Fitter class. ;  ;  fitCircle.C;   Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  ;  fitcont.C;   Example illustrating how to draw the n-sigma contour of a Minuit fit. ;  ;  fitConvolution.C;   Tutorial for convolution of two functions ;  ;  fitConvolution.py;   Tutorial for convolution of two functions ;  ;  fitEllipseTGraphDLSF.cxx;  ;  fitEllipseTGraphRMM.cxx;  ;  fitExclude.C;   Illustrates how to fit excluding points in a given range. ;  ;  fithist.C;   Example of fit where the model is histogram + function ;  ;  FitHistoInFile.C;   ;  ;  fitLinear.C;   Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:928,predict,predictor,928,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,1,['predict'],['predictor']
Safety,". ROOT: tutorials/fit/exampleFit3D.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exampleFit3D.C File ReferenceTutorials » Fit Tutorials. Detailed Description; example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 prob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exampleFit3D_8C.html:302,predict,predictor,302,doc/master/exampleFit3D_8C.html,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html,1,['predict'],['predictor']
Safety,". ROOT: tutorials/geom/assembly.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. assembly.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Geometry detector assembly example. ; ��A2␏V ; void assembly(); {; //--- Definition of a simple geometry; TGeoManager *geom = new TGeoManager(""Assemblies"",; ""Geometry using assemblies"");; Int_t i;; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Aluminium"",2, matAl);; ; //--- make the top container volume; TGeoVolume *top = geom->MakeBox(""TOP"", Vacuum, 1000., 1000., 100.);; geom->SetTopVolume(top);; ; // Make the elementary assembly of the whole structure; TGeoVolume *tplate = new TGeoVolumeAssembly(""TOOTHPLATE"");; ; Int_t ntooth = 5;; Double_t xplate = 25;; Double_t yplate = 50;; Double_t xtooth = 10;; Double_t ytooth = 0.5*yplate/ntooth;; Double_t dshift = 2.*xplate + xtooth;; Double_t xt,yt;; ; TGeoVolume *plate = geom->MakeBox(""PLATE"", Al, xplate,yplate,1);; plate->SetLineColor(kBlue);; TGeoVolume *tooth = geom->MakeBox(""TOOTH"", Al, xtooth,ytooth,1);; tooth->SetLineColor(kBlue);; tplate->AddNode(plate,1);; for (i=0; i<ntooth; i++) {; xt = xplate+xtooth;; yt = -yplate + (4*i+1)*ytooth;; tplate->AddNode(tooth, i+1, new TGeoTranslation(xt,yt,0));; xt = -xplate-xtooth;; yt = -yplate + (4*i+3)*ytooth;; tplate->AddNode(tooth, ntooth+i+1, new TGeoTranslation(xt,yt,0));; }; ; TGeoRotation *rot1 = new TGeoRotation();; rot1->RotateX(90);; TGeoRotation *rot;; // Make a hexagone cell out of 6 tooth plates. These can zip together; // without generating overlaps (they are self-contained); TGeoVolume *cell = new TGeoVolumeAssembly(""CELL"");; for (i=0; i<6; i++) {; Double_t phi = 60.*i;; Double_t phirad = phi*TMath::DegToRad();; Double_t xp = dshift*TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geom_2assembly_8C.html:219,detect,detector,219,doc/master/geom_2assembly_8C.html,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomAlice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAlice.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ALICE). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAlice(); {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; gGeoManager->GetVolume(""L3MO"")->InvisibleAll();; gGeoManager->GetVolume(""YOUT1"")->InvisibleAll();; gGeoManager->GetVolume(""YOUT2"")->InvisibleAll();; gGeoManager->GetVolume(""YSAA"")->InvisibleAll();; gGeoManager->GetVolume(""RB24"")->InvisibleAll();; gGeoManager->GetVolume(""RB26Pipe"")->InvisibleAll();; gGeoManager->GetVolume(""DDIP"")->InvisibleAll();; gGeoManager->GetVolume(""DCM0"")->InvisibleAll();; // gGeoManager->GetVolume(""PPRD"")->InvisibleAll();; gGeoManager->GetVolume(""BRS1"")->InvisibleAll();; gGeoManager->GetVolume(""BRS4"")->InvisibleAll();; // gGeoManager->GetVolume(""Dipole"")->InvisibleAll();; gGeoManager->GetVolume(""ZN1"")->InvisibleAll();; gGeoManager->GetVolume(""Q13T"")->InvisibleAll();; gGeoManager->GetVolume(""ZP1"")->InvisibleAll();; gGeoManager->GetVolume(""QTD1"")->InvisibleAll();; gGeoManager->GetVolume(""QTD2"")->InvisibleAll();; gGeoManager->GetVolume(""QBS7"")->InvisibleAll();; gGeoManager->GetVolume(""QA07"")->InvisibleAll();; gGeoManager->GetVolume(""MD1V"")->InvisibleAll();; gGeoManager->GetVolume(""QTD3"")->InvisibleAll();; gGeoManager->GetVolume(""QTD4"")->InvisibleAll();; gGeoManager->GetVolume(""QTD5"")->InvisibleAll();; gGeoManager->GetVolume(""QBS3"")->InvisibleAll();; gGeoManager->GetVolume(""QBS4""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomAlice_8C.html:229,detect,detector,229,doc/master/geomAlice_8C.html,https://root.cern,https://root.cern/doc/master/geomAlice_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomAlice_itsv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAlice_itsv.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ITSV from Alice). ; By default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAlice_itsv() {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; gGeoManager->GetVolume(""ITSV"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoManager::DefaultColorsvoid DefaultColors()Set default volume colors according to A of material.Definition TGeoManager.cxx:2259; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomAlice_itsv.C. tutorialsgeomgeomAlice_itsv.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomAlice__itsv_8C.html:239,detect,detector,239,doc/master/geomAlice__itsv_8C.html,https://root.cern,https://root.cern/doc/master/geomAlice__itsv_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomAtlas.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAtlas.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ATLAS). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAtlas() {; TGeoManager::Import(""http://root.cern/files/atlas.root"");; //gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(5000);; //gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""ATLS"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoManager::SetMaxVisNodesvoid SetMaxVisNodes(Int_t maxnodes=10000)set the maximum number of visible nodes.Definition TGeoManager.cxx:2380; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomAtlas.C. tutorialsgeomgeomAtlas.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomAtlas_8C.html:229,detect,detector,229,doc/master/geomAtlas_8C.html,https://root.cern,https://root.cern/doc/master/geomAtlas_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomBrahms.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomBrahms.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here BRAHMS). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomBrahms() {; TGeoManager::Import(""http://root.cern/files/brahms.root"");; gGeoManager->GetVolume(""CAVE"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomBrahms.C. tutorialsgeomgeomBrahms.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomBrahms_8C.html:231,detect,detector,231,doc/master/geomBrahms_8C.html,https://root.cern,https://root.cern/doc/master/geomBrahms_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomD0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomD0.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here D0). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site.; run with .x geomD0.C top level detectors are transparent; or .x geomD0.C(1) top level detectors are visible. ; void RecursiveInvisible(TGeoVolume *vol);; void RecursiveTransparency(TGeoVolume *vol, Int_t transp);; ; void geomD0(Int_t allVisible=0) {; TGeoManager::Import(""http://root.cern/files/d0.root"");; gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(40000);; //gGeoManager->SetVisLevel(4);; if (!allVisible) {; RecursiveInvisible(gGeoManager->GetVolume(""D0-""));; RecursiveInvisible(gGeoManager->GetVolume(""D0+""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WZ""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WL""));; RecursiveTransparency(gGeoManager->GetVolume(""MUON""), 90);; }; ; gGeoManager->GetVolume(""D0"")->Draw(""ogl"");; }; ; void RecursiveInvisible(TGeoVolume *vol); {; vol->InvisibleAll();; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveInvisible(vol->GetNode(i)->GetVolume());; }; }; ; void RecursiveTransparency(TGeoVolume *vol, Int_t transp); {; vol->SetTransparency(transp);; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveTransparency(vol->GetNode(i)->GetVolume(), transp);; }; }; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomD0_8C.html:223,detect,detector,223,doc/master/geomD0_8C.html,https://root.cern,https://root.cern/doc/master/geomD0_8C.html,3,['detect'],"['detector', 'detectors']"
Safety,". ROOT: tutorials/geom/na49view.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. na49view.C File ReferenceTutorials » Geometry tutorials. Detailed Description; This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. . ; void na49view() {; TCanvas *c1 = new TCanvas(""c1"",""The NA49 canvas"",200,10,700,780);; ; gBenchmark->Start(""na49view"");; ; TPad *all = new TPad(""all"",""A Global view of NA49"",0.02,0.02,0.48,0.82,28);; TPad *tof = new TPad(""tof"",""One Time Of Flight element"",0.52,0.02,0.98,0.82,28);; all->Draw();; tof->Draw();; TPaveLabel *na49title = new TPaveLabel(0.04,0.86,0.96,0.98,""Two views of the NA49 detector"");; na49title->SetFillColor(32);; na49title->Draw();; //; TFile *nageom = new TFile(""na49.root"");; if (!nageom || nageom->IsZombie()) return;; TGeometry *n49 =(TGeometry*)gROOT->FindObject(""na49"");; n49->SetBomb(1.2);; n49->cd(); //Set current geometry; all->cd(); //Set current pad; n49->Draw();; c1->Update();; tof->cd();; TNode *TOFR1 = n49->GetNode(""TOFR1"");; TOFR1->Draw();; c1->Update();; ; gBenchmark->Show(""na49view"");; ; // To have a better and dynamic view of any of these pads,; // you can click with the middle button of your mouse to select it.; // Then select ""View with x3d"" in the VIEW menu of the Canvas.; // Once in x3d, you are in wireframe mode by default.; // You can switch to:; // - Hidden Line mode by typing E; // - Solid mode by typing R; // - Wireframe mode by typing W; // - Stereo mode by clicking S (and you need special glasses); // - To leave x3d type Q; }; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gROOT#define gROOTDefinition TROOT.h:406; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49view_8C.html:256,detect,detector,256,doc/master/na49view_8C.html,https://root.cern,https://root.cern/doc/master/na49view_8C.html,2,['detect'],['detector']
Safety,". ROOT: tutorials/graphics/gaxis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Simple example illustrating how to draw TGaxis objects in various formats. . ; void gaxis(){; auto c1 = new TCanvas(""c1"",""Examples of TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; ; auto axis1 = new TGaxis(-4.5,-0.2,5.5,-0.2,-6,8,510,"""");; axis1->Draw();; ; auto axis2 = new TGaxis(-4.5,0.2,5.5,0.2,0.001,10000,510,""G"");; axis2->Draw();; ; auto axis3 = new TGaxis(-9,-0.8,-9,0.8,-8,8,50510,"""");; axis3->SetTitle(""axis3"");; axis3->SetTitleOffset(0.5);; axis3->Draw();; ; auto axis4 = new TGaxis(-7,-0.8,-7,0.8,1,10000,50510,""G"");; axis4->SetTitle(""axis4"");; axis4->Draw();; ; auto axis5 = new TGaxis(-4.5,-0.6,5.5,-0.6,1.2,1.32,80506,""-+"");; axis5->SetLabelSize(0.03);; axis5->SetTextFont(72);; axis5->Draw();; ; auto axis6 = new TGaxis(-4.5,0.5,5.5,0.5,100,900,50510,""-"");; axis6->Draw();; ; auto axis7 = new TGaxis(-5.5,0.85,5.5,0.85,0,4.3e-6,510,"""");; axis7->Draw();; ; auto axis8 = new TGaxis(8,-0.8,8,0.8,0,9000,50510,""+L"");; axis8->Draw();; ; // One can make a vertical axis going top->bottom. However the two x values should be; // slightly different to avoid labels overlapping.; auto axis9 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis9->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; c1return c1Definition legend1.C:41; AuthorsRene Brun, Olivier Couet ; Definition in file gaxis.C. tutorialsgraphicsgaxis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gaxis_8C.html:1272,avoid,avoid,1272,doc/master/gaxis_8C.html,https://root.cern,https://root.cern/doc/master/gaxis_8C.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/graphics/mass_spectrum.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. mass_spectrum.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro makes use of some basic graphics primitives such as line, arrow and text. ; It has been written using the TCanvas ToolBar to produce a first draft and was then modified for fine adjustments. Note also the use of C functions. They allow to simplify the macro reading and editing by avoiding code repetition or defining some graphics attributes in one single place. This technique to generate drawings may appear not very user friendly compare to all the ""wysiwyg"" graphics editors available. In some cases it can be more powerful than a GUI interface because it allows to generate very precise drawing and using computation to generate them. ; void hline (Double_t x, Double_t y); {; Double_t dx = 0.1;; TLine *l = new TLine(x,y,x+dx,y);; l->Draw();; l->SetLineWidth(4);; }; ; void DrawArrow (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t ls); {; TArrow *arr = new TArrow(x1,y1,x2,y2,0.025,""|>"");; arr->SetFillColor(1);; arr->SetFillStyle(1001);; arr->SetLineStyle(ls);; arr->SetAngle(19);; arr->Draw();; }; ; void mass_spectrum(); {; TCanvas *C = new TCanvas(""C"",""C"",800,500);; ; hline (0.10,0.25);; hline (0.10,0.80);; hline (0.30,0.90);; hline (0.30,0.35);; hline (0.45,0.60);; hline (0.58,0.68);; hline (0.73,0.70);; hline (0.89,0.75);; ; DrawArrow(0.32, 0.90, 0.32, 0.35, 1);; DrawArrow(0.34, 0.90, 0.34, 0.35, 1);; DrawArrow(0.36, 0.90, 0.36, 0.60, 1);; DrawArrow(0.38, 0.90, 0.38, 0.70, 1);; ; DrawArrow(0.30, 0.90, 0.18, 0.25, 1);; DrawArrow(0.30, 0.35, 0.19, 0.25, 1);; DrawArrow(0.40, 0.90, 0.47, 0.61, 1);; ; DrawArrow(0.15, 0.25, 0.15, 0.19, 1);; DrawArrow(0.15, 0.80, 0.15, 0.74, 1);; ; DrawArrow(0.50, 0.60, 0.50, 0.54, 1);; DrawArrow(0.60, 0.68, 0.60, 0.62, 1);; DrawArrow(0.94, 0.75, 0.94, 0.69, 1);; ; DrawArrow(0.32, 0.35, 0.32, 0.19, 1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mass__spectrum_8C.html:516,avoid,avoiding,516,doc/master/mass__spectrum_8C.html,https://root.cern,https://root.cern/doc/master/mass__spectrum_8C.html,1,['avoid'],['avoiding']
Safety,". ROOT: tutorials/graphics/saveall.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. saveall.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Creates many canvases and save as images or pdf. ; This macro creates 100 canvases and store them in different images files using TCanvas::SaveAll() method. Demonstrated how different output format can be used in batch mode.; ; void saveall(); {; gROOT->SetBatch(kTRUE); // enforce batch mode to avoid appearance of multiple canvas windows; ; std::vector<TPad *> pads;; ; for(int n = 0; n < 100; ++n) {; auto c = new TCanvas(TString::Format(""canvas%d"", n), ""Canvas with histogram"");; ; auto h1 = new TH1I(TString::Format(""hist%d"", n), ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; ; h1->Draw();; ; pads.push_back(c);; }; ; TCanvas::SaveAll(pads, ""image%03d.png""); // create 100 PNG images; ; TCanvas::SaveAll(pads, ""image.svg""); // create 100 SVG images, %d pattern will be automatically append; ; TCanvas::SaveAll(pads, ""images.root""); // create single ROOT file with all canvases; ; TCanvas::SaveAll(); // save all existing canvases in allcanvases.pdf file; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/saveall_8C.html:508,avoid,avoid,508,doc/master/saveall_8C.html,https://root.cern,https://root.cern/doc/master/saveall_8C.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/graphs/zdemo.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. zdemo.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC.; Note that the way greek symbols, super/subscripts are obtained illustrate the current limitations of Root in this area. ; #include ""TCanvas.h""; #include ""TPad.h""; #include ""TPaveLabel.h""; #include ""TLatex.h""; #include ""TGraph.h""; #include ""TFrame.h""; ; #ifdef HZ; #undef HZ; #endif; ; const Int_t NMAX = 20;; Int_t NLOOP;; Float_t Z[NMAX], HZ[NMAX], PT[NMAX], INVSIG[NMAX];; ; void hz_calc(Float_t, Float_t, Float_t, Float_t, Float_t, Float_t);; ; //__________________________________________________________________; void zdemo(); {; ; Float_t energ;; Float_t dens;; Float_t tgrad;; Float_t ptmin;; Float_t ptmax;; Float_t delp;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""zdemo"",; ""Monte Carlo Study of Z scaling"",10,40,800,600);; c1->Range(0,0,25,18);; c1->SetFillColor(40);; ; TPaveLabel *pl = new TPaveLabel(1,16.3,24,17.5,""Z-scaling of \; Direct Photon Productions in pp Collisions at RHIC Energies"",""br"");; pl->SetFillColor(18);; pl->SetTextFont(32);; pl->SetTextColor(49);; pl->Draw();; ; TLatex t0;; t0.SetTextFont(32);; t0.SetTextColor(1);; t0.SetTextSize(0.03);; t0.SetTextAlign(12);; t0.DrawLatex(3.1,15.5,""M.Tokarev, E.Potrebenikova "");; t0.DrawLatex(14.,15.5,""JINR preprint E2-98-64, Dubna, 1998 "");; ; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.02,0.02,0.48,0.83,33);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.52,0.02,0.98,0.83,33);; ; pad1->Draw();; pad2->Draw();; ; //; // Cross-section of direct photon production in pp collisions; // at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zdemo_8C.html:299,predict,predictions,299,doc/master/zdemo_8C.html,https://root.cern,https://root.cern/doc/master/zdemo_8C.html,1,['predict'],['predictions']
Safety,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:278,detect,detector,278,doc/master/tprofile2polyRealisticModuleError_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html,2,['detect'],['detector']
Safety,". ROOT: tutorials/pyroot/hsimple.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; hsimple.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This program creates : . a one dimensional histogram; a two dimensional histogram; a profile histogram; a memory-resident ntuple. These objects are filled with some random numbers and saved on a file. ; from ROOT import TCanvas, TFile, TProfile, TNtuple, TH1F, TH2F; from ROOT import gROOT, gBenchmark, gRandom, gSystem; import ctypes; ; # Create a new canvas, and customize it.; c1 = TCanvas( 'c1', 'Dynamic Filling Example', 200, 10, 700, 500 ); c1.SetFillColor( 42 ); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 6 ); c1.GetFrame().SetBorderMode( -1 ); ; # Create a new ROOT binary machine independent file.; # Note that this file may contain any kind of ROOT objects, histograms,; # pictures, graphics objects, detector geometries, tracks, events, etc..; # This file is now becoming the current directory.; ; hfile = gROOT.FindObject( 'py-hsimple.root' ); if hfile:; hfile.Close(); hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); ; # Create some histograms, a profile histogram and an ntuple; hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); ; # Set canvas/frame attributes.; hpx.SetFillColor( 48 ); ; gBenchmark.Start( 'hsimple' ); ; # Initialize random number generator.; gRandom.SetSeed(); rannor, rndm = gRandom.Rannor, gRandom.Rndm; ; # For speed, bind and cache the Fill member functions,; histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly.; px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); kUPDATE = 1000; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py.html:956,detect,detector,956,doc/master/hsimple_8py.html,https://root.cern,https://root.cern/doc/master/hsimple_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/pyroot/na49view.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; na49view.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro generates two views of the NA49 detector. ; To have a better and dynamic view of any of these pads, you can click with the middle button of your mouse to select it. Then select ""View with x3d"" in the VIEW menu of the Canvas. Once in x3d, you are in wireframe mode by default. You can switch to:; Hidden Line mode by typing E; Solid mode by typing R; Wireframe mode by typing W; Stereo mode by clicking S (and you need special glasses); To leave x3d type Q. ; import ROOT; ; c1 = ROOT.TCanvas( 'c1', 'The NA49 canvas', 200, 10, 700, 780 ); ; ROOT.gBenchmark.Start( 'na49view' ); ; all = ROOT.TPad( 'all', 'A Global view of NA49', 0.02, 0.02, 0.48, 0.82, 28 ); tof = ROOT.TPad( 'tof', 'One Time Of Flight element', 0.52, 0.02, 0.98, 0.82, 28 ); all.Draw();; tof.Draw();; na49title = ROOT.TPaveLabel( 0.04, 0.86, 0.96, 0.98, 'Two views of the NA49 detector' ); na49title.SetFillColor( 32 ); na49title.Draw(); #; nageom = ROOT.TFile( 'py-na49.root' ); n49 = ROOT.gROOT.FindObject( 'na49' ); n49.SetBomb( 1.2 ); n49.cd() # Set current geometry; all.cd() # Set current pad; n49.Draw(); c1.Update(); tof.cd(); TOFR1 = n49.GetNode( 'TOFR1' ); TOFR1.Draw(); c1.Update(); ; ROOT.gBenchmark.Show( 'na49view' ); AuthorWim Lavrijsen ; Definition in file na49view.py. tutorialspyrootna49view.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49view_8py.html:268,detect,detector,268,doc/master/na49view_8py.html,https://root.cern,https://root.cern/doc/master/na49view_8py.html,2,['detect'],['detector']
Safety,". ROOT: tutorials/pyroot/pyroot006_tcontext_context_manager.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot006_tcontext_context_manager.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial demonstrates the usage of the TContext class as a Python context manager. ; This functionality is related with how TFile works, so it is suggested to also take a look at the pyroot005 tutorial.; import os; ; import ROOT; from ROOT import TDirectory, TFile; ; # Sometimes it is useful to have multiple open files at once. In such cases,; # the current directory will always be the file that was open last.; file_1 = TFile(""pyroot006_file_1.root"", ""recreate""); file_2 = TFile(""pyroot006_file_2.root"", ""recreate""); print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # Changing directory into another file can be safely done through a TContext; # context manager.; with TDirectory.TContext(file_1):; # Inside the statement, the current directory is file_1; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); file_1.WriteObject(histo_1, ""my_histogram""); ; # After the context, the current directory is restored back to file_2. Also, the; # two files are kept open. This means that objects read, written or modified; # inside the context are still available afterwards.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); if file_1.IsOpen() and file_2.IsOpen():; print(""'{}' and '{}' are open.\n"".format(file_1.GetName(), file_2.GetName())); ; # TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html:920,safe,safely,920,doc/master/pyroot006__tcontext__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html,1,['safe'],['safely']
Safety,". ROOT: tutorials/pyroot/zdemo.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; zdemo.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC. ; import ROOT; from array import array; ; NMAX = 20; Z = array( 'f', [0.]*NMAX ); HZ = array( 'f', [0.]*NMAX ); PT = array( 'f', [0.]*NMAX ); INVSIG = array( 'f', [0.]*NMAX ); ; NLOOP = 0; saves = {}; ; #_______________________________________________________________________________; def hz_calc( ENERG, DENS, TGRAD, PTMIN, PTMAX, DELP ):; from math import sin, cos, sqrt; global NLOOP; global Z, HZ, PT, INVSIG; ; CSEFT= 1.; GM1 = 0.00001; GM2 = 0.00001; A1 = 1.; A2 = 1.; ALX = 2.; BETA = 1.; KF1 = 8.E-7; KF2 = 5.215; ; MN = 0.9383; DEGRAD=0.01745329; ; # print 'ENR= %f DENS= %f PTMIN= %f PTMAX= %f DELP= %f ' % (ENERG,DENS,PTMIN,PTMAX,DELP); ; DNDETA= DENS; MB1 = MN*A1; MB2 = MN*A2; EB1 = ENERG/2.*A1; EB2 = ENERG/2.*A2; M1 = GM1; M2 = GM2; THET = TGRAD*DEGRAD; NLOOP = int((PTMAX-PTMIN)/DELP); ; for I in range(NLOOP):; PT[I]=PTMIN+I*DELP; PTOT = PT[I]/sin(THET); ; ETOT = sqrt(M1*M1 + PTOT*PTOT); PB1 = sqrt(EB1*EB1 - MB1*MB1); PB2 = sqrt(EB2*EB2 - MB2*MB2); P2P3 = EB2*ETOT+PB2*PTOT*cos(THET); P1P2 = EB2*EB1+PB2*PB1; P1P3 = EB1*ETOT-PB1*PTOT*cos(THET); ; X1 = P2P3/P1P2; X2 = P1P3/P1P2; Y1 = X1+sqrt(X1*X2*(1.-X1)/(1.-X2)); Y2 = X2+sqrt(X1*X2*(1.-X2)/(1.-X1)); ; S = (MB1*MB1)+2.*P1P2+(MB2*MB2); SMIN = 4.*((MB1*MB1)*(X1*X1) +2.*X1*X2*P1P2+(MB2*MB2)*(X2*X2)); SX1 = 4.*( 2*(MB1*MB1)*X1+2*X2*P1P2); SX2 = 4.*( 2*(MB2*MB2)*X2+2*X1*P1P2); SX1X2= 4.*(2*P1P2); DELM = pow((1.-Y1)*(1.-Y2),ALX); ; Z[I] = sqrt(SMIN)/DELM/pow(DNDETA,BETA); ; Y1X1 = 1. +X2*(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zdemo_8py.html:314,predict,predictions,314,doc/master/zdemo_8py.html,https://root.cern,https://root.cern/doc/master/zdemo_8py.html,1,['predict'],['predictions']
Safety,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:587,predict,predicted,587,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,1,['predict'],['predicted']
Safety,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:600,predict,predicted,600,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,1,['predict'],['predicted']
Safety,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:373,recover,recovery,373,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,2,['recover'],"['recover', 'recovery']"
Safety,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:388,recover,recovery,388,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,2,['recover'],"['recover', 'recovery']"
Safety,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py.html:585,avoid,avoid,585,doc/master/tmva101__Training_8py.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py_source.html:728,avoid,avoid,728,doc/master/tmva101__Training_8py_source.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva102__Testing_8py.html:814,predict,prediction,814,doc/master/tmva102__Testing_8py.html,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html,1,['predict'],['prediction']
Safety,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Write and read tabular data with RNTuple. ; Adapted from the cernbuild and cernstaff tree tutorials. Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step taken by an ntuple reader or writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldServi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C.html:371,safe,safe,371,doc/master/ntpl001__staff_8C.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html,1,['safe'],['safe']
Safety,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Write and read tabular data with RNTuple. Adapted from the cernbuild and cernstaff tree tutorials.; 5/// Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step; 6/// taken by an ntuple reader or writer.; 7///; 8/// \macro_image; 9/// \macro_code; 10///; 11/// \date April 2019; 12/// \author The ROOT Team; 13 ; 14// NOTE: The RNTuple classes are experimental at this point.; 15// Functionality, interface, and data format is still subject to changes.; 16// Do not use for real data!; 17 ; 18#include <ROOT/RNTupleModel.hxx>; 19#include <ROOT/RNTupleReader.hxx>; 20#include <ROOT/RNTupleWriter.hxx>; 21 ; 22#include <TCanvas.h>; 23#include <TH1I.h>; 24#include <TROOT.h>; 25#include <TString.h>; 26 ; 27#include <cassert>; 28#include <cstdio>; 29#include <fstream>; 30#include <iostream>; 31#include <memory>; 32#include <string>; 33#include <sstream>; 34#include <utility>; 35 ; 36// Import classes from experimental namespace for the time being; 37using RNTupleModel = ROOT::Experimental::RNTupleModel;; 38using RNTupleReader = ROOT::Experimental::RNTupleReader;; 39using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; 40 ; 41constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; 42 ; 43void Ingest() {; 44 // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; 45 ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; 46 assert(fin.is_open());; 47 ; 48 // We create a unique pointer to an empty data model; 49 auto model = RNTupleModel::Create();; 50 ; 51 // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; 52 // MakeField returns a shared pointer to a memory location th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C_source.html:383,safe,safe,383,doc/master/ntpl001__staff_8C_source.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html,1,['safe'],['safe']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitData.html:1543,avoid,avoid,1543,root/html526/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitData.html:1543,avoid,avoid,1543,root/html528/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html602/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html534/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html604/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html530/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html532/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IBaseParam.html:453,avoid,avoid,453,root/html526/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IBaseParam.html:453,avoid,avoid,453,root/html528/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html602/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html604/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html534/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html530/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html532/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricFunctionMultiDim.html:577,avoid,avoid,577,root/html528/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Math::IParamMultiFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricFunctionMultiDim.html:577,avoid,avoid,577,root/html526/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(const ROOT::Math::IBaseParam&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(ROOT::Math::IParametricFunctionMultiDim&&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(const ROOT::Math::IParametricFunctionMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html602/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricFunctionMultiDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html532/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricFunctionOneDim.html:569,avoid,avoid,569,root/html528/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p); ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double * x, const double * p ). Evaluate function at a point x and for given parameters p.; This metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricFunctionOneDim.html:569,avoid,avoid,569,root/html526/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(); ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(const ROOT::Math::IBaseFunctionOneDim&); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(const ROOT::Math::IBaseParam&); ROOT::Math::IParametricFunctionOneDimIParametricFunctionOneDim(); ROOT::Math::IParametricFunctionOneDimIParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimIParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); ROOT::Math::IParametricFunctionOneDim&operator=(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricFunctionOneDim.html:571,avoid,avoid,571,root/html602/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricFunctionOneDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html:571,avoid,avoid,571,root/html530/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Fit::Fitter::IModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html:571,avoid,avoid,571,root/html534/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc, ROOT::Fit::Fitter::IGradModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html:564,avoid,avoid,564,root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html,2,['avoid'],['avoid']
